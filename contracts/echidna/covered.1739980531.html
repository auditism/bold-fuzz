<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/Solady/src/utils/LibString.sol</b>
<code>
    1 |     | <span class='unexecuted'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>/// @notice Library for converting numbers into strings and other string operations.</span>
    5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)</span>
    6 |     | <span class='neutral'>/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)</span>
    7 |     | <span class='neutral'>///</span>
    8 |     | <span class='neutral'>/// @dev Note:</span>
    9 |     | <span class='neutral'>/// For performance and bytecode compactness, most of the string operations are restricted to</span>
   10 |     | <span class='neutral'>/// byte strings (7-bit ASCII), except where otherwise specified.</span>
   11 |     | <span class='neutral'>/// Usage of byte string operations on charsets with runes spanning two or more bytes</span>
   12 |     | <span class='neutral'>/// can lead to undefined behavior.</span>
   13 |     | <span class='unexecuted'>library LibString {</span>
   14 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
   15 |     | <span class='neutral'>    /*                        CUSTOM ERRORS                       */</span>
   16 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
   17 |     | <span class='neutral'></span>
   18 |     | <span class='neutral'>    /// @dev The length of the output is too small to contain all the hex digits.</span>
   19 |     | <span class='neutral'>    error HexLengthInsufficient();</span>
   20 |     | <span class='neutral'></span>
   21 |     | <span class='neutral'>    /// @dev The length of the string is more than 32 bytes.</span>
   22 |     | <span class='neutral'>    error TooBigForSmallString();</span>
   23 |     | <span class='neutral'></span>
   24 |     | <span class='neutral'>    /// @dev The input string must be a 7-bit ASCII.</span>
   25 |     | <span class='neutral'>    error StringNot7BitASCII();</span>
   26 |     | <span class='neutral'></span>
   27 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
   28 |     | <span class='neutral'>    /*                         CONSTANTS                          */</span>
   29 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
   30 |     | <span class='neutral'></span>
   31 |     | <span class='neutral'>    /// @dev The constant returned when the `search` is not found in the string.</span>
   32 |     | <span class='neutral'>    uint256 internal constant NOT_FOUND = type(uint256).max;</span>
   33 |     | <span class='neutral'></span>
   34 |     | <span class='neutral'>    /// @dev Lookup for &#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;.</span>
   35 |     | <span class='neutral'>    uint128 internal constant ALPHANUMERIC_7_BIT_ASCII = 0x7fffffe07fffffe03ff000000000000;</span>
   36 |     | <span class='neutral'></span>
   37 |     | <span class='neutral'>    /// @dev Lookup for &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;.</span>
   38 |     | <span class='neutral'>    uint128 internal constant LETTERS_7_BIT_ASCII = 0x7fffffe07fffffe0000000000000000;</span>
   39 |     | <span class='neutral'></span>
   40 |     | <span class='neutral'>    /// @dev Lookup for &#39;abcdefghijklmnopqrstuvwxyz&#39;.</span>
   41 |     | <span class='neutral'>    uint128 internal constant LOWERCASE_7_BIT_ASCII = 0x7fffffe000000000000000000000000;</span>
   42 |     | <span class='neutral'></span>
   43 |     | <span class='neutral'>    /// @dev Lookup for &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;.</span>
   44 |     | <span class='neutral'>    uint128 internal constant UPPERCASE_7_BIT_ASCII = 0x7fffffe0000000000000000;</span>
   45 |     | <span class='neutral'></span>
   46 |     | <span class='neutral'>    /// @dev Lookup for &#39;0123456789&#39;.</span>
   47 |     | <span class='neutral'>    uint128 internal constant DIGITS_7_BIT_ASCII = 0x3ff000000000000;</span>
   48 |     | <span class='neutral'></span>
   49 |     | <span class='neutral'>    /// @dev Lookup for &#39;0123456789abcdefABCDEF&#39;.</span>
   50 |     | <span class='neutral'>    uint128 internal constant HEXDIGITS_7_BIT_ASCII = 0x7e0000007e03ff000000000000;</span>
   51 |     | <span class='neutral'></span>
   52 |     | <span class='neutral'>    /// @dev Lookup for &#39;01234567&#39;.</span>
   53 |     | <span class='neutral'>    uint128 internal constant OCTDIGITS_7_BIT_ASCII = 0xff000000000000;</span>
   54 |     | <span class='neutral'></span>
   55 |     | <span class='neutral'>    /// @dev Lookup for &#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;#$%&amp;\&#39;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~ \t\n\r\x0b\x0c&#39;.</span>
   56 |     | <span class='neutral'>    uint128 internal constant PRINTABLE_7_BIT_ASCII = 0x7fffffffffffffffffffffff00003e00;</span>
   57 |     | <span class='neutral'></span>
   58 |     | <span class='neutral'>    /// @dev Lookup for &#39;!&quot;#$%&amp;\&#39;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~&#39;.</span>
   59 |     | <span class='neutral'>    uint128 internal constant PUNCTUATION_7_BIT_ASCII = 0x78000001f8000001fc00fffe00000000;</span>
   60 |     | <span class='neutral'></span>
   61 |     | <span class='neutral'>    /// @dev Lookup for &#39; \t\n\r\x0b\x0c&#39;.</span>
   62 |     | <span class='neutral'>    uint128 internal constant WHITESPACE_7_BIT_ASCII = 0x100003e00;</span>
   63 |     | <span class='neutral'></span>
   64 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
   65 |     | <span class='neutral'>    /*                     DECIMAL OPERATIONS                     */</span>
   66 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
   67 |     | <span class='neutral'></span>
   68 |     | <span class='neutral'>    /// @dev Returns the base 10 decimal representation of `value`.</span>
   69 |     | <span class='unexecuted'>    function toString(uint256 value) internal pure returns (string memory str) {</span>
   70 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   71 |     | <span class='neutral'>        assembly {</span>
   72 |     | <span class='neutral'>            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but</span>
   73 |     | <span class='neutral'>            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.</span>
   74 |     | <span class='neutral'>            // We will need 1 word for the trailing zeros padding, 1 word for the length,</span>
   75 |     | <span class='neutral'>            // and 3 words for a maximum of 78 digits.</span>
   76 |     | <span class='unexecuted'>            str := add(mload(0x40), 0x80)</span>
   77 |     | <span class='unexecuted'>            mstore(0x40, add(str, 0x20)) // Allocate the memory.</span>
   78 |     | <span class='unexecuted'>            mstore(str, 0) // Zeroize the slot after the string.</span>
   79 |     | <span class='neutral'></span>
   80 |     | <span class='unexecuted'>            let end := str // Cache the end of the memory to calculate the length later.</span>
   81 |     | <span class='unexecuted'>            let w := not(0) // Tsk.</span>
   82 |     | <span class='neutral'>            // We write the string from rightmost digit to leftmost digit.</span>
   83 |     | <span class='neutral'>            // The following is essentially a do-while loop that also handles the zero case.</span>
   84 |     | <span class='unexecuted'>            for { let temp := value } 1 {} {</span>
   85 |     | <span class='unexecuted'>                str := add(str, w) // `sub(str, 1)`.</span>
   86 |     | <span class='neutral'>                // Store the character to the pointer.</span>
   87 |     | <span class='neutral'>                // The ASCII index of the &#39;0&#39; character is 48.</span>
   88 |     | <span class='unexecuted'>                mstore8(str, add(48, mod(temp, 10)))</span>
   89 |     | <span class='unexecuted'>                temp := div(temp, 10) // Keep dividing `temp` until zero.</span>
   90 |     | <span class='unexecuted'>                if iszero(temp) { break }</span>
   91 |     | <span class='neutral'>            }</span>
   92 |     | <span class='unexecuted'>            let length := sub(end, str)</span>
   93 |     | <span class='unexecuted'>            str := sub(str, 0x20) // Move the pointer 32 bytes back to make room for the length.</span>
   94 |     | <span class='unexecuted'>            mstore(str, length) // Store the length.</span>
   95 |     | <span class='neutral'>        }</span>
   96 |     | <span class='neutral'>    }</span>
   97 |     | <span class='neutral'></span>
   98 |     | <span class='neutral'>    /// @dev Returns the base 10 decimal representation of `value`.</span>
   99 |     | <span class='neutral'>    function toString(int256 value) internal pure returns (string memory str) {</span>
  100 |     | <span class='neutral'>        if (value &gt;= 0) return toString(uint256(value));</span>
  101 |     | <span class='neutral'>        unchecked {</span>
  102 |     | <span class='neutral'>            str = toString(~uint256(value) + 1);</span>
  103 |     | <span class='neutral'>        }</span>
  104 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  105 |     | <span class='neutral'>        assembly {</span>
  106 |     | <span class='neutral'>            // We still have some spare memory space on the left,</span>
  107 |     | <span class='neutral'>            // as we have allocated 3 words (96 bytes) for up to 78 digits.</span>
  108 |     | <span class='neutral'>            let length := mload(str) // Load the string length.</span>
  109 |     | <span class='neutral'>            mstore(str, 0x2d) // Store the &#39;-&#39; character.</span>
  110 |     | <span class='neutral'>            str := sub(str, 1) // Move back the string pointer by a byte.</span>
  111 |     | <span class='neutral'>            mstore(str, add(length, 1)) // Update the string length.</span>
  112 |     | <span class='neutral'>        }</span>
  113 |     | <span class='neutral'>    }</span>
  114 |     | <span class='neutral'></span>
  115 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
  116 |     | <span class='neutral'>    /*                   HEXADECIMAL OPERATIONS                   */</span>
  117 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
  118 |     | <span class='neutral'></span>
  119 |     | <span class='neutral'>    /// @dev Returns the hexadecimal representation of `value`,</span>
  120 |     | <span class='neutral'>    /// left-padded to an input length of `length` bytes.</span>
  121 |     | <span class='neutral'>    /// The output is prefixed with &quot;0x&quot; encoded using 2 hexadecimal digits per byte,</span>
  122 |     | <span class='neutral'>    /// giving a total length of `length * 2 + 2` bytes.</span>
  123 |     | <span class='neutral'>    /// Reverts if `length` is too small for the output to contain all the digits.</span>
  124 |     | <span class='neutral'>    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {</span>
  125 |     | <span class='neutral'>        str = toHexStringNoPrefix(value, length);</span>
  126 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  127 |     | <span class='neutral'>        assembly {</span>
  128 |     | <span class='neutral'>            let strLength := add(mload(str), 2) // Compute the length.</span>
  129 |     | <span class='neutral'>            mstore(str, 0x3078) // Store the &quot;0x&quot; prefix.</span>
  130 |     | <span class='neutral'>            str := sub(str, 2) // Move the pointer.</span>
  131 |     | <span class='neutral'>            mstore(str, strLength) // Store the length.</span>
  132 |     | <span class='neutral'>        }</span>
  133 |     | <span class='neutral'>    }</span>
  134 |     | <span class='neutral'></span>
  135 |     | <span class='neutral'>    /// @dev Returns the hexadecimal representation of `value`,</span>
  136 |     | <span class='neutral'>    /// left-padded to an input length of `length` bytes.</span>
  137 |     | <span class='neutral'>    /// The output is prefixed with &quot;0x&quot; encoded using 2 hexadecimal digits per byte,</span>
  138 |     | <span class='neutral'>    /// giving a total length of `length * 2` bytes.</span>
  139 |     | <span class='neutral'>    /// Reverts if `length` is too small for the output to contain all the digits.</span>
  140 |     | <span class='neutral'>    function toHexStringNoPrefix(uint256 value, uint256 length)</span>
  141 |     | <span class='neutral'>        internal</span>
  142 |     | <span class='neutral'>        pure</span>
  143 |     | <span class='neutral'>        returns (string memory str)</span>
  144 |     | <span class='neutral'>    {</span>
  145 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  146 |     | <span class='neutral'>        assembly {</span>
  147 |     | <span class='neutral'>            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes</span>
  148 |     | <span class='neutral'>            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.</span>
  149 |     | <span class='neutral'>            // We add 0x20 to the total and round down to a multiple of 0x20.</span>
  150 |     | <span class='neutral'>            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.</span>
  151 |     | <span class='neutral'>            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))</span>
  152 |     | <span class='neutral'>            mstore(0x40, add(str, 0x20)) // Allocate the memory.</span>
  153 |     | <span class='neutral'>            mstore(str, 0) // Zeroize the slot after the string.</span>
  154 |     | <span class='neutral'></span>
  155 |     | <span class='neutral'>            let end := str // Cache the end to calculate the length later.</span>
  156 |     | <span class='neutral'>            // Store &quot;0123456789abcdef&quot; in scratch space.</span>
  157 |     | <span class='neutral'>            mstore(0x0f, 0x30313233343536373839616263646566)</span>
  158 |     | <span class='neutral'></span>
  159 |     | <span class='neutral'>            let start := sub(str, add(length, length))</span>
  160 |     | <span class='neutral'>            let w := not(1) // Tsk.</span>
  161 |     | <span class='neutral'>            let temp := value</span>
  162 |     | <span class='neutral'>            // We write the string from rightmost digit to leftmost digit.</span>
  163 |     | <span class='neutral'>            // The following is essentially a do-while loop that also handles the zero case.</span>
  164 |     | <span class='neutral'>            for {} 1 {} {</span>
  165 |     | <span class='neutral'>                str := add(str, w) // `sub(str, 2)`.</span>
  166 |     | <span class='neutral'>                mstore8(add(str, 1), mload(and(temp, 15)))</span>
  167 |     | <span class='neutral'>                mstore8(str, mload(and(shr(4, temp), 15)))</span>
  168 |     | <span class='neutral'>                temp := shr(8, temp)</span>
  169 |     | <span class='neutral'>                if iszero(xor(str, start)) { break }</span>
  170 |     | <span class='neutral'>            }</span>
  171 |     | <span class='neutral'>            if temp {</span>
  172 |     | <span class='neutral'>                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.</span>
  173 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  174 |     | <span class='neutral'>            }</span>
  175 |     | <span class='neutral'>            let strLength := sub(end, str)</span>
  176 |     | <span class='neutral'>            str := sub(str, 0x20)</span>
  177 |     | <span class='neutral'>            mstore(str, strLength) // Store the length.</span>
  178 |     | <span class='neutral'>        }</span>
  179 |     | <span class='neutral'>    }</span>
  180 |     | <span class='neutral'></span>
  181 |     | <span class='neutral'>    /// @dev Returns the hexadecimal representation of `value`.</span>
  182 |     | <span class='neutral'>    /// The output is prefixed with &quot;0x&quot; and encoded using 2 hexadecimal digits per byte.</span>
  183 |     | <span class='neutral'>    /// As address are 20 bytes long, the output will left-padded to have</span>
  184 |     | <span class='neutral'>    /// a length of `20 * 2 + 2` bytes.</span>
  185 |     | <span class='unexecuted'>    function toHexString(uint256 value) internal pure returns (string memory str) {</span>
  186 |     | <span class='unexecuted'>        str = toHexStringNoPrefix(value);</span>
  187 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  188 |     | <span class='neutral'>        assembly {</span>
  189 |     | <span class='unexecuted'>            let strLength := add(mload(str), 2) // Compute the length.</span>
  190 |     | <span class='unexecuted'>            mstore(str, 0x3078) // Store the &quot;0x&quot; prefix.</span>
  191 |     | <span class='unexecuted'>            str := sub(str, 2) // Move the pointer.</span>
  192 |     | <span class='unexecuted'>            mstore(str, strLength) // Store the length.</span>
  193 |     | <span class='neutral'>        }</span>
  194 |     | <span class='neutral'>    }</span>
  195 |     | <span class='neutral'></span>
  196 |     | <span class='neutral'>    /// @dev Returns the hexadecimal representation of `value`.</span>
  197 |     | <span class='neutral'>    /// The output is prefixed with &quot;0x&quot;.</span>
  198 |     | <span class='neutral'>    /// The output excludes leading &quot;0&quot; from the `toHexString` output.</span>
  199 |     | <span class='neutral'>    /// `0x00: &quot;0x0&quot;, 0x01: &quot;0x1&quot;, 0x12: &quot;0x12&quot;, 0x123: &quot;0x123&quot;`.</span>
  200 |     | <span class='neutral'>    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {</span>
  201 |     | <span class='neutral'>        str = toHexStringNoPrefix(value);</span>
  202 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  203 |     | <span class='neutral'>        assembly {</span>
  204 |     | <span class='neutral'>            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.</span>
  205 |     | <span class='neutral'>            let strLength := add(mload(str), 2) // Compute the length.</span>
  206 |     | <span class='neutral'>            mstore(add(str, o), 0x3078) // Store the &quot;0x&quot; prefix, accounting for leading zero.</span>
  207 |     | <span class='neutral'>            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.</span>
  208 |     | <span class='neutral'>            mstore(str, sub(strLength, o)) // Store the length, accounting for leading zero.</span>
  209 |     | <span class='neutral'>        }</span>
  210 |     | <span class='neutral'>    }</span>
  211 |     | <span class='neutral'></span>
  212 |     | <span class='neutral'>    /// @dev Returns the hexadecimal representation of `value`.</span>
  213 |     | <span class='neutral'>    /// The output excludes leading &quot;0&quot; from the `toHexStringNoPrefix` output.</span>
  214 |     | <span class='neutral'>    /// `0x00: &quot;0&quot;, 0x01: &quot;1&quot;, 0x12: &quot;12&quot;, 0x123: &quot;123&quot;`.</span>
  215 |     | <span class='neutral'>    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {</span>
  216 |     | <span class='neutral'>        str = toHexStringNoPrefix(value);</span>
  217 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  218 |     | <span class='neutral'>        assembly {</span>
  219 |     | <span class='neutral'>            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.</span>
  220 |     | <span class='neutral'>            let strLength := mload(str) // Get the length.</span>
  221 |     | <span class='neutral'>            str := add(str, o) // Move the pointer, accounting for leading zero.</span>
  222 |     | <span class='neutral'>            mstore(str, sub(strLength, o)) // Store the length, accounting for leading zero.</span>
  223 |     | <span class='neutral'>        }</span>
  224 |     | <span class='neutral'>    }</span>
  225 |     | <span class='neutral'></span>
  226 |     | <span class='neutral'>    /// @dev Returns the hexadecimal representation of `value`.</span>
  227 |     | <span class='neutral'>    /// The output is encoded using 2 hexadecimal digits per byte.</span>
  228 |     | <span class='neutral'>    /// As address are 20 bytes long, the output will left-padded to have</span>
  229 |     | <span class='neutral'>    /// a length of `20 * 2` bytes.</span>
  230 |     | <span class='unexecuted'>    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {</span>
  231 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  232 |     | <span class='neutral'>        assembly {</span>
  233 |     | <span class='neutral'>            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,</span>
  234 |     | <span class='neutral'>            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.</span>
  235 |     | <span class='neutral'>            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.</span>
  236 |     | <span class='unexecuted'>            str := add(mload(0x40), 0x80)</span>
  237 |     | <span class='unexecuted'>            mstore(0x40, add(str, 0x20)) // Allocate the memory.</span>
  238 |     | <span class='unexecuted'>            mstore(str, 0) // Zeroize the slot after the string.</span>
  239 |     | <span class='neutral'></span>
  240 |     | <span class='unexecuted'>            let end := str // Cache the end to calculate the length later.</span>
  241 |     | <span class='unexecuted'>            mstore(0x0f, 0x30313233343536373839616263646566) // Store the &quot;0123456789abcdef&quot; lookup.</span>
  242 |     | <span class='neutral'></span>
  243 |     | <span class='unexecuted'>            let w := not(1) // Tsk.</span>
  244 |     | <span class='neutral'>            // We write the string from rightmost digit to leftmost digit.</span>
  245 |     | <span class='neutral'>            // The following is essentially a do-while loop that also handles the zero case.</span>
  246 |     | <span class='unexecuted'>            for { let temp := value } 1 {} {</span>
  247 |     | <span class='unexecuted'>                str := add(str, w) // `sub(str, 2)`.</span>
  248 |     | <span class='unexecuted'>                mstore8(add(str, 1), mload(and(temp, 15)))</span>
  249 |     | <span class='unexecuted'>                mstore8(str, mload(and(shr(4, temp), 15)))</span>
  250 |     | <span class='unexecuted'>                temp := shr(8, temp)</span>
  251 |     | <span class='unexecuted'>                if iszero(temp) { break }</span>
  252 |     | <span class='neutral'>            }</span>
  253 |     | <span class='neutral'>            let strLength := sub(end, str)</span>
  254 |     | <span class='neutral'>            str := sub(str, 0x20)</span>
  255 |     | <span class='neutral'>            mstore(str, strLength) // Store the length.</span>
  256 |     | <span class='neutral'>        }</span>
  257 |     | <span class='neutral'>    }</span>
  258 |     | <span class='neutral'></span>
  259 |     | <span class='neutral'>    /// @dev Returns the hexadecimal representation of `value`.</span>
  260 |     | <span class='neutral'>    /// The output is prefixed with &quot;0x&quot;, encoded using 2 hexadecimal digits per byte,</span>
  261 |     | <span class='neutral'>    /// and the alphabets are capitalized conditionally according to</span>
  262 |     | <span class='neutral'>    /// https://eips.ethereum.org/EIPS/eip-55</span>
  263 |     | <span class='unexecuted'>    function toHexStringChecksummed(address value) internal pure returns (string memory str) {</span>
  264 |     | <span class='unexecuted'>        str = toHexString(value);</span>
  265 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  266 |     | <span class='neutral'>        assembly {</span>
  267 |     | <span class='unexecuted'>            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`</span>
  268 |     | <span class='unexecuted'>            let o := add(str, 0x22)</span>
  269 |     | <span class='unexecuted'>            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `</span>
  270 |     | <span class='neutral'>            let t := shl(240, 136) // `0b10001000 &lt;&lt; 240`</span>
  271 |     | <span class='unexecuted'>            for { let i := 0 } 1 {} {</span>
  272 |     | <span class='unexecuted'>                mstore(add(i, i), mul(t, byte(i, hashed)))</span>
  273 |     | <span class='unexecuted'>                i := add(i, 1)</span>
  274 |     | <span class='unexecuted'>                if eq(i, 20) { break }</span>
  275 |     | <span class='neutral'>            }</span>
  276 |     | <span class='unexecuted'>            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))</span>
  277 |     | <span class='unexecuted'>            o := add(o, 0x20)</span>
  278 |     | <span class='unexecuted'>            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))</span>
  279 |     | <span class='neutral'>        }</span>
  280 |     | <span class='neutral'>    }</span>
  281 |     | <span class='neutral'></span>
  282 |     | <span class='neutral'>    /// @dev Returns the hexadecimal representation of `value`.</span>
  283 |     | <span class='neutral'>    /// The output is prefixed with &quot;0x&quot; and encoded using 2 hexadecimal digits per byte.</span>
  284 |     | <span class='unexecuted'>    function toHexString(address value) internal pure returns (string memory str) {</span>
  285 |     | <span class='unexecuted'>        str = toHexStringNoPrefix(value);</span>
  286 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  287 |     | <span class='neutral'>        assembly {</span>
  288 |     | <span class='neutral'>            let strLength := add(mload(str), 2) // Compute the length.</span>
  289 |     | <span class='neutral'>            mstore(str, 0x3078) // Store the &quot;0x&quot; prefix.</span>
  290 |     | <span class='neutral'>            str := sub(str, 2) // Move the pointer.</span>
  291 |     | <span class='neutral'>            mstore(str, strLength) // Store the length.</span>
  292 |     | <span class='neutral'>        }</span>
  293 |     | <span class='neutral'>    }</span>
  294 |     | <span class='neutral'></span>
  295 |     | <span class='neutral'>    /// @dev Returns the hexadecimal representation of `value`.</span>
  296 |     | <span class='neutral'>    /// The output is encoded using 2 hexadecimal digits per byte.</span>
  297 |     | <span class='unexecuted'>    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {</span>
  298 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  299 |     | <span class='neutral'>        assembly {</span>
  300 |     | <span class='unexecuted'>            str := mload(0x40)</span>
  301 |     | <span class='neutral'>            // Allocate the memory.</span>
  302 |     | <span class='neutral'>            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,</span>
  303 |     | <span class='neutral'>            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.</span>
  304 |     | <span class='neutral'>            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.</span>
  305 |     | <span class='unexecuted'>            mstore(0x40, add(str, 0x80))</span>
  306 |     | <span class='unexecuted'>            mstore(0x0f, 0x30313233343536373839616263646566) // Store the &quot;0123456789abcdef&quot; lookup.</span>
  307 |     | <span class='neutral'></span>
  308 |     | <span class='unexecuted'>            str := add(str, 2)</span>
  309 |     | <span class='unexecuted'>            mstore(str, 40) // Store the length.</span>
  310 |     | <span class='unexecuted'>            let o := add(str, 0x20)</span>
  311 |     | <span class='unexecuted'>            mstore(add(o, 40), 0) // Zeroize the slot after the string.</span>
  312 |     | <span class='unexecuted'>            value := shl(96, value)</span>
  313 |     | <span class='neutral'>            // We write the string from rightmost digit to leftmost digit.</span>
  314 |     | <span class='neutral'>            // The following is essentially a do-while loop that also handles the zero case.</span>
  315 |     | <span class='unexecuted'>            for { let i := 0 } 1 {} {</span>
  316 |     | <span class='unexecuted'>                let p := add(o, add(i, i))</span>
  317 |     | <span class='unexecuted'>                let temp := byte(i, value)</span>
  318 |     | <span class='unexecuted'>                mstore8(add(p, 1), mload(and(temp, 15)))</span>
  319 |     | <span class='unexecuted'>                mstore8(p, mload(shr(4, temp)))</span>
  320 |     | <span class='unexecuted'>                i := add(i, 1)</span>
  321 |     | <span class='unexecuted'>                if eq(i, 20) { break }</span>
  322 |     | <span class='neutral'>            }</span>
  323 |     | <span class='neutral'>        }</span>
  324 |     | <span class='neutral'>    }</span>
  325 |     | <span class='neutral'></span>
  326 |     | <span class='neutral'>    /// @dev Returns the hex encoded string from the raw bytes.</span>
  327 |     | <span class='neutral'>    /// The output is encoded using 2 hexadecimal digits per byte.</span>
  328 |     | <span class='neutral'>    function toHexString(bytes memory raw) internal pure returns (string memory str) {</span>
  329 |     | <span class='neutral'>        str = toHexStringNoPrefix(raw);</span>
  330 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  331 |     | <span class='neutral'>        assembly {</span>
  332 |     | <span class='neutral'>            let strLength := add(mload(str), 2) // Compute the length.</span>
  333 |     | <span class='neutral'>            mstore(str, 0x3078) // Store the &quot;0x&quot; prefix.</span>
  334 |     | <span class='neutral'>            str := sub(str, 2) // Move the pointer.</span>
  335 |     | <span class='neutral'>            mstore(str, strLength) // Store the length.</span>
  336 |     | <span class='neutral'>        }</span>
  337 |     | <span class='neutral'>    }</span>
  338 |     | <span class='neutral'></span>
  339 |     | <span class='neutral'>    /// @dev Returns the hex encoded string from the raw bytes.</span>
  340 |     | <span class='neutral'>    /// The output is encoded using 2 hexadecimal digits per byte.</span>
  341 |     | <span class='neutral'>    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {</span>
  342 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  343 |     | <span class='neutral'>        assembly {</span>
  344 |     | <span class='neutral'>            let length := mload(raw)</span>
  345 |     | <span class='neutral'>            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.</span>
  346 |     | <span class='neutral'>            mstore(str, add(length, length)) // Store the length of the output.</span>
  347 |     | <span class='neutral'></span>
  348 |     | <span class='neutral'>            mstore(0x0f, 0x30313233343536373839616263646566) // Store the &quot;0123456789abcdef&quot; lookup.</span>
  349 |     | <span class='neutral'>            let o := add(str, 0x20)</span>
  350 |     | <span class='neutral'>            let end := add(raw, length)</span>
  351 |     | <span class='neutral'>            for {} iszero(eq(raw, end)) {} {</span>
  352 |     | <span class='neutral'>                raw := add(raw, 1)</span>
  353 |     | <span class='neutral'>                mstore8(add(o, 1), mload(and(mload(raw), 15)))</span>
  354 |     | <span class='neutral'>                mstore8(o, mload(and(shr(4, mload(raw)), 15)))</span>
  355 |     | <span class='neutral'>                o := add(o, 2)</span>
  356 |     | <span class='neutral'>            }</span>
  357 |     | <span class='neutral'>            mstore(o, 0) // Zeroize the slot after the string.</span>
  358 |     | <span class='neutral'>            mstore(0x40, add(o, 0x20)) // Allocate the memory.</span>
  359 |     | <span class='neutral'>        }</span>
  360 |     | <span class='neutral'>    }</span>
  361 |     | <span class='neutral'></span>
  362 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
  363 |     | <span class='neutral'>    /*                   RUNE STRING OPERATIONS                   */</span>
  364 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
  365 |     | <span class='neutral'></span>
  366 |     | <span class='neutral'>    /// @dev Returns the number of UTF characters in the string.</span>
  367 |     | <span class='neutral'>    function runeCount(string memory s) internal pure returns (uint256 result) {</span>
  368 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  369 |     | <span class='neutral'>        assembly {</span>
  370 |     | <span class='neutral'>            if mload(s) {</span>
  371 |     | <span class='neutral'>                mstore(0x00, div(not(0), 255))</span>
  372 |     | <span class='neutral'>                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)</span>
  373 |     | <span class='neutral'>                let o := add(s, 0x20)</span>
  374 |     | <span class='neutral'>                let end := add(o, mload(s))</span>
  375 |     | <span class='neutral'>                for { result := 1 } 1 { result := add(result, 1) } {</span>
  376 |     | <span class='neutral'>                    o := add(o, byte(0, mload(shr(250, mload(o)))))</span>
  377 |     | <span class='neutral'>                    if iszero(lt(o, end)) { break }</span>
  378 |     | <span class='neutral'>                }</span>
  379 |     | <span class='neutral'>            }</span>
  380 |     | <span class='neutral'>        }</span>
  381 |     | <span class='neutral'>    }</span>
  382 |     | <span class='neutral'></span>
  383 |     | <span class='neutral'>    /// @dev Returns if this string is a 7-bit ASCII string.</span>
  384 |     | <span class='neutral'>    /// (i.e. all characters codes are in [0..127])</span>
  385 |     | <span class='neutral'>    function is7BitASCII(string memory s) internal pure returns (bool result) {</span>
  386 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  387 |     | <span class='neutral'>        assembly {</span>
  388 |     | <span class='neutral'>            let mask := shl(7, div(not(0), 255))</span>
  389 |     | <span class='neutral'>            result := 1</span>
  390 |     | <span class='neutral'>            let n := mload(s)</span>
  391 |     | <span class='neutral'>            if n {</span>
  392 |     | <span class='neutral'>                let o := add(s, 0x20)</span>
  393 |     | <span class='neutral'>                let end := add(o, n)</span>
  394 |     | <span class='neutral'>                let last := mload(end)</span>
  395 |     | <span class='neutral'>                mstore(end, 0)</span>
  396 |     | <span class='neutral'>                for {} 1 {} {</span>
  397 |     | <span class='neutral'>                    if and(mask, mload(o)) {</span>
  398 |     | <span class='neutral'>                        result := 0</span>
  399 |     | <span class='neutral'>                        break</span>
  400 |     | <span class='neutral'>                    }</span>
  401 |     | <span class='neutral'>                    o := add(o, 0x20)</span>
  402 |     | <span class='neutral'>                    if iszero(lt(o, end)) { break }</span>
  403 |     | <span class='neutral'>                }</span>
  404 |     | <span class='neutral'>                mstore(end, last)</span>
  405 |     | <span class='neutral'>            }</span>
  406 |     | <span class='neutral'>        }</span>
  407 |     | <span class='neutral'>    }</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='neutral'>    /// @dev Returns if this string is a 7-bit ASCII string,</span>
  410 |     | <span class='neutral'>    /// AND all characters are in the `allowed` lookup.</span>
  411 |     | <span class='neutral'>    /// Note: If `s` is empty, returns true regardless of `allowed`.</span>
  412 |     | <span class='neutral'>    function is7BitASCII(string memory s, uint128 allowed) internal pure returns (bool result) {</span>
  413 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  414 |     | <span class='neutral'>        assembly {</span>
  415 |     | <span class='neutral'>            result := 1</span>
  416 |     | <span class='neutral'>            if mload(s) {</span>
  417 |     | <span class='neutral'>                let allowed_ := shr(128, shl(128, allowed))</span>
  418 |     | <span class='neutral'>                let o := add(s, 0x20)</span>
  419 |     | <span class='neutral'>                let end := add(o, mload(s))</span>
  420 |     | <span class='neutral'>                for {} 1 {} {</span>
  421 |     | <span class='neutral'>                    result := and(result, shr(byte(0, mload(o)), allowed_))</span>
  422 |     | <span class='neutral'>                    o := add(o, 1)</span>
  423 |     | <span class='neutral'>                    if iszero(and(result, lt(o, end))) { break }</span>
  424 |     | <span class='neutral'>                }</span>
  425 |     | <span class='neutral'>            }</span>
  426 |     | <span class='neutral'>        }</span>
  427 |     | <span class='neutral'>    }</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>    /// @dev Converts the bytes in the 7-bit ASCII string `s` to</span>
  430 |     | <span class='neutral'>    /// an allowed lookup for use in `is7BitASCII(s, allowed)`.</span>
  431 |     | <span class='neutral'>    /// To save runtime gas, you can cache the result in an immutable variable.</span>
  432 |     | <span class='neutral'>    function to7BitASCIIAllowedLookup(string memory s) internal pure returns (uint128 result) {</span>
  433 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  434 |     | <span class='neutral'>        assembly {</span>
  435 |     | <span class='neutral'>            if mload(s) {</span>
  436 |     | <span class='neutral'>                let o := add(s, 0x20)</span>
  437 |     | <span class='neutral'>                let end := add(o, mload(s))</span>
  438 |     | <span class='neutral'>                for {} 1 {} {</span>
  439 |     | <span class='neutral'>                    result := or(result, shl(byte(0, mload(o)), 1))</span>
  440 |     | <span class='neutral'>                    o := add(o, 1)</span>
  441 |     | <span class='neutral'>                    if iszero(lt(o, end)) { break }</span>
  442 |     | <span class='neutral'>                }</span>
  443 |     | <span class='neutral'>                if shr(128, result) {</span>
  444 |     | <span class='neutral'>                    mstore(0x00, 0xc9807e0d) // `StringNot7BitASCII()`.</span>
  445 |     | <span class='neutral'>                    revert(0x1c, 0x04)</span>
  446 |     | <span class='neutral'>                }</span>
  447 |     | <span class='neutral'>            }</span>
  448 |     | <span class='neutral'>        }</span>
  449 |     | <span class='neutral'>    }</span>
  450 |     | <span class='neutral'></span>
  451 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
  452 |     | <span class='neutral'>    /*                   BYTE STRING OPERATIONS                   */</span>
  453 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
  454 |     | <span class='neutral'></span>
  455 |     | <span class='neutral'>    // For performance and bytecode compactness, byte string operations are restricted</span>
  456 |     | <span class='neutral'>    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.</span>
  457 |     | <span class='neutral'>    // Usage of byte string operations on charsets with runes spanning two or more bytes</span>
  458 |     | <span class='neutral'>    // can lead to undefined behavior.</span>
  459 |     | <span class='neutral'></span>
  460 |     | <span class='neutral'>    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.</span>
  461 |     | <span class='neutral'>    function replace(string memory subject, string memory search, string memory replacement)</span>
  462 |     | <span class='neutral'>        internal</span>
  463 |     | <span class='neutral'>        pure</span>
  464 |     | <span class='neutral'>        returns (string memory result)</span>
  465 |     | <span class='neutral'>    {</span>
  466 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  467 |     | <span class='neutral'>        assembly {</span>
  468 |     | <span class='neutral'>            let subjectLength := mload(subject)</span>
  469 |     | <span class='neutral'>            let searchLength := mload(search)</span>
  470 |     | <span class='neutral'>            let replacementLength := mload(replacement)</span>
  471 |     | <span class='neutral'></span>
  472 |     | <span class='neutral'>            subject := add(subject, 0x20)</span>
  473 |     | <span class='neutral'>            search := add(search, 0x20)</span>
  474 |     | <span class='neutral'>            replacement := add(replacement, 0x20)</span>
  475 |     | <span class='neutral'>            result := add(mload(0x40), 0x20)</span>
  476 |     | <span class='neutral'></span>
  477 |     | <span class='neutral'>            let subjectEnd := add(subject, subjectLength)</span>
  478 |     | <span class='neutral'>            if iszero(gt(searchLength, subjectLength)) {</span>
  479 |     | <span class='neutral'>                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)</span>
  480 |     | <span class='neutral'>                let h := 0</span>
  481 |     | <span class='neutral'>                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }</span>
  482 |     | <span class='neutral'>                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))</span>
  483 |     | <span class='neutral'>                let s := mload(search)</span>
  484 |     | <span class='neutral'>                for {} 1 {} {</span>
  485 |     | <span class='neutral'>                    let t := mload(subject)</span>
  486 |     | <span class='neutral'>                    // Whether the first `searchLength % 32` bytes of</span>
  487 |     | <span class='neutral'>                    // `subject` and `search` matches.</span>
  488 |     | <span class='neutral'>                    if iszero(shr(m, xor(t, s))) {</span>
  489 |     | <span class='neutral'>                        if h {</span>
  490 |     | <span class='neutral'>                            if iszero(eq(keccak256(subject, searchLength), h)) {</span>
  491 |     | <span class='neutral'>                                mstore(result, t)</span>
  492 |     | <span class='neutral'>                                result := add(result, 1)</span>
  493 |     | <span class='neutral'>                                subject := add(subject, 1)</span>
  494 |     | <span class='neutral'>                                if iszero(lt(subject, subjectSearchEnd)) { break }</span>
  495 |     | <span class='neutral'>                                continue</span>
  496 |     | <span class='neutral'>                            }</span>
  497 |     | <span class='neutral'>                        }</span>
  498 |     | <span class='neutral'>                        // Copy the `replacement` one word at a time.</span>
  499 |     | <span class='neutral'>                        for { let o := 0 } 1 {} {</span>
  500 |     | <span class='neutral'>                            mstore(add(result, o), mload(add(replacement, o)))</span>
  501 |     | <span class='neutral'>                            o := add(o, 0x20)</span>
  502 |     | <span class='neutral'>                            if iszero(lt(o, replacementLength)) { break }</span>
  503 |     | <span class='neutral'>                        }</span>
  504 |     | <span class='neutral'>                        result := add(result, replacementLength)</span>
  505 |     | <span class='neutral'>                        subject := add(subject, searchLength)</span>
  506 |     | <span class='neutral'>                        if searchLength {</span>
  507 |     | <span class='neutral'>                            if iszero(lt(subject, subjectSearchEnd)) { break }</span>
  508 |     | <span class='neutral'>                            continue</span>
  509 |     | <span class='neutral'>                        }</span>
  510 |     | <span class='neutral'>                    }</span>
  511 |     | <span class='neutral'>                    mstore(result, t)</span>
  512 |     | <span class='neutral'>                    result := add(result, 1)</span>
  513 |     | <span class='neutral'>                    subject := add(subject, 1)</span>
  514 |     | <span class='neutral'>                    if iszero(lt(subject, subjectSearchEnd)) { break }</span>
  515 |     | <span class='neutral'>                }</span>
  516 |     | <span class='neutral'>            }</span>
  517 |     | <span class='neutral'></span>
  518 |     | <span class='neutral'>            let resultRemainder := result</span>
  519 |     | <span class='neutral'>            result := add(mload(0x40), 0x20)</span>
  520 |     | <span class='neutral'>            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))</span>
  521 |     | <span class='neutral'>            // Copy the rest of the string one word at a time.</span>
  522 |     | <span class='neutral'>            for {} lt(subject, subjectEnd) {} {</span>
  523 |     | <span class='neutral'>                mstore(resultRemainder, mload(subject))</span>
  524 |     | <span class='neutral'>                resultRemainder := add(resultRemainder, 0x20)</span>
  525 |     | <span class='neutral'>                subject := add(subject, 0x20)</span>
  526 |     | <span class='neutral'>            }</span>
  527 |     | <span class='neutral'>            result := sub(result, 0x20)</span>
  528 |     | <span class='neutral'>            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.</span>
  529 |     | <span class='neutral'>            mstore(last, 0)</span>
  530 |     | <span class='neutral'>            mstore(0x40, add(last, 0x20)) // Allocate the memory.</span>
  531 |     | <span class='neutral'>            mstore(result, k) // Store the length.</span>
  532 |     | <span class='neutral'>        }</span>
  533 |     | <span class='neutral'>    }</span>
  534 |     | <span class='neutral'></span>
  535 |     | <span class='neutral'>    /// @dev Returns the byte index of the first location of `search` in `subject`,</span>
  536 |     | <span class='neutral'>    /// searching from left to right, starting from `from`.</span>
  537 |     | <span class='neutral'>    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.</span>
  538 |     | <span class='neutral'>    function indexOf(string memory subject, string memory search, uint256 from)</span>
  539 |     | <span class='neutral'>        internal</span>
  540 |     | <span class='neutral'>        pure</span>
  541 |     | <span class='neutral'>        returns (uint256 result)</span>
  542 |     | <span class='neutral'>    {</span>
  543 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  544 |     | <span class='neutral'>        assembly {</span>
  545 |     | <span class='neutral'>            for { let subjectLength := mload(subject) } 1 {} {</span>
  546 |     | <span class='neutral'>                if iszero(mload(search)) {</span>
  547 |     | <span class='neutral'>                    if iszero(gt(from, subjectLength)) {</span>
  548 |     | <span class='neutral'>                        result := from</span>
  549 |     | <span class='neutral'>                        break</span>
  550 |     | <span class='neutral'>                    }</span>
  551 |     | <span class='neutral'>                    result := subjectLength</span>
  552 |     | <span class='neutral'>                    break</span>
  553 |     | <span class='neutral'>                }</span>
  554 |     | <span class='neutral'>                let searchLength := mload(search)</span>
  555 |     | <span class='neutral'>                let subjectStart := add(subject, 0x20)</span>
  556 |     | <span class='neutral'></span>
  557 |     | <span class='neutral'>                result := not(0) // Initialize to `NOT_FOUND`.</span>
  558 |     | <span class='neutral'>                subject := add(subjectStart, from)</span>
  559 |     | <span class='neutral'>                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)</span>
  560 |     | <span class='neutral'></span>
  561 |     | <span class='neutral'>                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))</span>
  562 |     | <span class='neutral'>                let s := mload(add(search, 0x20))</span>
  563 |     | <span class='neutral'></span>
  564 |     | <span class='neutral'>                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }</span>
  565 |     | <span class='neutral'></span>
  566 |     | <span class='neutral'>                if iszero(lt(searchLength, 0x20)) {</span>
  567 |     | <span class='neutral'>                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {</span>
  568 |     | <span class='neutral'>                        if iszero(shr(m, xor(mload(subject), s))) {</span>
  569 |     | <span class='neutral'>                            if eq(keccak256(subject, searchLength), h) {</span>
  570 |     | <span class='neutral'>                                result := sub(subject, subjectStart)</span>
  571 |     | <span class='neutral'>                                break</span>
  572 |     | <span class='neutral'>                            }</span>
  573 |     | <span class='neutral'>                        }</span>
  574 |     | <span class='neutral'>                        subject := add(subject, 1)</span>
  575 |     | <span class='neutral'>                        if iszero(lt(subject, end)) { break }</span>
  576 |     | <span class='neutral'>                    }</span>
  577 |     | <span class='neutral'>                    break</span>
  578 |     | <span class='neutral'>                }</span>
  579 |     | <span class='neutral'>                for {} 1 {} {</span>
  580 |     | <span class='neutral'>                    if iszero(shr(m, xor(mload(subject), s))) {</span>
  581 |     | <span class='neutral'>                        result := sub(subject, subjectStart)</span>
  582 |     | <span class='neutral'>                        break</span>
  583 |     | <span class='neutral'>                    }</span>
  584 |     | <span class='neutral'>                    subject := add(subject, 1)</span>
  585 |     | <span class='neutral'>                    if iszero(lt(subject, end)) { break }</span>
  586 |     | <span class='neutral'>                }</span>
  587 |     | <span class='neutral'>                break</span>
  588 |     | <span class='neutral'>            }</span>
  589 |     | <span class='neutral'>        }</span>
  590 |     | <span class='neutral'>    }</span>
  591 |     | <span class='neutral'></span>
  592 |     | <span class='neutral'>    /// @dev Returns the byte index of the first location of `search` in `subject`,</span>
  593 |     | <span class='neutral'>    /// searching from left to right.</span>
  594 |     | <span class='neutral'>    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.</span>
  595 |     | <span class='neutral'>    function indexOf(string memory subject, string memory search)</span>
  596 |     | <span class='neutral'>        internal</span>
  597 |     | <span class='neutral'>        pure</span>
  598 |     | <span class='neutral'>        returns (uint256 result)</span>
  599 |     | <span class='neutral'>    {</span>
  600 |     | <span class='neutral'>        result = indexOf(subject, search, 0);</span>
  601 |     | <span class='neutral'>    }</span>
  602 |     | <span class='neutral'></span>
  603 |     | <span class='neutral'>    /// @dev Returns the byte index of the first location of `search` in `subject`,</span>
  604 |     | <span class='neutral'>    /// searching from right to left, starting from `from`.</span>
  605 |     | <span class='neutral'>    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.</span>
  606 |     | <span class='neutral'>    function lastIndexOf(string memory subject, string memory search, uint256 from)</span>
  607 |     | <span class='neutral'>        internal</span>
  608 |     | <span class='neutral'>        pure</span>
  609 |     | <span class='neutral'>        returns (uint256 result)</span>
  610 |     | <span class='neutral'>    {</span>
  611 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  612 |     | <span class='neutral'>        assembly {</span>
  613 |     | <span class='neutral'>            for {} 1 {} {</span>
  614 |     | <span class='neutral'>                result := not(0) // Initialize to `NOT_FOUND`.</span>
  615 |     | <span class='neutral'>                let searchLength := mload(search)</span>
  616 |     | <span class='neutral'>                if gt(searchLength, mload(subject)) { break }</span>
  617 |     | <span class='neutral'>                let w := result</span>
  618 |     | <span class='neutral'></span>
  619 |     | <span class='neutral'>                let fromMax := sub(mload(subject), searchLength)</span>
  620 |     | <span class='neutral'>                if iszero(gt(fromMax, from)) { from := fromMax }</span>
  621 |     | <span class='neutral'></span>
  622 |     | <span class='neutral'>                let end := add(add(subject, 0x20), w)</span>
  623 |     | <span class='neutral'>                subject := add(add(subject, 0x20), from)</span>
  624 |     | <span class='neutral'>                if iszero(gt(subject, end)) { break }</span>
  625 |     | <span class='neutral'>                // As this function is not too often used,</span>
  626 |     | <span class='neutral'>                // we shall simply use keccak256 for smaller bytecode size.</span>
  627 |     | <span class='neutral'>                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {</span>
  628 |     | <span class='neutral'>                    if eq(keccak256(subject, searchLength), h) {</span>
  629 |     | <span class='neutral'>                        result := sub(subject, add(end, 1))</span>
  630 |     | <span class='neutral'>                        break</span>
  631 |     | <span class='neutral'>                    }</span>
  632 |     | <span class='neutral'>                    subject := add(subject, w) // `sub(subject, 1)`.</span>
  633 |     | <span class='neutral'>                    if iszero(gt(subject, end)) { break }</span>
  634 |     | <span class='neutral'>                }</span>
  635 |     | <span class='neutral'>                break</span>
  636 |     | <span class='neutral'>            }</span>
  637 |     | <span class='neutral'>        }</span>
  638 |     | <span class='neutral'>    }</span>
  639 |     | <span class='neutral'></span>
  640 |     | <span class='neutral'>    /// @dev Returns the byte index of the first location of `search` in `subject`,</span>
  641 |     | <span class='neutral'>    /// searching from right to left.</span>
  642 |     | <span class='neutral'>    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.</span>
  643 |     | <span class='neutral'>    function lastIndexOf(string memory subject, string memory search)</span>
  644 |     | <span class='neutral'>        internal</span>
  645 |     | <span class='neutral'>        pure</span>
  646 |     | <span class='neutral'>        returns (uint256 result)</span>
  647 |     | <span class='neutral'>    {</span>
  648 |     | <span class='neutral'>        result = lastIndexOf(subject, search, uint256(int256(-1)));</span>
  649 |     | <span class='neutral'>    }</span>
  650 |     | <span class='neutral'></span>
  651 |     | <span class='neutral'>    /// @dev Returns true if `search` is found in `subject`, false otherwise.</span>
  652 |     | <span class='neutral'>    function contains(string memory subject, string memory search) internal pure returns (bool) {</span>
  653 |     | <span class='neutral'>        return indexOf(subject, search) != NOT_FOUND;</span>
  654 |     | <span class='neutral'>    }</span>
  655 |     | <span class='neutral'></span>
  656 |     | <span class='neutral'>    /// @dev Returns whether `subject` starts with `search`.</span>
  657 |     | <span class='neutral'>    function startsWith(string memory subject, string memory search)</span>
  658 |     | <span class='neutral'>        internal</span>
  659 |     | <span class='neutral'>        pure</span>
  660 |     | <span class='neutral'>        returns (bool result)</span>
  661 |     | <span class='neutral'>    {</span>
  662 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  663 |     | <span class='neutral'>        assembly {</span>
  664 |     | <span class='neutral'>            let searchLength := mload(search)</span>
  665 |     | <span class='neutral'>            // Just using keccak256 directly is actually cheaper.</span>
  666 |     | <span class='neutral'>            // forgefmt: disable-next-item</span>
  667 |     | <span class='neutral'>            result := and(</span>
  668 |     | <span class='neutral'>                iszero(gt(searchLength, mload(subject))),</span>
  669 |     | <span class='neutral'>                eq(</span>
  670 |     | <span class='neutral'>                    keccak256(add(subject, 0x20), searchLength),</span>
  671 |     | <span class='neutral'>                    keccak256(add(search, 0x20), searchLength)</span>
  672 |     | <span class='neutral'>                )</span>
  673 |     | <span class='neutral'>            )</span>
  674 |     | <span class='neutral'>        }</span>
  675 |     | <span class='neutral'>    }</span>
  676 |     | <span class='neutral'></span>
  677 |     | <span class='neutral'>    /// @dev Returns whether `subject` ends with `search`.</span>
  678 |     | <span class='neutral'>    function endsWith(string memory subject, string memory search)</span>
  679 |     | <span class='neutral'>        internal</span>
  680 |     | <span class='neutral'>        pure</span>
  681 |     | <span class='neutral'>        returns (bool result)</span>
  682 |     | <span class='neutral'>    {</span>
  683 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  684 |     | <span class='neutral'>        assembly {</span>
  685 |     | <span class='neutral'>            let searchLength := mload(search)</span>
  686 |     | <span class='neutral'>            let subjectLength := mload(subject)</span>
  687 |     | <span class='neutral'>            // Whether `search` is not longer than `subject`.</span>
  688 |     | <span class='neutral'>            let withinRange := iszero(gt(searchLength, subjectLength))</span>
  689 |     | <span class='neutral'>            // Just using keccak256 directly is actually cheaper.</span>
  690 |     | <span class='neutral'>            // forgefmt: disable-next-item</span>
  691 |     | <span class='neutral'>            result := and(</span>
  692 |     | <span class='neutral'>                withinRange,</span>
  693 |     | <span class='neutral'>                eq(</span>
  694 |     | <span class='neutral'>                    keccak256(</span>
  695 |     | <span class='neutral'>                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.</span>
  696 |     | <span class='neutral'>                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),</span>
  697 |     | <span class='neutral'>                        searchLength</span>
  698 |     | <span class='neutral'>                    ),</span>
  699 |     | <span class='neutral'>                    keccak256(add(search, 0x20), searchLength)</span>
  700 |     | <span class='neutral'>                )</span>
  701 |     | <span class='neutral'>            )</span>
  702 |     | <span class='neutral'>        }</span>
  703 |     | <span class='neutral'>    }</span>
  704 |     | <span class='neutral'></span>
  705 |     | <span class='neutral'>    /// @dev Returns `subject` repeated `times`.</span>
  706 |     | <span class='neutral'>    function repeat(string memory subject, uint256 times)</span>
  707 |     | <span class='neutral'>        internal</span>
  708 |     | <span class='neutral'>        pure</span>
  709 |     | <span class='neutral'>        returns (string memory result)</span>
  710 |     | <span class='neutral'>    {</span>
  711 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  712 |     | <span class='neutral'>        assembly {</span>
  713 |     | <span class='neutral'>            let subjectLength := mload(subject)</span>
  714 |     | <span class='neutral'>            if iszero(or(iszero(times), iszero(subjectLength))) {</span>
  715 |     | <span class='neutral'>                subject := add(subject, 0x20)</span>
  716 |     | <span class='neutral'>                result := mload(0x40)</span>
  717 |     | <span class='neutral'>                let output := add(result, 0x20)</span>
  718 |     | <span class='neutral'>                for {} 1 {} {</span>
  719 |     | <span class='neutral'>                    // Copy the `subject` one word at a time.</span>
  720 |     | <span class='neutral'>                    for { let o := 0 } 1 {} {</span>
  721 |     | <span class='neutral'>                        mstore(add(output, o), mload(add(subject, o)))</span>
  722 |     | <span class='neutral'>                        o := add(o, 0x20)</span>
  723 |     | <span class='neutral'>                        if iszero(lt(o, subjectLength)) { break }</span>
  724 |     | <span class='neutral'>                    }</span>
  725 |     | <span class='neutral'>                    output := add(output, subjectLength)</span>
  726 |     | <span class='neutral'>                    times := sub(times, 1)</span>
  727 |     | <span class='neutral'>                    if iszero(times) { break }</span>
  728 |     | <span class='neutral'>                }</span>
  729 |     | <span class='neutral'>                mstore(output, 0) // Zeroize the slot after the string.</span>
  730 |     | <span class='neutral'>                let resultLength := sub(output, add(result, 0x20))</span>
  731 |     | <span class='neutral'>                mstore(result, resultLength) // Store the length.</span>
  732 |     | <span class='neutral'>                mstore(0x40, add(result, add(resultLength, 0x40))) // Allocate the memory.</span>
  733 |     | <span class='neutral'>            }</span>
  734 |     | <span class='neutral'>        }</span>
  735 |     | <span class='neutral'>    }</span>
  736 |     | <span class='neutral'></span>
  737 |     | <span class='neutral'>    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).</span>
  738 |     | <span class='neutral'>    /// `start` and `end` are byte offsets.</span>
  739 |     | <span class='unexecuted'>    function slice(string memory subject, uint256 start, uint256 end)</span>
  740 |     | <span class='neutral'>        internal</span>
  741 |     | <span class='neutral'>        pure</span>
  742 |     | <span class='unexecuted'>        returns (string memory result)</span>
  743 |     | <span class='neutral'>    {</span>
  744 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  745 |     | <span class='neutral'>        assembly {</span>
  746 |     | <span class='unexecuted'>            let subjectLength := mload(subject)</span>
  747 |     | <span class='unexecuted'>            if iszero(gt(subjectLength, end)) { end := subjectLength }</span>
  748 |     | <span class='unexecuted'>            if iszero(gt(subjectLength, start)) { start := subjectLength }</span>
  749 |     | <span class='unexecuted'>            if lt(start, end) {</span>
  750 |     | <span class='unexecuted'>                result := mload(0x40)</span>
  751 |     | <span class='unexecuted'>                let resultLength := sub(end, start)</span>
  752 |     | <span class='unexecuted'>                mstore(result, resultLength)</span>
  753 |     | <span class='unexecuted'>                subject := add(subject, start)</span>
  754 |     | <span class='unexecuted'>                let w := not(0x1f)</span>
  755 |     | <span class='neutral'>                // Copy the `subject` one word at a time, backwards.</span>
  756 |     | <span class='unexecuted'>                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {</span>
  757 |     | <span class='unexecuted'>                    mstore(add(result, o), mload(add(subject, o)))</span>
  758 |     | <span class='unexecuted'>                    o := add(o, w) // `sub(o, 0x20)`.</span>
  759 |     | <span class='unexecuted'>                    if iszero(o) { break }</span>
  760 |     | <span class='neutral'>                }</span>
  761 |     | <span class='neutral'>                // Zeroize the slot after the string.</span>
  762 |     | <span class='unexecuted'>                mstore(add(add(result, 0x20), resultLength), 0)</span>
  763 |     | <span class='unexecuted'>                mstore(0x40, add(result, add(resultLength, 0x40))) // Allocate the memory.</span>
  764 |     | <span class='neutral'>            }</span>
  765 |     | <span class='neutral'>        }</span>
  766 |     | <span class='neutral'>    }</span>
  767 |     | <span class='neutral'></span>
  768 |     | <span class='neutral'>    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.</span>
  769 |     | <span class='neutral'>    /// `start` is a byte offset.</span>
  770 |     | <span class='neutral'>    function slice(string memory subject, uint256 start)</span>
  771 |     | <span class='neutral'>        internal</span>
  772 |     | <span class='neutral'>        pure</span>
  773 |     | <span class='neutral'>        returns (string memory result)</span>
  774 |     | <span class='neutral'>    {</span>
  775 |     | <span class='neutral'>        result = slice(subject, start, uint256(int256(-1)));</span>
  776 |     | <span class='neutral'>    }</span>
  777 |     | <span class='neutral'></span>
  778 |     | <span class='neutral'>    /// @dev Returns all the indices of `search` in `subject`.</span>
  779 |     | <span class='neutral'>    /// The indices are byte offsets.</span>
  780 |     | <span class='neutral'>    function indicesOf(string memory subject, string memory search)</span>
  781 |     | <span class='neutral'>        internal</span>
  782 |     | <span class='neutral'>        pure</span>
  783 |     | <span class='neutral'>        returns (uint256[] memory result)</span>
  784 |     | <span class='neutral'>    {</span>
  785 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  786 |     | <span class='neutral'>        assembly {</span>
  787 |     | <span class='neutral'>            let subjectLength := mload(subject)</span>
  788 |     | <span class='neutral'>            let searchLength := mload(search)</span>
  789 |     | <span class='neutral'></span>
  790 |     | <span class='neutral'>            if iszero(gt(searchLength, subjectLength)) {</span>
  791 |     | <span class='neutral'>                subject := add(subject, 0x20)</span>
  792 |     | <span class='neutral'>                search := add(search, 0x20)</span>
  793 |     | <span class='neutral'>                result := add(mload(0x40), 0x20)</span>
  794 |     | <span class='neutral'></span>
  795 |     | <span class='neutral'>                let subjectStart := subject</span>
  796 |     | <span class='neutral'>                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)</span>
  797 |     | <span class='neutral'>                let h := 0</span>
  798 |     | <span class='neutral'>                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }</span>
  799 |     | <span class='neutral'>                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))</span>
  800 |     | <span class='neutral'>                let s := mload(search)</span>
  801 |     | <span class='neutral'>                for {} 1 {} {</span>
  802 |     | <span class='neutral'>                    let t := mload(subject)</span>
  803 |     | <span class='neutral'>                    // Whether the first `searchLength % 32` bytes of</span>
  804 |     | <span class='neutral'>                    // `subject` and `search` matches.</span>
  805 |     | <span class='neutral'>                    if iszero(shr(m, xor(t, s))) {</span>
  806 |     | <span class='neutral'>                        if h {</span>
  807 |     | <span class='neutral'>                            if iszero(eq(keccak256(subject, searchLength), h)) {</span>
  808 |     | <span class='neutral'>                                subject := add(subject, 1)</span>
  809 |     | <span class='neutral'>                                if iszero(lt(subject, subjectSearchEnd)) { break }</span>
  810 |     | <span class='neutral'>                                continue</span>
  811 |     | <span class='neutral'>                            }</span>
  812 |     | <span class='neutral'>                        }</span>
  813 |     | <span class='neutral'>                        // Append to `result`.</span>
  814 |     | <span class='neutral'>                        mstore(result, sub(subject, subjectStart))</span>
  815 |     | <span class='neutral'>                        result := add(result, 0x20)</span>
  816 |     | <span class='neutral'>                        // Advance `subject` by `searchLength`.</span>
  817 |     | <span class='neutral'>                        subject := add(subject, searchLength)</span>
  818 |     | <span class='neutral'>                        if searchLength {</span>
  819 |     | <span class='neutral'>                            if iszero(lt(subject, subjectSearchEnd)) { break }</span>
  820 |     | <span class='neutral'>                            continue</span>
  821 |     | <span class='neutral'>                        }</span>
  822 |     | <span class='neutral'>                    }</span>
  823 |     | <span class='neutral'>                    subject := add(subject, 1)</span>
  824 |     | <span class='neutral'>                    if iszero(lt(subject, subjectSearchEnd)) { break }</span>
  825 |     | <span class='neutral'>                }</span>
  826 |     | <span class='neutral'>                let resultEnd := result</span>
  827 |     | <span class='neutral'>                // Assign `result` to the free memory pointer.</span>
  828 |     | <span class='neutral'>                result := mload(0x40)</span>
  829 |     | <span class='neutral'>                // Store the length of `result`.</span>
  830 |     | <span class='neutral'>                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))</span>
  831 |     | <span class='neutral'>                // Allocate memory for result.</span>
  832 |     | <span class='neutral'>                // We allocate one more word, so this array can be recycled for {split}.</span>
  833 |     | <span class='neutral'>                mstore(0x40, add(resultEnd, 0x20))</span>
  834 |     | <span class='neutral'>            }</span>
  835 |     | <span class='neutral'>        }</span>
  836 |     | <span class='neutral'>    }</span>
  837 |     | <span class='neutral'></span>
  838 |     | <span class='neutral'>    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.</span>
  839 |     | <span class='neutral'>    function split(string memory subject, string memory delimiter)</span>
  840 |     | <span class='neutral'>        internal</span>
  841 |     | <span class='neutral'>        pure</span>
  842 |     | <span class='neutral'>        returns (string[] memory result)</span>
  843 |     | <span class='neutral'>    {</span>
  844 |     | <span class='neutral'>        uint256[] memory indices = indicesOf(subject, delimiter);</span>
  845 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  846 |     | <span class='neutral'>        assembly {</span>
  847 |     | <span class='neutral'>            let w := not(0x1f)</span>
  848 |     | <span class='neutral'>            let indexPtr := add(indices, 0x20)</span>
  849 |     | <span class='neutral'>            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))</span>
  850 |     | <span class='neutral'>            mstore(add(indicesEnd, w), mload(subject))</span>
  851 |     | <span class='neutral'>            mstore(indices, add(mload(indices), 1))</span>
  852 |     | <span class='neutral'>            let prevIndex := 0</span>
  853 |     | <span class='neutral'>            for {} 1 {} {</span>
  854 |     | <span class='neutral'>                let index := mload(indexPtr)</span>
  855 |     | <span class='neutral'>                mstore(indexPtr, 0x60)</span>
  856 |     | <span class='neutral'>                if iszero(eq(index, prevIndex)) {</span>
  857 |     | <span class='neutral'>                    let element := mload(0x40)</span>
  858 |     | <span class='neutral'>                    let elementLength := sub(index, prevIndex)</span>
  859 |     | <span class='neutral'>                    mstore(element, elementLength)</span>
  860 |     | <span class='neutral'>                    // Copy the `subject` one word at a time, backwards.</span>
  861 |     | <span class='neutral'>                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {</span>
  862 |     | <span class='neutral'>                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))</span>
  863 |     | <span class='neutral'>                        o := add(o, w) // `sub(o, 0x20)`.</span>
  864 |     | <span class='neutral'>                        if iszero(o) { break }</span>
  865 |     | <span class='neutral'>                    }</span>
  866 |     | <span class='neutral'>                    // Zeroize the slot after the string.</span>
  867 |     | <span class='neutral'>                    mstore(add(add(element, 0x20), elementLength), 0)</span>
  868 |     | <span class='neutral'>                    // Allocate memory for the length and the bytes,</span>
  869 |     | <span class='neutral'>                    // rounded up to a multiple of 32.</span>
  870 |     | <span class='neutral'>                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))</span>
  871 |     | <span class='neutral'>                    // Store the `element` into the array.</span>
  872 |     | <span class='neutral'>                    mstore(indexPtr, element)</span>
  873 |     | <span class='neutral'>                }</span>
  874 |     | <span class='neutral'>                prevIndex := add(index, mload(delimiter))</span>
  875 |     | <span class='neutral'>                indexPtr := add(indexPtr, 0x20)</span>
  876 |     | <span class='neutral'>                if iszero(lt(indexPtr, indicesEnd)) { break }</span>
  877 |     | <span class='neutral'>            }</span>
  878 |     | <span class='neutral'>            result := indices</span>
  879 |     | <span class='neutral'>            if iszero(mload(delimiter)) {</span>
  880 |     | <span class='neutral'>                result := add(indices, 0x20)</span>
  881 |     | <span class='neutral'>                mstore(result, sub(mload(indices), 2))</span>
  882 |     | <span class='neutral'>            }</span>
  883 |     | <span class='neutral'>        }</span>
  884 |     | <span class='neutral'>    }</span>
  885 |     | <span class='neutral'></span>
  886 |     | <span class='neutral'>    /// @dev Returns a concatenated string of `a` and `b`.</span>
  887 |     | <span class='neutral'>    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.</span>
  888 |     | <span class='neutral'>    function concat(string memory a, string memory b)</span>
  889 |     | <span class='neutral'>        internal</span>
  890 |     | <span class='neutral'>        pure</span>
  891 |     | <span class='neutral'>        returns (string memory result)</span>
  892 |     | <span class='neutral'>    {</span>
  893 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  894 |     | <span class='neutral'>        assembly {</span>
  895 |     | <span class='neutral'>            let w := not(0x1f)</span>
  896 |     | <span class='neutral'>            result := mload(0x40)</span>
  897 |     | <span class='neutral'>            let aLength := mload(a)</span>
  898 |     | <span class='neutral'>            // Copy `a` one word at a time, backwards.</span>
  899 |     | <span class='neutral'>            for { let o := and(add(aLength, 0x20), w) } 1 {} {</span>
  900 |     | <span class='neutral'>                mstore(add(result, o), mload(add(a, o)))</span>
  901 |     | <span class='neutral'>                o := add(o, w) // `sub(o, 0x20)`.</span>
  902 |     | <span class='neutral'>                if iszero(o) { break }</span>
  903 |     | <span class='neutral'>            }</span>
  904 |     | <span class='neutral'>            let bLength := mload(b)</span>
  905 |     | <span class='neutral'>            let output := add(result, aLength)</span>
  906 |     | <span class='neutral'>            // Copy `b` one word at a time, backwards.</span>
  907 |     | <span class='neutral'>            for { let o := and(add(bLength, 0x20), w) } 1 {} {</span>
  908 |     | <span class='neutral'>                mstore(add(output, o), mload(add(b, o)))</span>
  909 |     | <span class='neutral'>                o := add(o, w) // `sub(o, 0x20)`.</span>
  910 |     | <span class='neutral'>                if iszero(o) { break }</span>
  911 |     | <span class='neutral'>            }</span>
  912 |     | <span class='neutral'>            let totalLength := add(aLength, bLength)</span>
  913 |     | <span class='neutral'>            let last := add(add(result, 0x20), totalLength)</span>
  914 |     | <span class='neutral'>            mstore(last, 0) // Zeroize the slot after the string.</span>
  915 |     | <span class='neutral'>            mstore(result, totalLength) // Store the length.</span>
  916 |     | <span class='neutral'>            mstore(0x40, add(last, 0x20)) // Allocate the memory.</span>
  917 |     | <span class='neutral'>        }</span>
  918 |     | <span class='neutral'>    }</span>
  919 |     | <span class='neutral'></span>
  920 |     | <span class='neutral'>    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.</span>
  921 |     | <span class='neutral'>    /// WARNING! This function is only compatible with 7-bit ASCII strings.</span>
  922 |     | <span class='neutral'>    function toCase(string memory subject, bool toUpper)</span>
  923 |     | <span class='neutral'>        internal</span>
  924 |     | <span class='neutral'>        pure</span>
  925 |     | <span class='neutral'>        returns (string memory result)</span>
  926 |     | <span class='neutral'>    {</span>
  927 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  928 |     | <span class='neutral'>        assembly {</span>
  929 |     | <span class='neutral'>            let length := mload(subject)</span>
  930 |     | <span class='neutral'>            if length {</span>
  931 |     | <span class='neutral'>                result := add(mload(0x40), 0x20)</span>
  932 |     | <span class='neutral'>                subject := add(subject, 1)</span>
  933 |     | <span class='neutral'>                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)</span>
  934 |     | <span class='neutral'>                let w := not(0)</span>
  935 |     | <span class='neutral'>                for { let o := length } 1 {} {</span>
  936 |     | <span class='neutral'>                    o := add(o, w)</span>
  937 |     | <span class='neutral'>                    let b := and(0xff, mload(add(subject, o)))</span>
  938 |     | <span class='neutral'>                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))</span>
  939 |     | <span class='neutral'>                    if iszero(o) { break }</span>
  940 |     | <span class='neutral'>                }</span>
  941 |     | <span class='neutral'>                result := mload(0x40)</span>
  942 |     | <span class='neutral'>                mstore(result, length) // Store the length.</span>
  943 |     | <span class='neutral'>                let last := add(add(result, 0x20), length)</span>
  944 |     | <span class='neutral'>                mstore(last, 0) // Zeroize the slot after the string.</span>
  945 |     | <span class='neutral'>                mstore(0x40, add(last, 0x20)) // Allocate the memory.</span>
  946 |     | <span class='neutral'>            }</span>
  947 |     | <span class='neutral'>        }</span>
  948 |     | <span class='neutral'>    }</span>
  949 |     | <span class='neutral'></span>
  950 |     | <span class='neutral'>    /// @dev Returns a string from a small bytes32 string.</span>
  951 |     | <span class='neutral'>    /// `s` must be null-terminated, or behavior will be undefined.</span>
  952 |     | <span class='neutral'>    function fromSmallString(bytes32 s) internal pure returns (string memory result) {</span>
  953 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  954 |     | <span class='neutral'>        assembly {</span>
  955 |     | <span class='neutral'>            result := mload(0x40)</span>
  956 |     | <span class='neutral'>            let n := 0</span>
  957 |     | <span class='neutral'>            for {} byte(n, s) { n := add(n, 1) } {} // Scan for &#39;\0&#39;.</span>
  958 |     | <span class='neutral'>            mstore(result, n) // Store the length.</span>
  959 |     | <span class='neutral'>            let o := add(result, 0x20)</span>
  960 |     | <span class='neutral'>            mstore(o, s) // Store the bytes of the string.</span>
  961 |     | <span class='neutral'>            mstore(add(o, n), 0) // Zeroize the slot after the string.</span>
  962 |     | <span class='neutral'>            mstore(0x40, add(result, 0x40)) // Allocate the memory.</span>
  963 |     | <span class='neutral'>        }</span>
  964 |     | <span class='neutral'>    }</span>
  965 |     | <span class='neutral'></span>
  966 |     | <span class='neutral'>    /// @dev Returns the small string, with all bytes after the first null byte zeroized.</span>
  967 |     | <span class='neutral'>    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {</span>
  968 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  969 |     | <span class='neutral'>        assembly {</span>
  970 |     | <span class='neutral'>            for {} byte(result, s) { result := add(result, 1) } {} // Scan for &#39;\0&#39;.</span>
  971 |     | <span class='neutral'>            mstore(0x00, s)</span>
  972 |     | <span class='neutral'>            mstore(result, 0x00)</span>
  973 |     | <span class='neutral'>            result := mload(0x00)</span>
  974 |     | <span class='neutral'>        }</span>
  975 |     | <span class='neutral'>    }</span>
  976 |     | <span class='neutral'></span>
  977 |     | <span class='neutral'>    /// @dev Returns the string as a normalized null-terminated small string.</span>
  978 |     | <span class='neutral'>    function toSmallString(string memory s) internal pure returns (bytes32 result) {</span>
  979 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  980 |     | <span class='neutral'>        assembly {</span>
  981 |     | <span class='neutral'>            result := mload(s)</span>
  982 |     | <span class='neutral'>            if iszero(lt(result, 33)) {</span>
  983 |     | <span class='neutral'>                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.</span>
  984 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  985 |     | <span class='neutral'>            }</span>
  986 |     | <span class='neutral'>            result := shl(shl(3, sub(32, result)), mload(add(s, result)))</span>
  987 |     | <span class='neutral'>        }</span>
  988 |     | <span class='neutral'>    }</span>
  989 |     | <span class='neutral'></span>
  990 |     | <span class='neutral'>    /// @dev Returns a lowercased copy of the string.</span>
  991 |     | <span class='neutral'>    /// WARNING! This function is only compatible with 7-bit ASCII strings.</span>
  992 |     | <span class='neutral'>    function lower(string memory subject) internal pure returns (string memory result) {</span>
  993 |     | <span class='neutral'>        result = toCase(subject, false);</span>
  994 |     | <span class='neutral'>    }</span>
  995 |     | <span class='neutral'></span>
  996 |     | <span class='neutral'>    /// @dev Returns an UPPERCASED copy of the string.</span>
  997 |     | <span class='neutral'>    /// WARNING! This function is only compatible with 7-bit ASCII strings.</span>
  998 |     | <span class='neutral'>    function upper(string memory subject) internal pure returns (string memory result) {</span>
  999 |     | <span class='neutral'>        result = toCase(subject, true);</span>
 1000 |     | <span class='neutral'>    }</span>
 1001 |     | <span class='neutral'></span>
 1002 |     | <span class='neutral'>    /// @dev Escapes the string to be used within HTML tags.</span>
 1003 |     | <span class='neutral'>    function escapeHTML(string memory s) internal pure returns (string memory result) {</span>
 1004 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1005 |     | <span class='neutral'>        assembly {</span>
 1006 |     | <span class='neutral'>            let end := add(s, mload(s))</span>
 1007 |     | <span class='neutral'>            result := add(mload(0x40), 0x20)</span>
 1008 |     | <span class='neutral'>            // Store the bytes of the packed offsets and strides into the scratch space.</span>
 1009 |     | <span class='neutral'>            // `packed = (stride &lt;&lt; 5) | offset`. Max offset is 20. Max stride is 6.</span>
 1010 |     | <span class='neutral'>            mstore(0x1f, 0x900094)</span>
 1011 |     | <span class='neutral'>            mstore(0x08, 0xc0000000a6ab)</span>
 1012 |     | <span class='neutral'>            // Store &quot;&amp;quot;&amp;amp;&amp;#39;&amp;lt;&amp;gt;&quot; into the scratch space.</span>
 1013 |     | <span class='neutral'>            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))</span>
 1014 |     | <span class='neutral'>            for {} iszero(eq(s, end)) {} {</span>
 1015 |     | <span class='neutral'>                s := add(s, 1)</span>
 1016 |     | <span class='neutral'>                let c := and(mload(s), 0xff)</span>
 1017 |     | <span class='neutral'>                // Not in `[&quot;\&quot;&quot;,&quot;&#39;&quot;,&quot;&amp;&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;]`.</span>
 1018 |     | <span class='neutral'>                if iszero(and(shl(c, 1), 0x500000c400000000)) {</span>
 1019 |     | <span class='neutral'>                    mstore8(result, c)</span>
 1020 |     | <span class='neutral'>                    result := add(result, 1)</span>
 1021 |     | <span class='neutral'>                    continue</span>
 1022 |     | <span class='neutral'>                }</span>
 1023 |     | <span class='neutral'>                let t := shr(248, mload(c))</span>
 1024 |     | <span class='neutral'>                mstore(result, mload(and(t, 0x1f)))</span>
 1025 |     | <span class='neutral'>                result := add(result, shr(5, t))</span>
 1026 |     | <span class='neutral'>            }</span>
 1027 |     | <span class='neutral'>            let last := result</span>
 1028 |     | <span class='neutral'>            mstore(last, 0) // Zeroize the slot after the string.</span>
 1029 |     | <span class='neutral'>            result := mload(0x40)</span>
 1030 |     | <span class='neutral'>            mstore(result, sub(last, add(result, 0x20))) // Store the length.</span>
 1031 |     | <span class='neutral'>            mstore(0x40, add(last, 0x20)) // Allocate the memory.</span>
 1032 |     | <span class='neutral'>        }</span>
 1033 |     | <span class='neutral'>    }</span>
 1034 |     | <span class='neutral'></span>
 1035 |     | <span class='neutral'>    /// @dev Escapes the string to be used within double-quotes in a JSON.</span>
 1036 |     | <span class='neutral'>    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.</span>
 1037 |     | <span class='neutral'>    function escapeJSON(string memory s, bool addDoubleQuotes)</span>
 1038 |     | <span class='neutral'>        internal</span>
 1039 |     | <span class='neutral'>        pure</span>
 1040 |     | <span class='neutral'>        returns (string memory result)</span>
 1041 |     | <span class='neutral'>    {</span>
 1042 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1043 |     | <span class='neutral'>        assembly {</span>
 1044 |     | <span class='neutral'>            let end := add(s, mload(s))</span>
 1045 |     | <span class='neutral'>            result := add(mload(0x40), 0x20)</span>
 1046 |     | <span class='neutral'>            if addDoubleQuotes {</span>
 1047 |     | <span class='neutral'>                mstore8(result, 34)</span>
 1048 |     | <span class='neutral'>                result := add(1, result)</span>
 1049 |     | <span class='neutral'>            }</span>
 1050 |     | <span class='neutral'>            // Store &quot;\\u0000&quot; in scratch space.</span>
 1051 |     | <span class='neutral'>            // Store &quot;0123456789abcdef&quot; in scratch space.</span>
 1052 |     | <span class='neutral'>            // Also, store `{0x08:&quot;b&quot;, 0x09:&quot;t&quot;, 0x0a:&quot;n&quot;, 0x0c:&quot;f&quot;, 0x0d:&quot;r&quot;}`.</span>
 1053 |     | <span class='neutral'>            // into the scratch space.</span>
 1054 |     | <span class='neutral'>            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)</span>
 1055 |     | <span class='neutral'>            // Bitmask for detecting `[&quot;\&quot;&quot;,&quot;\\&quot;]`.</span>
 1056 |     | <span class='neutral'>            let e := or(shl(0x22, 1), shl(0x5c, 1))</span>
 1057 |     | <span class='neutral'>            for {} iszero(eq(s, end)) {} {</span>
 1058 |     | <span class='neutral'>                s := add(s, 1)</span>
 1059 |     | <span class='neutral'>                let c := and(mload(s), 0xff)</span>
 1060 |     | <span class='neutral'>                if iszero(lt(c, 0x20)) {</span>
 1061 |     | <span class='neutral'>                    if iszero(and(shl(c, 1), e)) {</span>
 1062 |     | <span class='neutral'>                        // Not in `[&quot;\&quot;&quot;,&quot;\\&quot;]`.</span>
 1063 |     | <span class='neutral'>                        mstore8(result, c)</span>
 1064 |     | <span class='neutral'>                        result := add(result, 1)</span>
 1065 |     | <span class='neutral'>                        continue</span>
 1066 |     | <span class='neutral'>                    }</span>
 1067 |     | <span class='neutral'>                    mstore8(result, 0x5c) // &quot;\\&quot;.</span>
 1068 |     | <span class='neutral'>                    mstore8(add(result, 1), c)</span>
 1069 |     | <span class='neutral'>                    result := add(result, 2)</span>
 1070 |     | <span class='neutral'>                    continue</span>
 1071 |     | <span class='neutral'>                }</span>
 1072 |     | <span class='neutral'>                if iszero(and(shl(c, 1), 0x3700)) {</span>
 1073 |     | <span class='neutral'>                    // Not in `[&quot;\b&quot;,&quot;\t&quot;,&quot;\n&quot;,&quot;\f&quot;,&quot;\d&quot;]`.</span>
 1074 |     | <span class='neutral'>                    mstore8(0x1d, mload(shr(4, c))) // Hex value.</span>
 1075 |     | <span class='neutral'>                    mstore8(0x1e, mload(and(c, 15))) // Hex value.</span>
 1076 |     | <span class='neutral'>                    mstore(result, mload(0x19)) // &quot;\\u00XX&quot;.</span>
 1077 |     | <span class='neutral'>                    result := add(result, 6)</span>
 1078 |     | <span class='neutral'>                    continue</span>
 1079 |     | <span class='neutral'>                }</span>
 1080 |     | <span class='neutral'>                mstore8(result, 0x5c) // &quot;\\&quot;.</span>
 1081 |     | <span class='neutral'>                mstore8(add(result, 1), mload(add(c, 8)))</span>
 1082 |     | <span class='neutral'>                result := add(result, 2)</span>
 1083 |     | <span class='neutral'>            }</span>
 1084 |     | <span class='neutral'>            if addDoubleQuotes {</span>
 1085 |     | <span class='neutral'>                mstore8(result, 34)</span>
 1086 |     | <span class='neutral'>                result := add(1, result)</span>
 1087 |     | <span class='neutral'>            }</span>
 1088 |     | <span class='neutral'>            let last := result</span>
 1089 |     | <span class='neutral'>            mstore(last, 0) // Zeroize the slot after the string.</span>
 1090 |     | <span class='neutral'>            result := mload(0x40)</span>
 1091 |     | <span class='neutral'>            mstore(result, sub(last, add(result, 0x20))) // Store the length.</span>
 1092 |     | <span class='neutral'>            mstore(0x40, add(last, 0x20)) // Allocate the memory.</span>
 1093 |     | <span class='neutral'>        }</span>
 1094 |     | <span class='neutral'>    }</span>
 1095 |     | <span class='neutral'></span>
 1096 |     | <span class='neutral'>    /// @dev Escapes the string to be used within double-quotes in a JSON.</span>
 1097 |     | <span class='neutral'>    function escapeJSON(string memory s) internal pure returns (string memory result) {</span>
 1098 |     | <span class='neutral'>        result = escapeJSON(s, false);</span>
 1099 |     | <span class='neutral'>    }</span>
 1100 |     | <span class='neutral'></span>
 1101 |     | <span class='neutral'>    /// @dev Returns whether `a` equals `b`.</span>
 1102 |     | <span class='neutral'>    function eq(string memory a, string memory b) internal pure returns (bool result) {</span>
 1103 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1104 |     | <span class='neutral'>        assembly {</span>
 1105 |     | <span class='neutral'>            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))</span>
 1106 |     | <span class='neutral'>        }</span>
 1107 |     | <span class='neutral'>    }</span>
 1108 |     | <span class='neutral'></span>
 1109 |     | <span class='neutral'>    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.</span>
 1110 |     | <span class='neutral'>    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {</span>
 1111 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1112 |     | <span class='neutral'>        assembly {</span>
 1113 |     | <span class='neutral'>            // These should be evaluated on compile time, as far as possible.</span>
 1114 |     | <span class='neutral'>            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.</span>
 1115 |     | <span class='neutral'>            let x := not(or(m, or(b, add(m, and(b, m)))))</span>
 1116 |     | <span class='neutral'>            let r := shl(7, iszero(iszero(shr(128, x))))</span>
 1117 |     | <span class='neutral'>            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))</span>
 1118 |     | <span class='neutral'>            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))</span>
 1119 |     | <span class='neutral'>            r := or(r, shl(4, lt(0xffff, shr(r, x))))</span>
 1120 |     | <span class='neutral'>            r := or(r, shl(3, lt(0xff, shr(r, x))))</span>
 1121 |     | <span class='neutral'>            // forgefmt: disable-next-item</span>
 1122 |     | <span class='neutral'>            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),</span>
 1123 |     | <span class='neutral'>                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))</span>
 1124 |     | <span class='neutral'>        }</span>
 1125 |     | <span class='neutral'>    }</span>
 1126 |     | <span class='neutral'></span>
 1127 |     | <span class='neutral'>    /// @dev Packs a single string with its length into a single word.</span>
 1128 |     | <span class='neutral'>    /// Returns `bytes32(0)` if the length is zero or greater than 31.</span>
 1129 |     | <span class='neutral'>    function packOne(string memory a) internal pure returns (bytes32 result) {</span>
 1130 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1131 |     | <span class='neutral'>        assembly {</span>
 1132 |     | <span class='neutral'>            // We don&#39;t need to zero right pad the string,</span>
 1133 |     | <span class='neutral'>            // since this is our own custom non-standard packing scheme.</span>
 1134 |     | <span class='neutral'>            result :=</span>
 1135 |     | <span class='neutral'>                mul(</span>
 1136 |     | <span class='neutral'>                    // Load the length and the bytes.</span>
 1137 |     | <span class='neutral'>                    mload(add(a, 0x1f)),</span>
 1138 |     | <span class='neutral'>                    // `length != 0 &amp;&amp; length &lt; 32`. Abuses underflow.</span>
 1139 |     | <span class='neutral'>                    // Assumes that the length is valid and within the block gas limit.</span>
 1140 |     | <span class='neutral'>                    lt(sub(mload(a), 1), 0x1f)</span>
 1141 |     | <span class='neutral'>                )</span>
 1142 |     | <span class='neutral'>        }</span>
 1143 |     | <span class='neutral'>    }</span>
 1144 |     | <span class='neutral'></span>
 1145 |     | <span class='neutral'>    /// @dev Unpacks a string packed using {packOne}.</span>
 1146 |     | <span class='neutral'>    /// Returns the empty string if `packed` is `bytes32(0)`.</span>
 1147 |     | <span class='neutral'>    /// If `packed` is not an output of {packOne}, the output behavior is undefined.</span>
 1148 |     | <span class='neutral'>    function unpackOne(bytes32 packed) internal pure returns (string memory result) {</span>
 1149 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1150 |     | <span class='neutral'>        assembly {</span>
 1151 |     | <span class='neutral'>            result := mload(0x40) // Grab the free memory pointer.</span>
 1152 |     | <span class='neutral'>            mstore(0x40, add(result, 0x40)) // Allocate 2 words (1 for the length, 1 for the bytes).</span>
 1153 |     | <span class='neutral'>            mstore(result, 0) // Zeroize the length slot.</span>
 1154 |     | <span class='neutral'>            mstore(add(result, 0x1f), packed) // Store the length and bytes.</span>
 1155 |     | <span class='neutral'>            mstore(add(add(result, 0x20), mload(result)), 0) // Right pad with zeroes.</span>
 1156 |     | <span class='neutral'>        }</span>
 1157 |     | <span class='neutral'>    }</span>
 1158 |     | <span class='neutral'></span>
 1159 |     | <span class='neutral'>    /// @dev Packs two strings with their lengths into a single word.</span>
 1160 |     | <span class='neutral'>    /// Returns `bytes32(0)` if combined length is zero or greater than 30.</span>
 1161 |     | <span class='neutral'>    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {</span>
 1162 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1163 |     | <span class='neutral'>        assembly {</span>
 1164 |     | <span class='neutral'>            let aLength := mload(a)</span>
 1165 |     | <span class='neutral'>            // We don&#39;t need to zero right pad the strings,</span>
 1166 |     | <span class='neutral'>            // since this is our own custom non-standard packing scheme.</span>
 1167 |     | <span class='neutral'>            result :=</span>
 1168 |     | <span class='neutral'>                mul(</span>
 1169 |     | <span class='neutral'>                    or( // Load the length and the bytes of `a` and `b`.</span>
 1170 |     | <span class='neutral'>                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),</span>
 1171 |     | <span class='neutral'>                        mload(sub(add(b, 0x1e), aLength))</span>
 1172 |     | <span class='neutral'>                    ),</span>
 1173 |     | <span class='neutral'>                    // `totalLength != 0 &amp;&amp; totalLength &lt; 31`. Abuses underflow.</span>
 1174 |     | <span class='neutral'>                    // Assumes that the lengths are valid and within the block gas limit.</span>
 1175 |     | <span class='neutral'>                    lt(sub(add(aLength, mload(b)), 1), 0x1e)</span>
 1176 |     | <span class='neutral'>                )</span>
 1177 |     | <span class='neutral'>        }</span>
 1178 |     | <span class='neutral'>    }</span>
 1179 |     | <span class='neutral'></span>
 1180 |     | <span class='neutral'>    /// @dev Unpacks strings packed using {packTwo}.</span>
 1181 |     | <span class='neutral'>    /// Returns the empty strings if `packed` is `bytes32(0)`.</span>
 1182 |     | <span class='neutral'>    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.</span>
 1183 |     | <span class='neutral'>    function unpackTwo(bytes32 packed)</span>
 1184 |     | <span class='neutral'>        internal</span>
 1185 |     | <span class='neutral'>        pure</span>
 1186 |     | <span class='neutral'>        returns (string memory resultA, string memory resultB)</span>
 1187 |     | <span class='neutral'>    {</span>
 1188 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 1189 |     | <span class='neutral'>        assembly {</span>
 1190 |     | <span class='neutral'>            resultA := mload(0x40) // Grab the free memory pointer.</span>
 1191 |     | <span class='neutral'>            resultB := add(resultA, 0x40)</span>
 1192 |     | <span class='neutral'>            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.</span>
 1193 |     | <span class='neutral'>            mstore(0x40, add(resultB, 0x40))</span>
 1194 |     | <span class='neutral'>            // Zeroize the length slots.</span>
 1195 |     | <span class='neutral'>            mstore(resultA, 0)</span>
 1196 |     | <span class='neutral'>            mstore(resultB, 0)</span>
 1197 |     | <span class='neutral'>            // Store the lengths and bytes.</span>
 1198 |     | <span class='neutral'>            mstore(add(resultA, 0x1f), packed)</span>
 1199 |     | <span class='neutral'>            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))</span>
 1200 |     | <span class='neutral'>            // Right pad with zeroes.</span>
 1201 |     | <span class='neutral'>            mstore(add(add(resultA, 0x20), mload(resultA)), 0)</span>
 1202 |     | <span class='neutral'>            mstore(add(add(resultB, 0x20), mload(resultB)), 0)</span>
 1203 |     | <span class='neutral'>        }</span>
 1204 |     | <span class='neutral'>    }</span>
 1205 |     | <span class='neutral'></span>
 1206 |     | <span class='neutral'>    /// @dev Directly returns `a` without copying.</span>
 1207 |     | <span class='neutral'>    function directReturn(string memory a) internal pure {</span>
 1208 |     | <span class='neutral'>        assembly {</span>
 1209 |     | <span class='neutral'>            // Assumes that the string does not start from the scratch space.</span>
 1210 |     | <span class='neutral'>            let retStart := sub(a, 0x20)</span>
 1211 |     | <span class='neutral'>            let retUnpaddedSize := add(mload(a), 0x40)</span>
 1212 |     | <span class='neutral'>            // Right pad with zeroes. Just in case the string is produced</span>
 1213 |     | <span class='neutral'>            // by a method that doesn&#39;t zero right pad.</span>
 1214 |     | <span class='neutral'>            mstore(add(retStart, retUnpaddedSize), 0)</span>
 1215 |     | <span class='neutral'>            mstore(retStart, 0x20) // Store the return offset.</span>
 1216 |     | <span class='neutral'>            // End the transaction, returning the string.</span>
 1217 |     | <span class='neutral'>            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))</span>
 1218 |     | <span class='neutral'>        }</span>
 1219 |     | <span class='neutral'>    }</span>
 1220 |     | <span class='neutral'>}</span>
 1221 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/Solady/src/utils/SSTORE2.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Read and write to persistent storage at a fraction of the cost.</span>
   5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SSTORE2.sol)</span>
   6 |     | <span class='neutral'>/// @author Saw-mon-and-Natalie (https://github.com/Saw-mon-and-Natalie)</span>
   7 |     | <span class='neutral'>/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)</span>
   8 |     | <span class='neutral'>/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)</span>
   9 |     | <span class='neutral'>/// @author Modified from SSTORE3 (https://github.com/Philogy/sstore3)</span>
  10 |     | <span class='unexecuted'>library SSTORE2 {</span>
  11 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
  12 |     | <span class='neutral'>    /*                         CONSTANTS                          */</span>
  13 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    /// @dev The proxy initialization code.</span>
  16 |     | <span class='neutral'>    uint256 private constant _CREATE3_PROXY_INITCODE = 0x67363d3d37363d34f03d5260086018f3;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    /// @dev Hash of the `_CREATE3_PROXY_INITCODE`.</span>
  19 |     | <span class='neutral'>    /// Equivalent to `keccak256(abi.encodePacked(hex&quot;67363d3d37363d34f03d5260086018f3&quot;))`.</span>
  20 |     | <span class='neutral'>    bytes32 internal constant CREATE3_PROXY_INITCODE_HASH =</span>
  21 |     | <span class='neutral'>        0x21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
  24 |     | <span class='neutral'>    /*                        CUSTOM ERRORS                       */</span>
  25 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /// @dev Unable to deploy the storage contract.</span>
  28 |     | <span class='neutral'>    error DeploymentFailed();</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
  31 |     | <span class='neutral'>    /*                         WRITE LOGIC                        */</span>
  32 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.</span>
  35 |     | <span class='neutral'>    function write(bytes memory data) internal returns (address pointer) {</span>
  36 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  37 |     | <span class='neutral'>        assembly {</span>
  38 |     | <span class='neutral'>            let n := mload(data) // Let `l` be `n + 1`. +1 as we prefix a STOP opcode.</span>
  39 |     | <span class='neutral'>            /**</span>
  40 |     | <span class='neutral'>             * ---------------------------------------------------+</span>
  41 |     | <span class='neutral'>             * Opcode | Mnemonic       | Stack     | Memory       |</span>
  42 |     | <span class='neutral'>             * ---------------------------------------------------|</span>
  43 |     | <span class='neutral'>             * 61 l   | PUSH2 l        | l         |              |</span>
  44 |     | <span class='neutral'>             * 80     | DUP1           | l l       |              |</span>
  45 |     | <span class='neutral'>             * 60 0xa | PUSH1 0xa      | 0xa l l   |              |</span>
  46 |     | <span class='neutral'>             * 3D     | RETURNDATASIZE | 0 0xa l l |              |</span>
  47 |     | <span class='neutral'>             * 39     | CODECOPY       | l         | [0..l): code |</span>
  48 |     | <span class='neutral'>             * 3D     | RETURNDATASIZE | 0 l       | [0..l): code |</span>
  49 |     | <span class='neutral'>             * F3     | RETURN         |           | [0..l): code |</span>
  50 |     | <span class='neutral'>             * 00     | STOP           |           |              |</span>
  51 |     | <span class='neutral'>             * ---------------------------------------------------+</span>
  52 |     | <span class='neutral'>             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.</span>
  53 |     | <span class='neutral'>             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.</span>
  54 |     | <span class='neutral'>             */</span>
  55 |     | <span class='neutral'>            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.</span>
  56 |     | <span class='neutral'>            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))</span>
  57 |     | <span class='neutral'>            // Deploy a new contract with the generated creation code.</span>
  58 |     | <span class='neutral'>            pointer := create(0, add(data, 0x15), add(n, 0xb))</span>
  59 |     | <span class='neutral'>            if iszero(pointer) {</span>
  60 |     | <span class='neutral'>                mstore(0x00, 0x30116425) // `DeploymentFailed()`.</span>
  61 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  62 |     | <span class='neutral'>            }</span>
  63 |     | <span class='neutral'>            mstore(data, n) // Restore the length of `data`.</span>
  64 |     | <span class='neutral'>        }</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /// @dev Writes `data` into the bytecode of a storage contract with `salt`</span>
  68 |     | <span class='neutral'>    /// and returns its normal CREATE2 deterministic address.</span>
  69 |     | <span class='neutral'>    function writeCounterfactual(bytes memory data, bytes32 salt)</span>
  70 |     | <span class='neutral'>        internal</span>
  71 |     | <span class='neutral'>        returns (address pointer)</span>
  72 |     | <span class='neutral'>    {</span>
  73 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  74 |     | <span class='neutral'>        assembly {</span>
  75 |     | <span class='neutral'>            let n := mload(data)</span>
  76 |     | <span class='neutral'>            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.</span>
  77 |     | <span class='neutral'>            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))</span>
  78 |     | <span class='neutral'>            // Deploy a new contract with the generated creation code.</span>
  79 |     | <span class='neutral'>            pointer := create2(0, add(data, 0x15), add(n, 0xb), salt)</span>
  80 |     | <span class='neutral'>            if iszero(pointer) {</span>
  81 |     | <span class='neutral'>                mstore(0x00, 0x30116425) // `DeploymentFailed()`.</span>
  82 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
  83 |     | <span class='neutral'>            }</span>
  84 |     | <span class='neutral'>            mstore(data, n) // Restore the length of `data`.</span>
  85 |     | <span class='neutral'>        }</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.</span>
  89 |     | <span class='neutral'>    /// This uses the so-called &quot;CREATE3&quot; workflow,</span>
  90 |     | <span class='neutral'>    /// which means that `pointer` is agnostic to `data, and only depends on `salt`.</span>
  91 |     | <span class='neutral'>    function writeDeterministic(bytes memory data, bytes32 salt)</span>
  92 |     | <span class='neutral'>        internal</span>
  93 |     | <span class='neutral'>        returns (address pointer)</span>
  94 |     | <span class='neutral'>    {</span>
  95 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  96 |     | <span class='neutral'>        assembly {</span>
  97 |     | <span class='neutral'>            let n := mload(data)</span>
  98 |     | <span class='neutral'>            mstore(0x00, _CREATE3_PROXY_INITCODE) // Store the `_PROXY_INITCODE`.</span>
  99 |     | <span class='neutral'>            let proxy := create2(0, 0x10, 0x10, salt)</span>
 100 |     | <span class='neutral'>            if iszero(proxy) {</span>
 101 |     | <span class='neutral'>                mstore(0x00, 0x30116425) // `DeploymentFailed()`.</span>
 102 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
 103 |     | <span class='neutral'>            }</span>
 104 |     | <span class='neutral'>            mstore(0x14, proxy) // Store the proxy&#39;s address.</span>
 105 |     | <span class='neutral'>            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).</span>
 106 |     | <span class='neutral'>            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).</span>
 107 |     | <span class='neutral'>            mstore(0x00, 0xd694)</span>
 108 |     | <span class='neutral'>            mstore8(0x34, 0x01) // Nonce of the proxy contract (1).</span>
 109 |     | <span class='neutral'>            pointer := keccak256(0x1e, 0x17)</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.</span>
 112 |     | <span class='neutral'>            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))</span>
 113 |     | <span class='neutral'>            if iszero(</span>
 114 |     | <span class='neutral'>                mul( // The arguments of `mul` are evaluated last to first.</span>
 115 |     | <span class='neutral'>                    extcodesize(pointer),</span>
 116 |     | <span class='neutral'>                    call(gas(), proxy, 0, add(data, 0x15), add(n, 0xb), codesize(), 0x00)</span>
 117 |     | <span class='neutral'>                )</span>
 118 |     | <span class='neutral'>            ) {</span>
 119 |     | <span class='neutral'>                mstore(0x00, 0x30116425) // `DeploymentFailed()`.</span>
 120 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
 121 |     | <span class='neutral'>            }</span>
 122 |     | <span class='neutral'>            mstore(data, n) // Restore the length of `data`.</span>
 123 |     | <span class='neutral'>        }</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
 127 |     | <span class='neutral'>    /*                    ADDRESS CALCULATIONS                    */</span>
 128 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /// @dev Returns the initialization code hash of the storage contract for `data`.</span>
 131 |     | <span class='neutral'>    /// Used for mining vanity addresses with create2crunch.</span>
 132 |     | <span class='neutral'>    function initCodeHash(bytes memory data) internal pure returns (bytes32 hash) {</span>
 133 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 134 |     | <span class='neutral'>        assembly {</span>
 135 |     | <span class='neutral'>            let n := mload(data)</span>
 136 |     | <span class='neutral'>            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.</span>
 137 |     | <span class='neutral'>            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xfffe))</span>
 138 |     | <span class='neutral'>            mstore(data, add(0x61000180600a3d393df300, shl(0x40, n)))</span>
 139 |     | <span class='neutral'>            hash := keccak256(add(data, 0x15), add(n, 0xb))</span>
 140 |     | <span class='neutral'>            mstore(data, n) // Restore the length of `data`.</span>
 141 |     | <span class='neutral'>        }</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    /// @dev Equivalent to `predictCounterfactualAddress(data, salt, address(this))`</span>
 145 |     | <span class='neutral'>    function predictCounterfactualAddress(bytes memory data, bytes32 salt)</span>
 146 |     | <span class='neutral'>        internal</span>
 147 |     | <span class='neutral'>        view</span>
 148 |     | <span class='neutral'>        returns (address pointer)</span>
 149 |     | <span class='neutral'>    {</span>
 150 |     | <span class='neutral'>        pointer = predictCounterfactualAddress(data, salt, address(this));</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    /// @dev Returns the CREATE2 address of the storage contract for `data`</span>
 154 |     | <span class='neutral'>    /// deployed with `salt` by `deployer`.</span>
 155 |     | <span class='neutral'>    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.</span>
 156 |     | <span class='neutral'>    function predictCounterfactualAddress(bytes memory data, bytes32 salt, address deployer)</span>
 157 |     | <span class='neutral'>        internal</span>
 158 |     | <span class='neutral'>        pure</span>
 159 |     | <span class='neutral'>        returns (address predicted)</span>
 160 |     | <span class='neutral'>    {</span>
 161 |     | <span class='neutral'>        bytes32 hash = initCodeHash(data);</span>
 162 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 163 |     | <span class='neutral'>        assembly {</span>
 164 |     | <span class='neutral'>            // Compute and store the bytecode hash.</span>
 165 |     | <span class='neutral'>            mstore8(0x00, 0xff) // Write the prefix.</span>
 166 |     | <span class='neutral'>            mstore(0x35, hash)</span>
 167 |     | <span class='neutral'>            mstore(0x01, shl(96, deployer))</span>
 168 |     | <span class='neutral'>            mstore(0x15, salt)</span>
 169 |     | <span class='neutral'>            predicted := keccak256(0x00, 0x55)</span>
 170 |     | <span class='neutral'>            // Restore the part of the free memory pointer that has been overwritten.</span>
 171 |     | <span class='neutral'>            mstore(0x35, 0)</span>
 172 |     | <span class='neutral'>        }</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    /// @dev Equivalent to `predictDeterministicAddress(salt, address(this))`.</span>
 176 |     | <span class='neutral'>    function predictDeterministicAddress(bytes32 salt) internal view returns (address pointer) {</span>
 177 |     | <span class='neutral'>        pointer = predictDeterministicAddress(salt, address(this));</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    /// @dev Returns the &quot;CREATE3&quot; deterministic address for `salt` with `deployer`.</span>
 181 |     | <span class='neutral'>    function predictDeterministicAddress(bytes32 salt, address deployer)</span>
 182 |     | <span class='neutral'>        internal</span>
 183 |     | <span class='neutral'>        pure</span>
 184 |     | <span class='neutral'>        returns (address pointer)</span>
 185 |     | <span class='neutral'>    {</span>
 186 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 187 |     | <span class='neutral'>        assembly {</span>
 188 |     | <span class='neutral'>            let m := mload(0x40) // Cache the free memory pointer.</span>
 189 |     | <span class='neutral'>            mstore(0x00, deployer) // Store `deployer`.</span>
 190 |     | <span class='neutral'>            mstore8(0x0b, 0xff) // Store the prefix.</span>
 191 |     | <span class='neutral'>            mstore(0x20, salt) // Store the salt.</span>
 192 |     | <span class='neutral'>            mstore(0x40, CREATE3_PROXY_INITCODE_HASH) // Store the bytecode hash.</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>            mstore(0x14, keccak256(0x0b, 0x55)) // Store the proxy&#39;s address.</span>
 195 |     | <span class='neutral'>            mstore(0x40, m) // Restore the free memory pointer.</span>
 196 |     | <span class='neutral'>            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).</span>
 197 |     | <span class='neutral'>            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).</span>
 198 |     | <span class='neutral'>            mstore(0x00, 0xd694)</span>
 199 |     | <span class='neutral'>            mstore8(0x34, 0x01) // Nonce of the proxy contract (1).</span>
 200 |     | <span class='neutral'>            pointer := keccak256(0x1e, 0x17)</span>
 201 |     | <span class='neutral'>        }</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
 205 |     | <span class='neutral'>    /*                         READ LOGIC                         */</span>
 206 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    /// @dev Equivalent to `read(pointer, 0, 2 ** 256 - 1)`.</span>
 209 |     | <span class='neutral'>    function read(address pointer) internal view returns (bytes memory data) {</span>
 210 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 211 |     | <span class='neutral'>        assembly {</span>
 212 |     | <span class='neutral'>            data := mload(0x40)</span>
 213 |     | <span class='neutral'>            let n := and(sub(extcodesize(pointer), 0x01), 0xffffffffff)</span>
 214 |     | <span class='neutral'>            extcodecopy(pointer, add(data, 0x1f), 0x00, add(n, 0x21))</span>
 215 |     | <span class='neutral'>            mstore(data, n) // Store the length.</span>
 216 |     | <span class='neutral'>            mstore(0x40, add(n, add(data, 0x40))) // Allocate memory.</span>
 217 |     | <span class='neutral'>        }</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    /// @dev Equivalent to `read(pointer, start, 2 ** 256 - 1)`.</span>
 221 |     | <span class='neutral'>    function read(address pointer, uint256 start) internal view returns (bytes memory data) {</span>
 222 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 223 |     | <span class='neutral'>        assembly {</span>
 224 |     | <span class='neutral'>            data := mload(0x40)</span>
 225 |     | <span class='neutral'>            let n := and(sub(extcodesize(pointer), 0x01), 0xffffffffff)</span>
 226 |     | <span class='neutral'>            extcodecopy(pointer, add(data, 0x1f), start, add(n, 0x21))</span>
 227 |     | <span class='neutral'>            mstore(data, mul(sub(n, start), lt(start, n))) // Store the length.</span>
 228 |     | <span class='neutral'>            mstore(0x40, add(data, add(0x40, mload(data)))) // Allocate memory.</span>
 229 |     | <span class='neutral'>        }</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='neutral'>    /// @dev Returns a slice of the data on `pointer` from `start` to `end`.</span>
 233 |     | <span class='neutral'>    /// `start` and `end` will be clamped to the range `[0, args.length]`.</span>
 234 |     | <span class='neutral'>    /// The `pointer` MUST be deployed via the SSTORE2 write functions.</span>
 235 |     | <span class='neutral'>    /// Otherwise, the behavior is undefined.</span>
 236 |     | <span class='neutral'>    /// Out-of-gas reverts if `pointer` does not have any code.</span>
 237 |     | <span class='unexecuted'>    function read(address pointer, uint256 start, uint256 end)</span>
 238 |     | <span class='neutral'>        internal</span>
 239 |     | <span class='neutral'>        view</span>
 240 |     | <span class='neutral'>        returns (bytes memory data)</span>
 241 |     | <span class='neutral'>    {</span>
 242 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 243 |     | <span class='neutral'>        assembly {</span>
 244 |     | <span class='unexecuted'>            data := mload(0x40)</span>
 245 |     | <span class='unexecuted'>            if iszero(lt(end, 0xffff)) { end := 0xffff }</span>
 246 |     | <span class='unexecuted'>            let d := mul(sub(end, start), lt(start, end))</span>
 247 |     | <span class='unexecuted'>            extcodecopy(pointer, add(data, 0x1f), start, add(d, 0x01))</span>
 248 |     | <span class='unexecuted'>            if iszero(and(0xff, mload(add(data, d)))) {</span>
 249 |     | <span class='unexecuted'>                let n := sub(extcodesize(pointer), 0x01)</span>
 250 |     | <span class='unexecuted'>                returndatacopy(returndatasize(), returndatasize(), shr(64, n))</span>
 251 |     | <span class='unexecuted'>                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))</span>
 252 |     | <span class='neutral'>            }</span>
 253 |     | <span class='unexecuted'>            mstore(data, d) // Store the length.</span>
 254 |     | <span class='unexecuted'>            mstore(add(add(data, 0x20), d), 0) // Zeroize the slot after the bytes.</span>
 255 |     | <span class='unexecuted'>            mstore(0x40, add(add(data, 0x40), d)) // Allocate memory.</span>
 256 |     | <span class='neutral'>        }</span>
 257 |     | <span class='neutral'>    }</span>
 258 |     | <span class='neutral'>}</span>
 259 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/chimera/src/Asserts.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract Asserts {</span>
  5 |     | <span class='neutral'>    function gt(uint256 a, uint256 b, string memory reason) internal virtual;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function gte(uint256 a, uint256 b, string memory reason) internal virtual;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function lt(uint256 a, uint256 b, string memory reason) internal virtual;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function lte(uint256 a, uint256 b, string memory reason) internal virtual;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function eq(uint256 a, uint256 b, string memory reason) internal virtual;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function t(bool b, string memory reason) internal virtual;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function between(uint256 value, uint256 low, uint256 high) internal virtual returns (uint256);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function between(int256 value, int256 low, int256 high) internal virtual returns (int256);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function precondition(bool p) internal virtual;</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/chimera/src/BaseProperties.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>import {BaseSetup} from &quot;./BaseSetup.sol&quot;;</span>
 5 |     | <span class='neutral'></span>
 6 |     | <span class='neutral'>abstract contract BaseProperties is BaseSetup {}</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/chimera/src/BaseSetup.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>abstract contract BaseSetup {</span>
 5 |     | <span class='neutral'>    function setup() internal virtual;</span>
 6 |     | <span class='neutral'>}</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/chimera/src/BaseTargetFunctions.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>import {BaseProperties} from &quot;./BaseProperties.sol&quot;;</span>
 5 |     | <span class='neutral'>import {Asserts} from &quot;./Asserts.sol&quot;;</span>
 6 |     | <span class='neutral'></span>
 7 |     | <span class='neutral'>abstract contract BaseTargetFunctions is BaseProperties, Asserts {}</span>
 8 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/chimera/src/CryticAsserts.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Asserts} from &quot;./Asserts.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 | *   | <span class='executed'>contract CryticAsserts is Asserts {</span>
  7 |     | <span class='neutral'>    event Log(string);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function gt(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 10 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 11 |     | <span class='neutral'>            emit Log(reason);</span>
 12 |     | <span class='neutral'>            assert(false);</span>
 13 |     | <span class='neutral'>        }</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function gte(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 17 |     | <span class='neutral'>        if (!(a &gt;= b)) {</span>
 18 |     | <span class='neutral'>            emit Log(reason);</span>
 19 |     | <span class='neutral'>            assert(false);</span>
 20 |     | <span class='neutral'>        }</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function lt(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 24 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
 25 |     | <span class='neutral'>            emit Log(reason);</span>
 26 |     | <span class='neutral'>            assert(false);</span>
 27 |     | <span class='neutral'>        }</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    function lte(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 31 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 32 |     | <span class='neutral'>            emit Log(reason);</span>
 33 |     | <span class='neutral'>            assert(false);</span>
 34 |     | <span class='neutral'>        }</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function eq(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 38 |     | <span class='neutral'>        if (!(a == b)) {</span>
 39 |     | <span class='neutral'>            emit Log(reason);</span>
 40 |     | <span class='neutral'>            assert(false);</span>
 41 |     | <span class='neutral'>        }</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='unexecuted'>    function t(bool b, string memory reason) internal virtual override {</span>
 45 |     | <span class='unexecuted'>        if (!b) {</span>
 46 |     | <span class='unexecuted'>            emit Log(reason);</span>
 47 |     | <span class='unexecuted'>            assert(false);</span>
 48 |     | <span class='neutral'>        }</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    function between(uint256 value, uint256 low, uint256 high) internal virtual override returns (uint256) {</span>
 52 |     | <span class='neutral'>        if (value &lt; low || value &gt; high) {</span>
 53 |     | <span class='neutral'>            uint256 ans = low + (value % (high - low + 1));</span>
 54 |     | <span class='neutral'>            return ans;</span>
 55 |     | <span class='neutral'>        }</span>
 56 |     | <span class='neutral'>        return value;</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    function between(int256 value, int256 low, int256 high) internal virtual override returns (int256) {</span>
 60 |     | <span class='neutral'>        if (value &lt; low || value &gt; high) {</span>
 61 |     | <span class='neutral'>            int256 range = high - low + 1;</span>
 62 |     | <span class='neutral'>            int256 clamped = (value - low) % (range);</span>
 63 |     | <span class='neutral'>            if (clamped &lt; 0) clamped += range;</span>
 64 |     | <span class='neutral'>            int256 ans = low + clamped;</span>
 65 |     | <span class='neutral'>            return ans;</span>
 66 |     | <span class='neutral'>        }</span>
 67 |     | <span class='neutral'>        return value;</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>    function precondition(bool p) internal virtual override {</span>
 71 |     | <span class='neutral'>        require(p);</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'>}</span>
 74 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/chimera/src/FoundryAsserts.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Test} from &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Asserts} from &quot;./Asserts.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract FoundryAsserts is Test, Asserts {</span>
  8 |     | <span class='neutral'>    function gt(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
  9 |     | <span class='neutral'>        assertGt(a, b, reason);</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function gte(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 13 |     | <span class='neutral'>        assertGe(a, b, reason);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function lt(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 17 |     | <span class='neutral'>        assertLt(a, b, reason);</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function lte(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 21 |     | <span class='neutral'>        assertLe(a, b, reason);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    function eq(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 25 |     | <span class='neutral'>        assertEq(a, b, reason);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>    function t(bool b, string memory reason) internal virtual override {</span>
 29 |     | <span class='unexecuted'>        assertTrue(b, reason);</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    function between(uint256 value, uint256 low, uint256 high) internal virtual override returns (uint256) {</span>
 33 |     | <span class='neutral'>        if (value &lt; low || value &gt; high) {</span>
 34 |     | <span class='neutral'>            uint256 ans = low + (value % (high - low + 1));</span>
 35 |     | <span class='neutral'>            return ans;</span>
 36 |     | <span class='neutral'>        }</span>
 37 |     | <span class='neutral'>        return value;</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    function between(int256 value, int256 low, int256 high) internal virtual override returns (int256) {</span>
 41 |     | <span class='neutral'>        if (value &lt; low || value &gt; high) {</span>
 42 |     | <span class='neutral'>            int256 range = high - low + 1;</span>
 43 |     | <span class='neutral'>            int256 clamped = (value - low) % (range);</span>
 44 |     | <span class='neutral'>            if (clamped &lt; 0) clamped += range;</span>
 45 |     | <span class='neutral'>            int256 ans = low + clamped;</span>
 46 |     | <span class='neutral'>            return ans;</span>
 47 |     | <span class='neutral'>        }</span>
 48 |     | <span class='neutral'>        return value;</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    function precondition(bool p) internal virtual override {</span>
 52 |     | <span class='neutral'>        vm.assume(p);</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'>}</span>
 55 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/chimera/src/Hevm.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// slither-disable-start shadowing-local</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IHevm {</span>
  7 |     | <span class='neutral'>    // Set block.timestamp to newTimestamp</span>
  8 |     | <span class='neutral'>    function warp(uint256 newTimestamp) external;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    // Set block.number to newNumber</span>
 11 |     | <span class='neutral'>    function roll(uint256 newNumber) external;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    // Add the condition b to the assumption base for the current branch</span>
 14 |     | <span class='neutral'>    // This function is almost identical to require</span>
 15 |     | <span class='neutral'>    function assume(bool b) external;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    // Sets the eth balance of usr to amt</span>
 18 |     | <span class='neutral'>    function deal(address usr, uint256 amt) external;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    // Loads a storage slot from an address</span>
 21 |     | <span class='neutral'>    function load(address where, bytes32 slot) external returns (bytes32);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    // Stores a value to an address&#39; storage slot</span>
 24 |     | <span class='neutral'>    function store(address where, bytes32 slot, bytes32 value) external;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    // Signs data (privateKey, digest) =&gt; (v, r, s)</span>
 27 |     | <span class='neutral'>    function sign(uint256 privateKey, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    // Gets address for a given private key</span>
 30 |     | <span class='neutral'>    function addr(uint256 privateKey) external returns (address addr);</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    // Performs a foreign function call via terminal</span>
 33 |     | <span class='neutral'>    function ffi(string[] calldata inputs) external returns (bytes memory result);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    // Performs the next smart contract call with specified `msg.sender`</span>
 36 |     | <span class='neutral'>    function prank(address newSender) external;</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and the latest block and returns the identifier of the fork</span>
 39 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias) external returns (uint256);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    // Takes a fork identifier created by createFork and sets the corresponding forked state as active</span>
 42 |     | <span class='neutral'>    function selectFork(uint256 forkId) external;</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    // Returns the identifier of the current fork</span>
 45 |     | <span class='neutral'>    function activeFork() external returns (uint256);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    // Labels the address in traces</span>
 48 |     | <span class='neutral'>    function label(address addr, string calldata label) external;</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    /// Sets an address&#39; code.</span>
 51 |     | <span class='neutral'>    function etch(address target, bytes calldata newRuntimeBytecode) external;</span>
 52 |     | <span class='neutral'>}</span>
 53 |     | <span class='neutral'></span>
 54 | *   | <span class='executed'>IHevm constant vm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>// slither-disable-end shadowing-local</span>
 57 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/Base.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {StdStorage} from &quot;./StdStorage.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Vm, VmSafe} from &quot;./Vm.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract CommonBase {</span>
  8 |     | <span class='neutral'>    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.</span>
  9 |     | <span class='neutral'>    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;))));</span>
 10 |     | <span class='neutral'>    // console.sol and console2.sol work by executing a staticcall to this address.</span>
 11 |     | <span class='neutral'>    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
 12 |     | <span class='neutral'>    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.</span>
 13 |     | <span class='neutral'>    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;</span>
 14 |     | <span class='neutral'>    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.</span>
 15 |     | <span class='neutral'>    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(&quot;foundry default caller&quot;))));</span>
 16 |     | <span class='neutral'>    // Address of the test contract, deployed by the DEFAULT_SENDER.</span>
 17 |     | <span class='neutral'>    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;</span>
 18 |     | <span class='neutral'>    // Deterministic deployment address of the Multicall3 contract.</span>
 19 |     | <span class='neutral'>    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;</span>
 20 |     | <span class='neutral'>    // The order of the secp256k1 curve.</span>
 21 |     | <span class='neutral'>    uint256 internal constant SECP256K1_ORDER =</span>
 22 |     | <span class='neutral'>        115792089237316195423570985008687907852837564279074904382605163141518161494337;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    uint256 internal constant UINT256_MAX =</span>
 25 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    Vm internal constant vm = Vm(VM_ADDRESS);</span>
 28 |     | <span class='neutral'>    StdStorage internal stdstore;</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>abstract contract TestBase is CommonBase {}</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>abstract contract ScriptBase is CommonBase {</span>
 34 |     | <span class='neutral'>    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);</span>
 35 |     | <span class='neutral'>}</span>
 36 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/StdAssertions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>abstract contract StdAssertions {</span>
   8 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>    event log(string);</span>
  11 |     | <span class='neutral'>    event logs(bytes);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    event log_address(address);</span>
  14 |     | <span class='neutral'>    event log_bytes32(bytes32);</span>
  15 |     | <span class='neutral'>    event log_int(int256);</span>
  16 |     | <span class='neutral'>    event log_uint(uint256);</span>
  17 |     | <span class='neutral'>    event log_bytes(bytes);</span>
  18 |     | <span class='neutral'>    event log_string(string);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    event log_named_address(string key, address val);</span>
  21 |     | <span class='neutral'>    event log_named_bytes32(string key, bytes32 val);</span>
  22 |     | <span class='neutral'>    event log_named_decimal_int(string key, int256 val, uint256 decimals);</span>
  23 |     | <span class='neutral'>    event log_named_decimal_uint(string key, uint256 val, uint256 decimals);</span>
  24 |     | <span class='neutral'>    event log_named_int(string key, int256 val);</span>
  25 |     | <span class='neutral'>    event log_named_uint(string key, uint256 val);</span>
  26 |     | <span class='neutral'>    event log_named_bytes(string key, bytes val);</span>
  27 |     | <span class='neutral'>    event log_named_string(string key, string val);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    event log_array(uint256[] val);</span>
  30 |     | <span class='neutral'>    event log_array(int256[] val);</span>
  31 |     | <span class='neutral'>    event log_array(address[] val);</span>
  32 |     | <span class='neutral'>    event log_named_array(string key, uint256[] val);</span>
  33 |     | <span class='neutral'>    event log_named_array(string key, int256[] val);</span>
  34 |     | <span class='neutral'>    event log_named_array(string key, address[] val);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    bool private _failed;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    function failed() public view returns (bool) {</span>
  39 |     | <span class='unexecuted'>        if (_failed) {</span>
  40 |     | <span class='unexecuted'>            return _failed;</span>
  41 |     | <span class='neutral'>        } else {</span>
  42 |     | <span class='unexecuted'>            return vm.load(address(vm), bytes32(&quot;failed&quot;)) != bytes32(0);</span>
  43 |     | <span class='neutral'>        }</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    function fail() internal virtual {</span>
  47 |     | <span class='neutral'>        vm.store(address(vm), bytes32(&quot;failed&quot;), bytes32(uint256(1)));</span>
  48 |     | <span class='neutral'>        _failed = true;</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    function assertTrue(bool data) internal pure virtual {</span>
  52 |     | <span class='neutral'>        vm.assertTrue(data);</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>    function assertTrue(bool data, string memory err) internal pure virtual {</span>
  56 |     | <span class='unexecuted'>        vm.assertTrue(data, err);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    function assertFalse(bool data) internal pure virtual {</span>
  60 |     | <span class='neutral'>        vm.assertFalse(data);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    function assertFalse(bool data, string memory err) internal pure virtual {</span>
  64 |     | <span class='neutral'>        vm.assertFalse(data, err);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    function assertEq(bool left, bool right) internal pure virtual {</span>
  68 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    function assertEq(bool left, bool right, string memory err) internal pure virtual {</span>
  72 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    function assertEq(uint256 left, uint256 right) internal pure virtual {</span>
  76 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    function assertEq(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
  80 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
  84 |     | <span class='neutral'>        vm.assertEqDecimal(left, right, decimals);</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
  88 |     | <span class='neutral'>        vm.assertEqDecimal(left, right, decimals, err);</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    function assertEq(int256 left, int256 right) internal pure virtual {</span>
  92 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    function assertEq(int256 left, int256 right, string memory err) internal pure virtual {</span>
  96 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    function assertEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 100 |     | <span class='neutral'>        vm.assertEqDecimal(left, right, decimals);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 104 |     | <span class='neutral'>        vm.assertEqDecimal(left, right, decimals, err);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function assertEq(address left, address right) internal pure virtual {</span>
 108 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    function assertEq(address left, address right, string memory err) internal pure virtual {</span>
 112 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    function assertEq(bytes32 left, bytes32 right) internal pure virtual {</span>
 116 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    function assertEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {</span>
 120 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    function assertEq32(bytes32 left, bytes32 right) internal pure virtual {</span>
 124 |     | <span class='neutral'>        assertEq(left, right);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function assertEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {</span>
 128 |     | <span class='neutral'>        assertEq(left, right, err);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    function assertEq(string memory left, string memory right) internal pure virtual {</span>
 132 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    function assertEq(string memory left, string memory right, string memory err) internal pure virtual {</span>
 136 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    function assertEq(bytes memory left, bytes memory right) internal pure virtual {</span>
 140 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    function assertEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {</span>
 144 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    function assertEq(bool[] memory left, bool[] memory right) internal pure virtual {</span>
 148 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    function assertEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {</span>
 152 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    function assertEq(uint256[] memory left, uint256[] memory right) internal pure virtual {</span>
 156 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    function assertEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {</span>
 160 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    function assertEq(int256[] memory left, int256[] memory right) internal pure virtual {</span>
 164 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    function assertEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {</span>
 168 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    function assertEq(address[] memory left, address[] memory right) internal pure virtual {</span>
 172 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    function assertEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {</span>
 176 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    function assertEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {</span>
 180 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    function assertEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {</span>
 184 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    function assertEq(string[] memory left, string[] memory right) internal pure virtual {</span>
 188 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    function assertEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {</span>
 192 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    function assertEq(bytes[] memory left, bytes[] memory right) internal pure virtual {</span>
 196 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>    function assertEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {</span>
 200 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    // Legacy helper</span>
 204 |     | <span class='neutral'>    function assertEqUint(uint256 left, uint256 right) internal pure virtual {</span>
 205 |     | <span class='neutral'>        assertEq(left, right);</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    function assertNotEq(bool left, bool right) internal pure virtual {</span>
 209 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    function assertNotEq(bool left, bool right, string memory err) internal pure virtual {</span>
 213 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    function assertNotEq(uint256 left, uint256 right) internal pure virtual {</span>
 217 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    function assertNotEq(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 221 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 225 |     | <span class='neutral'>        vm.assertNotEqDecimal(left, right, decimals);</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err)</span>
 229 |     | <span class='neutral'>        internal</span>
 230 |     | <span class='neutral'>        pure</span>
 231 |     | <span class='neutral'>        virtual</span>
 232 |     | <span class='neutral'>    {</span>
 233 |     | <span class='neutral'>        vm.assertNotEqDecimal(left, right, decimals, err);</span>
 234 |     | <span class='neutral'>    }</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>    function assertNotEq(int256 left, int256 right) internal pure virtual {</span>
 237 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    function assertNotEq(int256 left, int256 right, string memory err) internal pure virtual {</span>
 241 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 242 |     | <span class='neutral'>    }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 245 |     | <span class='neutral'>        vm.assertNotEqDecimal(left, right, decimals);</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 249 |     | <span class='neutral'>        vm.assertNotEqDecimal(left, right, decimals, err);</span>
 250 |     | <span class='neutral'>    }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>    function assertNotEq(address left, address right) internal pure virtual {</span>
 253 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 254 |     | <span class='neutral'>    }</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>    function assertNotEq(address left, address right, string memory err) internal pure virtual {</span>
 257 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>    function assertNotEq(bytes32 left, bytes32 right) internal pure virtual {</span>
 261 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>    function assertNotEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {</span>
 265 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>    function assertNotEq32(bytes32 left, bytes32 right) internal pure virtual {</span>
 269 |     | <span class='neutral'>        assertNotEq(left, right);</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>    function assertNotEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {</span>
 273 |     | <span class='neutral'>        assertNotEq(left, right, err);</span>
 274 |     | <span class='neutral'>    }</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>    function assertNotEq(string memory left, string memory right) internal pure virtual {</span>
 277 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    function assertNotEq(string memory left, string memory right, string memory err) internal pure virtual {</span>
 281 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>    function assertNotEq(bytes memory left, bytes memory right) internal pure virtual {</span>
 285 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 286 |     | <span class='neutral'>    }</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>    function assertNotEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {</span>
 289 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>    function assertNotEq(bool[] memory left, bool[] memory right) internal pure virtual {</span>
 293 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 294 |     | <span class='neutral'>    }</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>    function assertNotEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {</span>
 297 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'>    function assertNotEq(uint256[] memory left, uint256[] memory right) internal pure virtual {</span>
 301 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 302 |     | <span class='neutral'>    }</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>    function assertNotEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {</span>
 305 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='neutral'>    function assertNotEq(int256[] memory left, int256[] memory right) internal pure virtual {</span>
 309 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 310 |     | <span class='neutral'>    }</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>    function assertNotEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {</span>
 313 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    function assertNotEq(address[] memory left, address[] memory right) internal pure virtual {</span>
 317 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 318 |     | <span class='neutral'>    }</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>    function assertNotEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {</span>
 321 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 322 |     | <span class='neutral'>    }</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='neutral'>    function assertNotEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {</span>
 325 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 326 |     | <span class='neutral'>    }</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='neutral'>    function assertNotEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {</span>
 329 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 330 |     | <span class='neutral'>    }</span>
 331 |     | <span class='neutral'></span>
 332 |     | <span class='neutral'>    function assertNotEq(string[] memory left, string[] memory right) internal pure virtual {</span>
 333 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 334 |     | <span class='neutral'>    }</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='neutral'>    function assertNotEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {</span>
 337 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 338 |     | <span class='neutral'>    }</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='neutral'>    function assertNotEq(bytes[] memory left, bytes[] memory right) internal pure virtual {</span>
 341 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>    function assertNotEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {</span>
 345 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 346 |     | <span class='neutral'>    }</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='neutral'>    function assertLt(uint256 left, uint256 right) internal pure virtual {</span>
 349 |     | <span class='neutral'>        vm.assertLt(left, right);</span>
 350 |     | <span class='neutral'>    }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>    function assertLt(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 353 |     | <span class='neutral'>        vm.assertLt(left, right, err);</span>
 354 |     | <span class='neutral'>    }</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='neutral'>    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 357 |     | <span class='neutral'>        vm.assertLtDecimal(left, right, decimals);</span>
 358 |     | <span class='neutral'>    }</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='neutral'>    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 361 |     | <span class='neutral'>        vm.assertLtDecimal(left, right, decimals, err);</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='neutral'>    function assertLt(int256 left, int256 right) internal pure virtual {</span>
 365 |     | <span class='neutral'>        vm.assertLt(left, right);</span>
 366 |     | <span class='neutral'>    }</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='neutral'>    function assertLt(int256 left, int256 right, string memory err) internal pure virtual {</span>
 369 |     | <span class='neutral'>        vm.assertLt(left, right, err);</span>
 370 |     | <span class='neutral'>    }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>    function assertLtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 373 |     | <span class='neutral'>        vm.assertLtDecimal(left, right, decimals);</span>
 374 |     | <span class='neutral'>    }</span>
 375 |     | <span class='neutral'></span>
 376 |     | <span class='neutral'>    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 377 |     | <span class='neutral'>        vm.assertLtDecimal(left, right, decimals, err);</span>
 378 |     | <span class='neutral'>    }</span>
 379 |     | <span class='neutral'></span>
 380 |     | <span class='neutral'>    function assertGt(uint256 left, uint256 right) internal pure virtual {</span>
 381 |     | <span class='neutral'>        vm.assertGt(left, right);</span>
 382 |     | <span class='neutral'>    }</span>
 383 |     | <span class='neutral'></span>
 384 |     | <span class='neutral'>    function assertGt(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 385 |     | <span class='neutral'>        vm.assertGt(left, right, err);</span>
 386 |     | <span class='neutral'>    }</span>
 387 |     | <span class='neutral'></span>
 388 |     | <span class='neutral'>    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 389 |     | <span class='neutral'>        vm.assertGtDecimal(left, right, decimals);</span>
 390 |     | <span class='neutral'>    }</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='neutral'>    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 393 |     | <span class='neutral'>        vm.assertGtDecimal(left, right, decimals, err);</span>
 394 |     | <span class='neutral'>    }</span>
 395 |     | <span class='neutral'></span>
 396 |     | <span class='neutral'>    function assertGt(int256 left, int256 right) internal pure virtual {</span>
 397 |     | <span class='neutral'>        vm.assertGt(left, right);</span>
 398 |     | <span class='neutral'>    }</span>
 399 |     | <span class='neutral'></span>
 400 |     | <span class='neutral'>    function assertGt(int256 left, int256 right, string memory err) internal pure virtual {</span>
 401 |     | <span class='neutral'>        vm.assertGt(left, right, err);</span>
 402 |     | <span class='neutral'>    }</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='neutral'>    function assertGtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 405 |     | <span class='neutral'>        vm.assertGtDecimal(left, right, decimals);</span>
 406 |     | <span class='neutral'>    }</span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='neutral'>    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 409 |     | <span class='neutral'>        vm.assertGtDecimal(left, right, decimals, err);</span>
 410 |     | <span class='neutral'>    }</span>
 411 |     | <span class='neutral'></span>
 412 |     | <span class='neutral'>    function assertLe(uint256 left, uint256 right) internal pure virtual {</span>
 413 |     | <span class='neutral'>        vm.assertLe(left, right);</span>
 414 |     | <span class='neutral'>    }</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>    function assertLe(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 417 |     | <span class='neutral'>        vm.assertLe(left, right, err);</span>
 418 |     | <span class='neutral'>    }</span>
 419 |     | <span class='neutral'></span>
 420 |     | <span class='neutral'>    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 421 |     | <span class='neutral'>        vm.assertLeDecimal(left, right, decimals);</span>
 422 |     | <span class='neutral'>    }</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='neutral'>    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 425 |     | <span class='neutral'>        vm.assertLeDecimal(left, right, decimals, err);</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    function assertLe(int256 left, int256 right) internal pure virtual {</span>
 429 |     | <span class='neutral'>        vm.assertLe(left, right);</span>
 430 |     | <span class='neutral'>    }</span>
 431 |     | <span class='neutral'></span>
 432 |     | <span class='neutral'>    function assertLe(int256 left, int256 right, string memory err) internal pure virtual {</span>
 433 |     | <span class='neutral'>        vm.assertLe(left, right, err);</span>
 434 |     | <span class='neutral'>    }</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='neutral'>    function assertLeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 437 |     | <span class='neutral'>        vm.assertLeDecimal(left, right, decimals);</span>
 438 |     | <span class='neutral'>    }</span>
 439 |     | <span class='neutral'></span>
 440 |     | <span class='neutral'>    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 441 |     | <span class='neutral'>        vm.assertLeDecimal(left, right, decimals, err);</span>
 442 |     | <span class='neutral'>    }</span>
 443 |     | <span class='neutral'></span>
 444 |     | <span class='neutral'>    function assertGe(uint256 left, uint256 right) internal pure virtual {</span>
 445 |     | <span class='neutral'>        vm.assertGe(left, right);</span>
 446 |     | <span class='neutral'>    }</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='neutral'>    function assertGe(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 449 |     | <span class='neutral'>        vm.assertGe(left, right, err);</span>
 450 |     | <span class='neutral'>    }</span>
 451 |     | <span class='neutral'></span>
 452 |     | <span class='neutral'>    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 453 |     | <span class='neutral'>        vm.assertGeDecimal(left, right, decimals);</span>
 454 |     | <span class='neutral'>    }</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='neutral'>    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 457 |     | <span class='neutral'>        vm.assertGeDecimal(left, right, decimals, err);</span>
 458 |     | <span class='neutral'>    }</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='neutral'>    function assertGe(int256 left, int256 right) internal pure virtual {</span>
 461 |     | <span class='neutral'>        vm.assertGe(left, right);</span>
 462 |     | <span class='neutral'>    }</span>
 463 |     | <span class='neutral'></span>
 464 |     | <span class='neutral'>    function assertGe(int256 left, int256 right, string memory err) internal pure virtual {</span>
 465 |     | <span class='neutral'>        vm.assertGe(left, right, err);</span>
 466 |     | <span class='neutral'>    }</span>
 467 |     | <span class='neutral'></span>
 468 |     | <span class='neutral'>    function assertGeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 469 |     | <span class='neutral'>        vm.assertGeDecimal(left, right, decimals);</span>
 470 |     | <span class='neutral'>    }</span>
 471 |     | <span class='neutral'></span>
 472 |     | <span class='neutral'>    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 473 |     | <span class='neutral'>        vm.assertGeDecimal(left, right, decimals, err);</span>
 474 |     | <span class='neutral'>    }</span>
 475 |     | <span class='neutral'></span>
 476 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) internal pure virtual {</span>
 477 |     | <span class='neutral'>        vm.assertApproxEqAbs(left, right, maxDelta);</span>
 478 |     | <span class='neutral'>    }</span>
 479 |     | <span class='neutral'></span>
 480 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string memory err)</span>
 481 |     | <span class='neutral'>        internal</span>
 482 |     | <span class='neutral'>        pure</span>
 483 |     | <span class='neutral'>        virtual</span>
 484 |     | <span class='neutral'>    {</span>
 485 |     | <span class='neutral'>        vm.assertApproxEqAbs(left, right, maxDelta, err);</span>
 486 |     | <span class='neutral'>    }</span>
 487 |     | <span class='neutral'></span>
 488 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals)</span>
 489 |     | <span class='neutral'>        internal</span>
 490 |     | <span class='neutral'>        pure</span>
 491 |     | <span class='neutral'>        virtual</span>
 492 |     | <span class='neutral'>    {</span>
 493 |     | <span class='neutral'>        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);</span>
 494 |     | <span class='neutral'>    }</span>
 495 |     | <span class='neutral'></span>
 496 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(</span>
 497 |     | <span class='neutral'>        uint256 left,</span>
 498 |     | <span class='neutral'>        uint256 right,</span>
 499 |     | <span class='neutral'>        uint256 maxDelta,</span>
 500 |     | <span class='neutral'>        uint256 decimals,</span>
 501 |     | <span class='neutral'>        string memory err</span>
 502 |     | <span class='neutral'>    ) internal pure virtual {</span>
 503 |     | <span class='neutral'>        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);</span>
 504 |     | <span class='neutral'>    }</span>
 505 |     | <span class='neutral'></span>
 506 |     | <span class='neutral'>    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) internal pure virtual {</span>
 507 |     | <span class='neutral'>        vm.assertApproxEqAbs(left, right, maxDelta);</span>
 508 |     | <span class='neutral'>    }</span>
 509 |     | <span class='neutral'></span>
 510 |     | <span class='neutral'>    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string memory err) internal pure virtual {</span>
 511 |     | <span class='neutral'>        vm.assertApproxEqAbs(left, right, maxDelta, err);</span>
 512 |     | <span class='neutral'>    }</span>
 513 |     | <span class='neutral'></span>
 514 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals)</span>
 515 |     | <span class='neutral'>        internal</span>
 516 |     | <span class='neutral'>        pure</span>
 517 |     | <span class='neutral'>        virtual</span>
 518 |     | <span class='neutral'>    {</span>
 519 |     | <span class='neutral'>        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);</span>
 520 |     | <span class='neutral'>    }</span>
 521 |     | <span class='neutral'></span>
 522 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals, string memory err)</span>
 523 |     | <span class='neutral'>        internal</span>
 524 |     | <span class='neutral'>        pure</span>
 525 |     | <span class='neutral'>        virtual</span>
 526 |     | <span class='neutral'>    {</span>
 527 |     | <span class='neutral'>        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);</span>
 528 |     | <span class='neutral'>    }</span>
 529 |     | <span class='neutral'></span>
 530 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 531 |     | <span class='neutral'>        uint256 left,</span>
 532 |     | <span class='neutral'>        uint256 right,</span>
 533 |     | <span class='neutral'>        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%</span>
 534 |     | <span class='neutral'>    ) internal pure virtual {</span>
 535 |     | <span class='neutral'>        vm.assertApproxEqRel(left, right, maxPercentDelta);</span>
 536 |     | <span class='neutral'>    }</span>
 537 |     | <span class='neutral'></span>
 538 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 539 |     | <span class='neutral'>        uint256 left,</span>
 540 |     | <span class='neutral'>        uint256 right,</span>
 541 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 542 |     | <span class='neutral'>        string memory err</span>
 543 |     | <span class='neutral'>    ) internal pure virtual {</span>
 544 |     | <span class='neutral'>        vm.assertApproxEqRel(left, right, maxPercentDelta, err);</span>
 545 |     | <span class='neutral'>    }</span>
 546 |     | <span class='neutral'></span>
 547 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 548 |     | <span class='neutral'>        uint256 left,</span>
 549 |     | <span class='neutral'>        uint256 right,</span>
 550 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 551 |     | <span class='neutral'>        uint256 decimals</span>
 552 |     | <span class='neutral'>    ) internal pure virtual {</span>
 553 |     | <span class='neutral'>        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);</span>
 554 |     | <span class='neutral'>    }</span>
 555 |     | <span class='neutral'></span>
 556 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 557 |     | <span class='neutral'>        uint256 left,</span>
 558 |     | <span class='neutral'>        uint256 right,</span>
 559 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 560 |     | <span class='neutral'>        uint256 decimals,</span>
 561 |     | <span class='neutral'>        string memory err</span>
 562 |     | <span class='neutral'>    ) internal pure virtual {</span>
 563 |     | <span class='neutral'>        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);</span>
 564 |     | <span class='neutral'>    }</span>
 565 |     | <span class='neutral'></span>
 566 |     | <span class='neutral'>    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) internal pure virtual {</span>
 567 |     | <span class='neutral'>        vm.assertApproxEqRel(left, right, maxPercentDelta);</span>
 568 |     | <span class='neutral'>    }</span>
 569 |     | <span class='neutral'></span>
 570 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 571 |     | <span class='neutral'>        int256 left,</span>
 572 |     | <span class='neutral'>        int256 right,</span>
 573 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 574 |     | <span class='neutral'>        string memory err</span>
 575 |     | <span class='neutral'>    ) internal pure virtual {</span>
 576 |     | <span class='neutral'>        vm.assertApproxEqRel(left, right, maxPercentDelta, err);</span>
 577 |     | <span class='neutral'>    }</span>
 578 |     | <span class='neutral'></span>
 579 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 580 |     | <span class='neutral'>        int256 left,</span>
 581 |     | <span class='neutral'>        int256 right,</span>
 582 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 583 |     | <span class='neutral'>        uint256 decimals</span>
 584 |     | <span class='neutral'>    ) internal pure virtual {</span>
 585 |     | <span class='neutral'>        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);</span>
 586 |     | <span class='neutral'>    }</span>
 587 |     | <span class='neutral'></span>
 588 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 589 |     | <span class='neutral'>        int256 left,</span>
 590 |     | <span class='neutral'>        int256 right,</span>
 591 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 592 |     | <span class='neutral'>        uint256 decimals,</span>
 593 |     | <span class='neutral'>        string memory err</span>
 594 |     | <span class='neutral'>    ) internal pure virtual {</span>
 595 |     | <span class='neutral'>        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);</span>
 596 |     | <span class='neutral'>    }</span>
 597 |     | <span class='neutral'></span>
 598 |     | <span class='neutral'>    // Inherited from DSTest, not used but kept for backwards-compatibility</span>
 599 |     | <span class='neutral'>    function checkEq0(bytes memory left, bytes memory right) internal pure returns (bool) {</span>
 600 |     | <span class='neutral'>        return keccak256(left) == keccak256(right);</span>
 601 |     | <span class='neutral'>    }</span>
 602 |     | <span class='neutral'></span>
 603 |     | <span class='neutral'>    function assertEq0(bytes memory left, bytes memory right) internal pure virtual {</span>
 604 |     | <span class='neutral'>        assertEq(left, right);</span>
 605 |     | <span class='neutral'>    }</span>
 606 |     | <span class='neutral'></span>
 607 |     | <span class='neutral'>    function assertEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {</span>
 608 |     | <span class='neutral'>        assertEq(left, right, err);</span>
 609 |     | <span class='neutral'>    }</span>
 610 |     | <span class='neutral'></span>
 611 |     | <span class='neutral'>    function assertNotEq0(bytes memory left, bytes memory right) internal pure virtual {</span>
 612 |     | <span class='neutral'>        assertNotEq(left, right);</span>
 613 |     | <span class='neutral'>    }</span>
 614 |     | <span class='neutral'></span>
 615 |     | <span class='neutral'>    function assertNotEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {</span>
 616 |     | <span class='neutral'>        assertNotEq(left, right, err);</span>
 617 |     | <span class='neutral'>    }</span>
 618 |     | <span class='neutral'></span>
 619 |     | <span class='neutral'>    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {</span>
 620 |     | <span class='neutral'>        assertEqCall(target, callDataA, target, callDataB, true);</span>
 621 |     | <span class='neutral'>    }</span>
 622 |     | <span class='neutral'></span>
 623 |     | <span class='neutral'>    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)</span>
 624 |     | <span class='neutral'>        internal</span>
 625 |     | <span class='neutral'>        virtual</span>
 626 |     | <span class='neutral'>    {</span>
 627 |     | <span class='neutral'>        assertEqCall(targetA, callDataA, targetB, callDataB, true);</span>
 628 |     | <span class='neutral'>    }</span>
 629 |     | <span class='neutral'></span>
 630 |     | <span class='neutral'>    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)</span>
 631 |     | <span class='neutral'>        internal</span>
 632 |     | <span class='neutral'>        virtual</span>
 633 |     | <span class='neutral'>    {</span>
 634 |     | <span class='neutral'>        assertEqCall(target, callDataA, target, callDataB, strictRevertData);</span>
 635 |     | <span class='neutral'>    }</span>
 636 |     | <span class='neutral'></span>
 637 |     | <span class='neutral'>    function assertEqCall(</span>
 638 |     | <span class='neutral'>        address targetA,</span>
 639 |     | <span class='neutral'>        bytes memory callDataA,</span>
 640 |     | <span class='neutral'>        address targetB,</span>
 641 |     | <span class='neutral'>        bytes memory callDataB,</span>
 642 |     | <span class='neutral'>        bool strictRevertData</span>
 643 |     | <span class='neutral'>    ) internal virtual {</span>
 644 |     | <span class='neutral'>        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);</span>
 645 |     | <span class='neutral'>        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);</span>
 646 |     | <span class='neutral'></span>
 647 |     | <span class='neutral'>        if (successA &amp;&amp; successB) {</span>
 648 |     | <span class='neutral'>            assertEq(returnDataA, returnDataB, &quot;Call return data does not match&quot;);</span>
 649 |     | <span class='neutral'>        }</span>
 650 |     | <span class='neutral'></span>
 651 |     | <span class='neutral'>        if (!successA &amp;&amp; !successB &amp;&amp; strictRevertData) {</span>
 652 |     | <span class='neutral'>            assertEq(returnDataA, returnDataB, &quot;Call revert data does not match&quot;);</span>
 653 |     | <span class='neutral'>        }</span>
 654 |     | <span class='neutral'></span>
 655 |     | <span class='neutral'>        if (!successA &amp;&amp; successB) {</span>
 656 |     | <span class='neutral'>            emit log(&quot;Error: Calls were not equal&quot;);</span>
 657 |     | <span class='neutral'>            emit log_named_bytes(&quot;  Left call revert data&quot;, returnDataA);</span>
 658 |     | <span class='neutral'>            emit log_named_bytes(&quot; Right call return data&quot;, returnDataB);</span>
 659 |     | <span class='neutral'>            revert(&quot;assertion failed&quot;);</span>
 660 |     | <span class='neutral'>        }</span>
 661 |     | <span class='neutral'></span>
 662 |     | <span class='neutral'>        if (successA &amp;&amp; !successB) {</span>
 663 |     | <span class='neutral'>            emit log(&quot;Error: Calls were not equal&quot;);</span>
 664 |     | <span class='neutral'>            emit log_named_bytes(&quot;  Left call return data&quot;, returnDataA);</span>
 665 |     | <span class='neutral'>            emit log_named_bytes(&quot; Right call revert data&quot;, returnDataB);</span>
 666 |     | <span class='neutral'>            revert(&quot;assertion failed&quot;);</span>
 667 |     | <span class='neutral'>        }</span>
 668 |     | <span class='neutral'>    }</span>
 669 |     | <span class='neutral'>}</span>
 670 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/StdChains.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * StdChains provides information about EVM compatible chains that can be used in scripts/tests.</span>
   8 |     | <span class='neutral'> * For each chain, the chain&#39;s name, chain ID, and a default RPC URL are provided. Chains are</span>
   9 |     | <span class='neutral'> * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of</span>
  10 |     | <span class='neutral'> * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the</span>
  11 |     | <span class='neutral'> * alias used in this contract, which can be found as the first argument to the</span>
  12 |     | <span class='neutral'> * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * There are two main ways to use this contract:</span>
  15 |     | <span class='neutral'> *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or</span>
  16 |     | <span class='neutral'> *      `setChain(string memory chainAlias, Chain memory chain)`</span>
  17 |     | <span class='neutral'> *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.</span>
  18 |     | <span class='neutral'> *</span>
  19 |     | <span class='neutral'> * The first time either of those are used, chains are initialized with the default set of RPC URLs.</span>
  20 |     | <span class='neutral'> * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in</span>
  21 |     | <span class='neutral'> * `defaultRpcUrls`.</span>
  22 |     | <span class='neutral'> *</span>
  23 |     | <span class='neutral'> * The `setChain` function is straightforward, and it simply saves off the given chain data.</span>
  24 |     | <span class='neutral'> *</span>
  25 |     | <span class='neutral'> * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let&#39;s say</span>
  26 |     | <span class='neutral'> * we want to retrieve the RPC URL for `mainnet`:</span>
  27 |     | <span class='neutral'> *   - If you have specified data with `setChain`, it will return that.</span>
  28 |     | <span class='neutral'> *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it</span>
  29 |     | <span class='neutral'> *     is valid (e.g. a URL is specified, or an environment variable is given and exists).</span>
  30 |     | <span class='neutral'> *   - If neither of the above conditions is met, the default data is returned.</span>
  31 |     | <span class='neutral'> *</span>
  32 |     | <span class='neutral'> * Summarizing the above, the prioritization hierarchy is `setChain` -&gt; `foundry.toml` -&gt; environment variable -&gt; defaults.</span>
  33 |     | <span class='neutral'> */</span>
  34 |     | <span class='neutral'>abstract contract StdChains {</span>
  35 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    bool private stdChainsInitialized;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    struct ChainData {</span>
  40 |     | <span class='neutral'>        string name;</span>
  41 |     | <span class='neutral'>        uint256 chainId;</span>
  42 |     | <span class='neutral'>        string rpcUrl;</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    struct Chain {</span>
  46 |     | <span class='neutral'>        // The chain name.</span>
  47 |     | <span class='neutral'>        string name;</span>
  48 |     | <span class='neutral'>        // The chain&#39;s Chain ID.</span>
  49 |     | <span class='neutral'>        uint256 chainId;</span>
  50 |     | <span class='neutral'>        // The chain&#39;s alias. (i.e. what gets specified in `foundry.toml`).</span>
  51 |     | <span class='neutral'>        string chainAlias;</span>
  52 |     | <span class='neutral'>        // A default RPC endpoint for this chain.</span>
  53 |     | <span class='neutral'>        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and</span>
  54 |     | <span class='neutral'>        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy</span>
  55 |     | <span class='neutral'>        // usage as you will be throttled and this is a disservice to others who need this endpoint.</span>
  56 |     | <span class='neutral'>        string rpcUrl;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    // Maps from the chain&#39;s alias (matching the alias in the `foundry.toml` file) to chain data.</span>
  60 |     | <span class='neutral'>    mapping(string =&gt; Chain) private chains;</span>
  61 |     | <span class='neutral'>    // Maps from the chain&#39;s alias to it&#39;s default RPC URL.</span>
  62 |     | <span class='neutral'>    mapping(string =&gt; string) private defaultRpcUrls;</span>
  63 |     | <span class='neutral'>    // Maps from a chain ID to it&#39;s alias.</span>
  64 |     | <span class='neutral'>    mapping(uint256 =&gt; string) private idToAlias;</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>    bool private fallbackToDefaultRpcUrls = true;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    // The RPC URL will be fetched from config or defaultRpcUrls if possible.</span>
  69 |     | <span class='neutral'>    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {</span>
  70 |     | <span class='neutral'>        require(bytes(chainAlias).length != 0, &quot;StdChains getChain(string): Chain alias cannot be the empty string.&quot;);</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>        initializeStdChains();</span>
  73 |     | <span class='neutral'>        chain = chains[chainAlias];</span>
  74 |     | <span class='neutral'>        require(</span>
  75 |     | <span class='neutral'>            chain.chainId != 0,</span>
  76 |     | <span class='neutral'>            string(abi.encodePacked(&quot;StdChains getChain(string): Chain with alias \&quot;&quot;, chainAlias, &quot;\&quot; not found.&quot;))</span>
  77 |     | <span class='neutral'>        );</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {</span>
  83 |     | <span class='neutral'>        require(chainId != 0, &quot;StdChains getChain(uint256): Chain ID cannot be 0.&quot;);</span>
  84 |     | <span class='neutral'>        initializeStdChains();</span>
  85 |     | <span class='neutral'>        string memory chainAlias = idToAlias[chainId];</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        chain = chains[chainAlias];</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        require(</span>
  90 |     | <span class='neutral'>            chain.chainId != 0,</span>
  91 |     | <span class='neutral'>            string(abi.encodePacked(&quot;StdChains getChain(uint256): Chain with ID &quot;, vm.toString(chainId), &quot; not found.&quot;))</span>
  92 |     | <span class='neutral'>        );</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    // set chain info, with priority to argument&#39;s rpcUrl field.</span>
  98 |     | <span class='neutral'>    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {</span>
  99 |     | <span class='neutral'>        require(</span>
 100 |     | <span class='neutral'>            bytes(chainAlias).length != 0,</span>
 101 |     | <span class='neutral'>            &quot;StdChains setChain(string,ChainData): Chain alias cannot be the empty string.&quot;</span>
 102 |     | <span class='neutral'>        );</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>        require(chain.chainId != 0, &quot;StdChains setChain(string,ChainData): Chain ID cannot be 0.&quot;);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>        initializeStdChains();</span>
 107 |     | <span class='neutral'>        string memory foundAlias = idToAlias[chain.chainId];</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        require(</span>
 110 |     | <span class='neutral'>            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),</span>
 111 |     | <span class='neutral'>            string(</span>
 112 |     | <span class='neutral'>                abi.encodePacked(</span>
 113 |     | <span class='neutral'>                    &quot;StdChains setChain(string,ChainData): Chain ID &quot;,</span>
 114 |     | <span class='neutral'>                    vm.toString(chain.chainId),</span>
 115 |     | <span class='neutral'>                    &quot; already used by \&quot;&quot;,</span>
 116 |     | <span class='neutral'>                    foundAlias,</span>
 117 |     | <span class='neutral'>                    &quot;\&quot;.&quot;</span>
 118 |     | <span class='neutral'>                )</span>
 119 |     | <span class='neutral'>            )</span>
 120 |     | <span class='neutral'>        );</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>        uint256 oldChainId = chains[chainAlias].chainId;</span>
 123 |     | <span class='neutral'>        delete idToAlias[oldChainId];</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>        chains[chainAlias] =</span>
 126 |     | <span class='neutral'>            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});</span>
 127 |     | <span class='neutral'>        idToAlias[chain.chainId] = chainAlias;</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    // set chain info, with priority to argument&#39;s rpcUrl field.</span>
 131 |     | <span class='neutral'>    function setChain(string memory chainAlias, Chain memory chain) internal virtual {</span>
 132 |     | <span class='neutral'>        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    function _toUpper(string memory str) private pure returns (string memory) {</span>
 136 |     | <span class='neutral'>        bytes memory strb = bytes(str);</span>
 137 |     | <span class='neutral'>        bytes memory copy = new bytes(strb.length);</span>
 138 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; strb.length; i++) {</span>
 139 |     | <span class='neutral'>            bytes1 b = strb[i];</span>
 140 |     | <span class='neutral'>            if (b &gt;= 0x61 &amp;&amp; b &lt;= 0x7A) {</span>
 141 |     | <span class='neutral'>                copy[i] = bytes1(uint8(b) - 32);</span>
 142 |     | <span class='neutral'>            } else {</span>
 143 |     | <span class='neutral'>                copy[i] = b;</span>
 144 |     | <span class='neutral'>            }</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='neutral'>        return string(copy);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    // lookup rpcUrl, in descending order of priority:</span>
 150 |     | <span class='neutral'>    // current -&gt; config (foundry.toml) -&gt; environment variable -&gt; default</span>
 151 |     | <span class='neutral'>    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)</span>
 152 |     | <span class='neutral'>        private</span>
 153 |     | <span class='neutral'>        view</span>
 154 |     | <span class='neutral'>        returns (Chain memory)</span>
 155 |     | <span class='neutral'>    {</span>
 156 |     | <span class='neutral'>        if (bytes(chain.rpcUrl).length == 0) {</span>
 157 |     | <span class='neutral'>            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {</span>
 158 |     | <span class='neutral'>                chain.rpcUrl = configRpcUrl;</span>
 159 |     | <span class='neutral'>            } catch (bytes memory err) {</span>
 160 |     | <span class='neutral'>                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), &quot;_RPC_URL&quot;));</span>
 161 |     | <span class='neutral'>                if (fallbackToDefaultRpcUrls) {</span>
 162 |     | <span class='neutral'>                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);</span>
 163 |     | <span class='neutral'>                } else {</span>
 164 |     | <span class='neutral'>                    chain.rpcUrl = vm.envString(envName);</span>
 165 |     | <span class='neutral'>                }</span>
 166 |     | <span class='neutral'>                // Distinguish &#39;not found&#39; from &#39;cannot read&#39;</span>
 167 |     | <span class='neutral'>                // The upstream error thrown by forge for failing cheats changed so we check both the old and new versions</span>
 168 |     | <span class='neutral'>                bytes memory oldNotFoundError =</span>
 169 |     | <span class='neutral'>                    abi.encodeWithSignature(&quot;CheatCodeError&quot;, string(abi.encodePacked(&quot;invalid rpc url &quot;, chainAlias)));</span>
 170 |     | <span class='neutral'>                bytes memory newNotFoundError = abi.encodeWithSignature(</span>
 171 |     | <span class='neutral'>                    &quot;CheatcodeError(string)&quot;, string(abi.encodePacked(&quot;invalid rpc url: &quot;, chainAlias))</span>
 172 |     | <span class='neutral'>                );</span>
 173 |     | <span class='neutral'>                bytes32 errHash = keccak256(err);</span>
 174 |     | <span class='neutral'>                if (</span>
 175 |     | <span class='neutral'>                    (errHash != keccak256(oldNotFoundError) &amp;&amp; errHash != keccak256(newNotFoundError))</span>
 176 |     | <span class='neutral'>                        || bytes(chain.rpcUrl).length == 0</span>
 177 |     | <span class='neutral'>                ) {</span>
 178 |     | <span class='neutral'>                    /// @solidity memory-safe-assembly</span>
 179 |     | <span class='neutral'>                    assembly {</span>
 180 |     | <span class='neutral'>                        revert(add(32, err), mload(err))</span>
 181 |     | <span class='neutral'>                    }</span>
 182 |     | <span class='neutral'>                }</span>
 183 |     | <span class='neutral'>            }</span>
 184 |     | <span class='neutral'>        }</span>
 185 |     | <span class='neutral'>        return chain;</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    function setFallbackToDefaultRpcUrls(bool useDefault) internal {</span>
 189 |     | <span class='neutral'>        fallbackToDefaultRpcUrls = useDefault;</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    function initializeStdChains() private {</span>
 193 |     | <span class='neutral'>        if (stdChainsInitialized) return;</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>        stdChainsInitialized = true;</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>        // If adding an RPC here, make sure to test the default RPC URL in `test_Rpcs` in `StdChains.t.sol`</span>
 198 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;anvil&quot;, ChainData(&quot;Anvil&quot;, 31337, &quot;http://127.0.0.1:8545&quot;));</span>
 199 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 200 |     | <span class='neutral'>            &quot;mainnet&quot;, ChainData(&quot;Mainnet&quot;, 1, &quot;https://eth-mainnet.alchemyapi.io/v2/pwc5rmJhrdoaSEfimoKEmsvOjKSmPDrP&quot;)</span>
 201 |     | <span class='neutral'>        );</span>
 202 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 203 |     | <span class='neutral'>            &quot;sepolia&quot;, ChainData(&quot;Sepolia&quot;, 11155111, &quot;https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001&quot;)</span>
 204 |     | <span class='neutral'>        );</span>
 205 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;holesky&quot;, ChainData(&quot;Holesky&quot;, 17000, &quot;https://rpc.holesky.ethpandaops.io&quot;));</span>
 206 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;optimism&quot;, ChainData(&quot;Optimism&quot;, 10, &quot;https://mainnet.optimism.io&quot;));</span>
 207 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 208 |     | <span class='neutral'>            &quot;optimism_sepolia&quot;, ChainData(&quot;Optimism Sepolia&quot;, 11155420, &quot;https://sepolia.optimism.io&quot;)</span>
 209 |     | <span class='neutral'>        );</span>
 210 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;arbitrum_one&quot;, ChainData(&quot;Arbitrum One&quot;, 42161, &quot;https://arb1.arbitrum.io/rpc&quot;));</span>
 211 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 212 |     | <span class='neutral'>            &quot;arbitrum_one_sepolia&quot;, ChainData(&quot;Arbitrum One Sepolia&quot;, 421614, &quot;https://sepolia-rollup.arbitrum.io/rpc&quot;)</span>
 213 |     | <span class='neutral'>        );</span>
 214 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;arbitrum_nova&quot;, ChainData(&quot;Arbitrum Nova&quot;, 42170, &quot;https://nova.arbitrum.io/rpc&quot;));</span>
 215 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;polygon&quot;, ChainData(&quot;Polygon&quot;, 137, &quot;https://polygon-rpc.com&quot;));</span>
 216 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 217 |     | <span class='neutral'>            &quot;polygon_amoy&quot;, ChainData(&quot;Polygon Amoy&quot;, 80002, &quot;https://rpc-amoy.polygon.technology&quot;)</span>
 218 |     | <span class='neutral'>        );</span>
 219 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;avalanche&quot;, ChainData(&quot;Avalanche&quot;, 43114, &quot;https://api.avax.network/ext/bc/C/rpc&quot;));</span>
 220 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 221 |     | <span class='neutral'>            &quot;avalanche_fuji&quot;, ChainData(&quot;Avalanche Fuji&quot;, 43113, &quot;https://api.avax-test.network/ext/bc/C/rpc&quot;)</span>
 222 |     | <span class='neutral'>        );</span>
 223 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 224 |     | <span class='neutral'>            &quot;bnb_smart_chain&quot;, ChainData(&quot;BNB Smart Chain&quot;, 56, &quot;https://bsc-dataseed1.binance.org&quot;)</span>
 225 |     | <span class='neutral'>        );</span>
 226 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 227 |     | <span class='neutral'>            &quot;bnb_smart_chain_testnet&quot;,</span>
 228 |     | <span class='neutral'>            ChainData(&quot;BNB Smart Chain Testnet&quot;, 97, &quot;https://rpc.ankr.com/bsc_testnet_chapel&quot;)</span>
 229 |     | <span class='neutral'>        );</span>
 230 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;gnosis_chain&quot;, ChainData(&quot;Gnosis Chain&quot;, 100, &quot;https://rpc.gnosischain.com&quot;));</span>
 231 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;moonbeam&quot;, ChainData(&quot;Moonbeam&quot;, 1284, &quot;https://rpc.api.moonbeam.network&quot;));</span>
 232 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 233 |     | <span class='neutral'>            &quot;moonriver&quot;, ChainData(&quot;Moonriver&quot;, 1285, &quot;https://rpc.api.moonriver.moonbeam.network&quot;)</span>
 234 |     | <span class='neutral'>        );</span>
 235 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;moonbase&quot;, ChainData(&quot;Moonbase&quot;, 1287, &quot;https://rpc.testnet.moonbeam.network&quot;));</span>
 236 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;base_sepolia&quot;, ChainData(&quot;Base Sepolia&quot;, 84532, &quot;https://sepolia.base.org&quot;));</span>
 237 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;base&quot;, ChainData(&quot;Base&quot;, 8453, &quot;https://mainnet.base.org&quot;));</span>
 238 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;blast_sepolia&quot;, ChainData(&quot;Blast Sepolia&quot;, 168587773, &quot;https://sepolia.blast.io&quot;));</span>
 239 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;blast&quot;, ChainData(&quot;Blast&quot;, 81457, &quot;https://rpc.blast.io&quot;));</span>
 240 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;fantom_opera&quot;, ChainData(&quot;Fantom Opera&quot;, 250, &quot;https://rpc.ankr.com/fantom/&quot;));</span>
 241 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 242 |     | <span class='neutral'>            &quot;fantom_opera_testnet&quot;, ChainData(&quot;Fantom Opera Testnet&quot;, 4002, &quot;https://rpc.ankr.com/fantom_testnet/&quot;)</span>
 243 |     | <span class='neutral'>        );</span>
 244 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;fraxtal&quot;, ChainData(&quot;Fraxtal&quot;, 252, &quot;https://rpc.frax.com&quot;));</span>
 245 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;fraxtal_testnet&quot;, ChainData(&quot;Fraxtal Testnet&quot;, 2522, &quot;https://rpc.testnet.frax.com&quot;));</span>
 246 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 247 |     | <span class='neutral'>            &quot;berachain_bartio_testnet&quot;, ChainData(&quot;Berachain bArtio Testnet&quot;, 80084, &quot;https://bartio.rpc.berachain.com&quot;)</span>
 248 |     | <span class='neutral'>        );</span>
 249 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;flare&quot;, ChainData(&quot;Flare&quot;, 14, &quot;https://flare-api.flare.network/ext/C/rpc&quot;));</span>
 250 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 251 |     | <span class='neutral'>            &quot;flare_coston2&quot;, ChainData(&quot;Flare Coston2&quot;, 114, &quot;https://coston2-api.flare.network/ext/C/rpc&quot;)</span>
 252 |     | <span class='neutral'>        );</span>
 253 |     | <span class='neutral'>    }</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>    // set chain info, with priority to chainAlias&#39; rpc url in foundry.toml</span>
 256 |     | <span class='neutral'>    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {</span>
 257 |     | <span class='neutral'>        string memory rpcUrl = chain.rpcUrl;</span>
 258 |     | <span class='neutral'>        defaultRpcUrls[chainAlias] = rpcUrl;</span>
 259 |     | <span class='neutral'>        chain.rpcUrl = &quot;&quot;;</span>
 260 |     | <span class='neutral'>        setChain(chainAlias, chain);</span>
 261 |     | <span class='neutral'>        chain.rpcUrl = rpcUrl; // restore argument</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'>}</span>
 264 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/StdCheats.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {StdStorage, stdStorage} from &quot;./StdStorage.sol&quot;;</span>
   7 |     | <span class='neutral'>import {console2} from &quot;./console2.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>abstract contract StdCheatsSafe {</span>
  11 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    uint256 private constant UINT256_MAX =</span>
  14 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    bool private gasMeteringOff;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    // Data structures to parse Transaction objects from the broadcast artifact</span>
  19 |     | <span class='neutral'>    // that conform to EIP1559. The Raw structs is what is parsed from the JSON</span>
  20 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    struct RawTx1559 {</span>
  23 |     | <span class='neutral'>        string[] arguments;</span>
  24 |     | <span class='neutral'>        address contractAddress;</span>
  25 |     | <span class='neutral'>        string contractName;</span>
  26 |     | <span class='neutral'>        // json value name = function</span>
  27 |     | <span class='neutral'>        string functionSig;</span>
  28 |     | <span class='neutral'>        bytes32 hash;</span>
  29 |     | <span class='neutral'>        // json value name = tx</span>
  30 |     | <span class='neutral'>        RawTx1559Detail txDetail;</span>
  31 |     | <span class='neutral'>        // json value name = type</span>
  32 |     | <span class='neutral'>        string opcode;</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    struct RawTx1559Detail {</span>
  36 |     | <span class='neutral'>        AccessList[] accessList;</span>
  37 |     | <span class='neutral'>        bytes data;</span>
  38 |     | <span class='neutral'>        address from;</span>
  39 |     | <span class='neutral'>        bytes gas;</span>
  40 |     | <span class='neutral'>        bytes nonce;</span>
  41 |     | <span class='neutral'>        address to;</span>
  42 |     | <span class='neutral'>        bytes txType;</span>
  43 |     | <span class='neutral'>        bytes value;</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    struct Tx1559 {</span>
  47 |     | <span class='neutral'>        string[] arguments;</span>
  48 |     | <span class='neutral'>        address contractAddress;</span>
  49 |     | <span class='neutral'>        string contractName;</span>
  50 |     | <span class='neutral'>        string functionSig;</span>
  51 |     | <span class='neutral'>        bytes32 hash;</span>
  52 |     | <span class='neutral'>        Tx1559Detail txDetail;</span>
  53 |     | <span class='neutral'>        string opcode;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    struct Tx1559Detail {</span>
  57 |     | <span class='neutral'>        AccessList[] accessList;</span>
  58 |     | <span class='neutral'>        bytes data;</span>
  59 |     | <span class='neutral'>        address from;</span>
  60 |     | <span class='neutral'>        uint256 gas;</span>
  61 |     | <span class='neutral'>        uint256 nonce;</span>
  62 |     | <span class='neutral'>        address to;</span>
  63 |     | <span class='neutral'>        uint256 txType;</span>
  64 |     | <span class='neutral'>        uint256 value;</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    // Data structures to parse Transaction objects from the broadcast artifact</span>
  68 |     | <span class='neutral'>    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON</span>
  69 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    struct TxLegacy {</span>
  72 |     | <span class='neutral'>        string[] arguments;</span>
  73 |     | <span class='neutral'>        address contractAddress;</span>
  74 |     | <span class='neutral'>        string contractName;</span>
  75 |     | <span class='neutral'>        string functionSig;</span>
  76 |     | <span class='neutral'>        string hash;</span>
  77 |     | <span class='neutral'>        string opcode;</span>
  78 |     | <span class='neutral'>        TxDetailLegacy transaction;</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    struct TxDetailLegacy {</span>
  82 |     | <span class='neutral'>        AccessList[] accessList;</span>
  83 |     | <span class='neutral'>        uint256 chainId;</span>
  84 |     | <span class='neutral'>        bytes data;</span>
  85 |     | <span class='neutral'>        address from;</span>
  86 |     | <span class='neutral'>        uint256 gas;</span>
  87 |     | <span class='neutral'>        uint256 gasPrice;</span>
  88 |     | <span class='neutral'>        bytes32 hash;</span>
  89 |     | <span class='neutral'>        uint256 nonce;</span>
  90 |     | <span class='neutral'>        bytes1 opcode;</span>
  91 |     | <span class='neutral'>        bytes32 r;</span>
  92 |     | <span class='neutral'>        bytes32 s;</span>
  93 |     | <span class='neutral'>        uint256 txType;</span>
  94 |     | <span class='neutral'>        address to;</span>
  95 |     | <span class='neutral'>        uint8 v;</span>
  96 |     | <span class='neutral'>        uint256 value;</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    struct AccessList {</span>
 100 |     | <span class='neutral'>        address accessAddress;</span>
 101 |     | <span class='neutral'>        bytes32[] storageKeys;</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    // Data structures to parse Receipt objects from the broadcast artifact.</span>
 105 |     | <span class='neutral'>    // The Raw structs is what is parsed from the JSON</span>
 106 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    struct RawReceipt {</span>
 109 |     | <span class='neutral'>        bytes32 blockHash;</span>
 110 |     | <span class='neutral'>        bytes blockNumber;</span>
 111 |     | <span class='neutral'>        address contractAddress;</span>
 112 |     | <span class='neutral'>        bytes cumulativeGasUsed;</span>
 113 |     | <span class='neutral'>        bytes effectiveGasPrice;</span>
 114 |     | <span class='neutral'>        address from;</span>
 115 |     | <span class='neutral'>        bytes gasUsed;</span>
 116 |     | <span class='neutral'>        RawReceiptLog[] logs;</span>
 117 |     | <span class='neutral'>        bytes logsBloom;</span>
 118 |     | <span class='neutral'>        bytes status;</span>
 119 |     | <span class='neutral'>        address to;</span>
 120 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 121 |     | <span class='neutral'>        bytes transactionIndex;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    struct Receipt {</span>
 125 |     | <span class='neutral'>        bytes32 blockHash;</span>
 126 |     | <span class='neutral'>        uint256 blockNumber;</span>
 127 |     | <span class='neutral'>        address contractAddress;</span>
 128 |     | <span class='neutral'>        uint256 cumulativeGasUsed;</span>
 129 |     | <span class='neutral'>        uint256 effectiveGasPrice;</span>
 130 |     | <span class='neutral'>        address from;</span>
 131 |     | <span class='neutral'>        uint256 gasUsed;</span>
 132 |     | <span class='neutral'>        ReceiptLog[] logs;</span>
 133 |     | <span class='neutral'>        bytes logsBloom;</span>
 134 |     | <span class='neutral'>        uint256 status;</span>
 135 |     | <span class='neutral'>        address to;</span>
 136 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 137 |     | <span class='neutral'>        uint256 transactionIndex;</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    // Data structures to parse the entire broadcast artifact, assuming the</span>
 141 |     | <span class='neutral'>    // transactions conform to EIP1559.</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    struct EIP1559ScriptArtifact {</span>
 144 |     | <span class='neutral'>        string[] libraries;</span>
 145 |     | <span class='neutral'>        string path;</span>
 146 |     | <span class='neutral'>        string[] pending;</span>
 147 |     | <span class='neutral'>        Receipt[] receipts;</span>
 148 |     | <span class='neutral'>        uint256 timestamp;</span>
 149 |     | <span class='neutral'>        Tx1559[] transactions;</span>
 150 |     | <span class='neutral'>        TxReturn[] txReturns;</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    struct RawEIP1559ScriptArtifact {</span>
 154 |     | <span class='neutral'>        string[] libraries;</span>
 155 |     | <span class='neutral'>        string path;</span>
 156 |     | <span class='neutral'>        string[] pending;</span>
 157 |     | <span class='neutral'>        RawReceipt[] receipts;</span>
 158 |     | <span class='neutral'>        TxReturn[] txReturns;</span>
 159 |     | <span class='neutral'>        uint256 timestamp;</span>
 160 |     | <span class='neutral'>        RawTx1559[] transactions;</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    struct RawReceiptLog {</span>
 164 |     | <span class='neutral'>        // json value = address</span>
 165 |     | <span class='neutral'>        address logAddress;</span>
 166 |     | <span class='neutral'>        bytes32 blockHash;</span>
 167 |     | <span class='neutral'>        bytes blockNumber;</span>
 168 |     | <span class='neutral'>        bytes data;</span>
 169 |     | <span class='neutral'>        bytes logIndex;</span>
 170 |     | <span class='neutral'>        bool removed;</span>
 171 |     | <span class='neutral'>        bytes32[] topics;</span>
 172 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 173 |     | <span class='neutral'>        bytes transactionIndex;</span>
 174 |     | <span class='neutral'>        bytes transactionLogIndex;</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    struct ReceiptLog {</span>
 178 |     | <span class='neutral'>        // json value = address</span>
 179 |     | <span class='neutral'>        address logAddress;</span>
 180 |     | <span class='neutral'>        bytes32 blockHash;</span>
 181 |     | <span class='neutral'>        uint256 blockNumber;</span>
 182 |     | <span class='neutral'>        bytes data;</span>
 183 |     | <span class='neutral'>        uint256 logIndex;</span>
 184 |     | <span class='neutral'>        bytes32[] topics;</span>
 185 |     | <span class='neutral'>        uint256 transactionIndex;</span>
 186 |     | <span class='neutral'>        uint256 transactionLogIndex;</span>
 187 |     | <span class='neutral'>        bool removed;</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    struct TxReturn {</span>
 191 |     | <span class='neutral'>        string internalType;</span>
 192 |     | <span class='neutral'>        string value;</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    struct Account {</span>
 196 |     | <span class='neutral'>        address addr;</span>
 197 |     | <span class='neutral'>        uint256 key;</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    enum AddressType {</span>
 201 |     | <span class='neutral'>        Payable,</span>
 202 |     | <span class='neutral'>        NonPayable,</span>
 203 |     | <span class='neutral'>        ZeroAddress,</span>
 204 |     | <span class='neutral'>        Precompile,</span>
 205 |     | <span class='neutral'>        ForgeAddress</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.</span>
 209 |     | <span class='neutral'>    function assumeNotBlacklisted(address token, address addr) internal view virtual {</span>
 210 |     | <span class='neutral'>        // Nothing to check if `token` is not a contract.</span>
 211 |     | <span class='neutral'>        uint256 tokenCodeSize;</span>
 212 |     | <span class='neutral'>        assembly {</span>
 213 |     | <span class='neutral'>            tokenCodeSize := extcodesize(token)</span>
 214 |     | <span class='neutral'>        }</span>
 215 |     | <span class='neutral'>        require(tokenCodeSize &gt; 0, &quot;StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.&quot;);</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>        bool success;</span>
 218 |     | <span class='neutral'>        bytes memory returnData;</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>        // 4-byte selector for `isBlacklisted(address)`, used by USDC.</span>
 221 |     | <span class='neutral'>        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));</span>
 222 |     | <span class='neutral'>        vm.assume(!success || abi.decode(returnData, (bool)) == false);</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>        // 4-byte selector for `isBlackListed(address)`, used by USDT.</span>
 225 |     | <span class='neutral'>        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));</span>
 226 |     | <span class='neutral'>        vm.assume(!success || abi.decode(returnData, (bool)) == false);</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.</span>
 230 |     | <span class='neutral'>    // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for</span>
 231 |     | <span class='neutral'>    // backwards compatibility, since this name was used in the original PR which already has</span>
 232 |     | <span class='neutral'>    // a release. This function can be removed in a future release once we want a breaking change.</span>
 233 |     | <span class='neutral'>    function assumeNoBlacklisted(address token, address addr) internal view virtual {</span>
 234 |     | <span class='neutral'>        assumeNotBlacklisted(token, addr);</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {</span>
 238 |     | <span class='neutral'>        if (addressType == AddressType.Payable) {</span>
 239 |     | <span class='neutral'>            assumeNotPayable(addr);</span>
 240 |     | <span class='neutral'>        } else if (addressType == AddressType.NonPayable) {</span>
 241 |     | <span class='neutral'>            assumePayable(addr);</span>
 242 |     | <span class='neutral'>        } else if (addressType == AddressType.ZeroAddress) {</span>
 243 |     | <span class='neutral'>            assumeNotZeroAddress(addr);</span>
 244 |     | <span class='neutral'>        } else if (addressType == AddressType.Precompile) {</span>
 245 |     | <span class='neutral'>            assumeNotPrecompile(addr);</span>
 246 |     | <span class='neutral'>        } else if (addressType == AddressType.ForgeAddress) {</span>
 247 |     | <span class='neutral'>            assumeNotForgeAddress(addr);</span>
 248 |     | <span class='neutral'>        }</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {</span>
 252 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType1);</span>
 253 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType2);</span>
 254 |     | <span class='neutral'>    }</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>    function assumeAddressIsNot(</span>
 257 |     | <span class='neutral'>        address addr,</span>
 258 |     | <span class='neutral'>        AddressType addressType1,</span>
 259 |     | <span class='neutral'>        AddressType addressType2,</span>
 260 |     | <span class='neutral'>        AddressType addressType3</span>
 261 |     | <span class='neutral'>    ) internal virtual {</span>
 262 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType1);</span>
 263 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType2);</span>
 264 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType3);</span>
 265 |     | <span class='neutral'>    }</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>    function assumeAddressIsNot(</span>
 268 |     | <span class='neutral'>        address addr,</span>
 269 |     | <span class='neutral'>        AddressType addressType1,</span>
 270 |     | <span class='neutral'>        AddressType addressType2,</span>
 271 |     | <span class='neutral'>        AddressType addressType3,</span>
 272 |     | <span class='neutral'>        AddressType addressType4</span>
 273 |     | <span class='neutral'>    ) internal virtual {</span>
 274 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType1);</span>
 275 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType2);</span>
 276 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType3);</span>
 277 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType4);</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to</span>
 281 |     | <span class='neutral'>    // `addr` and checking the `success` return value.</span>
 282 |     | <span class='neutral'>    // NOTE: This function may result in state changes depending on the fallback/receive logic</span>
 283 |     | <span class='neutral'>    // implemented by `addr`, which should be taken into account when this function is used.</span>
 284 |     | <span class='neutral'>    function _isPayable(address addr) private returns (bool) {</span>
 285 |     | <span class='neutral'>        require(</span>
 286 |     | <span class='neutral'>            addr.balance &lt; UINT256_MAX,</span>
 287 |     | <span class='neutral'>            &quot;StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds&quot;</span>
 288 |     | <span class='neutral'>        );</span>
 289 |     | <span class='neutral'>        uint256 origBalanceTest = address(this).balance;</span>
 290 |     | <span class='neutral'>        uint256 origBalanceAddr = address(addr).balance;</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>        vm.deal(address(this), 1);</span>
 293 |     | <span class='neutral'>        (bool success,) = payable(addr).call{value: 1}(&quot;&quot;);</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>        // reset balances</span>
 296 |     | <span class='neutral'>        vm.deal(address(this), origBalanceTest);</span>
 297 |     | <span class='neutral'>        vm.deal(addr, origBalanceAddr);</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>        return success;</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    // NOTE: This function may result in state changes depending on the fallback/receive logic</span>
 303 |     | <span class='neutral'>    // implemented by `addr`, which should be taken into account when this function is used. See the</span>
 304 |     | <span class='neutral'>    // `_isPayable` method for more information.</span>
 305 |     | <span class='neutral'>    function assumePayable(address addr) internal virtual {</span>
 306 |     | <span class='neutral'>        vm.assume(_isPayable(addr));</span>
 307 |     | <span class='neutral'>    }</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='neutral'>    function assumeNotPayable(address addr) internal virtual {</span>
 310 |     | <span class='neutral'>        vm.assume(!_isPayable(addr));</span>
 311 |     | <span class='neutral'>    }</span>
 312 |     | <span class='neutral'></span>
 313 |     | <span class='neutral'>    function assumeNotZeroAddress(address addr) internal pure virtual {</span>
 314 |     | <span class='neutral'>        vm.assume(addr != address(0));</span>
 315 |     | <span class='neutral'>    }</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='neutral'>    function assumeNotPrecompile(address addr) internal pure virtual {</span>
 318 |     | <span class='neutral'>        assumeNotPrecompile(addr, _pureChainId());</span>
 319 |     | <span class='neutral'>    }</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='neutral'>    function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {</span>
 322 |     | <span class='neutral'>        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific</span>
 323 |     | <span class='neutral'>        // address), but the same rationale for excluding them applies so we include those too.</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='neutral'>        // These are reserved by Ethereum and may be on all EVM-compatible chains.</span>
 326 |     | <span class='neutral'>        vm.assume(addr &lt; address(0x1) || addr &gt; address(0xff));</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='neutral'>        // forgefmt: disable-start</span>
 329 |     | <span class='neutral'>        if (chainId == 10 || chainId == 420) {</span>
 330 |     | <span class='neutral'>            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21</span>
 331 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x4200000000000000000000000000000000000000) || addr &gt; address(0x4200000000000000000000000000000000000800));</span>
 332 |     | <span class='neutral'>        } else if (chainId == 42161 || chainId == 421613) {</span>
 333 |     | <span class='neutral'>            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains</span>
 334 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0000000000000000000000000000000000000064) || addr &gt; address(0x0000000000000000000000000000000000000068));</span>
 335 |     | <span class='neutral'>        } else if (chainId == 43114 || chainId == 43113) {</span>
 336 |     | <span class='neutral'>            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59</span>
 337 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0100000000000000000000000000000000000000) || addr &gt; address(0x01000000000000000000000000000000000000ff));</span>
 338 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0200000000000000000000000000000000000000) || addr &gt; address(0x02000000000000000000000000000000000000FF));</span>
 339 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0300000000000000000000000000000000000000) || addr &gt; address(0x03000000000000000000000000000000000000Ff));</span>
 340 |     | <span class='neutral'>        }</span>
 341 |     | <span class='neutral'>        // forgefmt: disable-end</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>    function assumeNotForgeAddress(address addr) internal pure virtual {</span>
 345 |     | <span class='neutral'>        // vm, console, and Create2Deployer addresses</span>
 346 |     | <span class='neutral'>        vm.assume(</span>
 347 |     | <span class='neutral'>            addr != address(vm) &amp;&amp; addr != 0x000000000000000000636F6e736F6c652e6c6f67</span>
 348 |     | <span class='neutral'>                &amp;&amp; addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C</span>
 349 |     | <span class='neutral'>        );</span>
 350 |     | <span class='neutral'>    }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>    function assumeUnusedAddress(address addr) internal view virtual {</span>
 353 |     | <span class='neutral'>        uint256 size;</span>
 354 |     | <span class='neutral'>        assembly {</span>
 355 |     | <span class='neutral'>            size := extcodesize(addr)</span>
 356 |     | <span class='neutral'>        }</span>
 357 |     | <span class='neutral'>        vm.assume(size == 0);</span>
 358 |     | <span class='neutral'></span>
 359 |     | <span class='neutral'>        assumeNotPrecompile(addr);</span>
 360 |     | <span class='neutral'>        assumeNotZeroAddress(addr);</span>
 361 |     | <span class='neutral'>        assumeNotForgeAddress(addr);</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='neutral'>    function readEIP1559ScriptArtifact(string memory path)</span>
 365 |     | <span class='neutral'>        internal</span>
 366 |     | <span class='neutral'>        view</span>
 367 |     | <span class='neutral'>        virtual</span>
 368 |     | <span class='neutral'>        returns (EIP1559ScriptArtifact memory)</span>
 369 |     | <span class='neutral'>    {</span>
 370 |     | <span class='neutral'>        string memory data = vm.readFile(path);</span>
 371 |     | <span class='neutral'>        bytes memory parsedData = vm.parseJson(data);</span>
 372 |     | <span class='neutral'>        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));</span>
 373 |     | <span class='neutral'>        EIP1559ScriptArtifact memory artifact;</span>
 374 |     | <span class='neutral'>        artifact.libraries = rawArtifact.libraries;</span>
 375 |     | <span class='neutral'>        artifact.path = rawArtifact.path;</span>
 376 |     | <span class='neutral'>        artifact.timestamp = rawArtifact.timestamp;</span>
 377 |     | <span class='neutral'>        artifact.pending = rawArtifact.pending;</span>
 378 |     | <span class='neutral'>        artifact.txReturns = rawArtifact.txReturns;</span>
 379 |     | <span class='neutral'>        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);</span>
 380 |     | <span class='neutral'>        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);</span>
 381 |     | <span class='neutral'>        return artifact;</span>
 382 |     | <span class='neutral'>    }</span>
 383 |     | <span class='neutral'></span>
 384 |     | <span class='neutral'>    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {</span>
 385 |     | <span class='neutral'>        Tx1559[] memory txs = new Tx1559[](rawTxs.length);</span>
 386 |     | <span class='neutral'>        for (uint256 i; i &lt; rawTxs.length; i++) {</span>
 387 |     | <span class='neutral'>            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);</span>
 388 |     | <span class='neutral'>        }</span>
 389 |     | <span class='neutral'>        return txs;</span>
 390 |     | <span class='neutral'>    }</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='neutral'>    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {</span>
 393 |     | <span class='neutral'>        Tx1559 memory transaction;</span>
 394 |     | <span class='neutral'>        transaction.arguments = rawTx.arguments;</span>
 395 |     | <span class='neutral'>        transaction.contractName = rawTx.contractName;</span>
 396 |     | <span class='neutral'>        transaction.functionSig = rawTx.functionSig;</span>
 397 |     | <span class='neutral'>        transaction.hash = rawTx.hash;</span>
 398 |     | <span class='neutral'>        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);</span>
 399 |     | <span class='neutral'>        transaction.opcode = rawTx.opcode;</span>
 400 |     | <span class='neutral'>        return transaction;</span>
 401 |     | <span class='neutral'>    }</span>
 402 |     | <span class='neutral'></span>
 403 |     | <span class='neutral'>    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)</span>
 404 |     | <span class='neutral'>        internal</span>
 405 |     | <span class='neutral'>        pure</span>
 406 |     | <span class='neutral'>        virtual</span>
 407 |     | <span class='neutral'>        returns (Tx1559Detail memory)</span>
 408 |     | <span class='neutral'>    {</span>
 409 |     | <span class='neutral'>        Tx1559Detail memory txDetail;</span>
 410 |     | <span class='neutral'>        txDetail.data = rawDetail.data;</span>
 411 |     | <span class='neutral'>        txDetail.from = rawDetail.from;</span>
 412 |     | <span class='neutral'>        txDetail.to = rawDetail.to;</span>
 413 |     | <span class='neutral'>        txDetail.nonce = _bytesToUint(rawDetail.nonce);</span>
 414 |     | <span class='neutral'>        txDetail.txType = _bytesToUint(rawDetail.txType);</span>
 415 |     | <span class='neutral'>        txDetail.value = _bytesToUint(rawDetail.value);</span>
 416 |     | <span class='neutral'>        txDetail.gas = _bytesToUint(rawDetail.gas);</span>
 417 |     | <span class='neutral'>        txDetail.accessList = rawDetail.accessList;</span>
 418 |     | <span class='neutral'>        return txDetail;</span>
 419 |     | <span class='neutral'>    }</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='neutral'>    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {</span>
 422 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 423 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, &quot;.transactions&quot;);</span>
 424 |     | <span class='neutral'>        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));</span>
 425 |     | <span class='neutral'>        return rawToConvertedEIPTx1559s(rawTxs);</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {</span>
 429 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 430 |     | <span class='neutral'>        string memory key = string(abi.encodePacked(&quot;.transactions[&quot;, vm.toString(index), &quot;]&quot;));</span>
 431 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, key);</span>
 432 |     | <span class='neutral'>        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));</span>
 433 |     | <span class='neutral'>        return rawToConvertedEIPTx1559(rawTx);</span>
 434 |     | <span class='neutral'>    }</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='neutral'>    // Analogous to readTransactions, but for receipts.</span>
 437 |     | <span class='neutral'>    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {</span>
 438 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 439 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, &quot;.receipts&quot;);</span>
 440 |     | <span class='neutral'>        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));</span>
 441 |     | <span class='neutral'>        return rawToConvertedReceipts(rawReceipts);</span>
 442 |     | <span class='neutral'>    }</span>
 443 |     | <span class='neutral'></span>
 444 |     | <span class='neutral'>    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {</span>
 445 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 446 |     | <span class='neutral'>        string memory key = string(abi.encodePacked(&quot;.receipts[&quot;, vm.toString(index), &quot;]&quot;));</span>
 447 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, key);</span>
 448 |     | <span class='neutral'>        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));</span>
 449 |     | <span class='neutral'>        return rawToConvertedReceipt(rawReceipt);</span>
 450 |     | <span class='neutral'>    }</span>
 451 |     | <span class='neutral'></span>
 452 |     | <span class='neutral'>    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {</span>
 453 |     | <span class='neutral'>        Receipt[] memory receipts = new Receipt[](rawReceipts.length);</span>
 454 |     | <span class='neutral'>        for (uint256 i; i &lt; rawReceipts.length; i++) {</span>
 455 |     | <span class='neutral'>            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);</span>
 456 |     | <span class='neutral'>        }</span>
 457 |     | <span class='neutral'>        return receipts;</span>
 458 |     | <span class='neutral'>    }</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='neutral'>    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {</span>
 461 |     | <span class='neutral'>        Receipt memory receipt;</span>
 462 |     | <span class='neutral'>        receipt.blockHash = rawReceipt.blockHash;</span>
 463 |     | <span class='neutral'>        receipt.to = rawReceipt.to;</span>
 464 |     | <span class='neutral'>        receipt.from = rawReceipt.from;</span>
 465 |     | <span class='neutral'>        receipt.contractAddress = rawReceipt.contractAddress;</span>
 466 |     | <span class='neutral'>        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);</span>
 467 |     | <span class='neutral'>        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);</span>
 468 |     | <span class='neutral'>        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);</span>
 469 |     | <span class='neutral'>        receipt.status = _bytesToUint(rawReceipt.status);</span>
 470 |     | <span class='neutral'>        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);</span>
 471 |     | <span class='neutral'>        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);</span>
 472 |     | <span class='neutral'>        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);</span>
 473 |     | <span class='neutral'>        receipt.logsBloom = rawReceipt.logsBloom;</span>
 474 |     | <span class='neutral'>        receipt.transactionHash = rawReceipt.transactionHash;</span>
 475 |     | <span class='neutral'>        return receipt;</span>
 476 |     | <span class='neutral'>    }</span>
 477 |     | <span class='neutral'></span>
 478 |     | <span class='neutral'>    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)</span>
 479 |     | <span class='neutral'>        internal</span>
 480 |     | <span class='neutral'>        pure</span>
 481 |     | <span class='neutral'>        virtual</span>
 482 |     | <span class='neutral'>        returns (ReceiptLog[] memory)</span>
 483 |     | <span class='neutral'>    {</span>
 484 |     | <span class='neutral'>        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);</span>
 485 |     | <span class='neutral'>        for (uint256 i; i &lt; rawLogs.length; i++) {</span>
 486 |     | <span class='neutral'>            logs[i].logAddress = rawLogs[i].logAddress;</span>
 487 |     | <span class='neutral'>            logs[i].blockHash = rawLogs[i].blockHash;</span>
 488 |     | <span class='neutral'>            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);</span>
 489 |     | <span class='neutral'>            logs[i].data = rawLogs[i].data;</span>
 490 |     | <span class='neutral'>            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);</span>
 491 |     | <span class='neutral'>            logs[i].topics = rawLogs[i].topics;</span>
 492 |     | <span class='neutral'>            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);</span>
 493 |     | <span class='neutral'>            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);</span>
 494 |     | <span class='neutral'>            logs[i].removed = rawLogs[i].removed;</span>
 495 |     | <span class='neutral'>        }</span>
 496 |     | <span class='neutral'>        return logs;</span>
 497 |     | <span class='neutral'>    }</span>
 498 |     | <span class='neutral'></span>
 499 |     | <span class='neutral'>    // Deploy a contract by fetching the contract bytecode from</span>
 500 |     | <span class='neutral'>    // the artifacts directory</span>
 501 |     | <span class='neutral'>    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`</span>
 502 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {</span>
 503 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 504 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 505 |     | <span class='neutral'>        assembly {</span>
 506 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 507 |     | <span class='neutral'>        }</span>
 508 |     | <span class='neutral'></span>
 509 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,bytes): Deployment failed.&quot;);</span>
 510 |     | <span class='neutral'>    }</span>
 511 |     | <span class='neutral'></span>
 512 |     | <span class='neutral'>    function deployCode(string memory what) internal virtual returns (address addr) {</span>
 513 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 514 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 515 |     | <span class='neutral'>        assembly {</span>
 516 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 517 |     | <span class='neutral'>        }</span>
 518 |     | <span class='neutral'></span>
 519 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string): Deployment failed.&quot;);</span>
 520 |     | <span class='neutral'>    }</span>
 521 |     | <span class='neutral'></span>
 522 |     | <span class='neutral'>    /// @dev deploy contract with value on construction</span>
 523 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {</span>
 524 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 525 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 526 |     | <span class='neutral'>        assembly {</span>
 527 |     | <span class='neutral'>            addr := create(val, add(bytecode, 0x20), mload(bytecode))</span>
 528 |     | <span class='neutral'>        }</span>
 529 |     | <span class='neutral'></span>
 530 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,bytes,uint256): Deployment failed.&quot;);</span>
 531 |     | <span class='neutral'>    }</span>
 532 |     | <span class='neutral'></span>
 533 |     | <span class='neutral'>    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {</span>
 534 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 535 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 536 |     | <span class='neutral'>        assembly {</span>
 537 |     | <span class='neutral'>            addr := create(val, add(bytecode, 0x20), mload(bytecode))</span>
 538 |     | <span class='neutral'>        }</span>
 539 |     | <span class='neutral'></span>
 540 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,uint256): Deployment failed.&quot;);</span>
 541 |     | <span class='neutral'>    }</span>
 542 |     | <span class='neutral'></span>
 543 |     | <span class='neutral'>    // creates a labeled address and the corresponding private key</span>
 544 |     | <span class='neutral'>    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {</span>
 545 |     | <span class='neutral'>        privateKey = uint256(keccak256(abi.encodePacked(name)));</span>
 546 |     | <span class='neutral'>        addr = vm.addr(privateKey);</span>
 547 |     | <span class='neutral'>        vm.label(addr, name);</span>
 548 |     | <span class='neutral'>    }</span>
 549 |     | <span class='neutral'></span>
 550 |     | <span class='neutral'>    // creates a labeled address</span>
 551 |     | <span class='neutral'>    function makeAddr(string memory name) internal virtual returns (address addr) {</span>
 552 |     | <span class='neutral'>        (addr,) = makeAddrAndKey(name);</span>
 553 |     | <span class='neutral'>    }</span>
 554 |     | <span class='neutral'></span>
 555 |     | <span class='neutral'>    // Destroys an account immediately, sending the balance to beneficiary.</span>
 556 |     | <span class='neutral'>    // Destroying means: balance will be zero, code will be empty, and nonce will be 0</span>
 557 |     | <span class='neutral'>    // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce</span>
 558 |     | <span class='neutral'>    // only after tx ends, this will run immediately.</span>
 559 |     | <span class='neutral'>    function destroyAccount(address who, address beneficiary) internal virtual {</span>
 560 |     | <span class='neutral'>        uint256 currBalance = who.balance;</span>
 561 |     | <span class='neutral'>        vm.etch(who, abi.encode());</span>
 562 |     | <span class='neutral'>        vm.deal(who, 0);</span>
 563 |     | <span class='neutral'>        vm.resetNonce(who);</span>
 564 |     | <span class='neutral'></span>
 565 |     | <span class='neutral'>        uint256 beneficiaryBalance = beneficiary.balance;</span>
 566 |     | <span class='neutral'>        vm.deal(beneficiary, currBalance + beneficiaryBalance);</span>
 567 |     | <span class='neutral'>    }</span>
 568 |     | <span class='neutral'></span>
 569 |     | <span class='neutral'>    // creates a struct containing both a labeled address and the corresponding private key</span>
 570 |     | <span class='neutral'>    function makeAccount(string memory name) internal virtual returns (Account memory account) {</span>
 571 |     | <span class='neutral'>        (account.addr, account.key) = makeAddrAndKey(name);</span>
 572 |     | <span class='neutral'>    }</span>
 573 |     | <span class='neutral'></span>
 574 |     | <span class='neutral'>    function deriveRememberKey(string memory mnemonic, uint32 index)</span>
 575 |     | <span class='neutral'>        internal</span>
 576 |     | <span class='neutral'>        virtual</span>
 577 |     | <span class='neutral'>        returns (address who, uint256 privateKey)</span>
 578 |     | <span class='neutral'>    {</span>
 579 |     | <span class='neutral'>        privateKey = vm.deriveKey(mnemonic, index);</span>
 580 |     | <span class='neutral'>        who = vm.rememberKey(privateKey);</span>
 581 |     | <span class='neutral'>    }</span>
 582 |     | <span class='neutral'></span>
 583 |     | <span class='neutral'>    function _bytesToUint(bytes memory b) private pure returns (uint256) {</span>
 584 |     | <span class='neutral'>        require(b.length &lt;= 32, &quot;StdCheats _bytesToUint(bytes): Bytes length exceeds 32.&quot;);</span>
 585 |     | <span class='neutral'>        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));</span>
 586 |     | <span class='neutral'>    }</span>
 587 |     | <span class='neutral'></span>
 588 |     | <span class='neutral'>    function isFork() internal view virtual returns (bool status) {</span>
 589 |     | <span class='neutral'>        try vm.activeFork() {</span>
 590 |     | <span class='neutral'>            status = true;</span>
 591 |     | <span class='neutral'>        } catch (bytes memory) {}</span>
 592 |     | <span class='neutral'>    }</span>
 593 |     | <span class='neutral'></span>
 594 |     | <span class='neutral'>    modifier skipWhenForking() {</span>
 595 |     | <span class='neutral'>        if (!isFork()) {</span>
 596 |     | <span class='neutral'>            _;</span>
 597 |     | <span class='neutral'>        }</span>
 598 |     | <span class='neutral'>    }</span>
 599 |     | <span class='neutral'></span>
 600 |     | <span class='neutral'>    modifier skipWhenNotForking() {</span>
 601 |     | <span class='neutral'>        if (isFork()) {</span>
 602 |     | <span class='neutral'>            _;</span>
 603 |     | <span class='neutral'>        }</span>
 604 |     | <span class='neutral'>    }</span>
 605 |     | <span class='neutral'></span>
 606 |     | <span class='neutral'>    modifier noGasMetering() {</span>
 607 |     | <span class='neutral'>        vm.pauseGasMetering();</span>
 608 |     | <span class='neutral'>        // To prevent turning gas monitoring back on with nested functions that use this modifier,</span>
 609 |     | <span class='neutral'>        // we check if gasMetering started in the off position. If it did, we don&#39;t want to turn</span>
 610 |     | <span class='neutral'>        // it back on until we exit the top level function that used the modifier</span>
 611 |     | <span class='neutral'>        //</span>
 612 |     | <span class='neutral'>        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.</span>
 613 |     | <span class='neutral'>        // funcA will have `gasStartedOff` as false, funcB will have it as true,</span>
 614 |     | <span class='neutral'>        // so we only turn metering back on at the end of the funcA</span>
 615 |     | <span class='neutral'>        bool gasStartedOff = gasMeteringOff;</span>
 616 |     | <span class='neutral'>        gasMeteringOff = true;</span>
 617 |     | <span class='neutral'></span>
 618 |     | <span class='neutral'>        _;</span>
 619 |     | <span class='neutral'></span>
 620 |     | <span class='neutral'>        // if gas metering was on when this modifier was called, turn it back on at the end</span>
 621 |     | <span class='neutral'>        if (!gasStartedOff) {</span>
 622 |     | <span class='neutral'>            gasMeteringOff = false;</span>
 623 |     | <span class='neutral'>            vm.resumeGasMetering();</span>
 624 |     | <span class='neutral'>        }</span>
 625 |     | <span class='neutral'>    }</span>
 626 |     | <span class='neutral'></span>
 627 |     | <span class='neutral'>    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no</span>
 628 |     | <span class='neutral'>    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We</span>
 629 |     | <span class='neutral'>    // can&#39;t simply access the chain ID in a normal view or pure function because the solc View Pure</span>
 630 |     | <span class='neutral'>    // Checker changed `chainid` from pure to view in 0.8.0.</span>
 631 |     | <span class='neutral'>    function _viewChainId() private view returns (uint256 chainId) {</span>
 632 |     | <span class='neutral'>        // Assembly required since `block.chainid` was introduced in 0.8.0.</span>
 633 |     | <span class='neutral'>        assembly {</span>
 634 |     | <span class='neutral'>            chainId := chainid()</span>
 635 |     | <span class='neutral'>        }</span>
 636 |     | <span class='neutral'></span>
 637 |     | <span class='neutral'>        address(this); // Silence warnings in older Solc versions.</span>
 638 |     | <span class='neutral'>    }</span>
 639 |     | <span class='neutral'></span>
 640 |     | <span class='neutral'>    function _pureChainId() private pure returns (uint256 chainId) {</span>
 641 |     | <span class='neutral'>        function() internal view returns (uint256) fnIn = _viewChainId;</span>
 642 |     | <span class='neutral'>        function() internal pure returns (uint256) pureChainId;</span>
 643 |     | <span class='neutral'>        assembly {</span>
 644 |     | <span class='neutral'>            pureChainId := fnIn</span>
 645 |     | <span class='neutral'>        }</span>
 646 |     | <span class='neutral'>        chainId = pureChainId();</span>
 647 |     | <span class='neutral'>    }</span>
 648 |     | <span class='neutral'>}</span>
 649 |     | <span class='neutral'></span>
 650 |     | <span class='neutral'>// Wrappers around cheatcodes to avoid footguns</span>
 651 |     | <span class='neutral'>abstract contract StdCheats is StdCheatsSafe {</span>
 652 |     | <span class='neutral'>    using stdStorage for StdStorage;</span>
 653 |     | <span class='neutral'></span>
 654 |     | <span class='neutral'>    StdStorage private stdstore;</span>
 655 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
 656 |     | <span class='neutral'>    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
 657 |     | <span class='neutral'></span>
 658 |     | <span class='neutral'>    // Skip forward or rewind time by the specified number of seconds</span>
 659 |     | <span class='neutral'>    function skip(uint256 time) internal virtual {</span>
 660 |     | <span class='neutral'>        vm.warp(vm.getBlockTimestamp() + time);</span>
 661 |     | <span class='neutral'>    }</span>
 662 |     | <span class='neutral'></span>
 663 |     | <span class='neutral'>    function rewind(uint256 time) internal virtual {</span>
 664 |     | <span class='neutral'>        vm.warp(vm.getBlockTimestamp() - time);</span>
 665 |     | <span class='neutral'>    }</span>
 666 |     | <span class='neutral'></span>
 667 |     | <span class='neutral'>    // Setup a prank from an address that has some ether</span>
 668 |     | <span class='neutral'>    function hoax(address msgSender) internal virtual {</span>
 669 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 670 |     | <span class='neutral'>        vm.prank(msgSender);</span>
 671 |     | <span class='neutral'>    }</span>
 672 |     | <span class='neutral'></span>
 673 |     | <span class='neutral'>    function hoax(address msgSender, uint256 give) internal virtual {</span>
 674 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 675 |     | <span class='neutral'>        vm.prank(msgSender);</span>
 676 |     | <span class='neutral'>    }</span>
 677 |     | <span class='neutral'></span>
 678 |     | <span class='neutral'>    function hoax(address msgSender, address origin) internal virtual {</span>
 679 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 680 |     | <span class='neutral'>        vm.prank(msgSender, origin);</span>
 681 |     | <span class='neutral'>    }</span>
 682 |     | <span class='neutral'></span>
 683 |     | <span class='neutral'>    function hoax(address msgSender, address origin, uint256 give) internal virtual {</span>
 684 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 685 |     | <span class='neutral'>        vm.prank(msgSender, origin);</span>
 686 |     | <span class='neutral'>    }</span>
 687 |     | <span class='neutral'></span>
 688 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
 689 |     | <span class='neutral'>    function startHoax(address msgSender) internal virtual {</span>
 690 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 691 |     | <span class='neutral'>        vm.startPrank(msgSender);</span>
 692 |     | <span class='neutral'>    }</span>
 693 |     | <span class='neutral'></span>
 694 |     | <span class='neutral'>    function startHoax(address msgSender, uint256 give) internal virtual {</span>
 695 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 696 |     | <span class='neutral'>        vm.startPrank(msgSender);</span>
 697 |     | <span class='neutral'>    }</span>
 698 |     | <span class='neutral'></span>
 699 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
 700 |     | <span class='neutral'>    // tx.origin is set to the origin parameter</span>
 701 |     | <span class='neutral'>    function startHoax(address msgSender, address origin) internal virtual {</span>
 702 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 703 |     | <span class='neutral'>        vm.startPrank(msgSender, origin);</span>
 704 |     | <span class='neutral'>    }</span>
 705 |     | <span class='neutral'></span>
 706 |     | <span class='neutral'>    function startHoax(address msgSender, address origin, uint256 give) internal virtual {</span>
 707 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 708 |     | <span class='neutral'>        vm.startPrank(msgSender, origin);</span>
 709 |     | <span class='neutral'>    }</span>
 710 |     | <span class='neutral'></span>
 711 |     | <span class='neutral'>    function changePrank(address msgSender) internal virtual {</span>
 712 |     | <span class='neutral'>        console2_log_StdCheats(&quot;changePrank is deprecated. Please use vm.startPrank instead.&quot;);</span>
 713 |     | <span class='neutral'>        vm.stopPrank();</span>
 714 |     | <span class='neutral'>        vm.startPrank(msgSender);</span>
 715 |     | <span class='neutral'>    }</span>
 716 |     | <span class='neutral'></span>
 717 |     | <span class='neutral'>    function changePrank(address msgSender, address txOrigin) internal virtual {</span>
 718 |     | <span class='neutral'>        vm.stopPrank();</span>
 719 |     | <span class='neutral'>        vm.startPrank(msgSender, txOrigin);</span>
 720 |     | <span class='neutral'>    }</span>
 721 |     | <span class='neutral'></span>
 722 |     | <span class='neutral'>    // The same as Vm&#39;s `deal`</span>
 723 |     | <span class='neutral'>    // Use the alternative signature for ERC20 tokens</span>
 724 |     | <span class='neutral'>    function deal(address to, uint256 give) internal virtual {</span>
 725 |     | <span class='neutral'>        vm.deal(to, give);</span>
 726 |     | <span class='neutral'>    }</span>
 727 |     | <span class='neutral'></span>
 728 |     | <span class='neutral'>    // Set the balance of an account for any ERC20 token</span>
 729 |     | <span class='neutral'>    // Use the alternative signature to update `totalSupply`</span>
 730 |     | <span class='neutral'>    function deal(address token, address to, uint256 give) internal virtual {</span>
 731 |     | <span class='neutral'>        deal(token, to, give, false);</span>
 732 |     | <span class='neutral'>    }</span>
 733 |     | <span class='neutral'></span>
 734 |     | <span class='neutral'>    // Set the balance of an account for any ERC1155 token</span>
 735 |     | <span class='neutral'>    // Use the alternative signature to update `totalSupply`</span>
 736 |     | <span class='neutral'>    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {</span>
 737 |     | <span class='neutral'>        dealERC1155(token, to, id, give, false);</span>
 738 |     | <span class='neutral'>    }</span>
 739 |     | <span class='neutral'></span>
 740 |     | <span class='neutral'>    function deal(address token, address to, uint256 give, bool adjust) internal virtual {</span>
 741 |     | <span class='neutral'>        // get current balance</span>
 742 |     | <span class='neutral'>        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));</span>
 743 |     | <span class='neutral'>        uint256 prevBal = abi.decode(balData, (uint256));</span>
 744 |     | <span class='neutral'></span>
 745 |     | <span class='neutral'>        // update balance</span>
 746 |     | <span class='neutral'>        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);</span>
 747 |     | <span class='neutral'></span>
 748 |     | <span class='neutral'>        // update total supply</span>
 749 |     | <span class='neutral'>        if (adjust) {</span>
 750 |     | <span class='neutral'>            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));</span>
 751 |     | <span class='neutral'>            uint256 totSup = abi.decode(totSupData, (uint256));</span>
 752 |     | <span class='neutral'>            if (give &lt; prevBal) {</span>
 753 |     | <span class='neutral'>                totSup -= (prevBal - give);</span>
 754 |     | <span class='neutral'>            } else {</span>
 755 |     | <span class='neutral'>                totSup += (give - prevBal);</span>
 756 |     | <span class='neutral'>            }</span>
 757 |     | <span class='neutral'>            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);</span>
 758 |     | <span class='neutral'>        }</span>
 759 |     | <span class='neutral'>    }</span>
 760 |     | <span class='neutral'></span>
 761 |     | <span class='neutral'>    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {</span>
 762 |     | <span class='neutral'>        // get current balance</span>
 763 |     | <span class='neutral'>        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));</span>
 764 |     | <span class='neutral'>        uint256 prevBal = abi.decode(balData, (uint256));</span>
 765 |     | <span class='neutral'></span>
 766 |     | <span class='neutral'>        // update balance</span>
 767 |     | <span class='neutral'>        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);</span>
 768 |     | <span class='neutral'></span>
 769 |     | <span class='neutral'>        // update total supply</span>
 770 |     | <span class='neutral'>        if (adjust) {</span>
 771 |     | <span class='neutral'>            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));</span>
 772 |     | <span class='neutral'>            require(</span>
 773 |     | <span class='neutral'>                totSupData.length != 0,</span>
 774 |     | <span class='neutral'>                &quot;StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.&quot;</span>
 775 |     | <span class='neutral'>            );</span>
 776 |     | <span class='neutral'>            uint256 totSup = abi.decode(totSupData, (uint256));</span>
 777 |     | <span class='neutral'>            if (give &lt; prevBal) {</span>
 778 |     | <span class='neutral'>                totSup -= (prevBal - give);</span>
 779 |     | <span class='neutral'>            } else {</span>
 780 |     | <span class='neutral'>                totSup += (give - prevBal);</span>
 781 |     | <span class='neutral'>            }</span>
 782 |     | <span class='neutral'>            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);</span>
 783 |     | <span class='neutral'>        }</span>
 784 |     | <span class='neutral'>    }</span>
 785 |     | <span class='neutral'></span>
 786 |     | <span class='neutral'>    function dealERC721(address token, address to, uint256 id) internal virtual {</span>
 787 |     | <span class='neutral'>        // check if token id is already minted and the actual owner.</span>
 788 |     | <span class='neutral'>        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));</span>
 789 |     | <span class='neutral'>        require(successMinted, &quot;StdCheats deal(address,address,uint,bool): id not minted.&quot;);</span>
 790 |     | <span class='neutral'></span>
 791 |     | <span class='neutral'>        // get owner current balance</span>
 792 |     | <span class='neutral'>        (, bytes memory fromBalData) =</span>
 793 |     | <span class='neutral'>            token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));</span>
 794 |     | <span class='neutral'>        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));</span>
 795 |     | <span class='neutral'></span>
 796 |     | <span class='neutral'>        // get new user current balance</span>
 797 |     | <span class='neutral'>        (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));</span>
 798 |     | <span class='neutral'>        uint256 toPrevBal = abi.decode(toBalData, (uint256));</span>
 799 |     | <span class='neutral'></span>
 800 |     | <span class='neutral'>        // update balances</span>
 801 |     | <span class='neutral'>        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);</span>
 802 |     | <span class='neutral'>        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);</span>
 803 |     | <span class='neutral'></span>
 804 |     | <span class='neutral'>        // update owner</span>
 805 |     | <span class='neutral'>        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);</span>
 806 |     | <span class='neutral'>    }</span>
 807 |     | <span class='neutral'></span>
 808 |     | <span class='neutral'>    function deployCodeTo(string memory what, address where) internal virtual {</span>
 809 |     | <span class='neutral'>        deployCodeTo(what, &quot;&quot;, 0, where);</span>
 810 |     | <span class='neutral'>    }</span>
 811 |     | <span class='neutral'></span>
 812 |     | <span class='neutral'>    function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {</span>
 813 |     | <span class='neutral'>        deployCodeTo(what, args, 0, where);</span>
 814 |     | <span class='neutral'>    }</span>
 815 |     | <span class='neutral'></span>
 816 |     | <span class='neutral'>    function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {</span>
 817 |     | <span class='neutral'>        bytes memory creationCode = vm.getCode(what);</span>
 818 |     | <span class='neutral'>        vm.etch(where, abi.encodePacked(creationCode, args));</span>
 819 |     | <span class='neutral'>        (bool success, bytes memory runtimeBytecode) = where.call{value: value}(&quot;&quot;);</span>
 820 |     | <span class='neutral'>        require(success, &quot;StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.&quot;);</span>
 821 |     | <span class='neutral'>        vm.etch(where, runtimeBytecode);</span>
 822 |     | <span class='neutral'>    }</span>
 823 |     | <span class='neutral'></span>
 824 |     | <span class='neutral'>    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.</span>
 825 |     | <span class='neutral'>    function console2_log_StdCheats(string memory p0) private view {</span>
 826 |     | <span class='neutral'>        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
 827 |     | <span class='neutral'>        status;</span>
 828 |     | <span class='neutral'>    }</span>
 829 |     | <span class='neutral'>}</span>
 830 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/StdError.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// Panics work for versions &gt;=0.8.0, but we lowered the pragma to make this compatible with Test</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='unexecuted'>library stdError {</span>
  6 |     | <span class='unexecuted'>    bytes public constant assertionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x01);</span>
  7 |     | <span class='unexecuted'>    bytes public constant arithmeticError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x11);</span>
  8 |     | <span class='unexecuted'>    bytes public constant divisionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x12);</span>
  9 |     | <span class='unexecuted'>    bytes public constant enumConversionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x21);</span>
 10 |     | <span class='unexecuted'>    bytes public constant encodeStorageError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x22);</span>
 11 |     | <span class='unexecuted'>    bytes public constant popError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x31);</span>
 12 |     | <span class='unexecuted'>    bytes public constant indexOOBError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x32);</span>
 13 |     | <span class='unexecuted'>    bytes public constant memOverflowError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x41);</span>
 14 |     | <span class='unexecuted'>    bytes public constant zeroVarError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x51);</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/StdInvariant.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>abstract contract StdInvariant {</span>
   7 |     | <span class='neutral'>    struct FuzzSelector {</span>
   8 |     | <span class='neutral'>        address addr;</span>
   9 |     | <span class='neutral'>        bytes4[] selectors;</span>
  10 |     | <span class='neutral'>    }</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    struct FuzzArtifactSelector {</span>
  13 |     | <span class='neutral'>        string artifact;</span>
  14 |     | <span class='neutral'>        bytes4[] selectors;</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    struct FuzzInterface {</span>
  18 |     | <span class='neutral'>        address addr;</span>
  19 |     | <span class='neutral'>        string[] artifacts;</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    address[] private _excludedContracts;</span>
  23 |     | <span class='neutral'>    address[] private _excludedSenders;</span>
  24 |     | <span class='neutral'>    address[] private _targetedContracts;</span>
  25 |     | <span class='neutral'>    address[] private _targetedSenders;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    string[] private _excludedArtifacts;</span>
  28 |     | <span class='neutral'>    string[] private _targetedArtifacts;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    FuzzArtifactSelector[] private _targetedArtifactSelectors;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    FuzzSelector[] private _excludedSelectors;</span>
  33 |     | <span class='neutral'>    FuzzSelector[] private _targetedSelectors;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    FuzzInterface[] private _targetedInterfaces;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    // Functions for users:</span>
  38 |     | <span class='neutral'>    // These are intended to be called in tests.</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function excludeContract(address newExcludedContract_) internal {</span>
  41 |     | <span class='neutral'>        _excludedContracts.push(newExcludedContract_);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function excludeSelector(FuzzSelector memory newExcludedSelector_) internal {</span>
  45 |     | <span class='neutral'>        _excludedSelectors.push(newExcludedSelector_);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function excludeSender(address newExcludedSender_) internal {</span>
  49 |     | <span class='neutral'>        _excludedSenders.push(newExcludedSender_);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function excludeArtifact(string memory newExcludedArtifact_) internal {</span>
  53 |     | <span class='neutral'>        _excludedArtifacts.push(newExcludedArtifact_);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function targetArtifact(string memory newTargetedArtifact_) internal {</span>
  57 |     | <span class='neutral'>        _targetedArtifacts.push(newTargetedArtifact_);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function targetArtifactSelector(FuzzArtifactSelector memory newTargetedArtifactSelector_) internal {</span>
  61 |     | <span class='neutral'>        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function targetContract(address newTargetedContract_) internal {</span>
  65 |     | <span class='neutral'>        _targetedContracts.push(newTargetedContract_);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {</span>
  69 |     | <span class='neutral'>        _targetedSelectors.push(newTargetedSelector_);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function targetSender(address newTargetedSender_) internal {</span>
  73 |     | <span class='neutral'>        _targetedSenders.push(newTargetedSender_);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function targetInterface(FuzzInterface memory newTargetedInterface_) internal {</span>
  77 |     | <span class='neutral'>        _targetedInterfaces.push(newTargetedInterface_);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    // Functions for forge:</span>
  81 |     | <span class='neutral'>    // These are called by forge to run invariant tests and don&#39;t need to be called in tests.</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {</span>
  84 |     | <span class='unexecuted'>        excludedArtifacts_ = _excludedArtifacts;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>    function excludeContracts() public view returns (address[] memory excludedContracts_) {</span>
  88 |     | <span class='unexecuted'>        excludedContracts_ = _excludedContracts;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>    function excludeSelectors() public view returns (FuzzSelector[] memory excludedSelectors_) {</span>
  92 |     | <span class='unexecuted'>        excludedSelectors_ = _excludedSelectors;</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>    function excludeSenders() public view returns (address[] memory excludedSenders_) {</span>
  96 |     | <span class='unexecuted'>        excludedSenders_ = _excludedSenders;</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {</span>
 100 |     | <span class='unexecuted'>        targetedArtifacts_ = _targetedArtifacts;</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>    function targetArtifactSelectors() public view returns (FuzzArtifactSelector[] memory targetedArtifactSelectors_) {</span>
 104 |     | <span class='unexecuted'>        targetedArtifactSelectors_ = _targetedArtifactSelectors;</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>    function targetContracts() public view returns (address[] memory targetedContracts_) {</span>
 108 |     | <span class='unexecuted'>        targetedContracts_ = _targetedContracts;</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {</span>
 112 |     | <span class='unexecuted'>        targetedSelectors_ = _targetedSelectors;</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>    function targetSenders() public view returns (address[] memory targetedSenders_) {</span>
 116 |     | <span class='unexecuted'>        targetedSenders_ = _targetedSenders;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>    function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {</span>
 120 |     | <span class='unexecuted'>        targetedInterfaces_ = _targetedInterfaces;</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'>}</span>
 123 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/StdJson.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Helpers for parsing and writing JSON files</span>
   9 |     | <span class='neutral'>// To parse:</span>
  10 |     | <span class='neutral'>// ```</span>
  11 |     | <span class='neutral'>// using stdJson for string;</span>
  12 |     | <span class='neutral'>// string memory json = vm.readFile(&quot;&lt;some_path&gt;&quot;);</span>
  13 |     | <span class='neutral'>// json.readUint(&quot;&lt;json_path&gt;&quot;);</span>
  14 |     | <span class='neutral'>// ```</span>
  15 |     | <span class='neutral'>// To write:</span>
  16 |     | <span class='neutral'>// ```</span>
  17 |     | <span class='neutral'>// using stdJson for string;</span>
  18 |     | <span class='neutral'>// string memory json = &quot;json&quot;;</span>
  19 |     | <span class='neutral'>// json.serialize(&quot;a&quot;, uint256(123));</span>
  20 |     | <span class='neutral'>// string memory semiFinal = json.serialize(&quot;b&quot;, string(&quot;test&quot;));</span>
  21 |     | <span class='neutral'>// string memory finalJson = json.serialize(&quot;c&quot;, semiFinal);</span>
  22 |     | <span class='neutral'>// finalJson.write(&quot;&lt;some_path&gt;&quot;);</span>
  23 |     | <span class='neutral'>// ```</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>library stdJson {</span>
  26 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function keyExists(string memory json, string memory key) internal view returns (bool) {</span>
  29 |     | <span class='neutral'>        return vm.keyExistsJson(json, key);</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {</span>
  33 |     | <span class='neutral'>        return vm.parseJson(json, key);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    function readUint(string memory json, string memory key) internal pure returns (uint256) {</span>
  37 |     | <span class='neutral'>        return vm.parseJsonUint(json, key);</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {</span>
  41 |     | <span class='neutral'>        return vm.parseJsonUintArray(json, key);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function readInt(string memory json, string memory key) internal pure returns (int256) {</span>
  45 |     | <span class='neutral'>        return vm.parseJsonInt(json, key);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {</span>
  49 |     | <span class='neutral'>        return vm.parseJsonIntArray(json, key);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {</span>
  53 |     | <span class='neutral'>        return vm.parseJsonBytes32(json, key);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {</span>
  57 |     | <span class='neutral'>        return vm.parseJsonBytes32Array(json, key);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function readString(string memory json, string memory key) internal pure returns (string memory) {</span>
  61 |     | <span class='neutral'>        return vm.parseJsonString(json, key);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {</span>
  65 |     | <span class='neutral'>        return vm.parseJsonStringArray(json, key);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function readAddress(string memory json, string memory key) internal pure returns (address) {</span>
  69 |     | <span class='neutral'>        return vm.parseJsonAddress(json, key);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {</span>
  73 |     | <span class='neutral'>        return vm.parseJsonAddressArray(json, key);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function readBool(string memory json, string memory key) internal pure returns (bool) {</span>
  77 |     | <span class='neutral'>        return vm.parseJsonBool(json, key);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {</span>
  81 |     | <span class='neutral'>        return vm.parseJsonBoolArray(json, key);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {</span>
  85 |     | <span class='neutral'>        return vm.parseJsonBytes(json, key);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {</span>
  89 |     | <span class='neutral'>        return vm.parseJsonBytesArray(json, key);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function readUintOr(string memory json, string memory key, uint256 defaultValue) internal view returns (uint256) {</span>
  93 |     | <span class='neutral'>        return keyExists(json, key) ? readUint(json, key) : defaultValue;</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function readUintArrayOr(string memory json, string memory key, uint256[] memory defaultValue)</span>
  97 |     | <span class='neutral'>        internal</span>
  98 |     | <span class='neutral'>        view</span>
  99 |     | <span class='neutral'>        returns (uint256[] memory)</span>
 100 |     | <span class='neutral'>    {</span>
 101 |     | <span class='neutral'>        return keyExists(json, key) ? readUintArray(json, key) : defaultValue;</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    function readIntOr(string memory json, string memory key, int256 defaultValue) internal view returns (int256) {</span>
 105 |     | <span class='neutral'>        return keyExists(json, key) ? readInt(json, key) : defaultValue;</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    function readIntArrayOr(string memory json, string memory key, int256[] memory defaultValue)</span>
 109 |     | <span class='neutral'>        internal</span>
 110 |     | <span class='neutral'>        view</span>
 111 |     | <span class='neutral'>        returns (int256[] memory)</span>
 112 |     | <span class='neutral'>    {</span>
 113 |     | <span class='neutral'>        return keyExists(json, key) ? readIntArray(json, key) : defaultValue;</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    function readBytes32Or(string memory json, string memory key, bytes32 defaultValue)</span>
 117 |     | <span class='neutral'>        internal</span>
 118 |     | <span class='neutral'>        view</span>
 119 |     | <span class='neutral'>        returns (bytes32)</span>
 120 |     | <span class='neutral'>    {</span>
 121 |     | <span class='neutral'>        return keyExists(json, key) ? readBytes32(json, key) : defaultValue;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    function readBytes32ArrayOr(string memory json, string memory key, bytes32[] memory defaultValue)</span>
 125 |     | <span class='neutral'>        internal</span>
 126 |     | <span class='neutral'>        view</span>
 127 |     | <span class='neutral'>        returns (bytes32[] memory)</span>
 128 |     | <span class='neutral'>    {</span>
 129 |     | <span class='neutral'>        return keyExists(json, key) ? readBytes32Array(json, key) : defaultValue;</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    function readStringOr(string memory json, string memory key, string memory defaultValue)</span>
 133 |     | <span class='neutral'>        internal</span>
 134 |     | <span class='neutral'>        view</span>
 135 |     | <span class='neutral'>        returns (string memory)</span>
 136 |     | <span class='neutral'>    {</span>
 137 |     | <span class='neutral'>        return keyExists(json, key) ? readString(json, key) : defaultValue;</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function readStringArrayOr(string memory json, string memory key, string[] memory defaultValue)</span>
 141 |     | <span class='neutral'>        internal</span>
 142 |     | <span class='neutral'>        view</span>
 143 |     | <span class='neutral'>        returns (string[] memory)</span>
 144 |     | <span class='neutral'>    {</span>
 145 |     | <span class='neutral'>        return keyExists(json, key) ? readStringArray(json, key) : defaultValue;</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    function readAddressOr(string memory json, string memory key, address defaultValue)</span>
 149 |     | <span class='neutral'>        internal</span>
 150 |     | <span class='neutral'>        view</span>
 151 |     | <span class='neutral'>        returns (address)</span>
 152 |     | <span class='neutral'>    {</span>
 153 |     | <span class='neutral'>        return keyExists(json, key) ? readAddress(json, key) : defaultValue;</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    function readAddressArrayOr(string memory json, string memory key, address[] memory defaultValue)</span>
 157 |     | <span class='neutral'>        internal</span>
 158 |     | <span class='neutral'>        view</span>
 159 |     | <span class='neutral'>        returns (address[] memory)</span>
 160 |     | <span class='neutral'>    {</span>
 161 |     | <span class='neutral'>        return keyExists(json, key) ? readAddressArray(json, key) : defaultValue;</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    function readBoolOr(string memory json, string memory key, bool defaultValue) internal view returns (bool) {</span>
 165 |     | <span class='neutral'>        return keyExists(json, key) ? readBool(json, key) : defaultValue;</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    function readBoolArrayOr(string memory json, string memory key, bool[] memory defaultValue)</span>
 169 |     | <span class='neutral'>        internal</span>
 170 |     | <span class='neutral'>        view</span>
 171 |     | <span class='neutral'>        returns (bool[] memory)</span>
 172 |     | <span class='neutral'>    {</span>
 173 |     | <span class='neutral'>        return keyExists(json, key) ? readBoolArray(json, key) : defaultValue;</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function readBytesOr(string memory json, string memory key, bytes memory defaultValue)</span>
 177 |     | <span class='neutral'>        internal</span>
 178 |     | <span class='neutral'>        view</span>
 179 |     | <span class='neutral'>        returns (bytes memory)</span>
 180 |     | <span class='neutral'>    {</span>
 181 |     | <span class='neutral'>        return keyExists(json, key) ? readBytes(json, key) : defaultValue;</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    function readBytesArrayOr(string memory json, string memory key, bytes[] memory defaultValue)</span>
 185 |     | <span class='neutral'>        internal</span>
 186 |     | <span class='neutral'>        view</span>
 187 |     | <span class='neutral'>        returns (bytes[] memory)</span>
 188 |     | <span class='neutral'>    {</span>
 189 |     | <span class='neutral'>        return keyExists(json, key) ? readBytesArray(json, key) : defaultValue;</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {</span>
 193 |     | <span class='neutral'>        return vm.serializeJson(jsonKey, rootObject);</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {</span>
 197 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool[] memory value)</span>
 201 |     | <span class='neutral'>        internal</span>
 202 |     | <span class='neutral'>        returns (string memory)</span>
 203 |     | <span class='neutral'>    {</span>
 204 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {</span>
 208 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256[] memory value)</span>
 212 |     | <span class='neutral'>        internal</span>
 213 |     | <span class='neutral'>        returns (string memory)</span>
 214 |     | <span class='neutral'>    {</span>
 215 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {</span>
 219 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256[] memory value)</span>
 223 |     | <span class='neutral'>        internal</span>
 224 |     | <span class='neutral'>        returns (string memory)</span>
 225 |     | <span class='neutral'>    {</span>
 226 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {</span>
 230 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address[] memory value)</span>
 234 |     | <span class='neutral'>        internal</span>
 235 |     | <span class='neutral'>        returns (string memory)</span>
 236 |     | <span class='neutral'>    {</span>
 237 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {</span>
 241 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 242 |     | <span class='neutral'>    }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)</span>
 245 |     | <span class='neutral'>        internal</span>
 246 |     | <span class='neutral'>        returns (string memory)</span>
 247 |     | <span class='neutral'>    {</span>
 248 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {</span>
 252 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 253 |     | <span class='neutral'>    }</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes[] memory value)</span>
 256 |     | <span class='neutral'>        internal</span>
 257 |     | <span class='neutral'>        returns (string memory)</span>
 258 |     | <span class='neutral'>    {</span>
 259 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string memory value)</span>
 263 |     | <span class='neutral'>        internal</span>
 264 |     | <span class='neutral'>        returns (string memory)</span>
 265 |     | <span class='neutral'>    {</span>
 266 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string[] memory value)</span>
 270 |     | <span class='neutral'>        internal</span>
 271 |     | <span class='neutral'>        returns (string memory)</span>
 272 |     | <span class='neutral'>    {</span>
 273 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 274 |     | <span class='neutral'>    }</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path) internal {</span>
 277 |     | <span class='neutral'>        vm.writeJson(jsonKey, path);</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path, string memory valueKey) internal {</span>
 281 |     | <span class='neutral'>        vm.writeJson(jsonKey, path, valueKey);</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'>}</span>
 284 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/StdMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library stdMath {</span>
  5 |     | <span class='neutral'>    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function abs(int256 a) internal pure returns (uint256) {</span>
  8 |     | <span class='neutral'>        // Required or it will fail when `a = type(int256).min`</span>
  9 |     | <span class='neutral'>        if (a == INT256_MIN) {</span>
 10 |     | <span class='neutral'>            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
 11 |     | <span class='neutral'>        }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>        return uint256(a &gt; 0 ? a : -a);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function delta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 17 |     | <span class='neutral'>        return a &gt; b ? a - b : b - a;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function delta(int256 a, int256 b) internal pure returns (uint256) {</span>
 21 |     | <span class='neutral'>        // a and b are of the same sign</span>
 22 |     | <span class='neutral'>        // this works thanks to two&#39;s complement, the left-most bit is the sign bit</span>
 23 |     | <span class='neutral'>        if ((a ^ b) &gt; -1) {</span>
 24 |     | <span class='neutral'>            return delta(abs(a), abs(b));</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>        // a and b are of opposite signs</span>
 28 |     | <span class='neutral'>        return abs(a) + abs(b);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 32 |     | <span class='neutral'>        uint256 absDelta = delta(a, b);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>        return absDelta * 1e18 / b;</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {</span>
 38 |     | <span class='neutral'>        uint256 absDelta = delta(a, b);</span>
 39 |     | <span class='neutral'>        uint256 absB = abs(b);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>        return absDelta * 1e18 / absB;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/StdStorage.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>struct FindData {</span>
   7 |     | <span class='neutral'>    uint256 slot;</span>
   8 |     | <span class='neutral'>    uint256 offsetLeft;</span>
   9 |     | <span class='neutral'>    uint256 offsetRight;</span>
  10 |     | <span class='neutral'>    bool found;</span>
  11 |     | <span class='neutral'>}</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>struct StdStorage {</span>
  14 |     | <span class='neutral'>    mapping(address =&gt; mapping(bytes4 =&gt; mapping(bytes32 =&gt; FindData))) finds;</span>
  15 |     | <span class='neutral'>    bytes32[] _keys;</span>
  16 |     | <span class='neutral'>    bytes4 _sig;</span>
  17 |     | <span class='neutral'>    uint256 _depth;</span>
  18 |     | <span class='neutral'>    address _target;</span>
  19 |     | <span class='neutral'>    bytes32 _set;</span>
  20 |     | <span class='neutral'>    bool _enable_packed_slots;</span>
  21 |     | <span class='neutral'>    bytes _calldata;</span>
  22 |     | <span class='neutral'>}</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>library stdStorageSafe {</span>
  25 |     | <span class='neutral'>    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);</span>
  26 |     | <span class='neutral'>    event WARNING_UninitedSlot(address who, uint256 slot);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  29 |     | <span class='neutral'>    uint256 constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    function sigs(string memory sigStr) internal pure returns (bytes4) {</span>
  32 |     | <span class='neutral'>        return bytes4(keccak256(bytes(sigStr)));</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    function getCallParams(StdStorage storage self) internal view returns (bytes memory) {</span>
  36 |     | <span class='neutral'>        if (self._calldata.length == 0) {</span>
  37 |     | <span class='neutral'>            return flatten(self._keys);</span>
  38 |     | <span class='neutral'>        } else {</span>
  39 |     | <span class='neutral'>            return self._calldata;</span>
  40 |     | <span class='neutral'>        }</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    // Calls target contract with configured parameters</span>
  44 |     | <span class='neutral'>    function callTarget(StdStorage storage self) internal view returns (bool, bytes32) {</span>
  45 |     | <span class='neutral'>        bytes memory cald = abi.encodePacked(self._sig, getCallParams(self));</span>
  46 |     | <span class='neutral'>        (bool success, bytes memory rdat) = self._target.staticcall(cald);</span>
  47 |     | <span class='neutral'>        bytes32 result = bytesToBytes32(rdat, 32 * self._depth);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>        return (success, result);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    // Tries mutating slot value to determine if the targeted value is stored in it.</span>
  53 |     | <span class='neutral'>    // If current value is 0, then we are setting slot value to type(uint256).max</span>
  54 |     | <span class='neutral'>    // Otherwise, we set it to 0. That way, return value should always be affected.</span>
  55 |     | <span class='neutral'>    function checkSlotMutatesCall(StdStorage storage self, bytes32 slot) internal returns (bool) {</span>
  56 |     | <span class='neutral'>        bytes32 prevSlotValue = vm.load(self._target, slot);</span>
  57 |     | <span class='neutral'>        (bool success, bytes32 prevReturnValue) = callTarget(self);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        bytes32 testVal = prevReturnValue == bytes32(0) ? bytes32(UINT256_MAX) : bytes32(0);</span>
  60 |     | <span class='neutral'>        vm.store(self._target, slot, testVal);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>        (, bytes32 newReturnValue) = callTarget(self);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>        vm.store(self._target, slot, prevSlotValue);</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        return (success &amp;&amp; (prevReturnValue != newReturnValue));</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    // Tries setting one of the bits in slot to 1 until return value changes.</span>
  70 |     | <span class='neutral'>    // Index of resulted bit is an offset packed slot has from left/right side</span>
  71 |     | <span class='neutral'>    function findOffset(StdStorage storage self, bytes32 slot, bool left) internal returns (bool, uint256) {</span>
  72 |     | <span class='neutral'>        for (uint256 offset = 0; offset &lt; 256; offset++) {</span>
  73 |     | <span class='neutral'>            uint256 valueToPut = left ? (1 &lt;&lt; (255 - offset)) : (1 &lt;&lt; offset);</span>
  74 |     | <span class='neutral'>            vm.store(self._target, slot, bytes32(valueToPut));</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>            (bool success, bytes32 data) = callTarget(self);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>            if (success &amp;&amp; (uint256(data) &gt; 0)) {</span>
  79 |     | <span class='neutral'>                return (true, offset);</span>
  80 |     | <span class='neutral'>            }</span>
  81 |     | <span class='neutral'>        }</span>
  82 |     | <span class='neutral'>        return (false, 0);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    function findOffsets(StdStorage storage self, bytes32 slot) internal returns (bool, uint256, uint256) {</span>
  86 |     | <span class='neutral'>        bytes32 prevSlotValue = vm.load(self._target, slot);</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        (bool foundLeft, uint256 offsetLeft) = findOffset(self, slot, true);</span>
  89 |     | <span class='neutral'>        (bool foundRight, uint256 offsetRight) = findOffset(self, slot, false);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        // `findOffset` may mutate slot value, so we are setting it to initial value</span>
  92 |     | <span class='neutral'>        vm.store(self._target, slot, prevSlotValue);</span>
  93 |     | <span class='neutral'>        return (foundLeft &amp;&amp; foundRight, offsetLeft, offsetRight);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function find(StdStorage storage self) internal returns (FindData storage) {</span>
  97 |     | <span class='neutral'>        return find(self, true);</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against</span>
 101 |     | <span class='neutral'>    // slot complexity:</span>
 102 |     | <span class='neutral'>    //  if flat, will be bytes32(uint256(uint));</span>
 103 |     | <span class='neutral'>    //  if map, will be keccak256(abi.encode(key, uint(slot)));</span>
 104 |     | <span class='neutral'>    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));</span>
 105 |     | <span class='neutral'>    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);</span>
 106 |     | <span class='neutral'>    function find(StdStorage storage self, bool _clear) internal returns (FindData storage) {</span>
 107 |     | <span class='neutral'>        address who = self._target;</span>
 108 |     | <span class='neutral'>        bytes4 fsig = self._sig;</span>
 109 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 110 |     | <span class='neutral'>        bytes memory params = getCallParams(self);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>        // calldata to test against</span>
 113 |     | <span class='neutral'>        if (self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {</span>
 114 |     | <span class='neutral'>            if (_clear) {</span>
 115 |     | <span class='neutral'>                clear(self);</span>
 116 |     | <span class='neutral'>            }</span>
 117 |     | <span class='neutral'>            return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='neutral'>        vm.record();</span>
 120 |     | <span class='neutral'>        (, bytes32 callResult) = callTarget(self);</span>
 121 |     | <span class='neutral'>        (bytes32[] memory reads,) = vm.accesses(address(who));</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>        if (reads.length == 0) {</span>
 124 |     | <span class='neutral'>            revert(&quot;stdStorage find(StdStorage): No storage use detected for target.&quot;);</span>
 125 |     | <span class='neutral'>        } else {</span>
 126 |     | <span class='neutral'>            for (uint256 i = reads.length; --i &gt;= 0;) {</span>
 127 |     | <span class='neutral'>                bytes32 prev = vm.load(who, reads[i]);</span>
 128 |     | <span class='neutral'>                if (prev == bytes32(0)) {</span>
 129 |     | <span class='neutral'>                    emit WARNING_UninitedSlot(who, uint256(reads[i]));</span>
 130 |     | <span class='neutral'>                }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>                if (!checkSlotMutatesCall(self, reads[i])) {</span>
 133 |     | <span class='neutral'>                    continue;</span>
 134 |     | <span class='neutral'>                }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>                (uint256 offsetLeft, uint256 offsetRight) = (0, 0);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>                if (self._enable_packed_slots) {</span>
 139 |     | <span class='neutral'>                    bool found;</span>
 140 |     | <span class='neutral'>                    (found, offsetLeft, offsetRight) = findOffsets(self, reads[i]);</span>
 141 |     | <span class='neutral'>                    if (!found) {</span>
 142 |     | <span class='neutral'>                        continue;</span>
 143 |     | <span class='neutral'>                    }</span>
 144 |     | <span class='neutral'>                }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>                // Check that value between found offsets is equal to the current call result</span>
 147 |     | <span class='neutral'>                uint256 curVal = (uint256(prev) &amp; getMaskByOffsets(offsetLeft, offsetRight)) &gt;&gt; offsetRight;</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>                if (uint256(callResult) != curVal) {</span>
 150 |     | <span class='neutral'>                    continue;</span>
 151 |     | <span class='neutral'>                }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>                emit SlotFound(who, fsig, keccak256(abi.encodePacked(params, field_depth)), uint256(reads[i]));</span>
 154 |     | <span class='neutral'>                self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))] =</span>
 155 |     | <span class='neutral'>                    FindData(uint256(reads[i]), offsetLeft, offsetRight, true);</span>
 156 |     | <span class='neutral'>                break;</span>
 157 |     | <span class='neutral'>            }</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>        require(</span>
 161 |     | <span class='neutral'>            self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found,</span>
 162 |     | <span class='neutral'>            &quot;stdStorage find(StdStorage): Slot(s) not found.&quot;</span>
 163 |     | <span class='neutral'>        );</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>        if (_clear) {</span>
 166 |     | <span class='neutral'>            clear(self);</span>
 167 |     | <span class='neutral'>        }</span>
 168 |     | <span class='neutral'>        return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 172 |     | <span class='neutral'>        self._target = _target;</span>
 173 |     | <span class='neutral'>        return self;</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 177 |     | <span class='neutral'>        self._sig = _sig;</span>
 178 |     | <span class='neutral'>        return self;</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 182 |     | <span class='neutral'>        self._sig = sigs(_sig);</span>
 183 |     | <span class='neutral'>        return self;</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {</span>
 187 |     | <span class='neutral'>        self._calldata = _calldata;</span>
 188 |     | <span class='neutral'>        return self;</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 192 |     | <span class='neutral'>        self._keys.push(bytes32(uint256(uint160(who))));</span>
 193 |     | <span class='neutral'>        return self;</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 197 |     | <span class='neutral'>        self._keys.push(bytes32(amt));</span>
 198 |     | <span class='neutral'>        return self;</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 202 |     | <span class='neutral'>        self._keys.push(key);</span>
 203 |     | <span class='neutral'>        return self;</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {</span>
 207 |     | <span class='neutral'>        self._enable_packed_slots = true;</span>
 208 |     | <span class='neutral'>        return self;</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 212 |     | <span class='neutral'>        self._depth = _depth;</span>
 213 |     | <span class='neutral'>        return self;</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    function read(StdStorage storage self) private returns (bytes memory) {</span>
 217 |     | <span class='neutral'>        FindData storage data = find(self, false);</span>
 218 |     | <span class='neutral'>        uint256 mask = getMaskByOffsets(data.offsetLeft, data.offsetRight);</span>
 219 |     | <span class='neutral'>        uint256 value = (uint256(vm.load(self._target, bytes32(data.slot))) &amp; mask) &gt;&gt; data.offsetRight;</span>
 220 |     | <span class='neutral'>        clear(self);</span>
 221 |     | <span class='neutral'>        return abi.encode(value);</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 225 |     | <span class='neutral'>        return abi.decode(read(self), (bytes32));</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 229 |     | <span class='neutral'>        int256 v = read_int(self);</span>
 230 |     | <span class='neutral'>        if (v == 0) return false;</span>
 231 |     | <span class='neutral'>        if (v == 1) return true;</span>
 232 |     | <span class='neutral'>        revert(&quot;stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.&quot;);</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 236 |     | <span class='neutral'>        return abi.decode(read(self), (address));</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 240 |     | <span class='neutral'>        return abi.decode(read(self), (uint256));</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 244 |     | <span class='neutral'>        return abi.decode(read(self), (int256));</span>
 245 |     | <span class='neutral'>    }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>    function parent(StdStorage storage self) internal returns (uint256, bytes32) {</span>
 248 |     | <span class='neutral'>        address who = self._target;</span>
 249 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 250 |     | <span class='neutral'>        vm.startMappingRecording();</span>
 251 |     | <span class='neutral'>        uint256 child = find(self, true).slot - field_depth;</span>
 252 |     | <span class='neutral'>        (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));</span>
 253 |     | <span class='neutral'>        if (!found) {</span>
 254 |     | <span class='neutral'>            revert(</span>
 255 |     | <span class='neutral'>                &quot;stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.&quot;</span>
 256 |     | <span class='neutral'>            );</span>
 257 |     | <span class='neutral'>        }</span>
 258 |     | <span class='neutral'>        return (uint256(parent_slot), key);</span>
 259 |     | <span class='neutral'>    }</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>    function root(StdStorage storage self) internal returns (uint256) {</span>
 262 |     | <span class='neutral'>        address who = self._target;</span>
 263 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 264 |     | <span class='neutral'>        vm.startMappingRecording();</span>
 265 |     | <span class='neutral'>        uint256 child = find(self, true).slot - field_depth;</span>
 266 |     | <span class='neutral'>        bool found;</span>
 267 |     | <span class='neutral'>        bytes32 root_slot;</span>
 268 |     | <span class='neutral'>        bytes32 parent_slot;</span>
 269 |     | <span class='neutral'>        (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));</span>
 270 |     | <span class='neutral'>        if (!found) {</span>
 271 |     | <span class='neutral'>            revert(</span>
 272 |     | <span class='neutral'>                &quot;stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.&quot;</span>
 273 |     | <span class='neutral'>            );</span>
 274 |     | <span class='neutral'>        }</span>
 275 |     | <span class='neutral'>        while (found) {</span>
 276 |     | <span class='neutral'>            root_slot = parent_slot;</span>
 277 |     | <span class='neutral'>            (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));</span>
 278 |     | <span class='neutral'>        }</span>
 279 |     | <span class='neutral'>        return uint256(root_slot);</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {</span>
 283 |     | <span class='neutral'>        bytes32 out;</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>        uint256 max = b.length &gt; 32 ? 32 : b.length;</span>
 286 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; max; i++) {</span>
 287 |     | <span class='neutral'>            out |= bytes32(b[offset + i] &amp; 0xFF) &gt;&gt; (i * 8);</span>
 288 |     | <span class='neutral'>        }</span>
 289 |     | <span class='neutral'>        return out;</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>    function flatten(bytes32[] memory b) private pure returns (bytes memory) {</span>
 293 |     | <span class='neutral'>        bytes memory result = new bytes(b.length * 32);</span>
 294 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; b.length; i++) {</span>
 295 |     | <span class='neutral'>            bytes32 k = b[i];</span>
 296 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 297 |     | <span class='neutral'>            assembly {</span>
 298 |     | <span class='neutral'>                mstore(add(result, add(32, mul(32, i))), k)</span>
 299 |     | <span class='neutral'>            }</span>
 300 |     | <span class='neutral'>        }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>        return result;</span>
 303 |     | <span class='neutral'>    }</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>    function clear(StdStorage storage self) internal {</span>
 306 |     | <span class='neutral'>        delete self._target;</span>
 307 |     | <span class='neutral'>        delete self._sig;</span>
 308 |     | <span class='neutral'>        delete self._keys;</span>
 309 |     | <span class='neutral'>        delete self._depth;</span>
 310 |     | <span class='neutral'>        delete self._enable_packed_slots;</span>
 311 |     | <span class='neutral'>        delete self._calldata;</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    // Returns mask which contains non-zero bits for values between `offsetLeft` and `offsetRight`</span>
 315 |     | <span class='neutral'>    // (slotValue &amp; mask) &gt;&gt; offsetRight will be the value of the given packed variable</span>
 316 |     | <span class='neutral'>    function getMaskByOffsets(uint256 offsetLeft, uint256 offsetRight) internal pure returns (uint256 mask) {</span>
 317 |     | <span class='neutral'>        // mask = ((1 &lt;&lt; (256 - (offsetRight + offsetLeft))) - 1) &lt;&lt; offsetRight;</span>
 318 |     | <span class='neutral'>        // using assembly because (1 &lt;&lt; 256) causes overflow</span>
 319 |     | <span class='neutral'>        assembly {</span>
 320 |     | <span class='neutral'>            mask := shl(offsetRight, sub(shl(sub(256, add(offsetRight, offsetLeft)), 1), 1))</span>
 321 |     | <span class='neutral'>        }</span>
 322 |     | <span class='neutral'>    }</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='neutral'>    // Returns slot value with updated packed variable.</span>
 325 |     | <span class='neutral'>    function getUpdatedSlotValue(bytes32 curValue, uint256 varValue, uint256 offsetLeft, uint256 offsetRight)</span>
 326 |     | <span class='neutral'>        internal</span>
 327 |     | <span class='neutral'>        pure</span>
 328 |     | <span class='neutral'>        returns (bytes32 newValue)</span>
 329 |     | <span class='neutral'>    {</span>
 330 |     | <span class='neutral'>        return bytes32((uint256(curValue) &amp; ~getMaskByOffsets(offsetLeft, offsetRight)) | (varValue &lt;&lt; offsetRight));</span>
 331 |     | <span class='neutral'>    }</span>
 332 |     | <span class='neutral'>}</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='unexecuted'>library stdStorage {</span>
 335 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='neutral'>    function sigs(string memory sigStr) internal pure returns (bytes4) {</span>
 338 |     | <span class='neutral'>        return stdStorageSafe.sigs(sigStr);</span>
 339 |     | <span class='neutral'>    }</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='neutral'>    function find(StdStorage storage self) internal returns (uint256) {</span>
 342 |     | <span class='neutral'>        return find(self, true);</span>
 343 |     | <span class='neutral'>    }</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>    function find(StdStorage storage self, bool _clear) internal returns (uint256) {</span>
 346 |     | <span class='neutral'>        return stdStorageSafe.find(self, _clear).slot;</span>
 347 |     | <span class='neutral'>    }</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='neutral'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 350 |     | <span class='neutral'>        return stdStorageSafe.target(self, _target);</span>
 351 |     | <span class='neutral'>    }</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='neutral'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 354 |     | <span class='neutral'>        return stdStorageSafe.sig(self, _sig);</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 358 |     | <span class='neutral'>        return stdStorageSafe.sig(self, _sig);</span>
 359 |     | <span class='neutral'>    }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='neutral'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 362 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, who);</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 366 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, amt);</span>
 367 |     | <span class='neutral'>    }</span>
 368 |     | <span class='neutral'></span>
 369 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 370 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, key);</span>
 371 |     | <span class='neutral'>    }</span>
 372 |     | <span class='neutral'></span>
 373 |     | <span class='neutral'>    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {</span>
 374 |     | <span class='neutral'>        return stdStorageSafe.with_calldata(self, _calldata);</span>
 375 |     | <span class='neutral'>    }</span>
 376 |     | <span class='neutral'></span>
 377 |     | <span class='neutral'>    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {</span>
 378 |     | <span class='neutral'>        return stdStorageSafe.enable_packed_slots(self);</span>
 379 |     | <span class='neutral'>    }</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 382 |     | <span class='neutral'>        return stdStorageSafe.depth(self, _depth);</span>
 383 |     | <span class='neutral'>    }</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='neutral'>    function clear(StdStorage storage self) internal {</span>
 386 |     | <span class='neutral'>        stdStorageSafe.clear(self);</span>
 387 |     | <span class='neutral'>    }</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>    function checked_write(StdStorage storage self, address who) internal {</span>
 390 |     | <span class='neutral'>        checked_write(self, bytes32(uint256(uint160(who))));</span>
 391 |     | <span class='neutral'>    }</span>
 392 |     | <span class='neutral'></span>
 393 |     | <span class='neutral'>    function checked_write(StdStorage storage self, uint256 amt) internal {</span>
 394 |     | <span class='neutral'>        checked_write(self, bytes32(amt));</span>
 395 |     | <span class='neutral'>    }</span>
 396 |     | <span class='neutral'></span>
 397 |     | <span class='neutral'>    function checked_write_int(StdStorage storage self, int256 val) internal {</span>
 398 |     | <span class='neutral'>        checked_write(self, bytes32(uint256(val)));</span>
 399 |     | <span class='neutral'>    }</span>
 400 |     | <span class='neutral'></span>
 401 |     | <span class='neutral'>    function checked_write(StdStorage storage self, bool write) internal {</span>
 402 |     | <span class='neutral'>        bytes32 t;</span>
 403 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 404 |     | <span class='neutral'>        assembly {</span>
 405 |     | <span class='neutral'>            t := write</span>
 406 |     | <span class='neutral'>        }</span>
 407 |     | <span class='neutral'>        checked_write(self, t);</span>
 408 |     | <span class='neutral'>    }</span>
 409 |     | <span class='neutral'></span>
 410 |     | <span class='neutral'>    function checked_write(StdStorage storage self, bytes32 set) internal {</span>
 411 |     | <span class='neutral'>        address who = self._target;</span>
 412 |     | <span class='neutral'>        bytes4 fsig = self._sig;</span>
 413 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 414 |     | <span class='neutral'>        bytes memory params = stdStorageSafe.getCallParams(self);</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>        if (!self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {</span>
 417 |     | <span class='neutral'>            find(self, false);</span>
 418 |     | <span class='neutral'>        }</span>
 419 |     | <span class='neutral'>        FindData storage data = self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];</span>
 420 |     | <span class='neutral'>        if ((data.offsetLeft + data.offsetRight) &gt; 0) {</span>
 421 |     | <span class='neutral'>            uint256 maxVal = 2 ** (256 - (data.offsetLeft + data.offsetRight));</span>
 422 |     | <span class='neutral'>            require(</span>
 423 |     | <span class='neutral'>                uint256(set) &lt; maxVal,</span>
 424 |     | <span class='neutral'>                string(</span>
 425 |     | <span class='neutral'>                    abi.encodePacked(</span>
 426 |     | <span class='neutral'>                        &quot;stdStorage find(StdStorage): Packed slot. We can&#39;t fit value greater than &quot;,</span>
 427 |     | <span class='neutral'>                        vm.toString(maxVal)</span>
 428 |     | <span class='neutral'>                    )</span>
 429 |     | <span class='neutral'>                )</span>
 430 |     | <span class='neutral'>            );</span>
 431 |     | <span class='neutral'>        }</span>
 432 |     | <span class='neutral'>        bytes32 curVal = vm.load(who, bytes32(data.slot));</span>
 433 |     | <span class='neutral'>        bytes32 valToSet = stdStorageSafe.getUpdatedSlotValue(curVal, uint256(set), data.offsetLeft, data.offsetRight);</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='neutral'>        vm.store(who, bytes32(data.slot), valToSet);</span>
 436 |     | <span class='neutral'></span>
 437 |     | <span class='neutral'>        (bool success, bytes32 callResult) = stdStorageSafe.callTarget(self);</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='neutral'>        if (!success || callResult != set) {</span>
 440 |     | <span class='neutral'>            vm.store(who, bytes32(data.slot), curVal);</span>
 441 |     | <span class='neutral'>            revert(&quot;stdStorage find(StdStorage): Failed to write value.&quot;);</span>
 442 |     | <span class='neutral'>        }</span>
 443 |     | <span class='neutral'>        clear(self);</span>
 444 |     | <span class='neutral'>    }</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 447 |     | <span class='neutral'>        return stdStorageSafe.read_bytes32(self);</span>
 448 |     | <span class='neutral'>    }</span>
 449 |     | <span class='neutral'></span>
 450 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 451 |     | <span class='neutral'>        return stdStorageSafe.read_bool(self);</span>
 452 |     | <span class='neutral'>    }</span>
 453 |     | <span class='neutral'></span>
 454 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 455 |     | <span class='neutral'>        return stdStorageSafe.read_address(self);</span>
 456 |     | <span class='neutral'>    }</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 459 |     | <span class='neutral'>        return stdStorageSafe.read_uint(self);</span>
 460 |     | <span class='neutral'>    }</span>
 461 |     | <span class='neutral'></span>
 462 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 463 |     | <span class='neutral'>        return stdStorageSafe.read_int(self);</span>
 464 |     | <span class='neutral'>    }</span>
 465 |     | <span class='neutral'></span>
 466 |     | <span class='neutral'>    function parent(StdStorage storage self) internal returns (uint256, bytes32) {</span>
 467 |     | <span class='neutral'>        return stdStorageSafe.parent(self);</span>
 468 |     | <span class='neutral'>    }</span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='neutral'>    function root(StdStorage storage self) internal returns (uint256) {</span>
 471 |     | <span class='neutral'>        return stdStorageSafe.root(self);</span>
 472 |     | <span class='neutral'>    }</span>
 473 |     | <span class='neutral'>}</span>
 474 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/StdStyle.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='unexecuted'>library StdStyle {</span>
   7 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    string constant RED = &quot;\u001b[91m&quot;;</span>
  10 |     | <span class='neutral'>    string constant GREEN = &quot;\u001b[92m&quot;;</span>
  11 |     | <span class='neutral'>    string constant YELLOW = &quot;\u001b[93m&quot;;</span>
  12 |     | <span class='neutral'>    string constant BLUE = &quot;\u001b[94m&quot;;</span>
  13 |     | <span class='neutral'>    string constant MAGENTA = &quot;\u001b[95m&quot;;</span>
  14 |     | <span class='neutral'>    string constant CYAN = &quot;\u001b[96m&quot;;</span>
  15 |     | <span class='neutral'>    string constant BOLD = &quot;\u001b[1m&quot;;</span>
  16 |     | <span class='neutral'>    string constant DIM = &quot;\u001b[2m&quot;;</span>
  17 |     | <span class='neutral'>    string constant ITALIC = &quot;\u001b[3m&quot;;</span>
  18 |     | <span class='neutral'>    string constant UNDERLINE = &quot;\u001b[4m&quot;;</span>
  19 |     | <span class='neutral'>    string constant INVERSE = &quot;\u001b[7m&quot;;</span>
  20 |     | <span class='neutral'>    string constant RESET = &quot;\u001b[0m&quot;;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    function styleConcat(string memory style, string memory self) private pure returns (string memory) {</span>
  23 |     | <span class='neutral'>        return string(abi.encodePacked(style, self, RESET));</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    function red(string memory self) internal pure returns (string memory) {</span>
  27 |     | <span class='neutral'>        return styleConcat(RED, self);</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    function red(uint256 self) internal pure returns (string memory) {</span>
  31 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    function red(int256 self) internal pure returns (string memory) {</span>
  35 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    function red(address self) internal pure returns (string memory) {</span>
  39 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    function red(bool self) internal pure returns (string memory) {</span>
  43 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    function redBytes(bytes memory self) internal pure returns (string memory) {</span>
  47 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    function redBytes32(bytes32 self) internal pure returns (string memory) {</span>
  51 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    function green(string memory self) internal pure returns (string memory) {</span>
  55 |     | <span class='neutral'>        return styleConcat(GREEN, self);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    function green(uint256 self) internal pure returns (string memory) {</span>
  59 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    function green(int256 self) internal pure returns (string memory) {</span>
  63 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    function green(address self) internal pure returns (string memory) {</span>
  67 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    function green(bool self) internal pure returns (string memory) {</span>
  71 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    function greenBytes(bytes memory self) internal pure returns (string memory) {</span>
  75 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function greenBytes32(bytes32 self) internal pure returns (string memory) {</span>
  79 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    function yellow(string memory self) internal pure returns (string memory) {</span>
  83 |     | <span class='neutral'>        return styleConcat(YELLOW, self);</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function yellow(uint256 self) internal pure returns (string memory) {</span>
  87 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    function yellow(int256 self) internal pure returns (string memory) {</span>
  91 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    function yellow(address self) internal pure returns (string memory) {</span>
  95 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    function yellow(bool self) internal pure returns (string memory) {</span>
  99 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    function yellowBytes(bytes memory self) internal pure returns (string memory) {</span>
 103 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    function yellowBytes32(bytes32 self) internal pure returns (string memory) {</span>
 107 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    function blue(string memory self) internal pure returns (string memory) {</span>
 111 |     | <span class='neutral'>        return styleConcat(BLUE, self);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function blue(uint256 self) internal pure returns (string memory) {</span>
 115 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function blue(int256 self) internal pure returns (string memory) {</span>
 119 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    function blue(address self) internal pure returns (string memory) {</span>
 123 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    function blue(bool self) internal pure returns (string memory) {</span>
 127 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    function blueBytes(bytes memory self) internal pure returns (string memory) {</span>
 131 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    function blueBytes32(bytes32 self) internal pure returns (string memory) {</span>
 135 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    function magenta(string memory self) internal pure returns (string memory) {</span>
 139 |     | <span class='neutral'>        return styleConcat(MAGENTA, self);</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    function magenta(uint256 self) internal pure returns (string memory) {</span>
 143 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    function magenta(int256 self) internal pure returns (string memory) {</span>
 147 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    function magenta(address self) internal pure returns (string memory) {</span>
 151 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    function magenta(bool self) internal pure returns (string memory) {</span>
 155 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function magentaBytes(bytes memory self) internal pure returns (string memory) {</span>
 159 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    function magentaBytes32(bytes32 self) internal pure returns (string memory) {</span>
 163 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    function cyan(string memory self) internal pure returns (string memory) {</span>
 167 |     | <span class='neutral'>        return styleConcat(CYAN, self);</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    function cyan(uint256 self) internal pure returns (string memory) {</span>
 171 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    function cyan(int256 self) internal pure returns (string memory) {</span>
 175 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    function cyan(address self) internal pure returns (string memory) {</span>
 179 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    function cyan(bool self) internal pure returns (string memory) {</span>
 183 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    function cyanBytes(bytes memory self) internal pure returns (string memory) {</span>
 187 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    function cyanBytes32(bytes32 self) internal pure returns (string memory) {</span>
 191 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    function bold(string memory self) internal pure returns (string memory) {</span>
 195 |     | <span class='neutral'>        return styleConcat(BOLD, self);</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    function bold(uint256 self) internal pure returns (string memory) {</span>
 199 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    function bold(int256 self) internal pure returns (string memory) {</span>
 203 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function bold(address self) internal pure returns (string memory) {</span>
 207 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>    function bold(bool self) internal pure returns (string memory) {</span>
 211 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    function boldBytes(bytes memory self) internal pure returns (string memory) {</span>
 215 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    function boldBytes32(bytes32 self) internal pure returns (string memory) {</span>
 219 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    function dim(string memory self) internal pure returns (string memory) {</span>
 223 |     | <span class='neutral'>        return styleConcat(DIM, self);</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    function dim(uint256 self) internal pure returns (string memory) {</span>
 227 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    function dim(int256 self) internal pure returns (string memory) {</span>
 231 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    function dim(address self) internal pure returns (string memory) {</span>
 235 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>    function dim(bool self) internal pure returns (string memory) {</span>
 239 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    function dimBytes(bytes memory self) internal pure returns (string memory) {</span>
 243 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 244 |     | <span class='neutral'>    }</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>    function dimBytes32(bytes32 self) internal pure returns (string memory) {</span>
 247 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 248 |     | <span class='neutral'>    }</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>    function italic(string memory self) internal pure returns (string memory) {</span>
 251 |     | <span class='neutral'>        return styleConcat(ITALIC, self);</span>
 252 |     | <span class='neutral'>    }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    function italic(uint256 self) internal pure returns (string memory) {</span>
 255 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 256 |     | <span class='neutral'>    }</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>    function italic(int256 self) internal pure returns (string memory) {</span>
 259 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    function italic(address self) internal pure returns (string memory) {</span>
 263 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    function italic(bool self) internal pure returns (string memory) {</span>
 267 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 268 |     | <span class='neutral'>    }</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>    function italicBytes(bytes memory self) internal pure returns (string memory) {</span>
 271 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 272 |     | <span class='neutral'>    }</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>    function italicBytes32(bytes32 self) internal pure returns (string memory) {</span>
 275 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 276 |     | <span class='neutral'>    }</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='neutral'>    function underline(string memory self) internal pure returns (string memory) {</span>
 279 |     | <span class='neutral'>        return styleConcat(UNDERLINE, self);</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>    function underline(uint256 self) internal pure returns (string memory) {</span>
 283 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    function underline(int256 self) internal pure returns (string memory) {</span>
 287 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>    function underline(address self) internal pure returns (string memory) {</span>
 291 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 292 |     | <span class='neutral'>    }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>    function underline(bool self) internal pure returns (string memory) {</span>
 295 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 296 |     | <span class='neutral'>    }</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='neutral'>    function underlineBytes(bytes memory self) internal pure returns (string memory) {</span>
 299 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    function underlineBytes32(bytes32 self) internal pure returns (string memory) {</span>
 303 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>    function inverse(string memory self) internal pure returns (string memory) {</span>
 307 |     | <span class='neutral'>        return styleConcat(INVERSE, self);</span>
 308 |     | <span class='neutral'>    }</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>    function inverse(uint256 self) internal pure returns (string memory) {</span>
 311 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    function inverse(int256 self) internal pure returns (string memory) {</span>
 315 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 316 |     | <span class='neutral'>    }</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='neutral'>    function inverse(address self) internal pure returns (string memory) {</span>
 319 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>    function inverse(bool self) internal pure returns (string memory) {</span>
 323 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>    function inverseBytes(bytes memory self) internal pure returns (string memory) {</span>
 327 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 328 |     | <span class='neutral'>    }</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>    function inverseBytes32(bytes32 self) internal pure returns (string memory) {</span>
 331 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'>}</span>
 334 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/StdToml.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Helpers for parsing and writing TOML files</span>
   9 |     | <span class='neutral'>// To parse:</span>
  10 |     | <span class='neutral'>// ```</span>
  11 |     | <span class='neutral'>// using stdToml for string;</span>
  12 |     | <span class='neutral'>// string memory toml = vm.readFile(&quot;&lt;some_path&gt;&quot;);</span>
  13 |     | <span class='neutral'>// toml.readUint(&quot;&lt;json_path&gt;&quot;);</span>
  14 |     | <span class='neutral'>// ```</span>
  15 |     | <span class='neutral'>// To write:</span>
  16 |     | <span class='neutral'>// ```</span>
  17 |     | <span class='neutral'>// using stdToml for string;</span>
  18 |     | <span class='neutral'>// string memory json = &quot;json&quot;;</span>
  19 |     | <span class='neutral'>// json.serialize(&quot;a&quot;, uint256(123));</span>
  20 |     | <span class='neutral'>// string memory semiFinal = json.serialize(&quot;b&quot;, string(&quot;test&quot;));</span>
  21 |     | <span class='neutral'>// string memory finalJson = json.serialize(&quot;c&quot;, semiFinal);</span>
  22 |     | <span class='neutral'>// finalJson.write(&quot;&lt;some_path&gt;&quot;);</span>
  23 |     | <span class='neutral'>// ```</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>library stdToml {</span>
  26 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function keyExists(string memory toml, string memory key) internal view returns (bool) {</span>
  29 |     | <span class='neutral'>        return vm.keyExistsToml(toml, key);</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function parseRaw(string memory toml, string memory key) internal pure returns (bytes memory) {</span>
  33 |     | <span class='neutral'>        return vm.parseToml(toml, key);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    function readUint(string memory toml, string memory key) internal pure returns (uint256) {</span>
  37 |     | <span class='neutral'>        return vm.parseTomlUint(toml, key);</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function readUintArray(string memory toml, string memory key) internal pure returns (uint256[] memory) {</span>
  41 |     | <span class='neutral'>        return vm.parseTomlUintArray(toml, key);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function readInt(string memory toml, string memory key) internal pure returns (int256) {</span>
  45 |     | <span class='neutral'>        return vm.parseTomlInt(toml, key);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function readIntArray(string memory toml, string memory key) internal pure returns (int256[] memory) {</span>
  49 |     | <span class='neutral'>        return vm.parseTomlIntArray(toml, key);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function readBytes32(string memory toml, string memory key) internal pure returns (bytes32) {</span>
  53 |     | <span class='neutral'>        return vm.parseTomlBytes32(toml, key);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function readBytes32Array(string memory toml, string memory key) internal pure returns (bytes32[] memory) {</span>
  57 |     | <span class='neutral'>        return vm.parseTomlBytes32Array(toml, key);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function readString(string memory toml, string memory key) internal pure returns (string memory) {</span>
  61 |     | <span class='neutral'>        return vm.parseTomlString(toml, key);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function readStringArray(string memory toml, string memory key) internal pure returns (string[] memory) {</span>
  65 |     | <span class='neutral'>        return vm.parseTomlStringArray(toml, key);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function readAddress(string memory toml, string memory key) internal pure returns (address) {</span>
  69 |     | <span class='neutral'>        return vm.parseTomlAddress(toml, key);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function readAddressArray(string memory toml, string memory key) internal pure returns (address[] memory) {</span>
  73 |     | <span class='neutral'>        return vm.parseTomlAddressArray(toml, key);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function readBool(string memory toml, string memory key) internal pure returns (bool) {</span>
  77 |     | <span class='neutral'>        return vm.parseTomlBool(toml, key);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    function readBoolArray(string memory toml, string memory key) internal pure returns (bool[] memory) {</span>
  81 |     | <span class='neutral'>        return vm.parseTomlBoolArray(toml, key);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function readBytes(string memory toml, string memory key) internal pure returns (bytes memory) {</span>
  85 |     | <span class='neutral'>        return vm.parseTomlBytes(toml, key);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function readBytesArray(string memory toml, string memory key) internal pure returns (bytes[] memory) {</span>
  89 |     | <span class='neutral'>        return vm.parseTomlBytesArray(toml, key);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function readUintOr(string memory toml, string memory key, uint256 defaultValue) internal view returns (uint256) {</span>
  93 |     | <span class='neutral'>        return keyExists(toml, key) ? readUint(toml, key) : defaultValue;</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function readUintArrayOr(string memory toml, string memory key, uint256[] memory defaultValue)</span>
  97 |     | <span class='neutral'>        internal</span>
  98 |     | <span class='neutral'>        view</span>
  99 |     | <span class='neutral'>        returns (uint256[] memory)</span>
 100 |     | <span class='neutral'>    {</span>
 101 |     | <span class='neutral'>        return keyExists(toml, key) ? readUintArray(toml, key) : defaultValue;</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    function readIntOr(string memory toml, string memory key, int256 defaultValue) internal view returns (int256) {</span>
 105 |     | <span class='neutral'>        return keyExists(toml, key) ? readInt(toml, key) : defaultValue;</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    function readIntArrayOr(string memory toml, string memory key, int256[] memory defaultValue)</span>
 109 |     | <span class='neutral'>        internal</span>
 110 |     | <span class='neutral'>        view</span>
 111 |     | <span class='neutral'>        returns (int256[] memory)</span>
 112 |     | <span class='neutral'>    {</span>
 113 |     | <span class='neutral'>        return keyExists(toml, key) ? readIntArray(toml, key) : defaultValue;</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    function readBytes32Or(string memory toml, string memory key, bytes32 defaultValue)</span>
 117 |     | <span class='neutral'>        internal</span>
 118 |     | <span class='neutral'>        view</span>
 119 |     | <span class='neutral'>        returns (bytes32)</span>
 120 |     | <span class='neutral'>    {</span>
 121 |     | <span class='neutral'>        return keyExists(toml, key) ? readBytes32(toml, key) : defaultValue;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    function readBytes32ArrayOr(string memory toml, string memory key, bytes32[] memory defaultValue)</span>
 125 |     | <span class='neutral'>        internal</span>
 126 |     | <span class='neutral'>        view</span>
 127 |     | <span class='neutral'>        returns (bytes32[] memory)</span>
 128 |     | <span class='neutral'>    {</span>
 129 |     | <span class='neutral'>        return keyExists(toml, key) ? readBytes32Array(toml, key) : defaultValue;</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    function readStringOr(string memory toml, string memory key, string memory defaultValue)</span>
 133 |     | <span class='neutral'>        internal</span>
 134 |     | <span class='neutral'>        view</span>
 135 |     | <span class='neutral'>        returns (string memory)</span>
 136 |     | <span class='neutral'>    {</span>
 137 |     | <span class='neutral'>        return keyExists(toml, key) ? readString(toml, key) : defaultValue;</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function readStringArrayOr(string memory toml, string memory key, string[] memory defaultValue)</span>
 141 |     | <span class='neutral'>        internal</span>
 142 |     | <span class='neutral'>        view</span>
 143 |     | <span class='neutral'>        returns (string[] memory)</span>
 144 |     | <span class='neutral'>    {</span>
 145 |     | <span class='neutral'>        return keyExists(toml, key) ? readStringArray(toml, key) : defaultValue;</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    function readAddressOr(string memory toml, string memory key, address defaultValue)</span>
 149 |     | <span class='neutral'>        internal</span>
 150 |     | <span class='neutral'>        view</span>
 151 |     | <span class='neutral'>        returns (address)</span>
 152 |     | <span class='neutral'>    {</span>
 153 |     | <span class='neutral'>        return keyExists(toml, key) ? readAddress(toml, key) : defaultValue;</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    function readAddressArrayOr(string memory toml, string memory key, address[] memory defaultValue)</span>
 157 |     | <span class='neutral'>        internal</span>
 158 |     | <span class='neutral'>        view</span>
 159 |     | <span class='neutral'>        returns (address[] memory)</span>
 160 |     | <span class='neutral'>    {</span>
 161 |     | <span class='neutral'>        return keyExists(toml, key) ? readAddressArray(toml, key) : defaultValue;</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    function readBoolOr(string memory toml, string memory key, bool defaultValue) internal view returns (bool) {</span>
 165 |     | <span class='neutral'>        return keyExists(toml, key) ? readBool(toml, key) : defaultValue;</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    function readBoolArrayOr(string memory toml, string memory key, bool[] memory defaultValue)</span>
 169 |     | <span class='neutral'>        internal</span>
 170 |     | <span class='neutral'>        view</span>
 171 |     | <span class='neutral'>        returns (bool[] memory)</span>
 172 |     | <span class='neutral'>    {</span>
 173 |     | <span class='neutral'>        return keyExists(toml, key) ? readBoolArray(toml, key) : defaultValue;</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function readBytesOr(string memory toml, string memory key, bytes memory defaultValue)</span>
 177 |     | <span class='neutral'>        internal</span>
 178 |     | <span class='neutral'>        view</span>
 179 |     | <span class='neutral'>        returns (bytes memory)</span>
 180 |     | <span class='neutral'>    {</span>
 181 |     | <span class='neutral'>        return keyExists(toml, key) ? readBytes(toml, key) : defaultValue;</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    function readBytesArrayOr(string memory toml, string memory key, bytes[] memory defaultValue)</span>
 185 |     | <span class='neutral'>        internal</span>
 186 |     | <span class='neutral'>        view</span>
 187 |     | <span class='neutral'>        returns (bytes[] memory)</span>
 188 |     | <span class='neutral'>    {</span>
 189 |     | <span class='neutral'>        return keyExists(toml, key) ? readBytesArray(toml, key) : defaultValue;</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {</span>
 193 |     | <span class='neutral'>        return vm.serializeJson(jsonKey, rootObject);</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {</span>
 197 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool[] memory value)</span>
 201 |     | <span class='neutral'>        internal</span>
 202 |     | <span class='neutral'>        returns (string memory)</span>
 203 |     | <span class='neutral'>    {</span>
 204 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {</span>
 208 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256[] memory value)</span>
 212 |     | <span class='neutral'>        internal</span>
 213 |     | <span class='neutral'>        returns (string memory)</span>
 214 |     | <span class='neutral'>    {</span>
 215 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {</span>
 219 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256[] memory value)</span>
 223 |     | <span class='neutral'>        internal</span>
 224 |     | <span class='neutral'>        returns (string memory)</span>
 225 |     | <span class='neutral'>    {</span>
 226 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {</span>
 230 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address[] memory value)</span>
 234 |     | <span class='neutral'>        internal</span>
 235 |     | <span class='neutral'>        returns (string memory)</span>
 236 |     | <span class='neutral'>    {</span>
 237 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {</span>
 241 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 242 |     | <span class='neutral'>    }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)</span>
 245 |     | <span class='neutral'>        internal</span>
 246 |     | <span class='neutral'>        returns (string memory)</span>
 247 |     | <span class='neutral'>    {</span>
 248 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {</span>
 252 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 253 |     | <span class='neutral'>    }</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes[] memory value)</span>
 256 |     | <span class='neutral'>        internal</span>
 257 |     | <span class='neutral'>        returns (string memory)</span>
 258 |     | <span class='neutral'>    {</span>
 259 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string memory value)</span>
 263 |     | <span class='neutral'>        internal</span>
 264 |     | <span class='neutral'>        returns (string memory)</span>
 265 |     | <span class='neutral'>    {</span>
 266 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string[] memory value)</span>
 270 |     | <span class='neutral'>        internal</span>
 271 |     | <span class='neutral'>        returns (string memory)</span>
 272 |     | <span class='neutral'>    {</span>
 273 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 274 |     | <span class='neutral'>    }</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path) internal {</span>
 277 |     | <span class='neutral'>        vm.writeToml(jsonKey, path);</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path, string memory valueKey) internal {</span>
 281 |     | <span class='neutral'>        vm.writeToml(jsonKey, path, valueKey);</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'>}</span>
 284 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/StdUtils.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IMulticall3} from &quot;./interfaces/IMulticall3.sol&quot;;</span>
   7 |     | <span class='neutral'>import {MockERC20} from &quot;./mocks/MockERC20.sol&quot;;</span>
   8 |     | <span class='neutral'>import {MockERC721} from &quot;./mocks/MockERC721.sol&quot;;</span>
   9 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>abstract contract StdUtils {</span>
  12 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
  13 |     | <span class='neutral'>                                     CONSTANTS</span>
  14 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);</span>
  17 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  18 |     | <span class='neutral'>    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
  19 |     | <span class='neutral'>    uint256 private constant INT256_MIN_ABS =</span>
  20 |     | <span class='neutral'>        57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
  21 |     | <span class='neutral'>    uint256 private constant SECP256K1_ORDER =</span>
  22 |     | <span class='neutral'>        115792089237316195423570985008687907852837564279074904382605163141518161494337;</span>
  23 |     | <span class='neutral'>    uint256 private constant UINT256_MAX =</span>
  24 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.</span>
  27 |     | <span class='neutral'>    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
  30 |     | <span class='neutral'>                                 INTERNAL FUNCTIONS</span>
  31 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {</span>
  34 |     | <span class='neutral'>        require(min &lt;= max, &quot;StdUtils bound(uint256,uint256,uint256): Max is less than min.&quot;);</span>
  35 |     | <span class='neutral'>        // If x is between min and max, return x directly. This is to ensure that dictionary values</span>
  36 |     | <span class='neutral'>        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188</span>
  37 |     | <span class='neutral'>        if (x &gt;= min &amp;&amp; x &lt;= max) return x;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>        uint256 size = max - min + 1;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.</span>
  42 |     | <span class='neutral'>        // This helps ensure coverage of the min/max values.</span>
  43 |     | <span class='neutral'>        if (x &lt;= 3 &amp;&amp; size &gt; x) return min + x;</span>
  44 |     | <span class='neutral'>        if (x &gt;= UINT256_MAX - 3 &amp;&amp; size &gt; UINT256_MAX - x) return max - (UINT256_MAX - x);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.</span>
  47 |     | <span class='neutral'>        if (x &gt; max) {</span>
  48 |     | <span class='neutral'>            uint256 diff = x - max;</span>
  49 |     | <span class='neutral'>            uint256 rem = diff % size;</span>
  50 |     | <span class='neutral'>            if (rem == 0) return max;</span>
  51 |     | <span class='neutral'>            result = min + rem - 1;</span>
  52 |     | <span class='neutral'>        } else if (x &lt; min) {</span>
  53 |     | <span class='neutral'>            uint256 diff = min - x;</span>
  54 |     | <span class='neutral'>            uint256 rem = diff % size;</span>
  55 |     | <span class='neutral'>            if (rem == 0) return min;</span>
  56 |     | <span class='neutral'>            result = max - rem + 1;</span>
  57 |     | <span class='neutral'>        }</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {</span>
  61 |     | <span class='neutral'>        result = _bound(x, min, max);</span>
  62 |     | <span class='neutral'>        console2_log_StdUtils(&quot;Bound result&quot;, result);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {</span>
  66 |     | <span class='neutral'>        require(min &lt;= max, &quot;StdUtils bound(int256,int256,int256): Max is less than min.&quot;);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:</span>
  69 |     | <span class='neutral'>        // int256 : -(2**255) ~ (2**255 - 1)</span>
  70 |     | <span class='neutral'>        // uint256:     0     ~ (2**256 - 1)</span>
  71 |     | <span class='neutral'>        // So, add 2**255, INT256_MIN_ABS to the integer values.</span>
  72 |     | <span class='neutral'>        //</span>
  73 |     | <span class='neutral'>        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.</span>
  74 |     | <span class='neutral'>        // So, use `~uint256(x) + 1` instead.</span>
  75 |     | <span class='neutral'>        uint256 _x = x &lt; 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);</span>
  76 |     | <span class='neutral'>        uint256 _min = min &lt; 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);</span>
  77 |     | <span class='neutral'>        uint256 _max = max &lt; 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        uint256 y = _bound(_x, _min, _max);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>        // To move it back to int256 value, subtract INT256_MIN_ABS at here.</span>
  82 |     | <span class='neutral'>        result = y &lt; INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {</span>
  86 |     | <span class='neutral'>        result = _bound(x, min, max);</span>
  87 |     | <span class='neutral'>        console2_log_StdUtils(&quot;Bound result&quot;, vm.toString(result));</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {</span>
  91 |     | <span class='neutral'>        result = _bound(privateKey, 1, SECP256K1_ORDER - 1);</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {</span>
  95 |     | <span class='neutral'>        require(b.length &lt;= 32, &quot;StdUtils bytesToUint(bytes): Bytes length exceeds 32.&quot;);</span>
  96 |     | <span class='neutral'>        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce</span>
 100 |     | <span class='neutral'>    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)</span>
 101 |     | <span class='neutral'>    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {</span>
 102 |     | <span class='neutral'>        console2_log_StdUtils(&quot;computeCreateAddress is deprecated. Please use vm.computeCreateAddress instead.&quot;);</span>
 103 |     | <span class='neutral'>        return vm.computeCreateAddress(deployer, nonce);</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)</span>
 107 |     | <span class='neutral'>        internal</span>
 108 |     | <span class='neutral'>        pure</span>
 109 |     | <span class='neutral'>        virtual</span>
 110 |     | <span class='neutral'>        returns (address)</span>
 111 |     | <span class='neutral'>    {</span>
 112 |     | <span class='neutral'>        console2_log_StdUtils(&quot;computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.&quot;);</span>
 113 |     | <span class='neutral'>        return vm.computeCreate2Address(salt, initcodeHash, deployer);</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer</span>
 117 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {</span>
 118 |     | <span class='neutral'>        console2_log_StdUtils(&quot;computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.&quot;);</span>
 119 |     | <span class='neutral'>        return vm.computeCreate2Address(salt, initCodeHash);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /// @dev returns an initialized mock ERC20 contract</span>
 123 |     | <span class='neutral'>    function deployMockERC20(string memory name, string memory symbol, uint8 decimals)</span>
 124 |     | <span class='neutral'>        internal</span>
 125 |     | <span class='neutral'>        returns (MockERC20 mock)</span>
 126 |     | <span class='neutral'>    {</span>
 127 |     | <span class='neutral'>        mock = new MockERC20();</span>
 128 |     | <span class='neutral'>        mock.initialize(name, symbol, decimals);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /// @dev returns an initialized mock ERC721 contract</span>
 132 |     | <span class='neutral'>    function deployMockERC721(string memory name, string memory symbol) internal returns (MockERC721 mock) {</span>
 133 |     | <span class='neutral'>        mock = new MockERC721();</span>
 134 |     | <span class='neutral'>        mock.initialize(name, symbol);</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments</span>
 138 |     | <span class='neutral'>    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode</span>
 139 |     | <span class='neutral'>    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {</span>
 140 |     | <span class='neutral'>        return hashInitCode(creationCode, &quot;&quot;);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2</span>
 144 |     | <span class='neutral'>    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode</span>
 145 |     | <span class='neutral'>    /// @param args the ABI-encoded arguments to the constructor of C</span>
 146 |     | <span class='neutral'>    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {</span>
 147 |     | <span class='neutral'>        return keccak256(abi.encodePacked(creationCode, args));</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.</span>
 151 |     | <span class='neutral'>    function getTokenBalances(address token, address[] memory addresses)</span>
 152 |     | <span class='neutral'>        internal</span>
 153 |     | <span class='neutral'>        virtual</span>
 154 |     | <span class='neutral'>        returns (uint256[] memory balances)</span>
 155 |     | <span class='neutral'>    {</span>
 156 |     | <span class='neutral'>        uint256 tokenCodeSize;</span>
 157 |     | <span class='neutral'>        assembly {</span>
 158 |     | <span class='neutral'>            tokenCodeSize := extcodesize(token)</span>
 159 |     | <span class='neutral'>        }</span>
 160 |     | <span class='neutral'>        require(tokenCodeSize &gt; 0, &quot;StdUtils getTokenBalances(address,address[]): Token address is not a contract.&quot;);</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>        // ABI encode the aggregate call to Multicall3.</span>
 163 |     | <span class='neutral'>        uint256 length = addresses.length;</span>
 164 |     | <span class='neutral'>        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);</span>
 165 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; length; ++i) {</span>
 166 |     | <span class='neutral'>            // 0x70a08231 = bytes4(&quot;balanceOf(address)&quot;))</span>
 167 |     | <span class='neutral'>            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});</span>
 168 |     | <span class='neutral'>        }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>        // Make the aggregate call.</span>
 171 |     | <span class='neutral'>        (, bytes[] memory returnData) = multicall.aggregate(calls);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>        // ABI decode the return data and return the balances.</span>
 174 |     | <span class='neutral'>        balances = new uint256[](length);</span>
 175 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; length; ++i) {</span>
 176 |     | <span class='neutral'>            balances[i] = abi.decode(returnData[i], (uint256));</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
 181 |     | <span class='neutral'>                                 PRIVATE FUNCTIONS</span>
 182 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {</span>
 185 |     | <span class='neutral'>        return address(uint160(uint256(bytesValue)));</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    // This section is used to prevent the compilation of console, which shortens the compilation time when console is</span>
 189 |     | <span class='neutral'>    // not used elsewhere. We also trick the compiler into letting us make the console log methods as `pure` to avoid</span>
 190 |     | <span class='neutral'>    // any breaking changes to function signatures.</span>
 191 |     | <span class='neutral'>    function _castLogPayloadViewToPure(function(bytes memory) internal view fnIn)</span>
 192 |     | <span class='neutral'>        internal</span>
 193 |     | <span class='neutral'>        pure</span>
 194 |     | <span class='neutral'>        returns (function(bytes memory) internal pure fnOut)</span>
 195 |     | <span class='neutral'>    {</span>
 196 |     | <span class='neutral'>        assembly {</span>
 197 |     | <span class='neutral'>            fnOut := fnIn</span>
 198 |     | <span class='neutral'>        }</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>    function _sendLogPayload(bytes memory payload) internal pure {</span>
 202 |     | <span class='neutral'>        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);</span>
 203 |     | <span class='neutral'>    }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>    function _sendLogPayloadView(bytes memory payload) private view {</span>
 206 |     | <span class='neutral'>        uint256 payloadLength = payload.length;</span>
 207 |     | <span class='neutral'>        address consoleAddress = CONSOLE2_ADDRESS;</span>
 208 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 209 |     | <span class='neutral'>        assembly {</span>
 210 |     | <span class='neutral'>            let payloadStart := add(payload, 32)</span>
 211 |     | <span class='neutral'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>    function console2_log_StdUtils(string memory p0) private pure {</span>
 216 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>    function console2_log_StdUtils(string memory p0, uint256 p1) private pure {</span>
 220 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256)&quot;, p0, p1));</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    function console2_log_StdUtils(string memory p0, string memory p1) private pure {</span>
 224 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
 225 |     | <span class='neutral'>    }</span>
 226 |     | <span class='neutral'>}</span>
 227 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/Test.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>// 💬 ABOUT</span>
  7 |     | <span class='neutral'>// Forge Std&#39;s default Test.</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>// 🧩 MODULES</span>
 10 |     | <span class='neutral'>import {console} from &quot;./console.sol&quot;;</span>
 11 |     | <span class='neutral'>import {console2} from &quot;./console2.sol&quot;;</span>
 12 |     | <span class='neutral'>import {safeconsole} from &quot;./safeconsole.sol&quot;;</span>
 13 |     | <span class='neutral'>import {StdAssertions} from &quot;./StdAssertions.sol&quot;;</span>
 14 |     | <span class='neutral'>import {StdChains} from &quot;./StdChains.sol&quot;;</span>
 15 |     | <span class='neutral'>import {StdCheats} from &quot;./StdCheats.sol&quot;;</span>
 16 |     | <span class='neutral'>import {stdError} from &quot;./StdError.sol&quot;;</span>
 17 |     | <span class='neutral'>import {StdInvariant} from &quot;./StdInvariant.sol&quot;;</span>
 18 |     | <span class='neutral'>import {stdJson} from &quot;./StdJson.sol&quot;;</span>
 19 |     | <span class='neutral'>import {stdMath} from &quot;./StdMath.sol&quot;;</span>
 20 |     | <span class='neutral'>import {StdStorage, stdStorage} from &quot;./StdStorage.sol&quot;;</span>
 21 |     | <span class='neutral'>import {StdStyle} from &quot;./StdStyle.sol&quot;;</span>
 22 |     | <span class='neutral'>import {stdToml} from &quot;./StdToml.sol&quot;;</span>
 23 |     | <span class='neutral'>import {StdUtils} from &quot;./StdUtils.sol&quot;;</span>
 24 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>// 📦 BOILERPLATE</span>
 27 |     | <span class='neutral'>import {TestBase} from &quot;./Base.sol&quot;;</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>// ⭐️ TEST</span>
 30 |     | <span class='neutral'>abstract contract Test is TestBase, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {</span>
 31 |     | <span class='neutral'>    // Note: IS_TEST() must return true.</span>
 32 |     | <span class='unexecuted'>    bool public IS_TEST = true;</span>
 33 |     | <span class='neutral'>}</span>
 34 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/Vm.sol</b>
<code>
    1 |     | <span class='neutral'>// Automatically @generated by scripts/vm.py. Do not modify manually.</span>
    2 |     | <span class='neutral'></span>
    3 |     | <span class='neutral'>// SPDX-License-Identifier: MIT OR Apache-2.0</span>
    4 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
    5 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='neutral'>/// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may</span>
    8 |     | <span class='neutral'>/// result in Script simulations differing from on-chain execution. It is recommended to only use</span>
    9 |     | <span class='neutral'>/// these cheats in scripts.</span>
   10 |     | <span class='neutral'>interface VmSafe {</span>
   11 |     | <span class='neutral'>    /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.</span>
   12 |     | <span class='neutral'>    enum CallerMode {</span>
   13 |     | <span class='neutral'>        // No caller modification is currently active.</span>
   14 |     | <span class='neutral'>        None,</span>
   15 |     | <span class='neutral'>        // A one time broadcast triggered by a `vm.broadcast()` call is currently active.</span>
   16 |     | <span class='neutral'>        Broadcast,</span>
   17 |     | <span class='neutral'>        // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.</span>
   18 |     | <span class='neutral'>        RecurrentBroadcast,</span>
   19 |     | <span class='neutral'>        // A one time prank triggered by a `vm.prank()` call is currently active.</span>
   20 |     | <span class='neutral'>        Prank,</span>
   21 |     | <span class='neutral'>        // A recurrent prank triggered by a `vm.startPrank()` call is currently active.</span>
   22 |     | <span class='neutral'>        RecurrentPrank</span>
   23 |     | <span class='neutral'>    }</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>    /// The kind of account access that occurred.</span>
   26 |     | <span class='neutral'>    enum AccountAccessKind {</span>
   27 |     | <span class='neutral'>        // The account was called.</span>
   28 |     | <span class='neutral'>        Call,</span>
   29 |     | <span class='neutral'>        // The account was called via delegatecall.</span>
   30 |     | <span class='neutral'>        DelegateCall,</span>
   31 |     | <span class='neutral'>        // The account was called via callcode.</span>
   32 |     | <span class='neutral'>        CallCode,</span>
   33 |     | <span class='neutral'>        // The account was called via staticcall.</span>
   34 |     | <span class='neutral'>        StaticCall,</span>
   35 |     | <span class='neutral'>        // The account was created.</span>
   36 |     | <span class='neutral'>        Create,</span>
   37 |     | <span class='neutral'>        // The account was selfdestructed.</span>
   38 |     | <span class='neutral'>        SelfDestruct,</span>
   39 |     | <span class='neutral'>        // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).</span>
   40 |     | <span class='neutral'>        Resume,</span>
   41 |     | <span class='neutral'>        // The account&#39;s balance was read.</span>
   42 |     | <span class='neutral'>        Balance,</span>
   43 |     | <span class='neutral'>        // The account&#39;s codesize was read.</span>
   44 |     | <span class='neutral'>        Extcodesize,</span>
   45 |     | <span class='neutral'>        // The account&#39;s codehash was read.</span>
   46 |     | <span class='neutral'>        Extcodehash,</span>
   47 |     | <span class='neutral'>        // The account&#39;s code was copied.</span>
   48 |     | <span class='neutral'>        Extcodecopy</span>
   49 |     | <span class='neutral'>    }</span>
   50 |     | <span class='neutral'></span>
   51 |     | <span class='neutral'>    /// Forge execution contexts.</span>
   52 |     | <span class='neutral'>    enum ForgeContext {</span>
   53 |     | <span class='neutral'>        // Test group execution context (test, coverage or snapshot).</span>
   54 |     | <span class='neutral'>        TestGroup,</span>
   55 |     | <span class='neutral'>        // `forge test` execution context.</span>
   56 |     | <span class='neutral'>        Test,</span>
   57 |     | <span class='neutral'>        // `forge coverage` execution context.</span>
   58 |     | <span class='neutral'>        Coverage,</span>
   59 |     | <span class='neutral'>        // `forge snapshot` execution context.</span>
   60 |     | <span class='neutral'>        Snapshot,</span>
   61 |     | <span class='neutral'>        // Script group execution context (dry run, broadcast or resume).</span>
   62 |     | <span class='neutral'>        ScriptGroup,</span>
   63 |     | <span class='neutral'>        // `forge script` execution context.</span>
   64 |     | <span class='neutral'>        ScriptDryRun,</span>
   65 |     | <span class='neutral'>        // `forge script --broadcast` execution context.</span>
   66 |     | <span class='neutral'>        ScriptBroadcast,</span>
   67 |     | <span class='neutral'>        // `forge script --resume` execution context.</span>
   68 |     | <span class='neutral'>        ScriptResume,</span>
   69 |     | <span class='neutral'>        // Unknown `forge` execution context.</span>
   70 |     | <span class='neutral'>        Unknown</span>
   71 |     | <span class='neutral'>    }</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>    /// The transaction type (`txType`) of the broadcast.</span>
   74 |     | <span class='neutral'>    enum BroadcastTxType {</span>
   75 |     | <span class='neutral'>        // Represents a CALL broadcast tx.</span>
   76 |     | <span class='neutral'>        Call,</span>
   77 |     | <span class='neutral'>        // Represents a CREATE broadcast tx.</span>
   78 |     | <span class='neutral'>        Create,</span>
   79 |     | <span class='neutral'>        // Represents a CREATE2 broadcast tx.</span>
   80 |     | <span class='neutral'>        Create2</span>
   81 |     | <span class='neutral'>    }</span>
   82 |     | <span class='neutral'></span>
   83 |     | <span class='neutral'>    /// An Ethereum log. Returned by `getRecordedLogs`.</span>
   84 |     | <span class='neutral'>    struct Log {</span>
   85 |     | <span class='neutral'>        // The topics of the log, including the signature, if any.</span>
   86 |     | <span class='neutral'>        bytes32[] topics;</span>
   87 |     | <span class='neutral'>        // The raw data of the log.</span>
   88 |     | <span class='neutral'>        bytes data;</span>
   89 |     | <span class='neutral'>        // The address of the log&#39;s emitter.</span>
   90 |     | <span class='neutral'>        address emitter;</span>
   91 |     | <span class='neutral'>    }</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'>    /// An RPC URL and its alias. Returned by `rpcUrlStructs`.</span>
   94 |     | <span class='neutral'>    struct Rpc {</span>
   95 |     | <span class='neutral'>        // The alias of the RPC URL.</span>
   96 |     | <span class='neutral'>        string key;</span>
   97 |     | <span class='neutral'>        // The RPC URL.</span>
   98 |     | <span class='neutral'>        string url;</span>
   99 |     | <span class='neutral'>    }</span>
  100 |     | <span class='neutral'></span>
  101 |     | <span class='neutral'>    /// An RPC log object. Returned by `eth_getLogs`.</span>
  102 |     | <span class='neutral'>    struct EthGetLogs {</span>
  103 |     | <span class='neutral'>        // The address of the log&#39;s emitter.</span>
  104 |     | <span class='neutral'>        address emitter;</span>
  105 |     | <span class='neutral'>        // The topics of the log, including the signature, if any.</span>
  106 |     | <span class='neutral'>        bytes32[] topics;</span>
  107 |     | <span class='neutral'>        // The raw data of the log.</span>
  108 |     | <span class='neutral'>        bytes data;</span>
  109 |     | <span class='neutral'>        // The block hash.</span>
  110 |     | <span class='neutral'>        bytes32 blockHash;</span>
  111 |     | <span class='neutral'>        // The block number.</span>
  112 |     | <span class='neutral'>        uint64 blockNumber;</span>
  113 |     | <span class='neutral'>        // The transaction hash.</span>
  114 |     | <span class='neutral'>        bytes32 transactionHash;</span>
  115 |     | <span class='neutral'>        // The transaction index in the block.</span>
  116 |     | <span class='neutral'>        uint64 transactionIndex;</span>
  117 |     | <span class='neutral'>        // The log index.</span>
  118 |     | <span class='neutral'>        uint256 logIndex;</span>
  119 |     | <span class='neutral'>        // Whether the log was removed.</span>
  120 |     | <span class='neutral'>        bool removed;</span>
  121 |     | <span class='neutral'>    }</span>
  122 |     | <span class='neutral'></span>
  123 |     | <span class='neutral'>    /// A single entry in a directory listing. Returned by `readDir`.</span>
  124 |     | <span class='neutral'>    struct DirEntry {</span>
  125 |     | <span class='neutral'>        // The error message, if any.</span>
  126 |     | <span class='neutral'>        string errorMessage;</span>
  127 |     | <span class='neutral'>        // The path of the entry.</span>
  128 |     | <span class='neutral'>        string path;</span>
  129 |     | <span class='neutral'>        // The depth of the entry.</span>
  130 |     | <span class='neutral'>        uint64 depth;</span>
  131 |     | <span class='neutral'>        // Whether the entry is a directory.</span>
  132 |     | <span class='neutral'>        bool isDir;</span>
  133 |     | <span class='neutral'>        // Whether the entry is a symlink.</span>
  134 |     | <span class='neutral'>        bool isSymlink;</span>
  135 |     | <span class='neutral'>    }</span>
  136 |     | <span class='neutral'></span>
  137 |     | <span class='neutral'>    /// Metadata information about a file.</span>
  138 |     | <span class='neutral'>    /// This structure is returned from the `fsMetadata` function and represents known</span>
  139 |     | <span class='neutral'>    /// metadata about a file such as its permissions, size, modification</span>
  140 |     | <span class='neutral'>    /// times, etc.</span>
  141 |     | <span class='neutral'>    struct FsMetadata {</span>
  142 |     | <span class='neutral'>        // True if this metadata is for a directory.</span>
  143 |     | <span class='neutral'>        bool isDir;</span>
  144 |     | <span class='neutral'>        // True if this metadata is for a symlink.</span>
  145 |     | <span class='neutral'>        bool isSymlink;</span>
  146 |     | <span class='neutral'>        // The size of the file, in bytes, this metadata is for.</span>
  147 |     | <span class='neutral'>        uint256 length;</span>
  148 |     | <span class='neutral'>        // True if this metadata is for a readonly (unwritable) file.</span>
  149 |     | <span class='neutral'>        bool readOnly;</span>
  150 |     | <span class='neutral'>        // The last modification time listed in this metadata.</span>
  151 |     | <span class='neutral'>        uint256 modified;</span>
  152 |     | <span class='neutral'>        // The last access time of this metadata.</span>
  153 |     | <span class='neutral'>        uint256 accessed;</span>
  154 |     | <span class='neutral'>        // The creation time listed in this metadata.</span>
  155 |     | <span class='neutral'>        uint256 created;</span>
  156 |     | <span class='neutral'>    }</span>
  157 |     | <span class='neutral'></span>
  158 |     | <span class='neutral'>    /// A wallet with a public and private key.</span>
  159 |     | <span class='neutral'>    struct Wallet {</span>
  160 |     | <span class='neutral'>        // The wallet&#39;s address.</span>
  161 |     | <span class='neutral'>        address addr;</span>
  162 |     | <span class='neutral'>        // The wallet&#39;s public key `X`.</span>
  163 |     | <span class='neutral'>        uint256 publicKeyX;</span>
  164 |     | <span class='neutral'>        // The wallet&#39;s public key `Y`.</span>
  165 |     | <span class='neutral'>        uint256 publicKeyY;</span>
  166 |     | <span class='neutral'>        // The wallet&#39;s private key.</span>
  167 |     | <span class='neutral'>        uint256 privateKey;</span>
  168 |     | <span class='neutral'>    }</span>
  169 |     | <span class='neutral'></span>
  170 |     | <span class='neutral'>    /// The result of a `tryFfi` call.</span>
  171 |     | <span class='neutral'>    struct FfiResult {</span>
  172 |     | <span class='neutral'>        // The exit code of the call.</span>
  173 |     | <span class='neutral'>        int32 exitCode;</span>
  174 |     | <span class='neutral'>        // The optionally hex-decoded `stdout` data.</span>
  175 |     | <span class='neutral'>        bytes stdout;</span>
  176 |     | <span class='neutral'>        // The `stderr` data.</span>
  177 |     | <span class='neutral'>        bytes stderr;</span>
  178 |     | <span class='neutral'>    }</span>
  179 |     | <span class='neutral'></span>
  180 |     | <span class='neutral'>    /// Information on the chain and fork.</span>
  181 |     | <span class='neutral'>    struct ChainInfo {</span>
  182 |     | <span class='neutral'>        // The fork identifier. Set to zero if no fork is active.</span>
  183 |     | <span class='neutral'>        uint256 forkId;</span>
  184 |     | <span class='neutral'>        // The chain ID of the current fork.</span>
  185 |     | <span class='neutral'>        uint256 chainId;</span>
  186 |     | <span class='neutral'>    }</span>
  187 |     | <span class='neutral'></span>
  188 |     | <span class='neutral'>    /// The result of a `stopAndReturnStateDiff` call.</span>
  189 |     | <span class='neutral'>    struct AccountAccess {</span>
  190 |     | <span class='neutral'>        // The chain and fork the access occurred.</span>
  191 |     | <span class='neutral'>        ChainInfo chainInfo;</span>
  192 |     | <span class='neutral'>        // The kind of account access that determines what the account is.</span>
  193 |     | <span class='neutral'>        // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.</span>
  194 |     | <span class='neutral'>        // If kind is Create, then the account is the newly created account.</span>
  195 |     | <span class='neutral'>        // If kind is SelfDestruct, then the account is the selfdestruct recipient.</span>
  196 |     | <span class='neutral'>        // If kind is a Resume, then account represents a account context that has resumed.</span>
  197 |     | <span class='neutral'>        AccountAccessKind kind;</span>
  198 |     | <span class='neutral'>        // The account that was accessed.</span>
  199 |     | <span class='neutral'>        // It&#39;s either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.</span>
  200 |     | <span class='neutral'>        address account;</span>
  201 |     | <span class='neutral'>        // What accessed the account.</span>
  202 |     | <span class='neutral'>        address accessor;</span>
  203 |     | <span class='neutral'>        // If the account was initialized or empty prior to the access.</span>
  204 |     | <span class='neutral'>        // An account is considered initialized if it has code, a</span>
  205 |     | <span class='neutral'>        // non-zero nonce, or a non-zero balance.</span>
  206 |     | <span class='neutral'>        bool initialized;</span>
  207 |     | <span class='neutral'>        // The previous balance of the accessed account.</span>
  208 |     | <span class='neutral'>        uint256 oldBalance;</span>
  209 |     | <span class='neutral'>        // The potential new balance of the accessed account.</span>
  210 |     | <span class='neutral'>        // That is, all balance changes are recorded here, even if reverts occurred.</span>
  211 |     | <span class='neutral'>        uint256 newBalance;</span>
  212 |     | <span class='neutral'>        // Code of the account deployed by CREATE.</span>
  213 |     | <span class='neutral'>        bytes deployedCode;</span>
  214 |     | <span class='neutral'>        // Value passed along with the account access</span>
  215 |     | <span class='neutral'>        uint256 value;</span>
  216 |     | <span class='neutral'>        // Input data provided to the CREATE or CALL</span>
  217 |     | <span class='neutral'>        bytes data;</span>
  218 |     | <span class='neutral'>        // If this access reverted in either the current or parent context.</span>
  219 |     | <span class='neutral'>        bool reverted;</span>
  220 |     | <span class='neutral'>        // An ordered list of storage accesses made during an account access operation.</span>
  221 |     | <span class='neutral'>        StorageAccess[] storageAccesses;</span>
  222 |     | <span class='neutral'>        // Call depth traversed during the recording of state differences</span>
  223 |     | <span class='neutral'>        uint64 depth;</span>
  224 |     | <span class='neutral'>    }</span>
  225 |     | <span class='neutral'></span>
  226 |     | <span class='neutral'>    /// The storage accessed during an `AccountAccess`.</span>
  227 |     | <span class='neutral'>    struct StorageAccess {</span>
  228 |     | <span class='neutral'>        // The account whose storage was accessed.</span>
  229 |     | <span class='neutral'>        address account;</span>
  230 |     | <span class='neutral'>        // The slot that was accessed.</span>
  231 |     | <span class='neutral'>        bytes32 slot;</span>
  232 |     | <span class='neutral'>        // If the access was a write.</span>
  233 |     | <span class='neutral'>        bool isWrite;</span>
  234 |     | <span class='neutral'>        // The previous value of the slot.</span>
  235 |     | <span class='neutral'>        bytes32 previousValue;</span>
  236 |     | <span class='neutral'>        // The new value of the slot.</span>
  237 |     | <span class='neutral'>        bytes32 newValue;</span>
  238 |     | <span class='neutral'>        // If the access was reverted.</span>
  239 |     | <span class='neutral'>        bool reverted;</span>
  240 |     | <span class='neutral'>    }</span>
  241 |     | <span class='neutral'></span>
  242 |     | <span class='neutral'>    /// Gas used. Returned by `lastCallGas`.</span>
  243 |     | <span class='neutral'>    struct Gas {</span>
  244 |     | <span class='neutral'>        // The gas limit of the call.</span>
  245 |     | <span class='neutral'>        uint64 gasLimit;</span>
  246 |     | <span class='neutral'>        // The total gas used.</span>
  247 |     | <span class='neutral'>        uint64 gasTotalUsed;</span>
  248 |     | <span class='neutral'>        // DEPRECATED: The amount of gas used for memory expansion. Ref: &lt;https://github.com/foundry-rs/foundry/pull/7934#pullrequestreview-2069236939&gt;</span>
  249 |     | <span class='neutral'>        uint64 gasMemoryUsed;</span>
  250 |     | <span class='neutral'>        // The amount of gas refunded.</span>
  251 |     | <span class='neutral'>        int64 gasRefunded;</span>
  252 |     | <span class='neutral'>        // The amount of gas remaining.</span>
  253 |     | <span class='neutral'>        uint64 gasRemaining;</span>
  254 |     | <span class='neutral'>    }</span>
  255 |     | <span class='neutral'></span>
  256 |     | <span class='neutral'>    /// The result of the `stopDebugTraceRecording` call</span>
  257 |     | <span class='neutral'>    struct DebugStep {</span>
  258 |     | <span class='neutral'>        // The stack before executing the step of the run.</span>
  259 |     | <span class='neutral'>        // stack\[0\] represents the top of the stack.</span>
  260 |     | <span class='neutral'>        // and only stack data relevant to the opcode execution is contained.</span>
  261 |     | <span class='neutral'>        uint256[] stack;</span>
  262 |     | <span class='neutral'>        // The memory input data before executing the step of the run.</span>
  263 |     | <span class='neutral'>        // only input data relevant to the opcode execution is contained.</span>
  264 |     | <span class='neutral'>        // e.g. for MLOAD, it will have memory\[offset:offset+32\] copied here.</span>
  265 |     | <span class='neutral'>        // the offset value can be get by the stack data.</span>
  266 |     | <span class='neutral'>        bytes memoryInput;</span>
  267 |     | <span class='neutral'>        // The opcode that was accessed.</span>
  268 |     | <span class='neutral'>        uint8 opcode;</span>
  269 |     | <span class='neutral'>        // The call depth of the step.</span>
  270 |     | <span class='neutral'>        uint64 depth;</span>
  271 |     | <span class='neutral'>        // Whether the call end up with out of gas error.</span>
  272 |     | <span class='neutral'>        bool isOutOfGas;</span>
  273 |     | <span class='neutral'>        // The contract address where the opcode is running</span>
  274 |     | <span class='neutral'>        address contractAddr;</span>
  275 |     | <span class='neutral'>    }</span>
  276 |     | <span class='neutral'></span>
  277 |     | <span class='neutral'>    /// Represents a transaction&#39;s broadcast details.</span>
  278 |     | <span class='neutral'>    struct BroadcastTxSummary {</span>
  279 |     | <span class='neutral'>        // The hash of the transaction that was broadcasted</span>
  280 |     | <span class='neutral'>        bytes32 txHash;</span>
  281 |     | <span class='neutral'>        // Represent the type of transaction among CALL, CREATE, CREATE2</span>
  282 |     | <span class='neutral'>        BroadcastTxType txType;</span>
  283 |     | <span class='neutral'>        // The address of the contract that was called or created.</span>
  284 |     | <span class='neutral'>        // This is address of the contract that is created if the txType is CREATE or CREATE2.</span>
  285 |     | <span class='neutral'>        address contractAddress;</span>
  286 |     | <span class='neutral'>        // The block number the transaction landed in.</span>
  287 |     | <span class='neutral'>        uint64 blockNumber;</span>
  288 |     | <span class='neutral'>        // Status of the transaction, retrieved from the transaction receipt.</span>
  289 |     | <span class='neutral'>        bool success;</span>
  290 |     | <span class='neutral'>    }</span>
  291 |     | <span class='neutral'></span>
  292 |     | <span class='neutral'>    /// Holds a signed EIP-7702 authorization for an authority account to delegate to an implementation.</span>
  293 |     | <span class='neutral'>    struct SignedDelegation {</span>
  294 |     | <span class='neutral'>        // The y-parity of the recovered secp256k1 signature (0 or 1).</span>
  295 |     | <span class='neutral'>        uint8 v;</span>
  296 |     | <span class='neutral'>        // First 32 bytes of the signature.</span>
  297 |     | <span class='neutral'>        bytes32 r;</span>
  298 |     | <span class='neutral'>        // Second 32 bytes of the signature.</span>
  299 |     | <span class='neutral'>        bytes32 s;</span>
  300 |     | <span class='neutral'>        // The current nonce of the authority account at signing time.</span>
  301 |     | <span class='neutral'>        // Used to ensure signature can&#39;t be replayed after account nonce changes.</span>
  302 |     | <span class='neutral'>        uint64 nonce;</span>
  303 |     | <span class='neutral'>        // Address of the contract implementation that will be delegated to.</span>
  304 |     | <span class='neutral'>        // Gets encoded into delegation code: 0xef0100 || implementation.</span>
  305 |     | <span class='neutral'>        address implementation;</span>
  306 |     | <span class='neutral'>    }</span>
  307 |     | <span class='neutral'></span>
  308 |     | <span class='neutral'>    // ======== Crypto ========</span>
  309 |     | <span class='neutral'></span>
  310 |     | <span class='neutral'>    /// Derives a private key from the name, labels the account with that name, and returns the wallet.</span>
  311 |     | <span class='neutral'>    function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);</span>
  312 |     | <span class='neutral'></span>
  313 |     | <span class='neutral'>    /// Generates a wallet from the private key and returns the wallet.</span>
  314 |     | <span class='neutral'>    function createWallet(uint256 privateKey) external returns (Wallet memory wallet);</span>
  315 |     | <span class='neutral'></span>
  316 |     | <span class='neutral'>    /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.</span>
  317 |     | <span class='neutral'>    function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);</span>
  318 |     | <span class='neutral'></span>
  319 |     | <span class='neutral'>    /// Derive a private key from a provided mnenomic string (or mnenomic file path)</span>
  320 |     | <span class='neutral'>    /// at the derivation path `m/44&#39;/60&#39;/0&#39;/0/{index}`.</span>
  321 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);</span>
  322 |     | <span class='neutral'></span>
  323 |     | <span class='neutral'>    /// Derive a private key from a provided mnenomic string (or mnenomic file path)</span>
  324 |     | <span class='neutral'>    /// at `{derivationPath}{index}`.</span>
  325 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)</span>
  326 |     | <span class='neutral'>        external</span>
  327 |     | <span class='neutral'>        pure</span>
  328 |     | <span class='neutral'>        returns (uint256 privateKey);</span>
  329 |     | <span class='neutral'></span>
  330 |     | <span class='neutral'>    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language</span>
  331 |     | <span class='neutral'>    /// at the derivation path `m/44&#39;/60&#39;/0&#39;/0/{index}`.</span>
  332 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, uint32 index, string calldata language)</span>
  333 |     | <span class='neutral'>        external</span>
  334 |     | <span class='neutral'>        pure</span>
  335 |     | <span class='neutral'>        returns (uint256 privateKey);</span>
  336 |     | <span class='neutral'></span>
  337 |     | <span class='neutral'>    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language</span>
  338 |     | <span class='neutral'>    /// at `{derivationPath}{index}`.</span>
  339 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index, string calldata language)</span>
  340 |     | <span class='neutral'>        external</span>
  341 |     | <span class='neutral'>        pure</span>
  342 |     | <span class='neutral'>        returns (uint256 privateKey);</span>
  343 |     | <span class='neutral'></span>
  344 |     | <span class='neutral'>    /// Derives secp256r1 public key from the provided `privateKey`.</span>
  345 |     | <span class='neutral'>    function publicKeyP256(uint256 privateKey) external pure returns (uint256 publicKeyX, uint256 publicKeyY);</span>
  346 |     | <span class='neutral'></span>
  347 |     | <span class='neutral'>    /// Adds a private key to the local forge wallet and returns the address.</span>
  348 |     | <span class='neutral'>    function rememberKey(uint256 privateKey) external returns (address keyAddr);</span>
  349 |     | <span class='neutral'></span>
  350 |     | <span class='neutral'>    /// Derive a set number of wallets from a mnemonic at the derivation path `m/44&#39;/60&#39;/0&#39;/0/{0..count}`.</span>
  351 |     | <span class='neutral'>    /// The respective private keys are saved to the local forge wallet for later use and their addresses are returned.</span>
  352 |     | <span class='neutral'>    function rememberKeys(string calldata mnemonic, string calldata derivationPath, uint32 count)</span>
  353 |     | <span class='neutral'>        external</span>
  354 |     | <span class='neutral'>        returns (address[] memory keyAddrs);</span>
  355 |     | <span class='neutral'></span>
  356 |     | <span class='neutral'>    /// Derive a set number of wallets from a mnemonic in the specified language at the derivation path `m/44&#39;/60&#39;/0&#39;/0/{0..count}`.</span>
  357 |     | <span class='neutral'>    /// The respective private keys are saved to the local forge wallet for later use and their addresses are returned.</span>
  358 |     | <span class='neutral'>    function rememberKeys(</span>
  359 |     | <span class='neutral'>        string calldata mnemonic,</span>
  360 |     | <span class='neutral'>        string calldata derivationPath,</span>
  361 |     | <span class='neutral'>        string calldata language,</span>
  362 |     | <span class='neutral'>        uint32 count</span>
  363 |     | <span class='neutral'>    ) external returns (address[] memory keyAddrs);</span>
  364 |     | <span class='neutral'></span>
  365 |     | <span class='neutral'>    /// Signs data with a `Wallet`.</span>
  366 |     | <span class='neutral'>    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the</span>
  367 |     | <span class='neutral'>    /// signature&#39;s `s` value, and the recovery id `v` in a single bytes32.</span>
  368 |     | <span class='neutral'>    /// This format reduces the signature size from 65 to 64 bytes.</span>
  369 |     | <span class='neutral'>    function signCompact(Wallet calldata wallet, bytes32 digest) external returns (bytes32 r, bytes32 vs);</span>
  370 |     | <span class='neutral'></span>
  371 |     | <span class='neutral'>    /// Signs `digest` with `privateKey` using the secp256k1 curve.</span>
  372 |     | <span class='neutral'>    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the</span>
  373 |     | <span class='neutral'>    /// signature&#39;s `s` value, and the recovery id `v` in a single bytes32.</span>
  374 |     | <span class='neutral'>    /// This format reduces the signature size from 65 to 64 bytes.</span>
  375 |     | <span class='neutral'>    function signCompact(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);</span>
  376 |     | <span class='neutral'></span>
  377 |     | <span class='neutral'>    /// Signs `digest` with signer provided to script using the secp256k1 curve.</span>
  378 |     | <span class='neutral'>    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the</span>
  379 |     | <span class='neutral'>    /// signature&#39;s `s` value, and the recovery id `v` in a single bytes32.</span>
  380 |     | <span class='neutral'>    /// This format reduces the signature size from 65 to 64 bytes.</span>
  381 |     | <span class='neutral'>    /// If `--sender` is provided, the signer with provided address is used, otherwise,</span>
  382 |     | <span class='neutral'>    /// if exactly one signer is provided to the script, that signer is used.</span>
  383 |     | <span class='neutral'>    /// Raises error if signer passed through `--sender` does not match any unlocked signers or</span>
  384 |     | <span class='neutral'>    /// if `--sender` is not provided and not exactly one signer is passed to the script.</span>
  385 |     | <span class='neutral'>    function signCompact(bytes32 digest) external pure returns (bytes32 r, bytes32 vs);</span>
  386 |     | <span class='neutral'></span>
  387 |     | <span class='neutral'>    /// Signs `digest` with signer provided to script using the secp256k1 curve.</span>
  388 |     | <span class='neutral'>    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the</span>
  389 |     | <span class='neutral'>    /// signature&#39;s `s` value, and the recovery id `v` in a single bytes32.</span>
  390 |     | <span class='neutral'>    /// This format reduces the signature size from 65 to 64 bytes.</span>
  391 |     | <span class='neutral'>    /// Raises error if none of the signers passed into the script have provided address.</span>
  392 |     | <span class='neutral'>    function signCompact(address signer, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);</span>
  393 |     | <span class='neutral'></span>
  394 |     | <span class='neutral'>    /// Signs `digest` with `privateKey` using the secp256r1 curve.</span>
  395 |     | <span class='neutral'>    function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='neutral'>    /// Signs data with a `Wallet`.</span>
  398 |     | <span class='neutral'>    function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);</span>
  399 |     | <span class='neutral'></span>
  400 |     | <span class='neutral'>    /// Signs `digest` with `privateKey` using the secp256k1 curve.</span>
  401 |     | <span class='neutral'>    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);</span>
  402 |     | <span class='neutral'></span>
  403 |     | <span class='neutral'>    /// Signs `digest` with signer provided to script using the secp256k1 curve.</span>
  404 |     | <span class='neutral'>    /// If `--sender` is provided, the signer with provided address is used, otherwise,</span>
  405 |     | <span class='neutral'>    /// if exactly one signer is provided to the script, that signer is used.</span>
  406 |     | <span class='neutral'>    /// Raises error if signer passed through `--sender` does not match any unlocked signers or</span>
  407 |     | <span class='neutral'>    /// if `--sender` is not provided and not exactly one signer is passed to the script.</span>
  408 |     | <span class='neutral'>    function sign(bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);</span>
  409 |     | <span class='neutral'></span>
  410 |     | <span class='neutral'>    /// Signs `digest` with signer provided to script using the secp256k1 curve.</span>
  411 |     | <span class='neutral'>    /// Raises error if none of the signers passed into the script have provided address.</span>
  412 |     | <span class='neutral'>    function sign(address signer, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);</span>
  413 |     | <span class='neutral'></span>
  414 |     | <span class='neutral'>    // ======== Environment ========</span>
  415 |     | <span class='neutral'></span>
  416 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `address`.</span>
  417 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  418 |     | <span class='neutral'>    function envAddress(string calldata name) external view returns (address value);</span>
  419 |     | <span class='neutral'></span>
  420 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.</span>
  421 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  422 |     | <span class='neutral'>    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);</span>
  423 |     | <span class='neutral'></span>
  424 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bool`.</span>
  425 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  426 |     | <span class='neutral'>    function envBool(string calldata name) external view returns (bool value);</span>
  427 |     | <span class='neutral'></span>
  428 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.</span>
  429 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  430 |     | <span class='neutral'>    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);</span>
  431 |     | <span class='neutral'></span>
  432 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bytes32`.</span>
  433 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  434 |     | <span class='neutral'>    function envBytes32(string calldata name) external view returns (bytes32 value);</span>
  435 |     | <span class='neutral'></span>
  436 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.</span>
  437 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  438 |     | <span class='neutral'>    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);</span>
  439 |     | <span class='neutral'></span>
  440 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bytes`.</span>
  441 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  442 |     | <span class='neutral'>    function envBytes(string calldata name) external view returns (bytes memory value);</span>
  443 |     | <span class='neutral'></span>
  444 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.</span>
  445 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  446 |     | <span class='neutral'>    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);</span>
  447 |     | <span class='neutral'></span>
  448 |     | <span class='neutral'>    /// Gets the environment variable `name` and returns true if it exists, else returns false.</span>
  449 |     | <span class='neutral'>    function envExists(string calldata name) external view returns (bool result);</span>
  450 |     | <span class='neutral'></span>
  451 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `int256`.</span>
  452 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  453 |     | <span class='neutral'>    function envInt(string calldata name) external view returns (int256 value);</span>
  454 |     | <span class='neutral'></span>
  455 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.</span>
  456 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  457 |     | <span class='neutral'>    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);</span>
  458 |     | <span class='neutral'></span>
  459 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bool`.</span>
  460 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  461 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  462 |     | <span class='neutral'>    function envOr(string calldata name, bool defaultValue) external view returns (bool value);</span>
  463 |     | <span class='neutral'></span>
  464 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `uint256`.</span>
  465 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  466 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  467 |     | <span class='neutral'>    function envOr(string calldata name, uint256 defaultValue) external view returns (uint256 value);</span>
  468 |     | <span class='neutral'></span>
  469 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.</span>
  470 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  471 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  472 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)</span>
  473 |     | <span class='neutral'>        external</span>
  474 |     | <span class='neutral'>        view</span>
  475 |     | <span class='neutral'>        returns (address[] memory value);</span>
  476 |     | <span class='neutral'></span>
  477 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.</span>
  478 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  479 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  480 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)</span>
  481 |     | <span class='neutral'>        external</span>
  482 |     | <span class='neutral'>        view</span>
  483 |     | <span class='neutral'>        returns (bytes32[] memory value);</span>
  484 |     | <span class='neutral'></span>
  485 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.</span>
  486 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  487 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  488 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)</span>
  489 |     | <span class='neutral'>        external</span>
  490 |     | <span class='neutral'>        view</span>
  491 |     | <span class='neutral'>        returns (string[] memory value);</span>
  492 |     | <span class='neutral'></span>
  493 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.</span>
  494 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  495 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  496 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)</span>
  497 |     | <span class='neutral'>        external</span>
  498 |     | <span class='neutral'>        view</span>
  499 |     | <span class='neutral'>        returns (bytes[] memory value);</span>
  500 |     | <span class='neutral'></span>
  501 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `int256`.</span>
  502 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  503 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  504 |     | <span class='neutral'>    function envOr(string calldata name, int256 defaultValue) external view returns (int256 value);</span>
  505 |     | <span class='neutral'></span>
  506 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `address`.</span>
  507 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  508 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  509 |     | <span class='neutral'>    function envOr(string calldata name, address defaultValue) external view returns (address value);</span>
  510 |     | <span class='neutral'></span>
  511 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bytes32`.</span>
  512 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  513 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  514 |     | <span class='neutral'>    function envOr(string calldata name, bytes32 defaultValue) external view returns (bytes32 value);</span>
  515 |     | <span class='neutral'></span>
  516 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `string`.</span>
  517 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  518 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  519 |     | <span class='neutral'>    function envOr(string calldata name, string calldata defaultValue) external view returns (string memory value);</span>
  520 |     | <span class='neutral'></span>
  521 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bytes`.</span>
  522 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  523 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  524 |     | <span class='neutral'>    function envOr(string calldata name, bytes calldata defaultValue) external view returns (bytes memory value);</span>
  525 |     | <span class='neutral'></span>
  526 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.</span>
  527 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  528 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  529 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)</span>
  530 |     | <span class='neutral'>        external</span>
  531 |     | <span class='neutral'>        view</span>
  532 |     | <span class='neutral'>        returns (bool[] memory value);</span>
  533 |     | <span class='neutral'></span>
  534 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.</span>
  535 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  536 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  537 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)</span>
  538 |     | <span class='neutral'>        external</span>
  539 |     | <span class='neutral'>        view</span>
  540 |     | <span class='neutral'>        returns (uint256[] memory value);</span>
  541 |     | <span class='neutral'></span>
  542 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.</span>
  543 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  544 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  545 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)</span>
  546 |     | <span class='neutral'>        external</span>
  547 |     | <span class='neutral'>        view</span>
  548 |     | <span class='neutral'>        returns (int256[] memory value);</span>
  549 |     | <span class='neutral'></span>
  550 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `string`.</span>
  551 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  552 |     | <span class='neutral'>    function envString(string calldata name) external view returns (string memory value);</span>
  553 |     | <span class='neutral'></span>
  554 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.</span>
  555 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  556 |     | <span class='neutral'>    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);</span>
  557 |     | <span class='neutral'></span>
  558 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `uint256`.</span>
  559 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  560 |     | <span class='neutral'>    function envUint(string calldata name) external view returns (uint256 value);</span>
  561 |     | <span class='neutral'></span>
  562 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.</span>
  563 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  564 |     | <span class='neutral'>    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);</span>
  565 |     | <span class='neutral'></span>
  566 |     | <span class='neutral'>    /// Returns true if `forge` command was executed in given context.</span>
  567 |     | <span class='neutral'>    function isContext(ForgeContext context) external view returns (bool result);</span>
  568 |     | <span class='neutral'></span>
  569 |     | <span class='neutral'>    /// Sets environment variables.</span>
  570 |     | <span class='neutral'>    function setEnv(string calldata name, string calldata value) external;</span>
  571 |     | <span class='neutral'></span>
  572 |     | <span class='neutral'>    // ======== EVM ========</span>
  573 |     | <span class='neutral'></span>
  574 |     | <span class='neutral'>    /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.</span>
  575 |     | <span class='neutral'>    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);</span>
  576 |     | <span class='neutral'></span>
  577 |     | <span class='neutral'>    /// Gets the address for a given private key.</span>
  578 |     | <span class='neutral'>    function addr(uint256 privateKey) external pure returns (address keyAddr);</span>
  579 |     | <span class='neutral'></span>
  580 |     | <span class='neutral'>    /// Gets all the logs according to specified filter.</span>
  581 |     | <span class='neutral'>    function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] calldata topics)</span>
  582 |     | <span class='neutral'>        external</span>
  583 |     | <span class='neutral'>        returns (EthGetLogs[] memory logs);</span>
  584 |     | <span class='neutral'></span>
  585 |     | <span class='neutral'>    /// Gets the current `block.blobbasefee`.</span>
  586 |     | <span class='neutral'>    /// You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction,</span>
  587 |     | <span class='neutral'>    /// and as a result will get optimized out by the compiler.</span>
  588 |     | <span class='neutral'>    /// See https://github.com/foundry-rs/foundry/issues/6180</span>
  589 |     | <span class='neutral'>    function getBlobBaseFee() external view returns (uint256 blobBaseFee);</span>
  590 |     | <span class='neutral'></span>
  591 |     | <span class='neutral'>    /// Gets the current `block.number`.</span>
  592 |     | <span class='neutral'>    /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,</span>
  593 |     | <span class='neutral'>    /// and as a result will get optimized out by the compiler.</span>
  594 |     | <span class='neutral'>    /// See https://github.com/foundry-rs/foundry/issues/6180</span>
  595 |     | <span class='neutral'>    function getBlockNumber() external view returns (uint256 height);</span>
  596 |     | <span class='neutral'></span>
  597 |     | <span class='neutral'>    /// Gets the current `block.timestamp`.</span>
  598 |     | <span class='neutral'>    /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,</span>
  599 |     | <span class='neutral'>    /// and as a result will get optimized out by the compiler.</span>
  600 |     | <span class='neutral'>    /// See https://github.com/foundry-rs/foundry/issues/6180</span>
  601 |     | <span class='neutral'>    function getBlockTimestamp() external view returns (uint256 timestamp);</span>
  602 |     | <span class='neutral'></span>
  603 |     | <span class='neutral'>    /// Gets the map key and parent of a mapping at a given slot, for a given address.</span>
  604 |     | <span class='neutral'>    function getMappingKeyAndParentOf(address target, bytes32 elementSlot)</span>
  605 |     | <span class='neutral'>        external</span>
  606 |     | <span class='neutral'>        returns (bool found, bytes32 key, bytes32 parent);</span>
  607 |     | <span class='neutral'></span>
  608 |     | <span class='neutral'>    /// Gets the number of elements in the mapping at the given slot, for a given address.</span>
  609 |     | <span class='neutral'>    function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);</span>
  610 |     | <span class='neutral'></span>
  611 |     | <span class='neutral'>    /// Gets the elements at index idx of the mapping at the given slot, for a given address. The</span>
  612 |     | <span class='neutral'>    /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).</span>
  613 |     | <span class='neutral'>    function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);</span>
  614 |     | <span class='neutral'></span>
  615 |     | <span class='neutral'>    /// Gets the nonce of an account.</span>
  616 |     | <span class='neutral'>    function getNonce(address account) external view returns (uint64 nonce);</span>
  617 |     | <span class='neutral'></span>
  618 |     | <span class='neutral'>    /// Get the nonce of a `Wallet`.</span>
  619 |     | <span class='neutral'>    function getNonce(Wallet calldata wallet) external returns (uint64 nonce);</span>
  620 |     | <span class='neutral'></span>
  621 |     | <span class='neutral'>    /// Gets all the recorded logs.</span>
  622 |     | <span class='neutral'>    function getRecordedLogs() external returns (Log[] memory logs);</span>
  623 |     | <span class='neutral'></span>
  624 |     | <span class='neutral'>    /// Returns state diffs from current `vm.startStateDiffRecording` session.</span>
  625 |     | <span class='neutral'>    function getStateDiff() external view returns (string memory diff);</span>
  626 |     | <span class='neutral'></span>
  627 |     | <span class='neutral'>    /// Returns state diffs from current `vm.startStateDiffRecording` session, in json format.</span>
  628 |     | <span class='neutral'>    function getStateDiffJson() external view returns (string memory diff);</span>
  629 |     | <span class='neutral'></span>
  630 |     | <span class='neutral'>    /// Gets the gas used in the last call from the callee perspective.</span>
  631 |     | <span class='neutral'>    function lastCallGas() external view returns (Gas memory gas);</span>
  632 |     | <span class='neutral'></span>
  633 |     | <span class='neutral'>    /// Loads a storage slot from an address.</span>
  634 |     | <span class='neutral'>    function load(address target, bytes32 slot) external view returns (bytes32 data);</span>
  635 |     | <span class='neutral'></span>
  636 |     | <span class='neutral'>    /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.</span>
  637 |     | <span class='neutral'>    function pauseGasMetering() external;</span>
  638 |     | <span class='neutral'></span>
  639 |     | <span class='neutral'>    /// Records all storage reads and writes.</span>
  640 |     | <span class='neutral'>    function record() external;</span>
  641 |     | <span class='neutral'></span>
  642 |     | <span class='neutral'>    /// Record all the transaction logs.</span>
  643 |     | <span class='neutral'>    function recordLogs() external;</span>
  644 |     | <span class='neutral'></span>
  645 |     | <span class='neutral'>    /// Reset gas metering (i.e. gas usage is set to gas limit).</span>
  646 |     | <span class='neutral'>    function resetGasMetering() external;</span>
  647 |     | <span class='neutral'></span>
  648 |     | <span class='neutral'>    /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.</span>
  649 |     | <span class='neutral'>    function resumeGasMetering() external;</span>
  650 |     | <span class='neutral'></span>
  651 |     | <span class='neutral'>    /// Performs an Ethereum JSON-RPC request to the current fork URL.</span>
  652 |     | <span class='neutral'>    function rpc(string calldata method, string calldata params) external returns (bytes memory data);</span>
  653 |     | <span class='neutral'></span>
  654 |     | <span class='neutral'>    /// Performs an Ethereum JSON-RPC request to the given endpoint.</span>
  655 |     | <span class='neutral'>    function rpc(string calldata urlOrAlias, string calldata method, string calldata params)</span>
  656 |     | <span class='neutral'>        external</span>
  657 |     | <span class='neutral'>        returns (bytes memory data);</span>
  658 |     | <span class='neutral'></span>
  659 |     | <span class='neutral'>    /// Records the debug trace during the run.</span>
  660 |     | <span class='neutral'>    function startDebugTraceRecording() external;</span>
  661 |     | <span class='neutral'></span>
  662 |     | <span class='neutral'>    /// Starts recording all map SSTOREs for later retrieval.</span>
  663 |     | <span class='neutral'>    function startMappingRecording() external;</span>
  664 |     | <span class='neutral'></span>
  665 |     | <span class='neutral'>    /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,</span>
  666 |     | <span class='neutral'>    /// along with the context of the calls</span>
  667 |     | <span class='neutral'>    function startStateDiffRecording() external;</span>
  668 |     | <span class='neutral'></span>
  669 |     | <span class='neutral'>    /// Stop debug trace recording and returns the recorded debug trace.</span>
  670 |     | <span class='neutral'>    function stopAndReturnDebugTraceRecording() external returns (DebugStep[] memory step);</span>
  671 |     | <span class='neutral'></span>
  672 |     | <span class='neutral'>    /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.</span>
  673 |     | <span class='neutral'>    function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);</span>
  674 |     | <span class='neutral'></span>
  675 |     | <span class='neutral'>    /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.</span>
  676 |     | <span class='neutral'>    function stopMappingRecording() external;</span>
  677 |     | <span class='neutral'></span>
  678 |     | <span class='neutral'>    // ======== Filesystem ========</span>
  679 |     | <span class='neutral'></span>
  680 |     | <span class='neutral'>    /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.</span>
  681 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  682 |     | <span class='neutral'>    function closeFile(string calldata path) external;</span>
  683 |     | <span class='neutral'></span>
  684 |     | <span class='neutral'>    /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.</span>
  685 |     | <span class='neutral'>    /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.</span>
  686 |     | <span class='neutral'>    /// Both `from` and `to` are relative to the project root.</span>
  687 |     | <span class='neutral'>    function copyFile(string calldata from, string calldata to) external returns (uint64 copied);</span>
  688 |     | <span class='neutral'></span>
  689 |     | <span class='neutral'>    /// Creates a new, empty directory at the provided path.</span>
  690 |     | <span class='neutral'>    /// This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  691 |     | <span class='neutral'>    /// - User lacks permissions to modify `path`.</span>
  692 |     | <span class='neutral'>    /// - A parent of the given path doesn&#39;t exist and `recursive` is false.</span>
  693 |     | <span class='neutral'>    /// - `path` already exists and `recursive` is false.</span>
  694 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  695 |     | <span class='neutral'>    function createDir(string calldata path, bool recursive) external;</span>
  696 |     | <span class='neutral'></span>
  697 |     | <span class='neutral'>    /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the</span>
  698 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  699 |     | <span class='neutral'>    function deployCode(string calldata artifactPath) external returns (address deployedAddress);</span>
  700 |     | <span class='neutral'></span>
  701 |     | <span class='neutral'>    /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the</span>
  702 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  703 |     | <span class='neutral'>    /// Additionally accepts abi-encoded constructor arguments.</span>
  704 |     | <span class='neutral'>    function deployCode(string calldata artifactPath, bytes calldata constructorArgs)</span>
  705 |     | <span class='neutral'>        external</span>
  706 |     | <span class='neutral'>        returns (address deployedAddress);</span>
  707 |     | <span class='neutral'></span>
  708 |     | <span class='neutral'>    /// Returns true if the given path points to an existing entity, else returns false.</span>
  709 |     | <span class='neutral'>    function exists(string calldata path) external view returns (bool result);</span>
  710 |     | <span class='neutral'></span>
  711 |     | <span class='neutral'>    /// Performs a foreign function call via the terminal.</span>
  712 |     | <span class='neutral'>    function ffi(string[] calldata commandInput) external returns (bytes memory result);</span>
  713 |     | <span class='neutral'></span>
  714 |     | <span class='neutral'>    /// Given a path, query the file system to get information about a file, directory, etc.</span>
  715 |     | <span class='neutral'>    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);</span>
  716 |     | <span class='neutral'></span>
  717 |     | <span class='neutral'>    /// Gets the artifact path from code (aka. creation code).</span>
  718 |     | <span class='neutral'>    function getArtifactPathByCode(bytes calldata code) external view returns (string memory path);</span>
  719 |     | <span class='neutral'></span>
  720 |     | <span class='neutral'>    /// Gets the artifact path from deployed code (aka. runtime code).</span>
  721 |     | <span class='neutral'>    function getArtifactPathByDeployedCode(bytes calldata deployedCode) external view returns (string memory path);</span>
  722 |     | <span class='neutral'></span>
  723 |     | <span class='neutral'>    /// Returns the most recent broadcast for the given contract on `chainId` matching `txType`.</span>
  724 |     | <span class='neutral'>    /// For example:</span>
  725 |     | <span class='neutral'>    /// The most recent deployment can be fetched by passing `txType` as `CREATE` or `CREATE2`.</span>
  726 |     | <span class='neutral'>    /// The most recent call can be fetched by passing `txType` as `CALL`.</span>
  727 |     | <span class='neutral'>    function getBroadcast(string calldata contractName, uint64 chainId, BroadcastTxType txType)</span>
  728 |     | <span class='neutral'>        external</span>
  729 |     | <span class='neutral'>        view</span>
  730 |     | <span class='neutral'>        returns (BroadcastTxSummary memory);</span>
  731 |     | <span class='neutral'></span>
  732 |     | <span class='neutral'>    /// Returns all broadcasts for the given contract on `chainId` with the specified `txType`.</span>
  733 |     | <span class='neutral'>    /// Sorted such that the most recent broadcast is the first element, and the oldest is the last. i.e descending order of BroadcastTxSummary.blockNumber.</span>
  734 |     | <span class='neutral'>    function getBroadcasts(string calldata contractName, uint64 chainId, BroadcastTxType txType)</span>
  735 |     | <span class='neutral'>        external</span>
  736 |     | <span class='neutral'>        view</span>
  737 |     | <span class='neutral'>        returns (BroadcastTxSummary[] memory);</span>
  738 |     | <span class='neutral'></span>
  739 |     | <span class='neutral'>    /// Returns all broadcasts for the given contract on `chainId`.</span>
  740 |     | <span class='neutral'>    /// Sorted such that the most recent broadcast is the first element, and the oldest is the last. i.e descending order of BroadcastTxSummary.blockNumber.</span>
  741 |     | <span class='neutral'>    function getBroadcasts(string calldata contractName, uint64 chainId)</span>
  742 |     | <span class='neutral'>        external</span>
  743 |     | <span class='neutral'>        view</span>
  744 |     | <span class='neutral'>        returns (BroadcastTxSummary[] memory);</span>
  745 |     | <span class='neutral'></span>
  746 |     | <span class='neutral'>    /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the</span>
  747 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  748 |     | <span class='neutral'>    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);</span>
  749 |     | <span class='neutral'></span>
  750 |     | <span class='neutral'>    /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the</span>
  751 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  752 |     | <span class='neutral'>    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);</span>
  753 |     | <span class='neutral'></span>
  754 |     | <span class='neutral'>    /// Returns the most recent deployment for the current `chainId`.</span>
  755 |     | <span class='neutral'>    function getDeployment(string calldata contractName) external view returns (address deployedAddress);</span>
  756 |     | <span class='neutral'></span>
  757 |     | <span class='neutral'>    /// Returns the most recent deployment for the given contract on `chainId`</span>
  758 |     | <span class='neutral'>    function getDeployment(string calldata contractName, uint64 chainId)</span>
  759 |     | <span class='neutral'>        external</span>
  760 |     | <span class='neutral'>        view</span>
  761 |     | <span class='neutral'>        returns (address deployedAddress);</span>
  762 |     | <span class='neutral'></span>
  763 |     | <span class='neutral'>    /// Returns all deployments for the given contract on `chainId`</span>
  764 |     | <span class='neutral'>    /// Sorted in descending order of deployment time i.e descending order of BroadcastTxSummary.blockNumber.</span>
  765 |     | <span class='neutral'>    /// The most recent deployment is the first element, and the oldest is the last.</span>
  766 |     | <span class='neutral'>    function getDeployments(string calldata contractName, uint64 chainId)</span>
  767 |     | <span class='neutral'>        external</span>
  768 |     | <span class='neutral'>        view</span>
  769 |     | <span class='neutral'>        returns (address[] memory deployedAddresses);</span>
  770 |     | <span class='neutral'></span>
  771 |     | <span class='neutral'>    /// Returns true if the path exists on disk and is pointing at a directory, else returns false.</span>
  772 |     | <span class='neutral'>    function isDir(string calldata path) external view returns (bool result);</span>
  773 |     | <span class='neutral'></span>
  774 |     | <span class='neutral'>    /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.</span>
  775 |     | <span class='neutral'>    function isFile(string calldata path) external view returns (bool result);</span>
  776 |     | <span class='neutral'></span>
  777 |     | <span class='neutral'>    /// Get the path of the current project root.</span>
  778 |     | <span class='neutral'>    function projectRoot() external view returns (string memory path);</span>
  779 |     | <span class='neutral'></span>
  780 |     | <span class='neutral'>    /// Prompts the user for a string value in the terminal.</span>
  781 |     | <span class='neutral'>    function prompt(string calldata promptText) external returns (string memory input);</span>
  782 |     | <span class='neutral'></span>
  783 |     | <span class='neutral'>    /// Prompts the user for an address in the terminal.</span>
  784 |     | <span class='neutral'>    function promptAddress(string calldata promptText) external returns (address);</span>
  785 |     | <span class='neutral'></span>
  786 |     | <span class='neutral'>    /// Prompts the user for a hidden string value in the terminal.</span>
  787 |     | <span class='neutral'>    function promptSecret(string calldata promptText) external returns (string memory input);</span>
  788 |     | <span class='neutral'></span>
  789 |     | <span class='neutral'>    /// Prompts the user for hidden uint256 in the terminal (usually pk).</span>
  790 |     | <span class='neutral'>    function promptSecretUint(string calldata promptText) external returns (uint256);</span>
  791 |     | <span class='neutral'></span>
  792 |     | <span class='neutral'>    /// Prompts the user for uint256 in the terminal.</span>
  793 |     | <span class='neutral'>    function promptUint(string calldata promptText) external returns (uint256);</span>
  794 |     | <span class='neutral'></span>
  795 |     | <span class='neutral'>    /// Reads the directory at the given path recursively, up to `maxDepth`.</span>
  796 |     | <span class='neutral'>    /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.</span>
  797 |     | <span class='neutral'>    /// Follows symbolic links if `followLinks` is true.</span>
  798 |     | <span class='neutral'>    function readDir(string calldata path) external view returns (DirEntry[] memory entries);</span>
  799 |     | <span class='neutral'></span>
  800 |     | <span class='neutral'>    /// See `readDir(string)`.</span>
  801 |     | <span class='neutral'>    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);</span>
  802 |     | <span class='neutral'></span>
  803 |     | <span class='neutral'>    /// See `readDir(string)`.</span>
  804 |     | <span class='neutral'>    function readDir(string calldata path, uint64 maxDepth, bool followLinks)</span>
  805 |     | <span class='neutral'>        external</span>
  806 |     | <span class='neutral'>        view</span>
  807 |     | <span class='neutral'>        returns (DirEntry[] memory entries);</span>
  808 |     | <span class='neutral'></span>
  809 |     | <span class='neutral'>    /// Reads the entire content of file to string. `path` is relative to the project root.</span>
  810 |     | <span class='neutral'>    function readFile(string calldata path) external view returns (string memory data);</span>
  811 |     | <span class='neutral'></span>
  812 |     | <span class='neutral'>    /// Reads the entire content of file as binary. `path` is relative to the project root.</span>
  813 |     | <span class='neutral'>    function readFileBinary(string calldata path) external view returns (bytes memory data);</span>
  814 |     | <span class='neutral'></span>
  815 |     | <span class='neutral'>    /// Reads next line of file to string.</span>
  816 |     | <span class='neutral'>    function readLine(string calldata path) external view returns (string memory line);</span>
  817 |     | <span class='neutral'></span>
  818 |     | <span class='neutral'>    /// Reads a symbolic link, returning the path that the link points to.</span>
  819 |     | <span class='neutral'>    /// This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  820 |     | <span class='neutral'>    /// - `path` is not a symbolic link.</span>
  821 |     | <span class='neutral'>    /// - `path` does not exist.</span>
  822 |     | <span class='neutral'>    function readLink(string calldata linkPath) external view returns (string memory targetPath);</span>
  823 |     | <span class='neutral'></span>
  824 |     | <span class='neutral'>    /// Removes a directory at the provided path.</span>
  825 |     | <span class='neutral'>    /// This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  826 |     | <span class='neutral'>    /// - `path` doesn&#39;t exist.</span>
  827 |     | <span class='neutral'>    /// - `path` isn&#39;t a directory.</span>
  828 |     | <span class='neutral'>    /// - User lacks permissions to modify `path`.</span>
  829 |     | <span class='neutral'>    /// - The directory is not empty and `recursive` is false.</span>
  830 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  831 |     | <span class='neutral'>    function removeDir(string calldata path, bool recursive) external;</span>
  832 |     | <span class='neutral'></span>
  833 |     | <span class='neutral'>    /// Removes a file from the filesystem.</span>
  834 |     | <span class='neutral'>    /// This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  835 |     | <span class='neutral'>    /// - `path` points to a directory.</span>
  836 |     | <span class='neutral'>    /// - The file doesn&#39;t exist.</span>
  837 |     | <span class='neutral'>    /// - The user lacks permissions to remove the file.</span>
  838 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  839 |     | <span class='neutral'>    function removeFile(string calldata path) external;</span>
  840 |     | <span class='neutral'></span>
  841 |     | <span class='neutral'>    /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.</span>
  842 |     | <span class='neutral'>    function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);</span>
  843 |     | <span class='neutral'></span>
  844 |     | <span class='neutral'>    /// Returns the time since unix epoch in milliseconds.</span>
  845 |     | <span class='neutral'>    function unixTime() external view returns (uint256 milliseconds);</span>
  846 |     | <span class='neutral'></span>
  847 |     | <span class='neutral'>    /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.</span>
  848 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  849 |     | <span class='neutral'>    function writeFile(string calldata path, string calldata data) external;</span>
  850 |     | <span class='neutral'></span>
  851 |     | <span class='neutral'>    /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.</span>
  852 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  853 |     | <span class='neutral'>    function writeFileBinary(string calldata path, bytes calldata data) external;</span>
  854 |     | <span class='neutral'></span>
  855 |     | <span class='neutral'>    /// Writes line to file, creating a file if it does not exist.</span>
  856 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  857 |     | <span class='neutral'>    function writeLine(string calldata path, string calldata data) external;</span>
  858 |     | <span class='neutral'></span>
  859 |     | <span class='neutral'>    // ======== JSON ========</span>
  860 |     | <span class='neutral'></span>
  861 |     | <span class='neutral'>    /// Checks if `key` exists in a JSON object.</span>
  862 |     | <span class='neutral'>    function keyExistsJson(string calldata json, string calldata key) external view returns (bool);</span>
  863 |     | <span class='neutral'></span>
  864 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `address`.</span>
  865 |     | <span class='neutral'>    function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);</span>
  866 |     | <span class='neutral'></span>
  867 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `address[]`.</span>
  868 |     | <span class='neutral'>    function parseJsonAddressArray(string calldata json, string calldata key)</span>
  869 |     | <span class='neutral'>        external</span>
  870 |     | <span class='neutral'>        pure</span>
  871 |     | <span class='neutral'>        returns (address[] memory);</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bool`.</span>
  874 |     | <span class='neutral'>    function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);</span>
  875 |     | <span class='neutral'></span>
  876 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bool[]`.</span>
  877 |     | <span class='neutral'>    function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);</span>
  878 |     | <span class='neutral'></span>
  879 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bytes`.</span>
  880 |     | <span class='neutral'>    function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);</span>
  881 |     | <span class='neutral'></span>
  882 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bytes32`.</span>
  883 |     | <span class='neutral'>    function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);</span>
  884 |     | <span class='neutral'></span>
  885 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.</span>
  886 |     | <span class='neutral'>    function parseJsonBytes32Array(string calldata json, string calldata key)</span>
  887 |     | <span class='neutral'>        external</span>
  888 |     | <span class='neutral'>        pure</span>
  889 |     | <span class='neutral'>        returns (bytes32[] memory);</span>
  890 |     | <span class='neutral'></span>
  891 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.</span>
  892 |     | <span class='neutral'>    function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);</span>
  893 |     | <span class='neutral'></span>
  894 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `int256`.</span>
  895 |     | <span class='neutral'>    function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);</span>
  896 |     | <span class='neutral'></span>
  897 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `int256[]`.</span>
  898 |     | <span class='neutral'>    function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);</span>
  899 |     | <span class='neutral'></span>
  900 |     | <span class='neutral'>    /// Returns an array of all the keys in a JSON object.</span>
  901 |     | <span class='neutral'>    function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);</span>
  902 |     | <span class='neutral'></span>
  903 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `string`.</span>
  904 |     | <span class='neutral'>    function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);</span>
  905 |     | <span class='neutral'></span>
  906 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `string[]`.</span>
  907 |     | <span class='neutral'>    function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);</span>
  908 |     | <span class='neutral'></span>
  909 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to type array corresponding to `typeDescription`.</span>
  910 |     | <span class='neutral'>    function parseJsonTypeArray(string calldata json, string calldata key, string calldata typeDescription)</span>
  911 |     | <span class='neutral'>        external</span>
  912 |     | <span class='neutral'>        pure</span>
  913 |     | <span class='neutral'>        returns (bytes memory);</span>
  914 |     | <span class='neutral'></span>
  915 |     | <span class='neutral'>    /// Parses a string of JSON data and coerces it to type corresponding to `typeDescription`.</span>
  916 |     | <span class='neutral'>    function parseJsonType(string calldata json, string calldata typeDescription)</span>
  917 |     | <span class='neutral'>        external</span>
  918 |     | <span class='neutral'>        pure</span>
  919 |     | <span class='neutral'>        returns (bytes memory);</span>
  920 |     | <span class='neutral'></span>
  921 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to type corresponding to `typeDescription`.</span>
  922 |     | <span class='neutral'>    function parseJsonType(string calldata json, string calldata key, string calldata typeDescription)</span>
  923 |     | <span class='neutral'>        external</span>
  924 |     | <span class='neutral'>        pure</span>
  925 |     | <span class='neutral'>        returns (bytes memory);</span>
  926 |     | <span class='neutral'></span>
  927 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `uint256`.</span>
  928 |     | <span class='neutral'>    function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);</span>
  929 |     | <span class='neutral'></span>
  930 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.</span>
  931 |     | <span class='neutral'>    function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);</span>
  932 |     | <span class='neutral'></span>
  933 |     | <span class='neutral'>    /// ABI-encodes a JSON object.</span>
  934 |     | <span class='neutral'>    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);</span>
  935 |     | <span class='neutral'></span>
  936 |     | <span class='neutral'>    /// ABI-encodes a JSON object at `key`.</span>
  937 |     | <span class='neutral'>    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);</span>
  938 |     | <span class='neutral'></span>
  939 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  940 |     | <span class='neutral'>    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)</span>
  941 |     | <span class='neutral'>        external</span>
  942 |     | <span class='neutral'>        returns (string memory json);</span>
  943 |     | <span class='neutral'></span>
  944 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  945 |     | <span class='neutral'>    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)</span>
  946 |     | <span class='neutral'>        external</span>
  947 |     | <span class='neutral'>        returns (string memory json);</span>
  948 |     | <span class='neutral'></span>
  949 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  950 |     | <span class='neutral'>    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)</span>
  951 |     | <span class='neutral'>        external</span>
  952 |     | <span class='neutral'>        returns (string memory json);</span>
  953 |     | <span class='neutral'></span>
  954 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  955 |     | <span class='neutral'>    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)</span>
  956 |     | <span class='neutral'>        external</span>
  957 |     | <span class='neutral'>        returns (string memory json);</span>
  958 |     | <span class='neutral'></span>
  959 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  960 |     | <span class='neutral'>    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)</span>
  961 |     | <span class='neutral'>        external</span>
  962 |     | <span class='neutral'>        returns (string memory json);</span>
  963 |     | <span class='neutral'></span>
  964 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  965 |     | <span class='neutral'>    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)</span>
  966 |     | <span class='neutral'>        external</span>
  967 |     | <span class='neutral'>        returns (string memory json);</span>
  968 |     | <span class='neutral'></span>
  969 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  970 |     | <span class='neutral'>    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)</span>
  971 |     | <span class='neutral'>        external</span>
  972 |     | <span class='neutral'>        returns (string memory json);</span>
  973 |     | <span class='neutral'></span>
  974 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  975 |     | <span class='neutral'>    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)</span>
  976 |     | <span class='neutral'>        external</span>
  977 |     | <span class='neutral'>        returns (string memory json);</span>
  978 |     | <span class='neutral'></span>
  979 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  980 |     | <span class='neutral'>    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)</span>
  981 |     | <span class='neutral'>        external</span>
  982 |     | <span class='neutral'>        returns (string memory json);</span>
  983 |     | <span class='neutral'></span>
  984 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  985 |     | <span class='neutral'>    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)</span>
  986 |     | <span class='neutral'>        external</span>
  987 |     | <span class='neutral'>        returns (string memory json);</span>
  988 |     | <span class='neutral'></span>
  989 |     | <span class='neutral'>    /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.</span>
  990 |     | <span class='neutral'>    /// Returns the stringified version of the specific JSON file up to that moment.</span>
  991 |     | <span class='neutral'>    function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);</span>
  992 |     | <span class='neutral'></span>
  993 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  994 |     | <span class='neutral'>    function serializeJsonType(string calldata typeDescription, bytes calldata value)</span>
  995 |     | <span class='neutral'>        external</span>
  996 |     | <span class='neutral'>        pure</span>
  997 |     | <span class='neutral'>        returns (string memory json);</span>
  998 |     | <span class='neutral'></span>
  999 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1000 |     | <span class='neutral'>    function serializeJsonType(</span>
 1001 |     | <span class='neutral'>        string calldata objectKey,</span>
 1002 |     | <span class='neutral'>        string calldata valueKey,</span>
 1003 |     | <span class='neutral'>        string calldata typeDescription,</span>
 1004 |     | <span class='neutral'>        bytes calldata value</span>
 1005 |     | <span class='neutral'>    ) external returns (string memory json);</span>
 1006 |     | <span class='neutral'></span>
 1007 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1008 |     | <span class='neutral'>    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)</span>
 1009 |     | <span class='neutral'>        external</span>
 1010 |     | <span class='neutral'>        returns (string memory json);</span>
 1011 |     | <span class='neutral'></span>
 1012 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1013 |     | <span class='neutral'>    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)</span>
 1014 |     | <span class='neutral'>        external</span>
 1015 |     | <span class='neutral'>        returns (string memory json);</span>
 1016 |     | <span class='neutral'></span>
 1017 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1018 |     | <span class='neutral'>    function serializeUintToHex(string calldata objectKey, string calldata valueKey, uint256 value)</span>
 1019 |     | <span class='neutral'>        external</span>
 1020 |     | <span class='neutral'>        returns (string memory json);</span>
 1021 |     | <span class='neutral'></span>
 1022 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1023 |     | <span class='neutral'>    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)</span>
 1024 |     | <span class='neutral'>        external</span>
 1025 |     | <span class='neutral'>        returns (string memory json);</span>
 1026 |     | <span class='neutral'></span>
 1027 |     | <span class='neutral'>    /// See `serializeJson`.</span>
 1028 |     | <span class='neutral'>    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)</span>
 1029 |     | <span class='neutral'>        external</span>
 1030 |     | <span class='neutral'>        returns (string memory json);</span>
 1031 |     | <span class='neutral'></span>
 1032 |     | <span class='neutral'>    /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.</span>
 1033 |     | <span class='neutral'>    function writeJson(string calldata json, string calldata path) external;</span>
 1034 |     | <span class='neutral'></span>
 1035 |     | <span class='neutral'>    /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = &lt;value_key.&gt;</span>
 1036 |     | <span class='neutral'>    /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.</span>
 1037 |     | <span class='neutral'>    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;</span>
 1038 |     | <span class='neutral'></span>
 1039 |     | <span class='neutral'>    /// Checks if `key` exists in a JSON object</span>
 1040 |     | <span class='neutral'>    /// `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.</span>
 1041 |     | <span class='neutral'>    function keyExists(string calldata json, string calldata key) external view returns (bool);</span>
 1042 |     | <span class='neutral'></span>
 1043 |     | <span class='neutral'>    // ======== Scripting ========</span>
 1044 |     | <span class='neutral'></span>
 1045 |     | <span class='neutral'>    /// Designate the next call as an EIP-7702 transaction</span>
 1046 |     | <span class='neutral'>    function attachDelegation(SignedDelegation calldata signedDelegation) external;</span>
 1047 |     | <span class='neutral'></span>
 1048 |     | <span class='neutral'>    /// Takes a signed transaction and broadcasts it to the network.</span>
 1049 |     | <span class='neutral'>    function broadcastRawTransaction(bytes calldata data) external;</span>
 1050 |     | <span class='neutral'></span>
 1051 |     | <span class='neutral'>    /// Has the next call (at this call depth only) create transactions that can later be signed and sent onchain.</span>
 1052 |     | <span class='neutral'>    /// Broadcasting address is determined by checking the following in order:</span>
 1053 |     | <span class='neutral'>    /// 1. If `--sender` argument was provided, that address is used.</span>
 1054 |     | <span class='neutral'>    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.</span>
 1055 |     | <span class='neutral'>    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.</span>
 1056 |     | <span class='neutral'>    function broadcast() external;</span>
 1057 |     | <span class='neutral'></span>
 1058 |     | <span class='neutral'>    /// Has the next call (at this call depth only) create a transaction with the address provided</span>
 1059 |     | <span class='neutral'>    /// as the sender that can later be signed and sent onchain.</span>
 1060 |     | <span class='neutral'>    function broadcast(address signer) external;</span>
 1061 |     | <span class='neutral'></span>
 1062 |     | <span class='neutral'>    /// Has the next call (at this call depth only) create a transaction with the private key</span>
 1063 |     | <span class='neutral'>    /// provided as the sender that can later be signed and sent onchain.</span>
 1064 |     | <span class='neutral'>    function broadcast(uint256 privateKey) external;</span>
 1065 |     | <span class='neutral'></span>
 1066 |     | <span class='neutral'>    /// Returns addresses of available unlocked wallets in the script environment.</span>
 1067 |     | <span class='neutral'>    function getWallets() external returns (address[] memory wallets);</span>
 1068 |     | <span class='neutral'></span>
 1069 |     | <span class='neutral'>    /// Sign an EIP-7702 authorization and designate the next call as an EIP-7702 transaction</span>
 1070 |     | <span class='neutral'>    function signAndAttachDelegation(address implementation, uint256 privateKey)</span>
 1071 |     | <span class='neutral'>        external</span>
 1072 |     | <span class='neutral'>        returns (SignedDelegation memory signedDelegation);</span>
 1073 |     | <span class='neutral'></span>
 1074 |     | <span class='neutral'>    /// Sign an EIP-7702 authorization for delegation</span>
 1075 |     | <span class='neutral'>    function signDelegation(address implementation, uint256 privateKey)</span>
 1076 |     | <span class='neutral'>        external</span>
 1077 |     | <span class='neutral'>        returns (SignedDelegation memory signedDelegation);</span>
 1078 |     | <span class='neutral'></span>
 1079 |     | <span class='neutral'>    /// Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain.</span>
 1080 |     | <span class='neutral'>    /// Broadcasting address is determined by checking the following in order:</span>
 1081 |     | <span class='neutral'>    /// 1. If `--sender` argument was provided, that address is used.</span>
 1082 |     | <span class='neutral'>    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.</span>
 1083 |     | <span class='neutral'>    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.</span>
 1084 |     | <span class='neutral'>    function startBroadcast() external;</span>
 1085 |     | <span class='neutral'></span>
 1086 |     | <span class='neutral'>    /// Has all subsequent calls (at this call depth only) create transactions with the address</span>
 1087 |     | <span class='neutral'>    /// provided that can later be signed and sent onchain.</span>
 1088 |     | <span class='neutral'>    function startBroadcast(address signer) external;</span>
 1089 |     | <span class='neutral'></span>
 1090 |     | <span class='neutral'>    /// Has all subsequent calls (at this call depth only) create transactions with the private key</span>
 1091 |     | <span class='neutral'>    /// provided that can later be signed and sent onchain.</span>
 1092 |     | <span class='neutral'>    function startBroadcast(uint256 privateKey) external;</span>
 1093 |     | <span class='neutral'></span>
 1094 |     | <span class='neutral'>    /// Stops collecting onchain transactions.</span>
 1095 |     | <span class='neutral'>    function stopBroadcast() external;</span>
 1096 |     | <span class='neutral'></span>
 1097 |     | <span class='neutral'>    // ======== String ========</span>
 1098 |     | <span class='neutral'></span>
 1099 |     | <span class='neutral'>    /// Returns true if `search` is found in `subject`, false otherwise.</span>
 1100 |     | <span class='neutral'>    function contains(string calldata subject, string calldata search) external returns (bool result);</span>
 1101 |     | <span class='neutral'></span>
 1102 |     | <span class='neutral'>    /// Returns the index of the first occurrence of a `key` in an `input` string.</span>
 1103 |     | <span class='neutral'>    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found.</span>
 1104 |     | <span class='neutral'>    /// Returns 0 in case of an empty `key`.</span>
 1105 |     | <span class='neutral'>    function indexOf(string calldata input, string calldata key) external pure returns (uint256);</span>
 1106 |     | <span class='neutral'></span>
 1107 |     | <span class='neutral'>    /// Parses the given `string` into an `address`.</span>
 1108 |     | <span class='neutral'>    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);</span>
 1109 |     | <span class='neutral'></span>
 1110 |     | <span class='neutral'>    /// Parses the given `string` into a `bool`.</span>
 1111 |     | <span class='neutral'>    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);</span>
 1112 |     | <span class='neutral'></span>
 1113 |     | <span class='neutral'>    /// Parses the given `string` into `bytes`.</span>
 1114 |     | <span class='neutral'>    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);</span>
 1115 |     | <span class='neutral'></span>
 1116 |     | <span class='neutral'>    /// Parses the given `string` into a `bytes32`.</span>
 1117 |     | <span class='neutral'>    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);</span>
 1118 |     | <span class='neutral'></span>
 1119 |     | <span class='neutral'>    /// Parses the given `string` into a `int256`.</span>
 1120 |     | <span class='neutral'>    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);</span>
 1121 |     | <span class='neutral'></span>
 1122 |     | <span class='neutral'>    /// Parses the given `string` into a `uint256`.</span>
 1123 |     | <span class='neutral'>    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);</span>
 1124 |     | <span class='neutral'></span>
 1125 |     | <span class='neutral'>    /// Replaces occurrences of `from` in the given `string` with `to`.</span>
 1126 |     | <span class='neutral'>    function replace(string calldata input, string calldata from, string calldata to)</span>
 1127 |     | <span class='neutral'>        external</span>
 1128 |     | <span class='neutral'>        pure</span>
 1129 |     | <span class='neutral'>        returns (string memory output);</span>
 1130 |     | <span class='neutral'></span>
 1131 |     | <span class='neutral'>    /// Splits the given `string` into an array of strings divided by the `delimiter`.</span>
 1132 |     | <span class='neutral'>    function split(string calldata input, string calldata delimiter) external pure returns (string[] memory outputs);</span>
 1133 |     | <span class='neutral'></span>
 1134 |     | <span class='neutral'>    /// Converts the given `string` value to Lowercase.</span>
 1135 |     | <span class='neutral'>    function toLowercase(string calldata input) external pure returns (string memory output);</span>
 1136 |     | <span class='neutral'></span>
 1137 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
 1138 |     | <span class='neutral'>    function toString(address value) external pure returns (string memory stringifiedValue);</span>
 1139 |     | <span class='neutral'></span>
 1140 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
 1141 |     | <span class='neutral'>    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);</span>
 1142 |     | <span class='neutral'></span>
 1143 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
 1144 |     | <span class='neutral'>    function toString(bytes32 value) external pure returns (string memory stringifiedValue);</span>
 1145 |     | <span class='neutral'></span>
 1146 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
 1147 |     | <span class='neutral'>    function toString(bool value) external pure returns (string memory stringifiedValue);</span>
 1148 |     | <span class='neutral'></span>
 1149 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
 1150 |     | <span class='neutral'>    function toString(uint256 value) external pure returns (string memory stringifiedValue);</span>
 1151 |     | <span class='neutral'></span>
 1152 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
 1153 |     | <span class='neutral'>    function toString(int256 value) external pure returns (string memory stringifiedValue);</span>
 1154 |     | <span class='neutral'></span>
 1155 |     | <span class='neutral'>    /// Converts the given `string` value to Uppercase.</span>
 1156 |     | <span class='neutral'>    function toUppercase(string calldata input) external pure returns (string memory output);</span>
 1157 |     | <span class='neutral'></span>
 1158 |     | <span class='neutral'>    /// Trims leading and trailing whitespace from the given `string` value.</span>
 1159 |     | <span class='neutral'>    function trim(string calldata input) external pure returns (string memory output);</span>
 1160 |     | <span class='neutral'></span>
 1161 |     | <span class='neutral'>    // ======== Testing ========</span>
 1162 |     | <span class='neutral'></span>
 1163 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.</span>
 1164 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1165 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) external pure;</span>
 1166 |     | <span class='neutral'></span>
 1167 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.</span>
 1168 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1169 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(</span>
 1170 |     | <span class='neutral'>        uint256 left,</span>
 1171 |     | <span class='neutral'>        uint256 right,</span>
 1172 |     | <span class='neutral'>        uint256 maxDelta,</span>
 1173 |     | <span class='neutral'>        uint256 decimals,</span>
 1174 |     | <span class='neutral'>        string calldata error</span>
 1175 |     | <span class='neutral'>    ) external pure;</span>
 1176 |     | <span class='neutral'></span>
 1177 |     | <span class='neutral'>    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.</span>
 1178 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1179 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) external pure;</span>
 1180 |     | <span class='neutral'></span>
 1181 |     | <span class='neutral'>    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.</span>
 1182 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1183 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(</span>
 1184 |     | <span class='neutral'>        int256 left,</span>
 1185 |     | <span class='neutral'>        int256 right,</span>
 1186 |     | <span class='neutral'>        uint256 maxDelta,</span>
 1187 |     | <span class='neutral'>        uint256 decimals,</span>
 1188 |     | <span class='neutral'>        string calldata error</span>
 1189 |     | <span class='neutral'>    ) external pure;</span>
 1190 |     | <span class='neutral'></span>
 1191 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.</span>
 1192 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) external pure;</span>
 1193 |     | <span class='neutral'></span>
 1194 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.</span>
 1195 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1196 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string calldata error) external pure;</span>
 1197 |     | <span class='neutral'></span>
 1198 |     | <span class='neutral'>    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.</span>
 1199 |     | <span class='neutral'>    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) external pure;</span>
 1200 |     | <span class='neutral'></span>
 1201 |     | <span class='neutral'>    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.</span>
 1202 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1203 |     | <span class='neutral'>    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string calldata error) external pure;</span>
 1204 |     | <span class='neutral'></span>
 1205 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
 1206 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
 1207 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1208 |     | <span class='neutral'>    function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals)</span>
 1209 |     | <span class='neutral'>        external</span>
 1210 |     | <span class='neutral'>        pure;</span>
 1211 |     | <span class='neutral'></span>
 1212 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
 1213 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
 1214 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1215 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 1216 |     | <span class='neutral'>        uint256 left,</span>
 1217 |     | <span class='neutral'>        uint256 right,</span>
 1218 |     | <span class='neutral'>        uint256 maxPercentDelta,</span>
 1219 |     | <span class='neutral'>        uint256 decimals,</span>
 1220 |     | <span class='neutral'>        string calldata error</span>
 1221 |     | <span class='neutral'>    ) external pure;</span>
 1222 |     | <span class='neutral'></span>
 1223 |     | <span class='neutral'>    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
 1224 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
 1225 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1226 |     | <span class='neutral'>    function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals)</span>
 1227 |     | <span class='neutral'>        external</span>
 1228 |     | <span class='neutral'>        pure;</span>
 1229 |     | <span class='neutral'></span>
 1230 |     | <span class='neutral'>    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
 1231 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
 1232 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1233 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 1234 |     | <span class='neutral'>        int256 left,</span>
 1235 |     | <span class='neutral'>        int256 right,</span>
 1236 |     | <span class='neutral'>        uint256 maxPercentDelta,</span>
 1237 |     | <span class='neutral'>        uint256 decimals,</span>
 1238 |     | <span class='neutral'>        string calldata error</span>
 1239 |     | <span class='neutral'>    ) external pure;</span>
 1240 |     | <span class='neutral'></span>
 1241 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
 1242 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
 1243 |     | <span class='neutral'>    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) external pure;</span>
 1244 |     | <span class='neutral'></span>
 1245 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
 1246 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
 1247 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1248 |     | <span class='neutral'>    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string calldata error)</span>
 1249 |     | <span class='neutral'>        external</span>
 1250 |     | <span class='neutral'>        pure;</span>
 1251 |     | <span class='neutral'></span>
 1252 |     | <span class='neutral'>    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
 1253 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
 1254 |     | <span class='neutral'>    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) external pure;</span>
 1255 |     | <span class='neutral'></span>
 1256 |     | <span class='neutral'>    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
 1257 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
 1258 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1259 |     | <span class='neutral'>    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string calldata error)</span>
 1260 |     | <span class='neutral'>        external</span>
 1261 |     | <span class='neutral'>        pure;</span>
 1262 |     | <span class='neutral'></span>
 1263 |     | <span class='neutral'>    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.</span>
 1264 |     | <span class='neutral'>    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1265 |     | <span class='neutral'></span>
 1266 |     | <span class='neutral'>    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.</span>
 1267 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1268 |     | <span class='neutral'>    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1269 |     | <span class='neutral'></span>
 1270 |     | <span class='neutral'>    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.</span>
 1271 |     | <span class='neutral'>    function assertEqDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1272 |     | <span class='neutral'></span>
 1273 |     | <span class='neutral'>    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.</span>
 1274 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1275 |     | <span class='neutral'>    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1276 |     | <span class='neutral'></span>
 1277 |     | <span class='neutral'>    /// Asserts that two `bool` values are equal.</span>
 1278 |     | <span class='neutral'>    function assertEq(bool left, bool right) external pure;</span>
 1279 |     | <span class='neutral'></span>
 1280 |     | <span class='neutral'>    /// Asserts that two `bool` values are equal and includes error message into revert string on failure.</span>
 1281 |     | <span class='neutral'>    function assertEq(bool left, bool right, string calldata error) external pure;</span>
 1282 |     | <span class='neutral'></span>
 1283 |     | <span class='neutral'>    /// Asserts that two `string` values are equal.</span>
 1284 |     | <span class='neutral'>    function assertEq(string calldata left, string calldata right) external pure;</span>
 1285 |     | <span class='neutral'></span>
 1286 |     | <span class='neutral'>    /// Asserts that two `string` values are equal and includes error message into revert string on failure.</span>
 1287 |     | <span class='neutral'>    function assertEq(string calldata left, string calldata right, string calldata error) external pure;</span>
 1288 |     | <span class='neutral'></span>
 1289 |     | <span class='neutral'>    /// Asserts that two `bytes` values are equal.</span>
 1290 |     | <span class='neutral'>    function assertEq(bytes calldata left, bytes calldata right) external pure;</span>
 1291 |     | <span class='neutral'></span>
 1292 |     | <span class='neutral'>    /// Asserts that two `bytes` values are equal and includes error message into revert string on failure.</span>
 1293 |     | <span class='neutral'>    function assertEq(bytes calldata left, bytes calldata right, string calldata error) external pure;</span>
 1294 |     | <span class='neutral'></span>
 1295 |     | <span class='neutral'>    /// Asserts that two arrays of `bool` values are equal.</span>
 1296 |     | <span class='neutral'>    function assertEq(bool[] calldata left, bool[] calldata right) external pure;</span>
 1297 |     | <span class='neutral'></span>
 1298 |     | <span class='neutral'>    /// Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.</span>
 1299 |     | <span class='neutral'>    function assertEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;</span>
 1300 |     | <span class='neutral'></span>
 1301 |     | <span class='neutral'>    /// Asserts that two arrays of `uint256 values are equal.</span>
 1302 |     | <span class='neutral'>    function assertEq(uint256[] calldata left, uint256[] calldata right) external pure;</span>
 1303 |     | <span class='neutral'></span>
 1304 |     | <span class='neutral'>    /// Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.</span>
 1305 |     | <span class='neutral'>    function assertEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;</span>
 1306 |     | <span class='neutral'></span>
 1307 |     | <span class='neutral'>    /// Asserts that two arrays of `int256` values are equal.</span>
 1308 |     | <span class='neutral'>    function assertEq(int256[] calldata left, int256[] calldata right) external pure;</span>
 1309 |     | <span class='neutral'></span>
 1310 |     | <span class='neutral'>    /// Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.</span>
 1311 |     | <span class='neutral'>    function assertEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;</span>
 1312 |     | <span class='neutral'></span>
 1313 |     | <span class='neutral'>    /// Asserts that two `uint256` values are equal.</span>
 1314 |     | <span class='neutral'>    function assertEq(uint256 left, uint256 right) external pure;</span>
 1315 |     | <span class='neutral'></span>
 1316 |     | <span class='neutral'>    /// Asserts that two arrays of `address` values are equal.</span>
 1317 |     | <span class='neutral'>    function assertEq(address[] calldata left, address[] calldata right) external pure;</span>
 1318 |     | <span class='neutral'></span>
 1319 |     | <span class='neutral'>    /// Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.</span>
 1320 |     | <span class='neutral'>    function assertEq(address[] calldata left, address[] calldata right, string calldata error) external pure;</span>
 1321 |     | <span class='neutral'></span>
 1322 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes32` values are equal.</span>
 1323 |     | <span class='neutral'>    function assertEq(bytes32[] calldata left, bytes32[] calldata right) external pure;</span>
 1324 |     | <span class='neutral'></span>
 1325 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.</span>
 1326 |     | <span class='neutral'>    function assertEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;</span>
 1327 |     | <span class='neutral'></span>
 1328 |     | <span class='neutral'>    /// Asserts that two arrays of `string` values are equal.</span>
 1329 |     | <span class='neutral'>    function assertEq(string[] calldata left, string[] calldata right) external pure;</span>
 1330 |     | <span class='neutral'></span>
 1331 |     | <span class='neutral'>    /// Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.</span>
 1332 |     | <span class='neutral'>    function assertEq(string[] calldata left, string[] calldata right, string calldata error) external pure;</span>
 1333 |     | <span class='neutral'></span>
 1334 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes` values are equal.</span>
 1335 |     | <span class='neutral'>    function assertEq(bytes[] calldata left, bytes[] calldata right) external pure;</span>
 1336 |     | <span class='neutral'></span>
 1337 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.</span>
 1338 |     | <span class='neutral'>    function assertEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;</span>
 1339 |     | <span class='neutral'></span>
 1340 |     | <span class='neutral'>    /// Asserts that two `uint256` values are equal and includes error message into revert string on failure.</span>
 1341 |     | <span class='neutral'>    function assertEq(uint256 left, uint256 right, string calldata error) external pure;</span>
 1342 |     | <span class='neutral'></span>
 1343 |     | <span class='neutral'>    /// Asserts that two `int256` values are equal.</span>
 1344 |     | <span class='neutral'>    function assertEq(int256 left, int256 right) external pure;</span>
 1345 |     | <span class='neutral'></span>
 1346 |     | <span class='neutral'>    /// Asserts that two `int256` values are equal and includes error message into revert string on failure.</span>
 1347 |     | <span class='neutral'>    function assertEq(int256 left, int256 right, string calldata error) external pure;</span>
 1348 |     | <span class='neutral'></span>
 1349 |     | <span class='neutral'>    /// Asserts that two `address` values are equal.</span>
 1350 |     | <span class='neutral'>    function assertEq(address left, address right) external pure;</span>
 1351 |     | <span class='neutral'></span>
 1352 |     | <span class='neutral'>    /// Asserts that two `address` values are equal and includes error message into revert string on failure.</span>
 1353 |     | <span class='neutral'>    function assertEq(address left, address right, string calldata error) external pure;</span>
 1354 |     | <span class='neutral'></span>
 1355 |     | <span class='neutral'>    /// Asserts that two `bytes32` values are equal.</span>
 1356 |     | <span class='neutral'>    function assertEq(bytes32 left, bytes32 right) external pure;</span>
 1357 |     | <span class='neutral'></span>
 1358 |     | <span class='neutral'>    /// Asserts that two `bytes32` values are equal and includes error message into revert string on failure.</span>
 1359 |     | <span class='neutral'>    function assertEq(bytes32 left, bytes32 right, string calldata error) external pure;</span>
 1360 |     | <span class='neutral'></span>
 1361 |     | <span class='neutral'>    /// Asserts that the given condition is false.</span>
 1362 |     | <span class='neutral'>    function assertFalse(bool condition) external pure;</span>
 1363 |     | <span class='neutral'></span>
 1364 |     | <span class='neutral'>    /// Asserts that the given condition is false and includes error message into revert string on failure.</span>
 1365 |     | <span class='neutral'>    function assertFalse(bool condition, string calldata error) external pure;</span>
 1366 |     | <span class='neutral'></span>
 1367 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.</span>
 1368 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1369 |     | <span class='neutral'>    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1370 |     | <span class='neutral'></span>
 1371 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.</span>
 1372 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1373 |     | <span class='neutral'>    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1374 |     | <span class='neutral'></span>
 1375 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than or equal to second.</span>
 1376 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1377 |     | <span class='neutral'>    function assertGeDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1378 |     | <span class='neutral'></span>
 1379 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than or equal to second.</span>
 1380 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1381 |     | <span class='neutral'>    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1382 |     | <span class='neutral'></span>
 1383 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.</span>
 1384 |     | <span class='neutral'>    function assertGe(uint256 left, uint256 right) external pure;</span>
 1385 |     | <span class='neutral'></span>
 1386 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.</span>
 1387 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1388 |     | <span class='neutral'>    function assertGe(uint256 left, uint256 right, string calldata error) external pure;</span>
 1389 |     | <span class='neutral'></span>
 1390 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than or equal to second.</span>
 1391 |     | <span class='neutral'>    function assertGe(int256 left, int256 right) external pure;</span>
 1392 |     | <span class='neutral'></span>
 1393 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than or equal to second.</span>
 1394 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1395 |     | <span class='neutral'>    function assertGe(int256 left, int256 right, string calldata error) external pure;</span>
 1396 |     | <span class='neutral'></span>
 1397 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than second.</span>
 1398 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1399 |     | <span class='neutral'>    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1400 |     | <span class='neutral'></span>
 1401 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than second.</span>
 1402 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1403 |     | <span class='neutral'>    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1404 |     | <span class='neutral'></span>
 1405 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than second.</span>
 1406 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1407 |     | <span class='neutral'>    function assertGtDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1408 |     | <span class='neutral'></span>
 1409 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than second.</span>
 1410 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1411 |     | <span class='neutral'>    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1412 |     | <span class='neutral'></span>
 1413 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than second.</span>
 1414 |     | <span class='neutral'>    function assertGt(uint256 left, uint256 right) external pure;</span>
 1415 |     | <span class='neutral'></span>
 1416 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than second.</span>
 1417 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1418 |     | <span class='neutral'>    function assertGt(uint256 left, uint256 right, string calldata error) external pure;</span>
 1419 |     | <span class='neutral'></span>
 1420 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than second.</span>
 1421 |     | <span class='neutral'>    function assertGt(int256 left, int256 right) external pure;</span>
 1422 |     | <span class='neutral'></span>
 1423 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than second.</span>
 1424 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1425 |     | <span class='neutral'>    function assertGt(int256 left, int256 right, string calldata error) external pure;</span>
 1426 |     | <span class='neutral'></span>
 1427 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than or equal to second.</span>
 1428 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1429 |     | <span class='neutral'>    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1430 |     | <span class='neutral'></span>
 1431 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than or equal to second.</span>
 1432 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1433 |     | <span class='neutral'>    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1434 |     | <span class='neutral'></span>
 1435 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than or equal to second.</span>
 1436 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1437 |     | <span class='neutral'>    function assertLeDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1438 |     | <span class='neutral'></span>
 1439 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than or equal to second.</span>
 1440 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1441 |     | <span class='neutral'>    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1442 |     | <span class='neutral'></span>
 1443 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than or equal to second.</span>
 1444 |     | <span class='neutral'>    function assertLe(uint256 left, uint256 right) external pure;</span>
 1445 |     | <span class='neutral'></span>
 1446 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than or equal to second.</span>
 1447 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1448 |     | <span class='neutral'>    function assertLe(uint256 left, uint256 right, string calldata error) external pure;</span>
 1449 |     | <span class='neutral'></span>
 1450 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than or equal to second.</span>
 1451 |     | <span class='neutral'>    function assertLe(int256 left, int256 right) external pure;</span>
 1452 |     | <span class='neutral'></span>
 1453 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than or equal to second.</span>
 1454 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1455 |     | <span class='neutral'>    function assertLe(int256 left, int256 right, string calldata error) external pure;</span>
 1456 |     | <span class='neutral'></span>
 1457 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than second.</span>
 1458 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1459 |     | <span class='neutral'>    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1460 |     | <span class='neutral'></span>
 1461 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than second.</span>
 1462 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1463 |     | <span class='neutral'>    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1464 |     | <span class='neutral'></span>
 1465 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than second.</span>
 1466 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1467 |     | <span class='neutral'>    function assertLtDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1468 |     | <span class='neutral'></span>
 1469 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than second.</span>
 1470 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1471 |     | <span class='neutral'>    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1472 |     | <span class='neutral'></span>
 1473 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than second.</span>
 1474 |     | <span class='neutral'>    function assertLt(uint256 left, uint256 right) external pure;</span>
 1475 |     | <span class='neutral'></span>
 1476 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than second.</span>
 1477 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1478 |     | <span class='neutral'>    function assertLt(uint256 left, uint256 right, string calldata error) external pure;</span>
 1479 |     | <span class='neutral'></span>
 1480 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than second.</span>
 1481 |     | <span class='neutral'>    function assertLt(int256 left, int256 right) external pure;</span>
 1482 |     | <span class='neutral'></span>
 1483 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than second.</span>
 1484 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1485 |     | <span class='neutral'>    function assertLt(int256 left, int256 right, string calldata error) external pure;</span>
 1486 |     | <span class='neutral'></span>
 1487 |     | <span class='neutral'>    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.</span>
 1488 |     | <span class='neutral'>    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1489 |     | <span class='neutral'></span>
 1490 |     | <span class='neutral'>    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.</span>
 1491 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1492 |     | <span class='neutral'>    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1493 |     | <span class='neutral'></span>
 1494 |     | <span class='neutral'>    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.</span>
 1495 |     | <span class='neutral'>    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1496 |     | <span class='neutral'></span>
 1497 |     | <span class='neutral'>    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.</span>
 1498 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1499 |     | <span class='neutral'>    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1500 |     | <span class='neutral'></span>
 1501 |     | <span class='neutral'>    /// Asserts that two `bool` values are not equal.</span>
 1502 |     | <span class='neutral'>    function assertNotEq(bool left, bool right) external pure;</span>
 1503 |     | <span class='neutral'></span>
 1504 |     | <span class='neutral'>    /// Asserts that two `bool` values are not equal and includes error message into revert string on failure.</span>
 1505 |     | <span class='neutral'>    function assertNotEq(bool left, bool right, string calldata error) external pure;</span>
 1506 |     | <span class='neutral'></span>
 1507 |     | <span class='neutral'>    /// Asserts that two `string` values are not equal.</span>
 1508 |     | <span class='neutral'>    function assertNotEq(string calldata left, string calldata right) external pure;</span>
 1509 |     | <span class='neutral'></span>
 1510 |     | <span class='neutral'>    /// Asserts that two `string` values are not equal and includes error message into revert string on failure.</span>
 1511 |     | <span class='neutral'>    function assertNotEq(string calldata left, string calldata right, string calldata error) external pure;</span>
 1512 |     | <span class='neutral'></span>
 1513 |     | <span class='neutral'>    /// Asserts that two `bytes` values are not equal.</span>
 1514 |     | <span class='neutral'>    function assertNotEq(bytes calldata left, bytes calldata right) external pure;</span>
 1515 |     | <span class='neutral'></span>
 1516 |     | <span class='neutral'>    /// Asserts that two `bytes` values are not equal and includes error message into revert string on failure.</span>
 1517 |     | <span class='neutral'>    function assertNotEq(bytes calldata left, bytes calldata right, string calldata error) external pure;</span>
 1518 |     | <span class='neutral'></span>
 1519 |     | <span class='neutral'>    /// Asserts that two arrays of `bool` values are not equal.</span>
 1520 |     | <span class='neutral'>    function assertNotEq(bool[] calldata left, bool[] calldata right) external pure;</span>
 1521 |     | <span class='neutral'></span>
 1522 |     | <span class='neutral'>    /// Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.</span>
 1523 |     | <span class='neutral'>    function assertNotEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;</span>
 1524 |     | <span class='neutral'></span>
 1525 |     | <span class='neutral'>    /// Asserts that two arrays of `uint256` values are not equal.</span>
 1526 |     | <span class='neutral'>    function assertNotEq(uint256[] calldata left, uint256[] calldata right) external pure;</span>
 1527 |     | <span class='neutral'></span>
 1528 |     | <span class='neutral'>    /// Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.</span>
 1529 |     | <span class='neutral'>    function assertNotEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;</span>
 1530 |     | <span class='neutral'></span>
 1531 |     | <span class='neutral'>    /// Asserts that two arrays of `int256` values are not equal.</span>
 1532 |     | <span class='neutral'>    function assertNotEq(int256[] calldata left, int256[] calldata right) external pure;</span>
 1533 |     | <span class='neutral'></span>
 1534 |     | <span class='neutral'>    /// Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.</span>
 1535 |     | <span class='neutral'>    function assertNotEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;</span>
 1536 |     | <span class='neutral'></span>
 1537 |     | <span class='neutral'>    /// Asserts that two `uint256` values are not equal.</span>
 1538 |     | <span class='neutral'>    function assertNotEq(uint256 left, uint256 right) external pure;</span>
 1539 |     | <span class='neutral'></span>
 1540 |     | <span class='neutral'>    /// Asserts that two arrays of `address` values are not equal.</span>
 1541 |     | <span class='neutral'>    function assertNotEq(address[] calldata left, address[] calldata right) external pure;</span>
 1542 |     | <span class='neutral'></span>
 1543 |     | <span class='neutral'>    /// Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.</span>
 1544 |     | <span class='neutral'>    function assertNotEq(address[] calldata left, address[] calldata right, string calldata error) external pure;</span>
 1545 |     | <span class='neutral'></span>
 1546 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes32` values are not equal.</span>
 1547 |     | <span class='neutral'>    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right) external pure;</span>
 1548 |     | <span class='neutral'></span>
 1549 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.</span>
 1550 |     | <span class='neutral'>    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;</span>
 1551 |     | <span class='neutral'></span>
 1552 |     | <span class='neutral'>    /// Asserts that two arrays of `string` values are not equal.</span>
 1553 |     | <span class='neutral'>    function assertNotEq(string[] calldata left, string[] calldata right) external pure;</span>
 1554 |     | <span class='neutral'></span>
 1555 |     | <span class='neutral'>    /// Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.</span>
 1556 |     | <span class='neutral'>    function assertNotEq(string[] calldata left, string[] calldata right, string calldata error) external pure;</span>
 1557 |     | <span class='neutral'></span>
 1558 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes` values are not equal.</span>
 1559 |     | <span class='neutral'>    function assertNotEq(bytes[] calldata left, bytes[] calldata right) external pure;</span>
 1560 |     | <span class='neutral'></span>
 1561 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.</span>
 1562 |     | <span class='neutral'>    function assertNotEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;</span>
 1563 |     | <span class='neutral'></span>
 1564 |     | <span class='neutral'>    /// Asserts that two `uint256` values are not equal and includes error message into revert string on failure.</span>
 1565 |     | <span class='neutral'>    function assertNotEq(uint256 left, uint256 right, string calldata error) external pure;</span>
 1566 |     | <span class='neutral'></span>
 1567 |     | <span class='neutral'>    /// Asserts that two `int256` values are not equal.</span>
 1568 |     | <span class='neutral'>    function assertNotEq(int256 left, int256 right) external pure;</span>
 1569 |     | <span class='neutral'></span>
 1570 |     | <span class='neutral'>    /// Asserts that two `int256` values are not equal and includes error message into revert string on failure.</span>
 1571 |     | <span class='neutral'>    function assertNotEq(int256 left, int256 right, string calldata error) external pure;</span>
 1572 |     | <span class='neutral'></span>
 1573 |     | <span class='neutral'>    /// Asserts that two `address` values are not equal.</span>
 1574 |     | <span class='neutral'>    function assertNotEq(address left, address right) external pure;</span>
 1575 |     | <span class='neutral'></span>
 1576 |     | <span class='neutral'>    /// Asserts that two `address` values are not equal and includes error message into revert string on failure.</span>
 1577 |     | <span class='neutral'>    function assertNotEq(address left, address right, string calldata error) external pure;</span>
 1578 |     | <span class='neutral'></span>
 1579 |     | <span class='neutral'>    /// Asserts that two `bytes32` values are not equal.</span>
 1580 |     | <span class='neutral'>    function assertNotEq(bytes32 left, bytes32 right) external pure;</span>
 1581 |     | <span class='neutral'></span>
 1582 |     | <span class='neutral'>    /// Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.</span>
 1583 |     | <span class='neutral'>    function assertNotEq(bytes32 left, bytes32 right, string calldata error) external pure;</span>
 1584 |     | <span class='neutral'></span>
 1585 |     | <span class='neutral'>    /// Asserts that the given condition is true.</span>
 1586 |     | <span class='neutral'>    function assertTrue(bool condition) external pure;</span>
 1587 |     | <span class='neutral'></span>
 1588 |     | <span class='neutral'>    /// Asserts that the given condition is true and includes error message into revert string on failure.</span>
 1589 |     | <span class='neutral'>    function assertTrue(bool condition, string calldata error) external pure;</span>
 1590 |     | <span class='neutral'></span>
 1591 |     | <span class='neutral'>    /// If the condition is false, discard this run&#39;s fuzz inputs and generate new ones.</span>
 1592 |     | <span class='neutral'>    function assume(bool condition) external pure;</span>
 1593 |     | <span class='neutral'></span>
 1594 |     | <span class='neutral'>    /// Discard this run&#39;s fuzz inputs and generate new ones if next call reverted.</span>
 1595 |     | <span class='neutral'>    function assumeNoRevert() external pure;</span>
 1596 |     | <span class='neutral'></span>
 1597 |     | <span class='neutral'>    /// Writes a breakpoint to jump to in the debugger.</span>
 1598 |     | <span class='neutral'>    function breakpoint(string calldata char) external pure;</span>
 1599 |     | <span class='neutral'></span>
 1600 |     | <span class='neutral'>    /// Writes a conditional breakpoint to jump to in the debugger.</span>
 1601 |     | <span class='neutral'>    function breakpoint(string calldata char, bool value) external pure;</span>
 1602 |     | <span class='neutral'></span>
 1603 |     | <span class='neutral'>    /// Returns the Foundry version.</span>
 1604 |     | <span class='neutral'>    /// Format: &lt;cargo_version&gt;+&lt;git_sha&gt;+&lt;build_timestamp&gt;</span>
 1605 |     | <span class='neutral'>    /// Sample output: 0.2.0+faa94c384+202407110019</span>
 1606 |     | <span class='neutral'>    /// Note: Build timestamps may vary slightly across platforms due to separate CI jobs.</span>
 1607 |     | <span class='neutral'>    /// For reliable version comparisons, use YYYYMMDD0000 format (e.g., &gt;= 202407110000)</span>
 1608 |     | <span class='neutral'>    /// to compare timestamps while ignoring minor time differences.</span>
 1609 |     | <span class='neutral'>    function getFoundryVersion() external view returns (string memory version);</span>
 1610 |     | <span class='neutral'></span>
 1611 |     | <span class='neutral'>    /// Returns the RPC url for the given alias.</span>
 1612 |     | <span class='neutral'>    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);</span>
 1613 |     | <span class='neutral'></span>
 1614 |     | <span class='neutral'>    /// Returns all rpc urls and their aliases as structs.</span>
 1615 |     | <span class='neutral'>    function rpcUrlStructs() external view returns (Rpc[] memory urls);</span>
 1616 |     | <span class='neutral'></span>
 1617 |     | <span class='neutral'>    /// Returns all rpc urls and their aliases `[alias, url][]`.</span>
 1618 |     | <span class='neutral'>    function rpcUrls() external view returns (string[2][] memory urls);</span>
 1619 |     | <span class='neutral'></span>
 1620 |     | <span class='neutral'>    /// Suspends execution of the main thread for `duration` milliseconds.</span>
 1621 |     | <span class='neutral'>    function sleep(uint256 duration) external;</span>
 1622 |     | <span class='neutral'></span>
 1623 |     | <span class='neutral'>    // ======== Toml ========</span>
 1624 |     | <span class='neutral'></span>
 1625 |     | <span class='neutral'>    /// Checks if `key` exists in a TOML table.</span>
 1626 |     | <span class='neutral'>    function keyExistsToml(string calldata toml, string calldata key) external view returns (bool);</span>
 1627 |     | <span class='neutral'></span>
 1628 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `address`.</span>
 1629 |     | <span class='neutral'>    function parseTomlAddress(string calldata toml, string calldata key) external pure returns (address);</span>
 1630 |     | <span class='neutral'></span>
 1631 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `address[]`.</span>
 1632 |     | <span class='neutral'>    function parseTomlAddressArray(string calldata toml, string calldata key)</span>
 1633 |     | <span class='neutral'>        external</span>
 1634 |     | <span class='neutral'>        pure</span>
 1635 |     | <span class='neutral'>        returns (address[] memory);</span>
 1636 |     | <span class='neutral'></span>
 1637 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bool`.</span>
 1638 |     | <span class='neutral'>    function parseTomlBool(string calldata toml, string calldata key) external pure returns (bool);</span>
 1639 |     | <span class='neutral'></span>
 1640 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bool[]`.</span>
 1641 |     | <span class='neutral'>    function parseTomlBoolArray(string calldata toml, string calldata key) external pure returns (bool[] memory);</span>
 1642 |     | <span class='neutral'></span>
 1643 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bytes`.</span>
 1644 |     | <span class='neutral'>    function parseTomlBytes(string calldata toml, string calldata key) external pure returns (bytes memory);</span>
 1645 |     | <span class='neutral'></span>
 1646 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bytes32`.</span>
 1647 |     | <span class='neutral'>    function parseTomlBytes32(string calldata toml, string calldata key) external pure returns (bytes32);</span>
 1648 |     | <span class='neutral'></span>
 1649 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bytes32[]`.</span>
 1650 |     | <span class='neutral'>    function parseTomlBytes32Array(string calldata toml, string calldata key)</span>
 1651 |     | <span class='neutral'>        external</span>
 1652 |     | <span class='neutral'>        pure</span>
 1653 |     | <span class='neutral'>        returns (bytes32[] memory);</span>
 1654 |     | <span class='neutral'></span>
 1655 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bytes[]`.</span>
 1656 |     | <span class='neutral'>    function parseTomlBytesArray(string calldata toml, string calldata key) external pure returns (bytes[] memory);</span>
 1657 |     | <span class='neutral'></span>
 1658 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `int256`.</span>
 1659 |     | <span class='neutral'>    function parseTomlInt(string calldata toml, string calldata key) external pure returns (int256);</span>
 1660 |     | <span class='neutral'></span>
 1661 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `int256[]`.</span>
 1662 |     | <span class='neutral'>    function parseTomlIntArray(string calldata toml, string calldata key) external pure returns (int256[] memory);</span>
 1663 |     | <span class='neutral'></span>
 1664 |     | <span class='neutral'>    /// Returns an array of all the keys in a TOML table.</span>
 1665 |     | <span class='neutral'>    function parseTomlKeys(string calldata toml, string calldata key) external pure returns (string[] memory keys);</span>
 1666 |     | <span class='neutral'></span>
 1667 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `string`.</span>
 1668 |     | <span class='neutral'>    function parseTomlString(string calldata toml, string calldata key) external pure returns (string memory);</span>
 1669 |     | <span class='neutral'></span>
 1670 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `string[]`.</span>
 1671 |     | <span class='neutral'>    function parseTomlStringArray(string calldata toml, string calldata key) external pure returns (string[] memory);</span>
 1672 |     | <span class='neutral'></span>
 1673 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to type array corresponding to `typeDescription`.</span>
 1674 |     | <span class='neutral'>    function parseTomlTypeArray(string calldata toml, string calldata key, string calldata typeDescription)</span>
 1675 |     | <span class='neutral'>        external</span>
 1676 |     | <span class='neutral'>        pure</span>
 1677 |     | <span class='neutral'>        returns (bytes memory);</span>
 1678 |     | <span class='neutral'></span>
 1679 |     | <span class='neutral'>    /// Parses a string of TOML data and coerces it to type corresponding to `typeDescription`.</span>
 1680 |     | <span class='neutral'>    function parseTomlType(string calldata toml, string calldata typeDescription)</span>
 1681 |     | <span class='neutral'>        external</span>
 1682 |     | <span class='neutral'>        pure</span>
 1683 |     | <span class='neutral'>        returns (bytes memory);</span>
 1684 |     | <span class='neutral'></span>
 1685 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to type corresponding to `typeDescription`.</span>
 1686 |     | <span class='neutral'>    function parseTomlType(string calldata toml, string calldata key, string calldata typeDescription)</span>
 1687 |     | <span class='neutral'>        external</span>
 1688 |     | <span class='neutral'>        pure</span>
 1689 |     | <span class='neutral'>        returns (bytes memory);</span>
 1690 |     | <span class='neutral'></span>
 1691 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `uint256`.</span>
 1692 |     | <span class='neutral'>    function parseTomlUint(string calldata toml, string calldata key) external pure returns (uint256);</span>
 1693 |     | <span class='neutral'></span>
 1694 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `uint256[]`.</span>
 1695 |     | <span class='neutral'>    function parseTomlUintArray(string calldata toml, string calldata key) external pure returns (uint256[] memory);</span>
 1696 |     | <span class='neutral'></span>
 1697 |     | <span class='neutral'>    /// ABI-encodes a TOML table.</span>
 1698 |     | <span class='neutral'>    function parseToml(string calldata toml) external pure returns (bytes memory abiEncodedData);</span>
 1699 |     | <span class='neutral'></span>
 1700 |     | <span class='neutral'>    /// ABI-encodes a TOML table at `key`.</span>
 1701 |     | <span class='neutral'>    function parseToml(string calldata toml, string calldata key) external pure returns (bytes memory abiEncodedData);</span>
 1702 |     | <span class='neutral'></span>
 1703 |     | <span class='neutral'>    /// Takes serialized JSON, converts to TOML and write a serialized TOML to a file.</span>
 1704 |     | <span class='neutral'>    function writeToml(string calldata json, string calldata path) external;</span>
 1705 |     | <span class='neutral'></span>
 1706 |     | <span class='neutral'>    /// Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = &lt;value_key.&gt;</span>
 1707 |     | <span class='neutral'>    /// This is useful to replace a specific value of a TOML file, without having to parse the entire thing.</span>
 1708 |     | <span class='neutral'>    function writeToml(string calldata json, string calldata path, string calldata valueKey) external;</span>
 1709 |     | <span class='neutral'></span>
 1710 |     | <span class='neutral'>    // ======== Utilities ========</span>
 1711 |     | <span class='neutral'></span>
 1712 |     | <span class='neutral'>    /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.</span>
 1713 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer)</span>
 1714 |     | <span class='neutral'>        external</span>
 1715 |     | <span class='neutral'>        pure</span>
 1716 |     | <span class='neutral'>        returns (address);</span>
 1717 |     | <span class='neutral'></span>
 1718 |     | <span class='neutral'>    /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.</span>
 1719 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);</span>
 1720 |     | <span class='neutral'></span>
 1721 |     | <span class='neutral'>    /// Compute the address a contract will be deployed at for a given deployer address and nonce.</span>
 1722 |     | <span class='neutral'>    function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);</span>
 1723 |     | <span class='neutral'></span>
 1724 |     | <span class='neutral'>    /// Utility cheatcode to copy storage of `from` contract to another `to` contract.</span>
 1725 |     | <span class='neutral'>    function copyStorage(address from, address to) external;</span>
 1726 |     | <span class='neutral'></span>
 1727 |     | <span class='neutral'>    /// Returns ENS namehash for provided string.</span>
 1728 |     | <span class='neutral'>    function ensNamehash(string calldata name) external pure returns (bytes32);</span>
 1729 |     | <span class='neutral'></span>
 1730 |     | <span class='neutral'>    /// Gets the label for the specified address.</span>
 1731 |     | <span class='neutral'>    function getLabel(address account) external view returns (string memory currentLabel);</span>
 1732 |     | <span class='neutral'></span>
 1733 |     | <span class='neutral'>    /// Labels an address in call traces.</span>
 1734 |     | <span class='neutral'>    function label(address account, string calldata newLabel) external;</span>
 1735 |     | <span class='neutral'></span>
 1736 |     | <span class='neutral'>    /// Pauses collection of call traces. Useful in cases when you want to skip tracing of</span>
 1737 |     | <span class='neutral'>    /// complex calls which are not useful for debugging.</span>
 1738 |     | <span class='neutral'>    function pauseTracing() external view;</span>
 1739 |     | <span class='neutral'></span>
 1740 |     | <span class='neutral'>    /// Returns a random `address`.</span>
 1741 |     | <span class='neutral'>    function randomAddress() external returns (address);</span>
 1742 |     | <span class='neutral'></span>
 1743 |     | <span class='neutral'>    /// Returns a random `bool`.</span>
 1744 |     | <span class='neutral'>    function randomBool() external view returns (bool);</span>
 1745 |     | <span class='neutral'></span>
 1746 |     | <span class='neutral'>    /// Returns a random byte array value of the given length.</span>
 1747 |     | <span class='neutral'>    function randomBytes(uint256 len) external view returns (bytes memory);</span>
 1748 |     | <span class='neutral'></span>
 1749 |     | <span class='neutral'>    /// Returns a random fixed-size byte array of length 4.</span>
 1750 |     | <span class='neutral'>    function randomBytes4() external view returns (bytes4);</span>
 1751 |     | <span class='neutral'></span>
 1752 |     | <span class='neutral'>    /// Returns a random fixed-size byte array of length 8.</span>
 1753 |     | <span class='neutral'>    function randomBytes8() external view returns (bytes8);</span>
 1754 |     | <span class='neutral'></span>
 1755 |     | <span class='neutral'>    /// Returns a random `int256` value.</span>
 1756 |     | <span class='neutral'>    function randomInt() external view returns (int256);</span>
 1757 |     | <span class='neutral'></span>
 1758 |     | <span class='neutral'>    /// Returns a random `int256` value of given bits.</span>
 1759 |     | <span class='neutral'>    function randomInt(uint256 bits) external view returns (int256);</span>
 1760 |     | <span class='neutral'></span>
 1761 |     | <span class='neutral'>    /// Returns a random uint256 value.</span>
 1762 |     | <span class='neutral'>    function randomUint() external returns (uint256);</span>
 1763 |     | <span class='neutral'></span>
 1764 |     | <span class='neutral'>    /// Returns random uint256 value between the provided range (=min..=max).</span>
 1765 |     | <span class='neutral'>    function randomUint(uint256 min, uint256 max) external returns (uint256);</span>
 1766 |     | <span class='neutral'></span>
 1767 |     | <span class='neutral'>    /// Returns a random `uint256` value of given bits.</span>
 1768 |     | <span class='neutral'>    function randomUint(uint256 bits) external view returns (uint256);</span>
 1769 |     | <span class='neutral'></span>
 1770 |     | <span class='neutral'>    /// Unpauses collection of call traces.</span>
 1771 |     | <span class='neutral'>    function resumeTracing() external view;</span>
 1772 |     | <span class='neutral'></span>
 1773 |     | <span class='neutral'>    /// Utility cheatcode to set arbitrary storage for given target address.</span>
 1774 |     | <span class='neutral'>    function setArbitraryStorage(address target) external;</span>
 1775 |     | <span class='neutral'></span>
 1776 |     | <span class='neutral'>    /// Encodes a `bytes` value to a base64url string.</span>
 1777 |     | <span class='neutral'>    function toBase64URL(bytes calldata data) external pure returns (string memory);</span>
 1778 |     | <span class='neutral'></span>
 1779 |     | <span class='neutral'>    /// Encodes a `string` value to a base64url string.</span>
 1780 |     | <span class='neutral'>    function toBase64URL(string calldata data) external pure returns (string memory);</span>
 1781 |     | <span class='neutral'></span>
 1782 |     | <span class='neutral'>    /// Encodes a `bytes` value to a base64 string.</span>
 1783 |     | <span class='neutral'>    function toBase64(bytes calldata data) external pure returns (string memory);</span>
 1784 |     | <span class='neutral'></span>
 1785 |     | <span class='neutral'>    /// Encodes a `string` value to a base64 string.</span>
 1786 |     | <span class='neutral'>    function toBase64(string calldata data) external pure returns (string memory);</span>
 1787 |     | <span class='neutral'>}</span>
 1788 |     | <span class='neutral'></span>
 1789 |     | <span class='neutral'>/// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used</span>
 1790 |     | <span class='neutral'>/// in tests, but it is not recommended to use these cheats in scripts.</span>
 1791 |     | <span class='neutral'>interface Vm is VmSafe {</span>
 1792 |     | <span class='neutral'>    // ======== EVM ========</span>
 1793 |     | <span class='neutral'></span>
 1794 |     | <span class='neutral'>    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.</span>
 1795 |     | <span class='neutral'>    function activeFork() external view returns (uint256 forkId);</span>
 1796 |     | <span class='neutral'></span>
 1797 |     | <span class='neutral'>    /// In forking mode, explicitly grant the given address cheatcode access.</span>
 1798 |     | <span class='neutral'>    function allowCheatcodes(address account) external;</span>
 1799 |     | <span class='neutral'></span>
 1800 |     | <span class='neutral'>    /// Sets `block.blobbasefee`</span>
 1801 |     | <span class='neutral'>    function blobBaseFee(uint256 newBlobBaseFee) external;</span>
 1802 |     | <span class='neutral'></span>
 1803 |     | <span class='neutral'>    /// Sets the blobhashes in the transaction.</span>
 1804 |     | <span class='neutral'>    /// Not available on EVM versions before Cancun.</span>
 1805 |     | <span class='neutral'>    /// If used on unsupported EVM versions it will revert.</span>
 1806 |     | <span class='neutral'>    function blobhashes(bytes32[] calldata hashes) external;</span>
 1807 |     | <span class='neutral'></span>
 1808 |     | <span class='neutral'>    /// Sets `block.chainid`.</span>
 1809 |     | <span class='neutral'>    function chainId(uint256 newChainId) external;</span>
 1810 |     | <span class='neutral'></span>
 1811 |     | <span class='neutral'>    /// Clears all mocked calls.</span>
 1812 |     | <span class='neutral'>    function clearMockedCalls() external;</span>
 1813 |     | <span class='neutral'></span>
 1814 |     | <span class='neutral'>    /// Clones a source account code, state, balance and nonce to a target account and updates in-memory EVM state.</span>
 1815 |     | <span class='neutral'>    function cloneAccount(address source, address target) external;</span>
 1816 |     | <span class='neutral'></span>
 1817 |     | <span class='neutral'>    /// Sets `block.coinbase`.</span>
 1818 |     | <span class='neutral'>    function coinbase(address newCoinbase) external;</span>
 1819 |     | <span class='neutral'></span>
 1820 |     | <span class='neutral'>    /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.</span>
 1821 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);</span>
 1822 |     | <span class='neutral'></span>
 1823 |     | <span class='neutral'>    /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.</span>
 1824 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);</span>
 1825 |     | <span class='neutral'></span>
 1826 |     | <span class='neutral'>    /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,</span>
 1827 |     | <span class='neutral'>    /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.</span>
 1828 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);</span>
 1829 |     | <span class='neutral'></span>
 1830 |     | <span class='neutral'>    /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.</span>
 1831 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);</span>
 1832 |     | <span class='neutral'></span>
 1833 |     | <span class='neutral'>    /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.</span>
 1834 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);</span>
 1835 |     | <span class='neutral'></span>
 1836 |     | <span class='neutral'>    /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,</span>
 1837 |     | <span class='neutral'>    /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.</span>
 1838 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);</span>
 1839 |     | <span class='neutral'></span>
 1840 |     | <span class='neutral'>    /// Sets an address&#39; balance.</span>
 1841 |     | <span class='neutral'>    function deal(address account, uint256 newBalance) external;</span>
 1842 |     | <span class='neutral'></span>
 1843 |     | <span class='neutral'>    /// Removes the snapshot with the given ID created by `snapshot`.</span>
 1844 |     | <span class='neutral'>    /// Takes the snapshot ID to delete.</span>
 1845 |     | <span class='neutral'>    /// Returns `true` if the snapshot was successfully deleted.</span>
 1846 |     | <span class='neutral'>    /// Returns `false` if the snapshot does not exist.</span>
 1847 |     | <span class='neutral'>    function deleteStateSnapshot(uint256 snapshotId) external returns (bool success);</span>
 1848 |     | <span class='neutral'></span>
 1849 |     | <span class='neutral'>    /// Removes _all_ snapshots previously created by `snapshot`.</span>
 1850 |     | <span class='neutral'>    function deleteStateSnapshots() external;</span>
 1851 |     | <span class='neutral'></span>
 1852 |     | <span class='neutral'>    /// Sets `block.difficulty`.</span>
 1853 |     | <span class='neutral'>    /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.</span>
 1854 |     | <span class='neutral'>    /// Reverts if used on unsupported EVM versions.</span>
 1855 |     | <span class='neutral'>    function difficulty(uint256 newDifficulty) external;</span>
 1856 |     | <span class='neutral'></span>
 1857 |     | <span class='neutral'>    /// Dump a genesis JSON file&#39;s `allocs` to disk.</span>
 1858 |     | <span class='neutral'>    function dumpState(string calldata pathToStateJson) external;</span>
 1859 |     | <span class='neutral'></span>
 1860 |     | <span class='neutral'>    /// Sets an address&#39; code.</span>
 1861 |     | <span class='neutral'>    function etch(address target, bytes calldata newRuntimeBytecode) external;</span>
 1862 |     | <span class='neutral'></span>
 1863 |     | <span class='neutral'>    /// Sets `block.basefee`.</span>
 1864 |     | <span class='neutral'>    function fee(uint256 newBasefee) external;</span>
 1865 |     | <span class='neutral'></span>
 1866 |     | <span class='neutral'>    /// Gets the blockhashes from the current transaction.</span>
 1867 |     | <span class='neutral'>    /// Not available on EVM versions before Cancun.</span>
 1868 |     | <span class='neutral'>    /// If used on unsupported EVM versions it will revert.</span>
 1869 |     | <span class='neutral'>    function getBlobhashes() external view returns (bytes32[] memory hashes);</span>
 1870 |     | <span class='neutral'></span>
 1871 |     | <span class='neutral'>    /// Returns true if the account is marked as persistent.</span>
 1872 |     | <span class='neutral'>    function isPersistent(address account) external view returns (bool persistent);</span>
 1873 |     | <span class='neutral'></span>
 1874 |     | <span class='neutral'>    /// Load a genesis JSON file&#39;s `allocs` into the in-memory EVM state.</span>
 1875 |     | <span class='neutral'>    function loadAllocs(string calldata pathToAllocsJson) external;</span>
 1876 |     | <span class='neutral'></span>
 1877 |     | <span class='neutral'>    /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup</span>
 1878 |     | <span class='neutral'>    /// Meaning, changes made to the state of this account will be kept when switching forks.</span>
 1879 |     | <span class='neutral'>    function makePersistent(address account) external;</span>
 1880 |     | <span class='neutral'></span>
 1881 |     | <span class='neutral'>    /// See `makePersistent(address)`.</span>
 1882 |     | <span class='neutral'>    function makePersistent(address account0, address account1) external;</span>
 1883 |     | <span class='neutral'></span>
 1884 |     | <span class='neutral'>    /// See `makePersistent(address)`.</span>
 1885 |     | <span class='neutral'>    function makePersistent(address account0, address account1, address account2) external;</span>
 1886 |     | <span class='neutral'></span>
 1887 |     | <span class='neutral'>    /// See `makePersistent(address)`.</span>
 1888 |     | <span class='neutral'>    function makePersistent(address[] calldata accounts) external;</span>
 1889 |     | <span class='neutral'></span>
 1890 |     | <span class='neutral'>    /// Reverts a call to an address with specified revert data.</span>
 1891 |     | <span class='neutral'>    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;</span>
 1892 |     | <span class='neutral'></span>
 1893 |     | <span class='neutral'>    /// Reverts a call to an address with a specific `msg.value`, with specified revert data.</span>
 1894 |     | <span class='neutral'>    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)</span>
 1895 |     | <span class='neutral'>        external;</span>
 1896 |     | <span class='neutral'></span>
 1897 |     | <span class='neutral'>    /// Reverts a call to an address with specified revert data.</span>
 1898 |     | <span class='neutral'>    /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.</span>
 1899 |     | <span class='neutral'>    function mockCallRevert(address callee, bytes4 data, bytes calldata revertData) external;</span>
 1900 |     | <span class='neutral'></span>
 1901 |     | <span class='neutral'>    /// Reverts a call to an address with a specific `msg.value`, with specified revert data.</span>
 1902 |     | <span class='neutral'>    /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.</span>
 1903 |     | <span class='neutral'>    function mockCallRevert(address callee, uint256 msgValue, bytes4 data, bytes calldata revertData) external;</span>
 1904 |     | <span class='neutral'></span>
 1905 |     | <span class='neutral'>    /// Mocks a call to an address, returning specified data.</span>
 1906 |     | <span class='neutral'>    /// Calldata can either be strict or a partial match, e.g. if you only</span>
 1907 |     | <span class='neutral'>    /// pass a Solidity selector to the expected calldata, then the entire Solidity</span>
 1908 |     | <span class='neutral'>    /// function will be mocked.</span>
 1909 |     | <span class='neutral'>    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;</span>
 1910 |     | <span class='neutral'></span>
 1911 |     | <span class='neutral'>    /// Mocks a call to an address with a specific `msg.value`, returning specified data.</span>
 1912 |     | <span class='neutral'>    /// Calldata match takes precedence over `msg.value` in case of ambiguity.</span>
 1913 |     | <span class='neutral'>    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;</span>
 1914 |     | <span class='neutral'></span>
 1915 |     | <span class='neutral'>    /// Mocks a call to an address, returning specified data.</span>
 1916 |     | <span class='neutral'>    /// Calldata can either be strict or a partial match, e.g. if you only</span>
 1917 |     | <span class='neutral'>    /// pass a Solidity selector to the expected calldata, then the entire Solidity</span>
 1918 |     | <span class='neutral'>    /// function will be mocked.</span>
 1919 |     | <span class='neutral'>    /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.</span>
 1920 |     | <span class='neutral'>    function mockCall(address callee, bytes4 data, bytes calldata returnData) external;</span>
 1921 |     | <span class='neutral'></span>
 1922 |     | <span class='neutral'>    /// Mocks a call to an address with a specific `msg.value`, returning specified data.</span>
 1923 |     | <span class='neutral'>    /// Calldata match takes precedence over `msg.value` in case of ambiguity.</span>
 1924 |     | <span class='neutral'>    /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.</span>
 1925 |     | <span class='neutral'>    function mockCall(address callee, uint256 msgValue, bytes4 data, bytes calldata returnData) external;</span>
 1926 |     | <span class='neutral'></span>
 1927 |     | <span class='neutral'>    /// Mocks multiple calls to an address, returning specified data for each call.</span>
 1928 |     | <span class='neutral'>    function mockCalls(address callee, bytes calldata data, bytes[] calldata returnData) external;</span>
 1929 |     | <span class='neutral'></span>
 1930 |     | <span class='neutral'>    /// Mocks multiple calls to an address with a specific `msg.value`, returning specified data for each call.</span>
 1931 |     | <span class='neutral'>    function mockCalls(address callee, uint256 msgValue, bytes calldata data, bytes[] calldata returnData) external;</span>
 1932 |     | <span class='neutral'></span>
 1933 |     | <span class='neutral'>    /// Whenever a call is made to `callee` with calldata `data`, this cheatcode instead calls</span>
 1934 |     | <span class='neutral'>    /// `target` with the same calldata. This functionality is similar to a delegate call made to</span>
 1935 |     | <span class='neutral'>    /// `target` contract from `callee`.</span>
 1936 |     | <span class='neutral'>    /// Can be used to substitute a call to a function with another implementation that captures</span>
 1937 |     | <span class='neutral'>    /// the primary logic of the original function but is easier to reason about.</span>
 1938 |     | <span class='neutral'>    /// If calldata is not a strict match then partial match by selector is attempted.</span>
 1939 |     | <span class='neutral'>    function mockFunction(address callee, address target, bytes calldata data) external;</span>
 1940 |     | <span class='neutral'></span>
 1941 |     | <span class='neutral'>    /// Sets the *next* call&#39;s `msg.sender` to be the input address.</span>
 1942 |     | <span class='neutral'>    function prank(address msgSender) external;</span>
 1943 |     | <span class='neutral'></span>
 1944 |     | <span class='neutral'>    /// Sets the *next* call&#39;s `msg.sender` to be the input address, and the `tx.origin` to be the second input.</span>
 1945 |     | <span class='neutral'>    function prank(address msgSender, address txOrigin) external;</span>
 1946 |     | <span class='neutral'></span>
 1947 |     | <span class='neutral'>    /// Sets the *next* delegate call&#39;s `msg.sender` to be the input address.</span>
 1948 |     | <span class='neutral'>    function prank(address msgSender, bool delegateCall) external;</span>
 1949 |     | <span class='neutral'></span>
 1950 |     | <span class='neutral'>    /// Sets the *next* delegate call&#39;s `msg.sender` to be the input address, and the `tx.origin` to be the second input.</span>
 1951 |     | <span class='neutral'>    function prank(address msgSender, address txOrigin, bool delegateCall) external;</span>
 1952 |     | <span class='neutral'></span>
 1953 |     | <span class='neutral'>    /// Sets `block.prevrandao`.</span>
 1954 |     | <span class='neutral'>    /// Not available on EVM versions before Paris. Use `difficulty` instead.</span>
 1955 |     | <span class='neutral'>    /// If used on unsupported EVM versions it will revert.</span>
 1956 |     | <span class='neutral'>    function prevrandao(bytes32 newPrevrandao) external;</span>
 1957 |     | <span class='neutral'></span>
 1958 |     | <span class='neutral'>    /// Sets `block.prevrandao`.</span>
 1959 |     | <span class='neutral'>    /// Not available on EVM versions before Paris. Use `difficulty` instead.</span>
 1960 |     | <span class='neutral'>    /// If used on unsupported EVM versions it will revert.</span>
 1961 |     | <span class='neutral'>    function prevrandao(uint256 newPrevrandao) external;</span>
 1962 |     | <span class='neutral'></span>
 1963 |     | <span class='neutral'>    /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.</span>
 1964 |     | <span class='neutral'>    function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);</span>
 1965 |     | <span class='neutral'></span>
 1966 |     | <span class='neutral'>    /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.</span>
 1967 |     | <span class='neutral'>    function resetNonce(address account) external;</span>
 1968 |     | <span class='neutral'></span>
 1969 |     | <span class='neutral'>    /// Revert the state of the EVM to a previous snapshot</span>
 1970 |     | <span class='neutral'>    /// Takes the snapshot ID to revert to.</span>
 1971 |     | <span class='neutral'>    /// Returns `true` if the snapshot was successfully reverted.</span>
 1972 |     | <span class='neutral'>    /// Returns `false` if the snapshot does not exist.</span>
 1973 |     | <span class='neutral'>    /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteStateSnapshot`.</span>
 1974 |     | <span class='neutral'>    function revertToState(uint256 snapshotId) external returns (bool success);</span>
 1975 |     | <span class='neutral'></span>
 1976 |     | <span class='neutral'>    /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots</span>
 1977 |     | <span class='neutral'>    /// Takes the snapshot ID to revert to.</span>
 1978 |     | <span class='neutral'>    /// Returns `true` if the snapshot was successfully reverted and deleted.</span>
 1979 |     | <span class='neutral'>    /// Returns `false` if the snapshot does not exist.</span>
 1980 |     | <span class='neutral'>    function revertToStateAndDelete(uint256 snapshotId) external returns (bool success);</span>
 1981 |     | <span class='neutral'></span>
 1982 |     | <span class='neutral'>    /// Revokes persistent status from the address, previously added via `makePersistent`.</span>
 1983 |     | <span class='neutral'>    function revokePersistent(address account) external;</span>
 1984 |     | <span class='neutral'></span>
 1985 |     | <span class='neutral'>    /// See `revokePersistent(address)`.</span>
 1986 |     | <span class='neutral'>    function revokePersistent(address[] calldata accounts) external;</span>
 1987 |     | <span class='neutral'></span>
 1988 |     | <span class='neutral'>    /// Sets `block.height`.</span>
 1989 |     | <span class='neutral'>    function roll(uint256 newHeight) external;</span>
 1990 |     | <span class='neutral'></span>
 1991 |     | <span class='neutral'>    /// Updates the currently active fork to given block number</span>
 1992 |     | <span class='neutral'>    /// This is similar to `roll` but for the currently active fork.</span>
 1993 |     | <span class='neutral'>    function rollFork(uint256 blockNumber) external;</span>
 1994 |     | <span class='neutral'></span>
 1995 |     | <span class='neutral'>    /// Updates the currently active fork to given transaction. This will `rollFork` with the number</span>
 1996 |     | <span class='neutral'>    /// of the block the transaction was mined in and replays all transaction mined before it in the block.</span>
 1997 |     | <span class='neutral'>    function rollFork(bytes32 txHash) external;</span>
 1998 |     | <span class='neutral'></span>
 1999 |     | <span class='neutral'>    /// Updates the given fork to given block number.</span>
 2000 |     | <span class='neutral'>    function rollFork(uint256 forkId, uint256 blockNumber) external;</span>
 2001 |     | <span class='neutral'></span>
 2002 |     | <span class='neutral'>    /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.</span>
 2003 |     | <span class='neutral'>    function rollFork(uint256 forkId, bytes32 txHash) external;</span>
 2004 |     | <span class='neutral'></span>
 2005 |     | <span class='neutral'>    /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.</span>
 2006 |     | <span class='neutral'>    function selectFork(uint256 forkId) external;</span>
 2007 |     | <span class='neutral'></span>
 2008 |     | <span class='neutral'>    /// Set blockhash for the current block.</span>
 2009 |     | <span class='neutral'>    /// It only sets the blockhash for blocks where `block.number - 256 &lt;= number &lt; block.number`.</span>
 2010 |     | <span class='neutral'>    function setBlockhash(uint256 blockNumber, bytes32 blockHash) external;</span>
 2011 |     | <span class='neutral'></span>
 2012 |     | <span class='neutral'>    /// Sets the nonce of an account. Must be higher than the current nonce of the account.</span>
 2013 |     | <span class='neutral'>    function setNonce(address account, uint64 newNonce) external;</span>
 2014 |     | <span class='neutral'></span>
 2015 |     | <span class='neutral'>    /// Sets the nonce of an account to an arbitrary value.</span>
 2016 |     | <span class='neutral'>    function setNonceUnsafe(address account, uint64 newNonce) external;</span>
 2017 |     | <span class='neutral'></span>
 2018 |     | <span class='neutral'>    /// Snapshot capture the gas usage of the last call by name from the callee perspective.</span>
 2019 |     | <span class='neutral'>    function snapshotGasLastCall(string calldata name) external returns (uint256 gasUsed);</span>
 2020 |     | <span class='neutral'></span>
 2021 |     | <span class='neutral'>    /// Snapshot capture the gas usage of the last call by name in a group from the callee perspective.</span>
 2022 |     | <span class='neutral'>    function snapshotGasLastCall(string calldata group, string calldata name) external returns (uint256 gasUsed);</span>
 2023 |     | <span class='neutral'></span>
 2024 |     | <span class='neutral'>    /// Snapshot the current state of the evm.</span>
 2025 |     | <span class='neutral'>    /// Returns the ID of the snapshot that was created.</span>
 2026 |     | <span class='neutral'>    /// To revert a snapshot use `revertToState`.</span>
 2027 |     | <span class='neutral'>    function snapshotState() external returns (uint256 snapshotId);</span>
 2028 |     | <span class='neutral'></span>
 2029 |     | <span class='neutral'>    /// Snapshot capture an arbitrary numerical value by name.</span>
 2030 |     | <span class='neutral'>    /// The group name is derived from the contract name.</span>
 2031 |     | <span class='neutral'>    function snapshotValue(string calldata name, uint256 value) external;</span>
 2032 |     | <span class='neutral'></span>
 2033 |     | <span class='neutral'>    /// Snapshot capture an arbitrary numerical value by name in a group.</span>
 2034 |     | <span class='neutral'>    function snapshotValue(string calldata group, string calldata name, uint256 value) external;</span>
 2035 |     | <span class='neutral'></span>
 2036 |     | <span class='neutral'>    /// Sets all subsequent calls&#39; `msg.sender` to be the input address until `stopPrank` is called.</span>
 2037 |     | <span class='neutral'>    function startPrank(address msgSender) external;</span>
 2038 |     | <span class='neutral'></span>
 2039 |     | <span class='neutral'>    /// Sets all subsequent calls&#39; `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.</span>
 2040 |     | <span class='neutral'>    function startPrank(address msgSender, address txOrigin) external;</span>
 2041 |     | <span class='neutral'></span>
 2042 |     | <span class='neutral'>    /// Sets all subsequent delegate calls&#39; `msg.sender` to be the input address until `stopPrank` is called.</span>
 2043 |     | <span class='neutral'>    function startPrank(address msgSender, bool delegateCall) external;</span>
 2044 |     | <span class='neutral'></span>
 2045 |     | <span class='neutral'>    /// Sets all subsequent delegate calls&#39; `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.</span>
 2046 |     | <span class='neutral'>    function startPrank(address msgSender, address txOrigin, bool delegateCall) external;</span>
 2047 |     | <span class='neutral'></span>
 2048 |     | <span class='neutral'>    /// Start a snapshot capture of the current gas usage by name.</span>
 2049 |     | <span class='neutral'>    /// The group name is derived from the contract name.</span>
 2050 |     | <span class='neutral'>    function startSnapshotGas(string calldata name) external;</span>
 2051 |     | <span class='neutral'></span>
 2052 |     | <span class='neutral'>    /// Start a snapshot capture of the current gas usage by name in a group.</span>
 2053 |     | <span class='neutral'>    function startSnapshotGas(string calldata group, string calldata name) external;</span>
 2054 |     | <span class='neutral'></span>
 2055 |     | <span class='neutral'>    /// Resets subsequent calls&#39; `msg.sender` to be `address(this)`.</span>
 2056 |     | <span class='neutral'>    function stopPrank() external;</span>
 2057 |     | <span class='neutral'></span>
 2058 |     | <span class='neutral'>    /// Stop the snapshot capture of the current gas by latest snapshot name, capturing the gas used since the start.</span>
 2059 |     | <span class='neutral'>    function stopSnapshotGas() external returns (uint256 gasUsed);</span>
 2060 |     | <span class='neutral'></span>
 2061 |     | <span class='neutral'>    /// Stop the snapshot capture of the current gas usage by name, capturing the gas used since the start.</span>
 2062 |     | <span class='neutral'>    /// The group name is derived from the contract name.</span>
 2063 |     | <span class='neutral'>    function stopSnapshotGas(string calldata name) external returns (uint256 gasUsed);</span>
 2064 |     | <span class='neutral'></span>
 2065 |     | <span class='neutral'>    /// Stop the snapshot capture of the current gas usage by name in a group, capturing the gas used since the start.</span>
 2066 |     | <span class='neutral'>    function stopSnapshotGas(string calldata group, string calldata name) external returns (uint256 gasUsed);</span>
 2067 |     | <span class='neutral'></span>
 2068 |     | <span class='neutral'>    /// Stores a value to an address&#39; storage slot.</span>
 2069 |     | <span class='neutral'>    function store(address target, bytes32 slot, bytes32 value) external;</span>
 2070 |     | <span class='neutral'></span>
 2071 |     | <span class='neutral'>    /// Fetches the given transaction from the active fork and executes it on the current state.</span>
 2072 |     | <span class='neutral'>    function transact(bytes32 txHash) external;</span>
 2073 |     | <span class='neutral'></span>
 2074 |     | <span class='neutral'>    /// Fetches the given transaction from the given fork and executes it on the current state.</span>
 2075 |     | <span class='neutral'>    function transact(uint256 forkId, bytes32 txHash) external;</span>
 2076 |     | <span class='neutral'></span>
 2077 |     | <span class='neutral'>    /// Sets `tx.gasprice`.</span>
 2078 |     | <span class='neutral'>    function txGasPrice(uint256 newGasPrice) external;</span>
 2079 |     | <span class='neutral'></span>
 2080 |     | <span class='neutral'>    /// Sets `block.timestamp`.</span>
 2081 |     | <span class='neutral'>    function warp(uint256 newTimestamp) external;</span>
 2082 |     | <span class='neutral'></span>
 2083 |     | <span class='neutral'>    /// `deleteSnapshot` is being deprecated in favor of `deleteStateSnapshot`. It will be removed in future versions.</span>
 2084 |     | <span class='neutral'>    function deleteSnapshot(uint256 snapshotId) external returns (bool success);</span>
 2085 |     | <span class='neutral'></span>
 2086 |     | <span class='neutral'>    /// `deleteSnapshots` is being deprecated in favor of `deleteStateSnapshots`. It will be removed in future versions.</span>
 2087 |     | <span class='neutral'>    function deleteSnapshots() external;</span>
 2088 |     | <span class='neutral'></span>
 2089 |     | <span class='neutral'>    /// `revertToAndDelete` is being deprecated in favor of `revertToStateAndDelete`. It will be removed in future versions.</span>
 2090 |     | <span class='neutral'>    function revertToAndDelete(uint256 snapshotId) external returns (bool success);</span>
 2091 |     | <span class='neutral'></span>
 2092 |     | <span class='neutral'>    /// `revertTo` is being deprecated in favor of `revertToState`. It will be removed in future versions.</span>
 2093 |     | <span class='neutral'>    function revertTo(uint256 snapshotId) external returns (bool success);</span>
 2094 |     | <span class='neutral'></span>
 2095 |     | <span class='neutral'>    /// `snapshot` is being deprecated in favor of `snapshotState`. It will be removed in future versions.</span>
 2096 |     | <span class='neutral'>    function snapshot() external returns (uint256 snapshotId);</span>
 2097 |     | <span class='neutral'></span>
 2098 |     | <span class='neutral'>    // ======== Testing ========</span>
 2099 |     | <span class='neutral'></span>
 2100 |     | <span class='neutral'>    /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.</span>
 2101 |     | <span class='neutral'>    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;</span>
 2102 |     | <span class='neutral'></span>
 2103 |     | <span class='neutral'>    /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.</span>
 2104 |     | <span class='neutral'>    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)</span>
 2105 |     | <span class='neutral'>        external;</span>
 2106 |     | <span class='neutral'></span>
 2107 |     | <span class='neutral'>    /// Expects a call to an address with the specified calldata.</span>
 2108 |     | <span class='neutral'>    /// Calldata can either be a strict or a partial match.</span>
 2109 |     | <span class='neutral'>    function expectCall(address callee, bytes calldata data) external;</span>
 2110 |     | <span class='neutral'></span>
 2111 |     | <span class='neutral'>    /// Expects given number of calls to an address with the specified calldata.</span>
 2112 |     | <span class='neutral'>    function expectCall(address callee, bytes calldata data, uint64 count) external;</span>
 2113 |     | <span class='neutral'></span>
 2114 |     | <span class='neutral'>    /// Expects a call to an address with the specified `msg.value` and calldata.</span>
 2115 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;</span>
 2116 |     | <span class='neutral'></span>
 2117 |     | <span class='neutral'>    /// Expects given number of calls to an address with the specified `msg.value` and calldata.</span>
 2118 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;</span>
 2119 |     | <span class='neutral'></span>
 2120 |     | <span class='neutral'>    /// Expect a call to an address with the specified `msg.value`, gas, and calldata.</span>
 2121 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;</span>
 2122 |     | <span class='neutral'></span>
 2123 |     | <span class='neutral'>    /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.</span>
 2124 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;</span>
 2125 |     | <span class='neutral'></span>
 2126 |     | <span class='neutral'>    /// Prepare an expected anonymous log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).</span>
 2127 |     | <span class='neutral'>    /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if</span>
 2128 |     | <span class='neutral'>    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).</span>
 2129 |     | <span class='neutral'>    function expectEmitAnonymous(bool checkTopic0, bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData)</span>
 2130 |     | <span class='neutral'>        external;</span>
 2131 |     | <span class='neutral'></span>
 2132 |     | <span class='neutral'>    /// Same as the previous method, but also checks supplied address against emitting contract.</span>
 2133 |     | <span class='neutral'>    function expectEmitAnonymous(</span>
 2134 |     | <span class='neutral'>        bool checkTopic0,</span>
 2135 |     | <span class='neutral'>        bool checkTopic1,</span>
 2136 |     | <span class='neutral'>        bool checkTopic2,</span>
 2137 |     | <span class='neutral'>        bool checkTopic3,</span>
 2138 |     | <span class='neutral'>        bool checkData,</span>
 2139 |     | <span class='neutral'>        address emitter</span>
 2140 |     | <span class='neutral'>    ) external;</span>
 2141 |     | <span class='neutral'></span>
 2142 |     | <span class='neutral'>    /// Prepare an expected anonymous log with all topic and data checks enabled.</span>
 2143 |     | <span class='neutral'>    /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if</span>
 2144 |     | <span class='neutral'>    /// logs were emitted in the expected order with the expected topics and data.</span>
 2145 |     | <span class='neutral'>    function expectEmitAnonymous() external;</span>
 2146 |     | <span class='neutral'></span>
 2147 |     | <span class='neutral'>    /// Same as the previous method, but also checks supplied address against emitting contract.</span>
 2148 |     | <span class='neutral'>    function expectEmitAnonymous(address emitter) external;</span>
 2149 |     | <span class='neutral'></span>
 2150 |     | <span class='neutral'>    /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).</span>
 2151 |     | <span class='neutral'>    /// Call this function, then emit an event, then call a function. Internally after the call, we check if</span>
 2152 |     | <span class='neutral'>    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).</span>
 2153 |     | <span class='neutral'>    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;</span>
 2154 |     | <span class='neutral'></span>
 2155 |     | <span class='neutral'>    /// Same as the previous method, but also checks supplied address against emitting contract.</span>
 2156 |     | <span class='neutral'>    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)</span>
 2157 |     | <span class='neutral'>        external;</span>
 2158 |     | <span class='neutral'></span>
 2159 |     | <span class='neutral'>    /// Prepare an expected log with all topic and data checks enabled.</span>
 2160 |     | <span class='neutral'>    /// Call this function, then emit an event, then call a function. Internally after the call, we check if</span>
 2161 |     | <span class='neutral'>    /// logs were emitted in the expected order with the expected topics and data.</span>
 2162 |     | <span class='neutral'>    function expectEmit() external;</span>
 2163 |     | <span class='neutral'></span>
 2164 |     | <span class='neutral'>    /// Same as the previous method, but also checks supplied address against emitting contract.</span>
 2165 |     | <span class='neutral'>    function expectEmit(address emitter) external;</span>
 2166 |     | <span class='neutral'></span>
 2167 |     | <span class='neutral'>    /// Expect a given number of logs with the provided topics.</span>
 2168 |     | <span class='neutral'>    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, uint64 count) external;</span>
 2169 |     | <span class='neutral'></span>
 2170 |     | <span class='neutral'>    /// Expect a given number of logs from a specific emitter with the provided topics.</span>
 2171 |     | <span class='neutral'>    function expectEmit(</span>
 2172 |     | <span class='neutral'>        bool checkTopic1,</span>
 2173 |     | <span class='neutral'>        bool checkTopic2,</span>
 2174 |     | <span class='neutral'>        bool checkTopic3,</span>
 2175 |     | <span class='neutral'>        bool checkData,</span>
 2176 |     | <span class='neutral'>        address emitter,</span>
 2177 |     | <span class='neutral'>        uint64 count</span>
 2178 |     | <span class='neutral'>    ) external;</span>
 2179 |     | <span class='neutral'></span>
 2180 |     | <span class='neutral'>    /// Expect a given number of logs with all topic and data checks enabled.</span>
 2181 |     | <span class='neutral'>    function expectEmit(uint64 count) external;</span>
 2182 |     | <span class='neutral'></span>
 2183 |     | <span class='neutral'>    /// Expect a given number of logs from a specific emitter with all topic and data checks enabled.</span>
 2184 |     | <span class='neutral'>    function expectEmit(address emitter, uint64 count) external;</span>
 2185 |     | <span class='neutral'></span>
 2186 |     | <span class='neutral'>    /// Expects an error on next call that starts with the revert data.</span>
 2187 |     | <span class='neutral'>    function expectPartialRevert(bytes4 revertData) external;</span>
 2188 |     | <span class='neutral'></span>
 2189 |     | <span class='neutral'>    /// Expects an error on next call to reverter address, that starts with the revert data.</span>
 2190 |     | <span class='neutral'>    function expectPartialRevert(bytes4 revertData, address reverter) external;</span>
 2191 |     | <span class='neutral'></span>
 2192 |     | <span class='neutral'>    /// Expects an error on next call with any revert data.</span>
 2193 |     | <span class='neutral'>    function expectRevert() external;</span>
 2194 |     | <span class='neutral'></span>
 2195 |     | <span class='neutral'>    /// Expects an error on next call that exactly matches the revert data.</span>
 2196 |     | <span class='neutral'>    function expectRevert(bytes4 revertData) external;</span>
 2197 |     | <span class='neutral'></span>
 2198 |     | <span class='neutral'>    /// Expects a `count` number of reverts from the upcoming calls from the reverter address that match the revert data.</span>
 2199 |     | <span class='neutral'>    function expectRevert(bytes4 revertData, address reverter, uint64 count) external;</span>
 2200 |     | <span class='neutral'></span>
 2201 |     | <span class='neutral'>    /// Expects a `count` number of reverts from the upcoming calls from the reverter address that exactly match the revert data.</span>
 2202 |     | <span class='neutral'>    function expectRevert(bytes calldata revertData, address reverter, uint64 count) external;</span>
 2203 |     | <span class='neutral'></span>
 2204 |     | <span class='neutral'>    /// Expects an error on next call that exactly matches the revert data.</span>
 2205 |     | <span class='neutral'>    function expectRevert(bytes calldata revertData) external;</span>
 2206 |     | <span class='neutral'></span>
 2207 |     | <span class='neutral'>    /// Expects an error with any revert data on next call to reverter address.</span>
 2208 |     | <span class='neutral'>    function expectRevert(address reverter) external;</span>
 2209 |     | <span class='neutral'></span>
 2210 |     | <span class='neutral'>    /// Expects an error from reverter address on next call, with any revert data.</span>
 2211 |     | <span class='neutral'>    function expectRevert(bytes4 revertData, address reverter) external;</span>
 2212 |     | <span class='neutral'></span>
 2213 |     | <span class='neutral'>    /// Expects an error from reverter address on next call, that exactly matches the revert data.</span>
 2214 |     | <span class='neutral'>    function expectRevert(bytes calldata revertData, address reverter) external;</span>
 2215 |     | <span class='neutral'></span>
 2216 |     | <span class='neutral'>    /// Expects a `count` number of reverts from the upcoming calls with any revert data or reverter.</span>
 2217 |     | <span class='neutral'>    function expectRevert(uint64 count) external;</span>
 2218 |     | <span class='neutral'></span>
 2219 |     | <span class='neutral'>    /// Expects a `count` number of reverts from the upcoming calls that match the revert data.</span>
 2220 |     | <span class='neutral'>    function expectRevert(bytes4 revertData, uint64 count) external;</span>
 2221 |     | <span class='neutral'></span>
 2222 |     | <span class='neutral'>    /// Expects a `count` number of reverts from the upcoming calls that exactly match the revert data.</span>
 2223 |     | <span class='neutral'>    function expectRevert(bytes calldata revertData, uint64 count) external;</span>
 2224 |     | <span class='neutral'></span>
 2225 |     | <span class='neutral'>    /// Expects a `count` number of reverts from the upcoming calls from the reverter address.</span>
 2226 |     | <span class='neutral'>    function expectRevert(address reverter, uint64 count) external;</span>
 2227 |     | <span class='neutral'></span>
 2228 |     | <span class='neutral'>    /// Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the current subcontext. If any other</span>
 2229 |     | <span class='neutral'>    /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.</span>
 2230 |     | <span class='neutral'>    function expectSafeMemory(uint64 min, uint64 max) external;</span>
 2231 |     | <span class='neutral'></span>
 2232 |     | <span class='neutral'>    /// Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the next created subcontext.</span>
 2233 |     | <span class='neutral'>    /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges</span>
 2234 |     | <span class='neutral'>    /// to the set.</span>
 2235 |     | <span class='neutral'>    function expectSafeMemoryCall(uint64 min, uint64 max) external;</span>
 2236 |     | <span class='neutral'></span>
 2237 |     | <span class='neutral'>    /// Marks a test as skipped. Must be called at the top level of a test.</span>
 2238 |     | <span class='neutral'>    function skip(bool skipTest) external;</span>
 2239 |     | <span class='neutral'></span>
 2240 |     | <span class='neutral'>    /// Marks a test as skipped with a reason. Must be called at the top level of a test.</span>
 2241 |     | <span class='neutral'>    function skip(bool skipTest, string calldata reason) external;</span>
 2242 |     | <span class='neutral'></span>
 2243 |     | <span class='neutral'>    /// Stops all safe memory expectation in the current subcontext.</span>
 2244 |     | <span class='neutral'>    function stopExpectSafeMemory() external;</span>
 2245 |     | <span class='neutral'>}</span>
 2246 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/console.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='unexecuted'>library console {</span>
    5 |     | <span class='neutral'>    address constant CONSOLE_ADDRESS =</span>
    6 |     | <span class='unexecuted'>        0x000000000000000000636F6e736F6c652e6c6f67;</span>
    7 |     | <span class='neutral'></span>
    8 |     | <span class='unexecuted'>    function _sendLogPayloadImplementation(bytes memory payload) internal view {</span>
    9 |     | <span class='unexecuted'>        address consoleAddress = CONSOLE_ADDRESS;</span>
   10 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   11 |     | <span class='unexecuted'>        assembly {</span>
   12 |     | <span class='unexecuted'>            pop(</span>
   13 |     | <span class='unexecuted'>                staticcall(</span>
   14 |     | <span class='unexecuted'>                    gas(),</span>
   15 |     | <span class='unexecuted'>                    consoleAddress,</span>
   16 |     | <span class='unexecuted'>                    add(payload, 32),</span>
   17 |     | <span class='unexecuted'>                    mload(payload),</span>
   18 |     | <span class='unexecuted'>                    0,</span>
   19 |     | <span class='unexecuted'>                    0</span>
   20 |     | <span class='neutral'>                )</span>
   21 |     | <span class='neutral'>            )</span>
   22 |     | <span class='neutral'>        }</span>
   23 |     | <span class='neutral'>    }</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>    function _castToPure(</span>
   26 |     | <span class='neutral'>      function(bytes memory) internal view fnIn</span>
   27 |     | <span class='neutral'>    ) internal pure returns (function(bytes memory) pure fnOut) {</span>
   28 |     | <span class='neutral'>        assembly {</span>
   29 |     | <span class='neutral'>            fnOut := fnIn</span>
   30 |     | <span class='neutral'>        }</span>
   31 |     | <span class='neutral'>    }</span>
   32 |     | <span class='neutral'></span>
   33 |     | <span class='unexecuted'>    function _sendLogPayload(bytes memory payload) internal pure {</span>
   34 |     | <span class='unexecuted'>        _castToPure(_sendLogPayloadImplementation)(payload);</span>
   35 |     | <span class='neutral'>    }</span>
   36 |     | <span class='neutral'></span>
   37 |     | <span class='neutral'>    function log() internal pure {</span>
   38 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   39 |     | <span class='neutral'>    }</span>
   40 |     | <span class='neutral'></span>
   41 |     | <span class='neutral'>    function logInt(int256 p0) internal pure {</span>
   42 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int256)&quot;, p0));</span>
   43 |     | <span class='neutral'>    }</span>
   44 |     | <span class='neutral'></span>
   45 |     | <span class='neutral'>    function logUint(uint256 p0) internal pure {</span>
   46 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
   47 |     | <span class='neutral'>    }</span>
   48 |     | <span class='neutral'></span>
   49 |     | <span class='neutral'>    function logString(string memory p0) internal pure {</span>
   50 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   51 |     | <span class='neutral'>    }</span>
   52 |     | <span class='neutral'></span>
   53 |     | <span class='neutral'>    function logBool(bool p0) internal pure {</span>
   54 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   55 |     | <span class='neutral'>    }</span>
   56 |     | <span class='neutral'></span>
   57 |     | <span class='neutral'>    function logAddress(address p0) internal pure {</span>
   58 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   59 |     | <span class='neutral'>    }</span>
   60 |     | <span class='neutral'></span>
   61 |     | <span class='neutral'>    function logBytes(bytes memory p0) internal pure {</span>
   62 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   63 |     | <span class='neutral'>    }</span>
   64 |     | <span class='neutral'></span>
   65 |     | <span class='neutral'>    function logBytes1(bytes1 p0) internal pure {</span>
   66 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   67 |     | <span class='neutral'>    }</span>
   68 |     | <span class='neutral'></span>
   69 |     | <span class='neutral'>    function logBytes2(bytes2 p0) internal pure {</span>
   70 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   71 |     | <span class='neutral'>    }</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>    function logBytes3(bytes3 p0) internal pure {</span>
   74 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   75 |     | <span class='neutral'>    }</span>
   76 |     | <span class='neutral'></span>
   77 |     | <span class='neutral'>    function logBytes4(bytes4 p0) internal pure {</span>
   78 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   79 |     | <span class='neutral'>    }</span>
   80 |     | <span class='neutral'></span>
   81 |     | <span class='neutral'>    function logBytes5(bytes5 p0) internal pure {</span>
   82 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   83 |     | <span class='neutral'>    }</span>
   84 |     | <span class='neutral'></span>
   85 |     | <span class='neutral'>    function logBytes6(bytes6 p0) internal pure {</span>
   86 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   87 |     | <span class='neutral'>    }</span>
   88 |     | <span class='neutral'></span>
   89 |     | <span class='neutral'>    function logBytes7(bytes7 p0) internal pure {</span>
   90 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   91 |     | <span class='neutral'>    }</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'>    function logBytes8(bytes8 p0) internal pure {</span>
   94 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   95 |     | <span class='neutral'>    }</span>
   96 |     | <span class='neutral'></span>
   97 |     | <span class='neutral'>    function logBytes9(bytes9 p0) internal pure {</span>
   98 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   99 |     | <span class='neutral'>    }</span>
  100 |     | <span class='neutral'></span>
  101 |     | <span class='neutral'>    function logBytes10(bytes10 p0) internal pure {</span>
  102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
  103 |     | <span class='neutral'>    }</span>
  104 |     | <span class='neutral'></span>
  105 |     | <span class='neutral'>    function logBytes11(bytes11 p0) internal pure {</span>
  106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
  107 |     | <span class='neutral'>    }</span>
  108 |     | <span class='neutral'></span>
  109 |     | <span class='neutral'>    function logBytes12(bytes12 p0) internal pure {</span>
  110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
  111 |     | <span class='neutral'>    }</span>
  112 |     | <span class='neutral'></span>
  113 |     | <span class='neutral'>    function logBytes13(bytes13 p0) internal pure {</span>
  114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
  115 |     | <span class='neutral'>    }</span>
  116 |     | <span class='neutral'></span>
  117 |     | <span class='neutral'>    function logBytes14(bytes14 p0) internal pure {</span>
  118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
  119 |     | <span class='neutral'>    }</span>
  120 |     | <span class='neutral'></span>
  121 |     | <span class='neutral'>    function logBytes15(bytes15 p0) internal pure {</span>
  122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  123 |     | <span class='neutral'>    }</span>
  124 |     | <span class='neutral'></span>
  125 |     | <span class='neutral'>    function logBytes16(bytes16 p0) internal pure {</span>
  126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  127 |     | <span class='neutral'>    }</span>
  128 |     | <span class='neutral'></span>
  129 |     | <span class='neutral'>    function logBytes17(bytes17 p0) internal pure {</span>
  130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  131 |     | <span class='neutral'>    }</span>
  132 |     | <span class='neutral'></span>
  133 |     | <span class='neutral'>    function logBytes18(bytes18 p0) internal pure {</span>
  134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  135 |     | <span class='neutral'>    }</span>
  136 |     | <span class='neutral'></span>
  137 |     | <span class='neutral'>    function logBytes19(bytes19 p0) internal pure {</span>
  138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  139 |     | <span class='neutral'>    }</span>
  140 |     | <span class='neutral'></span>
  141 |     | <span class='neutral'>    function logBytes20(bytes20 p0) internal pure {</span>
  142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  143 |     | <span class='neutral'>    }</span>
  144 |     | <span class='neutral'></span>
  145 |     | <span class='neutral'>    function logBytes21(bytes21 p0) internal pure {</span>
  146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  147 |     | <span class='neutral'>    }</span>
  148 |     | <span class='neutral'></span>
  149 |     | <span class='neutral'>    function logBytes22(bytes22 p0) internal pure {</span>
  150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  151 |     | <span class='neutral'>    }</span>
  152 |     | <span class='neutral'></span>
  153 |     | <span class='neutral'>    function logBytes23(bytes23 p0) internal pure {</span>
  154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  155 |     | <span class='neutral'>    }</span>
  156 |     | <span class='neutral'></span>
  157 |     | <span class='neutral'>    function logBytes24(bytes24 p0) internal pure {</span>
  158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  159 |     | <span class='neutral'>    }</span>
  160 |     | <span class='neutral'></span>
  161 |     | <span class='neutral'>    function logBytes25(bytes25 p0) internal pure {</span>
  162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  163 |     | <span class='neutral'>    }</span>
  164 |     | <span class='neutral'></span>
  165 |     | <span class='neutral'>    function logBytes26(bytes26 p0) internal pure {</span>
  166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  167 |     | <span class='neutral'>    }</span>
  168 |     | <span class='neutral'></span>
  169 |     | <span class='neutral'>    function logBytes27(bytes27 p0) internal pure {</span>
  170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  171 |     | <span class='neutral'>    }</span>
  172 |     | <span class='neutral'></span>
  173 |     | <span class='neutral'>    function logBytes28(bytes28 p0) internal pure {</span>
  174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  175 |     | <span class='neutral'>    }</span>
  176 |     | <span class='neutral'></span>
  177 |     | <span class='neutral'>    function logBytes29(bytes29 p0) internal pure {</span>
  178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  179 |     | <span class='neutral'>    }</span>
  180 |     | <span class='neutral'></span>
  181 |     | <span class='neutral'>    function logBytes30(bytes30 p0) internal pure {</span>
  182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  183 |     | <span class='neutral'>    }</span>
  184 |     | <span class='neutral'></span>
  185 |     | <span class='neutral'>    function logBytes31(bytes31 p0) internal pure {</span>
  186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  187 |     | <span class='neutral'>    }</span>
  188 |     | <span class='neutral'></span>
  189 |     | <span class='neutral'>    function logBytes32(bytes32 p0) internal pure {</span>
  190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  191 |     | <span class='neutral'>    }</span>
  192 |     | <span class='neutral'></span>
  193 |     | <span class='unexecuted'>    function log(uint256 p0) internal pure {</span>
  194 |     | <span class='unexecuted'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256)&quot;, p0));</span>
  195 |     | <span class='neutral'>    }</span>
  196 |     | <span class='neutral'></span>
  197 |     | <span class='neutral'>    function log(int256 p0) internal pure {</span>
  198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int256)&quot;, p0));</span>
  199 |     | <span class='neutral'>    }</span>
  200 |     | <span class='neutral'></span>
  201 |     | <span class='unexecuted'>    function log(string memory p0) internal pure {</span>
  202 |     | <span class='unexecuted'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  203 |     | <span class='neutral'>    }</span>
  204 |     | <span class='neutral'></span>
  205 |     | <span class='neutral'>    function log(bool p0) internal pure {</span>
  206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  207 |     | <span class='neutral'>    }</span>
  208 |     | <span class='neutral'></span>
  209 |     | <span class='neutral'>    function log(address p0) internal pure {</span>
  210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  211 |     | <span class='neutral'>    }</span>
  212 |     | <span class='neutral'></span>
  213 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1) internal pure {</span>
  214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256)&quot;, p0, p1));</span>
  215 |     | <span class='neutral'>    }</span>
  216 |     | <span class='neutral'></span>
  217 |     | <span class='neutral'>    function log(uint256 p0, string memory p1) internal pure {</span>
  218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string)&quot;, p0, p1));</span>
  219 |     | <span class='neutral'>    }</span>
  220 |     | <span class='neutral'></span>
  221 |     | <span class='neutral'>    function log(uint256 p0, bool p1) internal pure {</span>
  222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool)&quot;, p0, p1));</span>
  223 |     | <span class='neutral'>    }</span>
  224 |     | <span class='neutral'></span>
  225 |     | <span class='neutral'>    function log(uint256 p0, address p1) internal pure {</span>
  226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address)&quot;, p0, p1));</span>
  227 |     | <span class='neutral'>    }</span>
  228 |     | <span class='neutral'></span>
  229 |     | <span class='neutral'>    function log(string memory p0, uint256 p1) internal pure {</span>
  230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256)&quot;, p0, p1));</span>
  231 |     | <span class='neutral'>    }</span>
  232 |     | <span class='neutral'></span>
  233 |     | <span class='neutral'>    function log(string memory p0, int256 p1) internal pure {</span>
  234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,int256)&quot;, p0, p1));</span>
  235 |     | <span class='neutral'>    }</span>
  236 |     | <span class='neutral'></span>
  237 |     | <span class='neutral'>    function log(string memory p0, string memory p1) internal pure {</span>
  238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  239 |     | <span class='neutral'>    }</span>
  240 |     | <span class='neutral'></span>
  241 |     | <span class='neutral'>    function log(string memory p0, bool p1) internal pure {</span>
  242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  243 |     | <span class='neutral'>    }</span>
  244 |     | <span class='neutral'></span>
  245 |     | <span class='neutral'>    function log(string memory p0, address p1) internal pure {</span>
  246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  247 |     | <span class='neutral'>    }</span>
  248 |     | <span class='neutral'></span>
  249 |     | <span class='neutral'>    function log(bool p0, uint256 p1) internal pure {</span>
  250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256)&quot;, p0, p1));</span>
  251 |     | <span class='neutral'>    }</span>
  252 |     | <span class='neutral'></span>
  253 |     | <span class='neutral'>    function log(bool p0, string memory p1) internal pure {</span>
  254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  255 |     | <span class='neutral'>    }</span>
  256 |     | <span class='neutral'></span>
  257 |     | <span class='neutral'>    function log(bool p0, bool p1) internal pure {</span>
  258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  259 |     | <span class='neutral'>    }</span>
  260 |     | <span class='neutral'></span>
  261 |     | <span class='neutral'>    function log(bool p0, address p1) internal pure {</span>
  262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  263 |     | <span class='neutral'>    }</span>
  264 |     | <span class='neutral'></span>
  265 |     | <span class='neutral'>    function log(address p0, uint256 p1) internal pure {</span>
  266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256)&quot;, p0, p1));</span>
  267 |     | <span class='neutral'>    }</span>
  268 |     | <span class='neutral'></span>
  269 |     | <span class='neutral'>    function log(address p0, string memory p1) internal pure {</span>
  270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  271 |     | <span class='neutral'>    }</span>
  272 |     | <span class='neutral'></span>
  273 |     | <span class='neutral'>    function log(address p0, bool p1) internal pure {</span>
  274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  275 |     | <span class='neutral'>    }</span>
  276 |     | <span class='neutral'></span>
  277 |     | <span class='neutral'>    function log(address p0, address p1) internal pure {</span>
  278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  279 |     | <span class='neutral'>    }</span>
  280 |     | <span class='neutral'></span>
  281 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {</span>
  282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256)&quot;, p0, p1, p2));</span>
  283 |     | <span class='neutral'>    }</span>
  284 |     | <span class='neutral'></span>
  285 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2) internal pure {</span>
  286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string)&quot;, p0, p1, p2));</span>
  287 |     | <span class='neutral'>    }</span>
  288 |     | <span class='neutral'></span>
  289 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2) internal pure {</span>
  290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool)&quot;, p0, p1, p2));</span>
  291 |     | <span class='neutral'>    }</span>
  292 |     | <span class='neutral'></span>
  293 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2) internal pure {</span>
  294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address)&quot;, p0, p1, p2));</span>
  295 |     | <span class='neutral'>    }</span>
  296 |     | <span class='neutral'></span>
  297 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2) internal pure {</span>
  298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256)&quot;, p0, p1, p2));</span>
  299 |     | <span class='neutral'>    }</span>
  300 |     | <span class='neutral'></span>
  301 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2) internal pure {</span>
  302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string)&quot;, p0, p1, p2));</span>
  303 |     | <span class='neutral'>    }</span>
  304 |     | <span class='neutral'></span>
  305 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2) internal pure {</span>
  306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool)&quot;, p0, p1, p2));</span>
  307 |     | <span class='neutral'>    }</span>
  308 |     | <span class='neutral'></span>
  309 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2) internal pure {</span>
  310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address)&quot;, p0, p1, p2));</span>
  311 |     | <span class='neutral'>    }</span>
  312 |     | <span class='neutral'></span>
  313 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2) internal pure {</span>
  314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256)&quot;, p0, p1, p2));</span>
  315 |     | <span class='neutral'>    }</span>
  316 |     | <span class='neutral'></span>
  317 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2) internal pure {</span>
  318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string)&quot;, p0, p1, p2));</span>
  319 |     | <span class='neutral'>    }</span>
  320 |     | <span class='neutral'></span>
  321 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2) internal pure {</span>
  322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool)&quot;, p0, p1, p2));</span>
  323 |     | <span class='neutral'>    }</span>
  324 |     | <span class='neutral'></span>
  325 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2) internal pure {</span>
  326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address)&quot;, p0, p1, p2));</span>
  327 |     | <span class='neutral'>    }</span>
  328 |     | <span class='neutral'></span>
  329 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2) internal pure {</span>
  330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256)&quot;, p0, p1, p2));</span>
  331 |     | <span class='neutral'>    }</span>
  332 |     | <span class='neutral'></span>
  333 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2) internal pure {</span>
  334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string)&quot;, p0, p1, p2));</span>
  335 |     | <span class='neutral'>    }</span>
  336 |     | <span class='neutral'></span>
  337 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2) internal pure {</span>
  338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool)&quot;, p0, p1, p2));</span>
  339 |     | <span class='neutral'>    }</span>
  340 |     | <span class='neutral'></span>
  341 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2) internal pure {</span>
  342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address)&quot;, p0, p1, p2));</span>
  343 |     | <span class='neutral'>    }</span>
  344 |     | <span class='neutral'></span>
  345 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2) internal pure {</span>
  346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256)&quot;, p0, p1, p2));</span>
  347 |     | <span class='neutral'>    }</span>
  348 |     | <span class='neutral'></span>
  349 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2) internal pure {</span>
  350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string)&quot;, p0, p1, p2));</span>
  351 |     | <span class='neutral'>    }</span>
  352 |     | <span class='neutral'></span>
  353 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2) internal pure {</span>
  354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool)&quot;, p0, p1, p2));</span>
  355 |     | <span class='neutral'>    }</span>
  356 |     | <span class='neutral'></span>
  357 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2) internal pure {</span>
  358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address)&quot;, p0, p1, p2));</span>
  359 |     | <span class='neutral'>    }</span>
  360 |     | <span class='neutral'></span>
  361 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2) internal pure {</span>
  362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256)&quot;, p0, p1, p2));</span>
  363 |     | <span class='neutral'>    }</span>
  364 |     | <span class='neutral'></span>
  365 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2) internal pure {</span>
  366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  367 |     | <span class='neutral'>    }</span>
  368 |     | <span class='neutral'></span>
  369 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2) internal pure {</span>
  370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  371 |     | <span class='neutral'>    }</span>
  372 |     | <span class='neutral'></span>
  373 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2) internal pure {</span>
  374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  375 |     | <span class='neutral'>    }</span>
  376 |     | <span class='neutral'></span>
  377 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2) internal pure {</span>
  378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256)&quot;, p0, p1, p2));</span>
  379 |     | <span class='neutral'>    }</span>
  380 |     | <span class='neutral'></span>
  381 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2) internal pure {</span>
  382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  383 |     | <span class='neutral'>    }</span>
  384 |     | <span class='neutral'></span>
  385 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2) internal pure {</span>
  386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  387 |     | <span class='neutral'>    }</span>
  388 |     | <span class='neutral'></span>
  389 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2) internal pure {</span>
  390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  391 |     | <span class='neutral'>    }</span>
  392 |     | <span class='neutral'></span>
  393 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2) internal pure {</span>
  394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256)&quot;, p0, p1, p2));</span>
  395 |     | <span class='neutral'>    }</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2) internal pure {</span>
  398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  399 |     | <span class='neutral'>    }</span>
  400 |     | <span class='neutral'></span>
  401 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2) internal pure {</span>
  402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  403 |     | <span class='neutral'>    }</span>
  404 |     | <span class='neutral'></span>
  405 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2) internal pure {</span>
  406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  407 |     | <span class='neutral'>    }</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2) internal pure {</span>
  410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256)&quot;, p0, p1, p2));</span>
  411 |     | <span class='neutral'>    }</span>
  412 |     | <span class='neutral'></span>
  413 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2) internal pure {</span>
  414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string)&quot;, p0, p1, p2));</span>
  415 |     | <span class='neutral'>    }</span>
  416 |     | <span class='neutral'></span>
  417 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2) internal pure {</span>
  418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool)&quot;, p0, p1, p2));</span>
  419 |     | <span class='neutral'>    }</span>
  420 |     | <span class='neutral'></span>
  421 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2) internal pure {</span>
  422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address)&quot;, p0, p1, p2));</span>
  423 |     | <span class='neutral'>    }</span>
  424 |     | <span class='neutral'></span>
  425 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2) internal pure {</span>
  426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256)&quot;, p0, p1, p2));</span>
  427 |     | <span class='neutral'>    }</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2) internal pure {</span>
  430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  431 |     | <span class='neutral'>    }</span>
  432 |     | <span class='neutral'></span>
  433 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2) internal pure {</span>
  434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  435 |     | <span class='neutral'>    }</span>
  436 |     | <span class='neutral'></span>
  437 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2) internal pure {</span>
  438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  439 |     | <span class='neutral'>    }</span>
  440 |     | <span class='neutral'></span>
  441 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2) internal pure {</span>
  442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256)&quot;, p0, p1, p2));</span>
  443 |     | <span class='neutral'>    }</span>
  444 |     | <span class='neutral'></span>
  445 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2) internal pure {</span>
  446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  447 |     | <span class='neutral'>    }</span>
  448 |     | <span class='neutral'></span>
  449 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal pure {</span>
  450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  451 |     | <span class='neutral'>    }</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal pure {</span>
  454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  455 |     | <span class='neutral'>    }</span>
  456 |     | <span class='neutral'></span>
  457 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2) internal pure {</span>
  458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256)&quot;, p0, p1, p2));</span>
  459 |     | <span class='neutral'>    }</span>
  460 |     | <span class='neutral'></span>
  461 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2) internal pure {</span>
  462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  463 |     | <span class='neutral'>    }</span>
  464 |     | <span class='neutral'></span>
  465 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal pure {</span>
  466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  467 |     | <span class='neutral'>    }</span>
  468 |     | <span class='neutral'></span>
  469 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal pure {</span>
  470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  471 |     | <span class='neutral'>    }</span>
  472 |     | <span class='neutral'></span>
  473 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2) internal pure {</span>
  474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256)&quot;, p0, p1, p2));</span>
  475 |     | <span class='neutral'>    }</span>
  476 |     | <span class='neutral'></span>
  477 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2) internal pure {</span>
  478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string)&quot;, p0, p1, p2));</span>
  479 |     | <span class='neutral'>    }</span>
  480 |     | <span class='neutral'></span>
  481 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2) internal pure {</span>
  482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool)&quot;, p0, p1, p2));</span>
  483 |     | <span class='neutral'>    }</span>
  484 |     | <span class='neutral'></span>
  485 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2) internal pure {</span>
  486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address)&quot;, p0, p1, p2));</span>
  487 |     | <span class='neutral'>    }</span>
  488 |     | <span class='neutral'></span>
  489 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2) internal pure {</span>
  490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256)&quot;, p0, p1, p2));</span>
  491 |     | <span class='neutral'>    }</span>
  492 |     | <span class='neutral'></span>
  493 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2) internal pure {</span>
  494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  495 |     | <span class='neutral'>    }</span>
  496 |     | <span class='neutral'></span>
  497 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2) internal pure {</span>
  498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  499 |     | <span class='neutral'>    }</span>
  500 |     | <span class='neutral'></span>
  501 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2) internal pure {</span>
  502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  503 |     | <span class='neutral'>    }</span>
  504 |     | <span class='neutral'></span>
  505 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2) internal pure {</span>
  506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256)&quot;, p0, p1, p2));</span>
  507 |     | <span class='neutral'>    }</span>
  508 |     | <span class='neutral'></span>
  509 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2) internal pure {</span>
  510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  511 |     | <span class='neutral'>    }</span>
  512 |     | <span class='neutral'></span>
  513 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal pure {</span>
  514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  515 |     | <span class='neutral'>    }</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal pure {</span>
  518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  519 |     | <span class='neutral'>    }</span>
  520 |     | <span class='neutral'></span>
  521 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2) internal pure {</span>
  522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256)&quot;, p0, p1, p2));</span>
  523 |     | <span class='neutral'>    }</span>
  524 |     | <span class='neutral'></span>
  525 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2) internal pure {</span>
  526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  527 |     | <span class='neutral'>    }</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal pure {</span>
  530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  531 |     | <span class='neutral'>    }</span>
  532 |     | <span class='neutral'></span>
  533 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal pure {</span>
  534 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  535 |     | <span class='neutral'>    }</span>
  536 |     | <span class='neutral'></span>
  537 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  538 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  539 |     | <span class='neutral'>    }</span>
  540 |     | <span class='neutral'></span>
  541 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {</span>
  542 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  543 |     | <span class='neutral'>    }</span>
  544 |     | <span class='neutral'></span>
  545 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  546 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  547 |     | <span class='neutral'>    }</span>
  548 |     | <span class='neutral'></span>
  549 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  550 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  551 |     | <span class='neutral'>    }</span>
  552 |     | <span class='neutral'></span>
  553 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {</span>
  554 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  555 |     | <span class='neutral'>    }</span>
  556 |     | <span class='neutral'></span>
  557 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {</span>
  558 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  559 |     | <span class='neutral'>    }</span>
  560 |     | <span class='neutral'></span>
  561 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {</span>
  562 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  563 |     | <span class='neutral'>    }</span>
  564 |     | <span class='neutral'></span>
  565 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {</span>
  566 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  567 |     | <span class='neutral'>    }</span>
  568 |     | <span class='neutral'></span>
  569 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  570 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  571 |     | <span class='neutral'>    }</span>
  572 |     | <span class='neutral'></span>
  573 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {</span>
  574 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  575 |     | <span class='neutral'>    }</span>
  576 |     | <span class='neutral'></span>
  577 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  578 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  579 |     | <span class='neutral'>    }</span>
  580 |     | <span class='neutral'></span>
  581 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {</span>
  582 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  583 |     | <span class='neutral'>    }</span>
  584 |     | <span class='neutral'></span>
  585 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  586 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  587 |     | <span class='neutral'>    }</span>
  588 |     | <span class='neutral'></span>
  589 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {</span>
  590 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  591 |     | <span class='neutral'>    }</span>
  592 |     | <span class='neutral'></span>
  593 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {</span>
  594 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  595 |     | <span class='neutral'>    }</span>
  596 |     | <span class='neutral'></span>
  597 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {</span>
  598 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  599 |     | <span class='neutral'>    }</span>
  600 |     | <span class='neutral'></span>
  601 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {</span>
  602 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  603 |     | <span class='neutral'>    }</span>
  604 |     | <span class='neutral'></span>
  605 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {</span>
  606 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  607 |     | <span class='neutral'>    }</span>
  608 |     | <span class='neutral'></span>
  609 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {</span>
  610 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  611 |     | <span class='neutral'>    }</span>
  612 |     | <span class='neutral'></span>
  613 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {</span>
  614 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  615 |     | <span class='neutral'>    }</span>
  616 |     | <span class='neutral'></span>
  617 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {</span>
  618 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  619 |     | <span class='neutral'>    }</span>
  620 |     | <span class='neutral'></span>
  621 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
  622 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,string)&quot;, p0, p1, p2, p3));</span>
  623 |     | <span class='neutral'>    }</span>
  624 |     | <span class='neutral'></span>
  625 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {</span>
  626 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  627 |     | <span class='neutral'>    }</span>
  628 |     | <span class='neutral'></span>
  629 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {</span>
  630 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,string,address)&quot;, p0, p1, p2, p3));</span>
  631 |     | <span class='neutral'>    }</span>
  632 |     | <span class='neutral'></span>
  633 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {</span>
  634 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  635 |     | <span class='neutral'>    }</span>
  636 |     | <span class='neutral'></span>
  637 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {</span>
  638 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  639 |     | <span class='neutral'>    }</span>
  640 |     | <span class='neutral'></span>
  641 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {</span>
  642 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  643 |     | <span class='neutral'>    }</span>
  644 |     | <span class='neutral'></span>
  645 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {</span>
  646 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  647 |     | <span class='neutral'>    }</span>
  648 |     | <span class='neutral'></span>
  649 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {</span>
  650 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  651 |     | <span class='neutral'>    }</span>
  652 |     | <span class='neutral'></span>
  653 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {</span>
  654 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,string)&quot;, p0, p1, p2, p3));</span>
  655 |     | <span class='neutral'>    }</span>
  656 |     | <span class='neutral'></span>
  657 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {</span>
  658 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  659 |     | <span class='neutral'>    }</span>
  660 |     | <span class='neutral'></span>
  661 |     | <span class='neutral'>    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {</span>
  662 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,string,address,address)&quot;, p0, p1, p2, p3));</span>
  663 |     | <span class='neutral'>    }</span>
  664 |     | <span class='neutral'></span>
  665 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  666 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  667 |     | <span class='neutral'>    }</span>
  668 |     | <span class='neutral'></span>
  669 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {</span>
  670 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  671 |     | <span class='neutral'>    }</span>
  672 |     | <span class='neutral'></span>
  673 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  674 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  675 |     | <span class='neutral'>    }</span>
  676 |     | <span class='neutral'></span>
  677 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {</span>
  678 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  679 |     | <span class='neutral'>    }</span>
  680 |     | <span class='neutral'></span>
  681 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {</span>
  682 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  683 |     | <span class='neutral'>    }</span>
  684 |     | <span class='neutral'></span>
  685 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {</span>
  686 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  687 |     | <span class='neutral'>    }</span>
  688 |     | <span class='neutral'></span>
  689 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {</span>
  690 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  691 |     | <span class='neutral'>    }</span>
  692 |     | <span class='neutral'></span>
  693 |     | <span class='neutral'>    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {</span>
  694 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  695 |     | <span class='neutral'>    }</span>
  696 |     | <span class='neutral'></span>
  697 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  698 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  699 |     | <span class='neutral'>    }</span>
  700 |     | <span class='neutral'></span>
  701 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {</span>
  702 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  703 |     | <span class='neutral'>    }</span>
  704 |     | <span class='neutral'></span>
  705 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {</span>
  706 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  707 |     | <span class='neutral'>    }</span>
  708 |     | <span class='neutral'></span>
  709 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {</span>
  710 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  711 |     | <span class='neutral'>    }</span>
  712 |     | <span class='neutral'></span>
  713 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {</span>
  714 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  715 |     | <span class='neutral'>    }</span>
  716 |     | <span class='neutral'></span>
  717 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {</span>
  718 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  719 |     | <span class='neutral'>    }</span>
  720 |     | <span class='neutral'></span>
  721 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {</span>
  722 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  723 |     | <span class='neutral'>    }</span>
  724 |     | <span class='neutral'></span>
  725 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, address p3) internal pure {</span>
  726 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  727 |     | <span class='neutral'>    }</span>
  728 |     | <span class='neutral'></span>
  729 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  730 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  731 |     | <span class='neutral'>    }</span>
  732 |     | <span class='neutral'></span>
  733 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {</span>
  734 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  735 |     | <span class='neutral'>    }</span>
  736 |     | <span class='neutral'></span>
  737 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {</span>
  738 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  739 |     | <span class='neutral'>    }</span>
  740 |     | <span class='neutral'></span>
  741 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {</span>
  742 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  743 |     | <span class='neutral'>    }</span>
  744 |     | <span class='neutral'></span>
  745 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {</span>
  746 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
  747 |     | <span class='neutral'>    }</span>
  748 |     | <span class='neutral'></span>
  749 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {</span>
  750 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,string)&quot;, p0, p1, p2, p3));</span>
  751 |     | <span class='neutral'>    }</span>
  752 |     | <span class='neutral'></span>
  753 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {</span>
  754 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  755 |     | <span class='neutral'>    }</span>
  756 |     | <span class='neutral'></span>
  757 |     | <span class='neutral'>    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {</span>
  758 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,string,address)&quot;, p0, p1, p2, p3));</span>
  759 |     | <span class='neutral'>    }</span>
  760 |     | <span class='neutral'></span>
  761 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {</span>
  762 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  763 |     | <span class='neutral'>    }</span>
  764 |     | <span class='neutral'></span>
  765 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {</span>
  766 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  767 |     | <span class='neutral'>    }</span>
  768 |     | <span class='neutral'></span>
  769 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {</span>
  770 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  771 |     | <span class='neutral'>    }</span>
  772 |     | <span class='neutral'></span>
  773 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, address p3) internal pure {</span>
  774 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  775 |     | <span class='neutral'>    }</span>
  776 |     | <span class='neutral'></span>
  777 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {</span>
  778 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
  779 |     | <span class='neutral'>    }</span>
  780 |     | <span class='neutral'></span>
  781 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {</span>
  782 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,string)&quot;, p0, p1, p2, p3));</span>
  783 |     | <span class='neutral'>    }</span>
  784 |     | <span class='neutral'></span>
  785 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, bool p3) internal pure {</span>
  786 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  787 |     | <span class='neutral'>    }</span>
  788 |     | <span class='neutral'></span>
  789 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, address p3) internal pure {</span>
  790 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint256,address,address,address)&quot;, p0, p1, p2, p3));</span>
  791 |     | <span class='neutral'>    }</span>
  792 |     | <span class='neutral'></span>
  793 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  794 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  795 |     | <span class='neutral'>    }</span>
  796 |     | <span class='neutral'></span>
  797 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {</span>
  798 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
  799 |     | <span class='neutral'>    }</span>
  800 |     | <span class='neutral'></span>
  801 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  802 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  803 |     | <span class='neutral'>    }</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  806 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
  807 |     | <span class='neutral'>    }</span>
  808 |     | <span class='neutral'></span>
  809 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {</span>
  810 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
  811 |     | <span class='neutral'>    }</span>
  812 |     | <span class='neutral'></span>
  813 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {</span>
  814 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
  815 |     | <span class='neutral'>    }</span>
  816 |     | <span class='neutral'></span>
  817 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {</span>
  818 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
  819 |     | <span class='neutral'>    }</span>
  820 |     | <span class='neutral'></span>
  821 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {</span>
  822 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
  823 |     | <span class='neutral'>    }</span>
  824 |     | <span class='neutral'></span>
  825 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  826 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  827 |     | <span class='neutral'>    }</span>
  828 |     | <span class='neutral'></span>
  829 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {</span>
  830 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
  831 |     | <span class='neutral'>    }</span>
  832 |     | <span class='neutral'></span>
  833 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  834 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
  835 |     | <span class='neutral'>    }</span>
  836 |     | <span class='neutral'></span>
  837 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {</span>
  838 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
  839 |     | <span class='neutral'>    }</span>
  840 |     | <span class='neutral'></span>
  841 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  842 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
  843 |     | <span class='neutral'>    }</span>
  844 |     | <span class='neutral'></span>
  845 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {</span>
  846 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
  847 |     | <span class='neutral'>    }</span>
  848 |     | <span class='neutral'></span>
  849 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {</span>
  850 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
  851 |     | <span class='neutral'>    }</span>
  852 |     | <span class='neutral'></span>
  853 |     | <span class='neutral'>    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {</span>
  854 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
  855 |     | <span class='neutral'>    }</span>
  856 |     | <span class='neutral'></span>
  857 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {</span>
  858 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  859 |     | <span class='neutral'>    }</span>
  860 |     | <span class='neutral'></span>
  861 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {</span>
  862 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
  863 |     | <span class='neutral'>    }</span>
  864 |     | <span class='neutral'></span>
  865 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {</span>
  866 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  867 |     | <span class='neutral'>    }</span>
  868 |     | <span class='neutral'></span>
  869 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {</span>
  870 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
  871 |     | <span class='neutral'>    }</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {</span>
  874 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
  875 |     | <span class='neutral'>    }</span>
  876 |     | <span class='neutral'></span>
  877 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
  878 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  879 |     | <span class='neutral'>    }</span>
  880 |     | <span class='neutral'></span>
  881 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {</span>
  882 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  883 |     | <span class='neutral'>    }</span>
  884 |     | <span class='neutral'></span>
  885 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {</span>
  886 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  887 |     | <span class='neutral'>    }</span>
  888 |     | <span class='neutral'></span>
  889 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {</span>
  890 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  891 |     | <span class='neutral'>    }</span>
  892 |     | <span class='neutral'></span>
  893 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {</span>
  894 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  895 |     | <span class='neutral'>    }</span>
  896 |     | <span class='neutral'></span>
  897 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {</span>
  898 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  899 |     | <span class='neutral'>    }</span>
  900 |     | <span class='neutral'></span>
  901 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {</span>
  902 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  903 |     | <span class='neutral'>    }</span>
  904 |     | <span class='neutral'></span>
  905 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {</span>
  906 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
  907 |     | <span class='neutral'>    }</span>
  908 |     | <span class='neutral'></span>
  909 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {</span>
  910 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  911 |     | <span class='neutral'>    }</span>
  912 |     | <span class='neutral'></span>
  913 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {</span>
  914 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  915 |     | <span class='neutral'>    }</span>
  916 |     | <span class='neutral'></span>
  917 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, address p3) internal pure {</span>
  918 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  919 |     | <span class='neutral'>    }</span>
  920 |     | <span class='neutral'></span>
  921 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  922 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  923 |     | <span class='neutral'>    }</span>
  924 |     | <span class='neutral'></span>
  925 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {</span>
  926 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
  927 |     | <span class='neutral'>    }</span>
  928 |     | <span class='neutral'></span>
  929 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  930 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  931 |     | <span class='neutral'>    }</span>
  932 |     | <span class='neutral'></span>
  933 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {</span>
  934 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
  935 |     | <span class='neutral'>    }</span>
  936 |     | <span class='neutral'></span>
  937 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {</span>
  938 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
  939 |     | <span class='neutral'>    }</span>
  940 |     | <span class='neutral'></span>
  941 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {</span>
  942 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  943 |     | <span class='neutral'>    }</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {</span>
  946 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  947 |     | <span class='neutral'>    }</span>
  948 |     | <span class='neutral'></span>
  949 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {</span>
  950 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  951 |     | <span class='neutral'>    }</span>
  952 |     | <span class='neutral'></span>
  953 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  954 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
  955 |     | <span class='neutral'>    }</span>
  956 |     | <span class='neutral'></span>
  957 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {</span>
  958 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  959 |     | <span class='neutral'>    }</span>
  960 |     | <span class='neutral'></span>
  961 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {</span>
  962 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  963 |     | <span class='neutral'>    }</span>
  964 |     | <span class='neutral'></span>
  965 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, address p3) internal pure {</span>
  966 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  967 |     | <span class='neutral'>    }</span>
  968 |     | <span class='neutral'></span>
  969 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {</span>
  970 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
  971 |     | <span class='neutral'>    }</span>
  972 |     | <span class='neutral'></span>
  973 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {</span>
  974 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  975 |     | <span class='neutral'>    }</span>
  976 |     | <span class='neutral'></span>
  977 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, bool p3) internal pure {</span>
  978 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  979 |     | <span class='neutral'>    }</span>
  980 |     | <span class='neutral'></span>
  981 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, address p3) internal pure {</span>
  982 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  983 |     | <span class='neutral'>    }</span>
  984 |     | <span class='neutral'></span>
  985 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  986 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
  987 |     | <span class='neutral'>    }</span>
  988 |     | <span class='neutral'></span>
  989 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {</span>
  990 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
  991 |     | <span class='neutral'>    }</span>
  992 |     | <span class='neutral'></span>
  993 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {</span>
  994 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
  995 |     | <span class='neutral'>    }</span>
  996 |     | <span class='neutral'></span>
  997 |     | <span class='neutral'>    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {</span>
  998 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
  999 |     | <span class='neutral'>    }</span>
 1000 |     | <span class='neutral'></span>
 1001 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {</span>
 1002 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1003 |     | <span class='neutral'>    }</span>
 1004 |     | <span class='neutral'></span>
 1005 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {</span>
 1006 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1007 |     | <span class='neutral'>    }</span>
 1008 |     | <span class='neutral'></span>
 1009 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {</span>
 1010 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1011 |     | <span class='neutral'>    }</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, address p3) internal pure {</span>
 1014 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1015 |     | <span class='neutral'>    }</span>
 1016 |     | <span class='neutral'></span>
 1017 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {</span>
 1018 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1019 |     | <span class='neutral'>    }</span>
 1020 |     | <span class='neutral'></span>
 1021 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {</span>
 1022 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1023 |     | <span class='neutral'>    }</span>
 1024 |     | <span class='neutral'></span>
 1025 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, bool p3) internal pure {</span>
 1026 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1027 |     | <span class='neutral'>    }</span>
 1028 |     | <span class='neutral'></span>
 1029 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, address p3) internal pure {</span>
 1030 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1031 |     | <span class='neutral'>    }</span>
 1032 |     | <span class='neutral'></span>
 1033 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {</span>
 1034 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1035 |     | <span class='neutral'>    }</span>
 1036 |     | <span class='neutral'></span>
 1037 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, string memory p3) internal pure {</span>
 1038 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1039 |     | <span class='neutral'>    }</span>
 1040 |     | <span class='neutral'></span>
 1041 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, bool p3) internal pure {</span>
 1042 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1043 |     | <span class='neutral'>    }</span>
 1044 |     | <span class='neutral'></span>
 1045 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, address p3) internal pure {</span>
 1046 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1047 |     | <span class='neutral'>    }</span>
 1048 |     | <span class='neutral'></span>
 1049 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
 1050 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1051 |     | <span class='neutral'>    }</span>
 1052 |     | <span class='neutral'></span>
 1053 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {</span>
 1054 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1055 |     | <span class='neutral'>    }</span>
 1056 |     | <span class='neutral'></span>
 1057 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
 1058 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1059 |     | <span class='neutral'>    }</span>
 1060 |     | <span class='neutral'></span>
 1061 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
 1062 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1063 |     | <span class='neutral'>    }</span>
 1064 |     | <span class='neutral'></span>
 1065 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {</span>
 1066 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1067 |     | <span class='neutral'>    }</span>
 1068 |     | <span class='neutral'></span>
 1069 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {</span>
 1070 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1071 |     | <span class='neutral'>    }</span>
 1072 |     | <span class='neutral'></span>
 1073 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {</span>
 1074 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1075 |     | <span class='neutral'>    }</span>
 1076 |     | <span class='neutral'></span>
 1077 |     | <span class='neutral'>    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {</span>
 1078 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1079 |     | <span class='neutral'>    }</span>
 1080 |     | <span class='neutral'></span>
 1081 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
 1082 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1083 |     | <span class='neutral'>    }</span>
 1084 |     | <span class='neutral'></span>
 1085 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {</span>
 1086 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1087 |     | <span class='neutral'>    }</span>
 1088 |     | <span class='neutral'></span>
 1089 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {</span>
 1090 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1091 |     | <span class='neutral'>    }</span>
 1092 |     | <span class='neutral'></span>
 1093 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {</span>
 1094 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1095 |     | <span class='neutral'>    }</span>
 1096 |     | <span class='neutral'></span>
 1097 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
 1098 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1099 |     | <span class='neutral'>    }</span>
 1100 |     | <span class='neutral'></span>
 1101 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {</span>
 1102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1103 |     | <span class='neutral'>    }</span>
 1104 |     | <span class='neutral'></span>
 1105 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {</span>
 1106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1107 |     | <span class='neutral'>    }</span>
 1108 |     | <span class='neutral'></span>
 1109 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, address p3) internal pure {</span>
 1110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1111 |     | <span class='neutral'>    }</span>
 1112 |     | <span class='neutral'></span>
 1113 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {</span>
 1114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1115 |     | <span class='neutral'>    }</span>
 1116 |     | <span class='neutral'></span>
 1117 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {</span>
 1118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1119 |     | <span class='neutral'>    }</span>
 1120 |     | <span class='neutral'></span>
 1121 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {</span>
 1122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1123 |     | <span class='neutral'>    }</span>
 1124 |     | <span class='neutral'></span>
 1125 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {</span>
 1126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1127 |     | <span class='neutral'>    }</span>
 1128 |     | <span class='neutral'></span>
 1129 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {</span>
 1130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1131 |     | <span class='neutral'>    }</span>
 1132 |     | <span class='neutral'></span>
 1133 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
 1134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1135 |     | <span class='neutral'>    }</span>
 1136 |     | <span class='neutral'></span>
 1137 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {</span>
 1138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1139 |     | <span class='neutral'>    }</span>
 1140 |     | <span class='neutral'></span>
 1141 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {</span>
 1142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1143 |     | <span class='neutral'>    }</span>
 1144 |     | <span class='neutral'></span>
 1145 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {</span>
 1146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1147 |     | <span class='neutral'>    }</span>
 1148 |     | <span class='neutral'></span>
 1149 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {</span>
 1150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1151 |     | <span class='neutral'>    }</span>
 1152 |     | <span class='neutral'></span>
 1153 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {</span>
 1154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1155 |     | <span class='neutral'>    }</span>
 1156 |     | <span class='neutral'></span>
 1157 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, address p3) internal pure {</span>
 1158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1159 |     | <span class='neutral'>    }</span>
 1160 |     | <span class='neutral'></span>
 1161 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {</span>
 1162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1163 |     | <span class='neutral'>    }</span>
 1164 |     | <span class='neutral'></span>
 1165 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {</span>
 1166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1167 |     | <span class='neutral'>    }</span>
 1168 |     | <span class='neutral'></span>
 1169 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, bool p3) internal pure {</span>
 1170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1171 |     | <span class='neutral'>    }</span>
 1172 |     | <span class='neutral'></span>
 1173 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, address p3) internal pure {</span>
 1174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1175 |     | <span class='neutral'>    }</span>
 1176 |     | <span class='neutral'></span>
 1177 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
 1178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1179 |     | <span class='neutral'>    }</span>
 1180 |     | <span class='neutral'></span>
 1181 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {</span>
 1182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1183 |     | <span class='neutral'>    }</span>
 1184 |     | <span class='neutral'></span>
 1185 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {</span>
 1186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1187 |     | <span class='neutral'>    }</span>
 1188 |     | <span class='neutral'></span>
 1189 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {</span>
 1190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1191 |     | <span class='neutral'>    }</span>
 1192 |     | <span class='neutral'></span>
 1193 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {</span>
 1194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1195 |     | <span class='neutral'>    }</span>
 1196 |     | <span class='neutral'></span>
 1197 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {</span>
 1198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1199 |     | <span class='neutral'>    }</span>
 1200 |     | <span class='neutral'></span>
 1201 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {</span>
 1202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1203 |     | <span class='neutral'>    }</span>
 1204 |     | <span class='neutral'></span>
 1205 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, address p3) internal pure {</span>
 1206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1207 |     | <span class='neutral'>    }</span>
 1208 |     | <span class='neutral'></span>
 1209 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {</span>
 1210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1211 |     | <span class='neutral'>    }</span>
 1212 |     | <span class='neutral'></span>
 1213 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {</span>
 1214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1215 |     | <span class='neutral'>    }</span>
 1216 |     | <span class='neutral'></span>
 1217 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal pure {</span>
 1218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1219 |     | <span class='neutral'>    }</span>
 1220 |     | <span class='neutral'></span>
 1221 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal pure {</span>
 1222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1223 |     | <span class='neutral'>    }</span>
 1224 |     | <span class='neutral'></span>
 1225 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {</span>
 1226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1227 |     | <span class='neutral'>    }</span>
 1228 |     | <span class='neutral'></span>
 1229 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, string memory p3) internal pure {</span>
 1230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1231 |     | <span class='neutral'>    }</span>
 1232 |     | <span class='neutral'></span>
 1233 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal pure {</span>
 1234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1235 |     | <span class='neutral'>    }</span>
 1236 |     | <span class='neutral'></span>
 1237 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal pure {</span>
 1238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1239 |     | <span class='neutral'>    }</span>
 1240 |     | <span class='neutral'></span>
 1241 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
 1242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1243 |     | <span class='neutral'>    }</span>
 1244 |     | <span class='neutral'></span>
 1245 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {</span>
 1246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1247 |     | <span class='neutral'>    }</span>
 1248 |     | <span class='neutral'></span>
 1249 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {</span>
 1250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1251 |     | <span class='neutral'>    }</span>
 1252 |     | <span class='neutral'></span>
 1253 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, address p3) internal pure {</span>
 1254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1255 |     | <span class='neutral'>    }</span>
 1256 |     | <span class='neutral'></span>
 1257 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {</span>
 1258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1259 |     | <span class='neutral'>    }</span>
 1260 |     | <span class='neutral'></span>
 1261 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {</span>
 1262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1263 |     | <span class='neutral'>    }</span>
 1264 |     | <span class='neutral'></span>
 1265 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, bool p3) internal pure {</span>
 1266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1267 |     | <span class='neutral'>    }</span>
 1268 |     | <span class='neutral'></span>
 1269 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, address p3) internal pure {</span>
 1270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1271 |     | <span class='neutral'>    }</span>
 1272 |     | <span class='neutral'></span>
 1273 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {</span>
 1274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1275 |     | <span class='neutral'>    }</span>
 1276 |     | <span class='neutral'></span>
 1277 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, string memory p3) internal pure {</span>
 1278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1279 |     | <span class='neutral'>    }</span>
 1280 |     | <span class='neutral'></span>
 1281 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal pure {</span>
 1282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1283 |     | <span class='neutral'>    }</span>
 1284 |     | <span class='neutral'></span>
 1285 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal pure {</span>
 1286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1287 |     | <span class='neutral'>    }</span>
 1288 |     | <span class='neutral'></span>
 1289 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint256 p3) internal pure {</span>
 1290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1291 |     | <span class='neutral'>    }</span>
 1292 |     | <span class='neutral'></span>
 1293 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, string memory p3) internal pure {</span>
 1294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1295 |     | <span class='neutral'>    }</span>
 1296 |     | <span class='neutral'></span>
 1297 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal pure {</span>
 1298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1299 |     | <span class='neutral'>    }</span>
 1300 |     | <span class='neutral'></span>
 1301 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal pure {</span>
 1302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1303 |     | <span class='neutral'>    }</span>
 1304 |     | <span class='neutral'></span>
 1305 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
 1306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1307 |     | <span class='neutral'>    }</span>
 1308 |     | <span class='neutral'></span>
 1309 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {</span>
 1310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1311 |     | <span class='neutral'>    }</span>
 1312 |     | <span class='neutral'></span>
 1313 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
 1314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1315 |     | <span class='neutral'>    }</span>
 1316 |     | <span class='neutral'></span>
 1317 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
 1318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1319 |     | <span class='neutral'>    }</span>
 1320 |     | <span class='neutral'></span>
 1321 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {</span>
 1322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1323 |     | <span class='neutral'>    }</span>
 1324 |     | <span class='neutral'></span>
 1325 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {</span>
 1326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,string)&quot;, p0, p1, p2, p3));</span>
 1327 |     | <span class='neutral'>    }</span>
 1328 |     | <span class='neutral'></span>
 1329 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {</span>
 1330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,bool)&quot;, p0, p1, p2, p3));</span>
 1331 |     | <span class='neutral'>    }</span>
 1332 |     | <span class='neutral'></span>
 1333 |     | <span class='neutral'>    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {</span>
 1334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,string,address)&quot;, p0, p1, p2, p3));</span>
 1335 |     | <span class='neutral'>    }</span>
 1336 |     | <span class='neutral'></span>
 1337 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
 1338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1339 |     | <span class='neutral'>    }</span>
 1340 |     | <span class='neutral'></span>
 1341 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {</span>
 1342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,string)&quot;, p0, p1, p2, p3));</span>
 1343 |     | <span class='neutral'>    }</span>
 1344 |     | <span class='neutral'></span>
 1345 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {</span>
 1346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1347 |     | <span class='neutral'>    }</span>
 1348 |     | <span class='neutral'></span>
 1349 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, address p3) internal pure {</span>
 1350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,bool,address)&quot;, p0, p1, p2, p3));</span>
 1351 |     | <span class='neutral'>    }</span>
 1352 |     | <span class='neutral'></span>
 1353 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
 1354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1355 |     | <span class='neutral'>    }</span>
 1356 |     | <span class='neutral'></span>
 1357 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {</span>
 1358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,string)&quot;, p0, p1, p2, p3));</span>
 1359 |     | <span class='neutral'>    }</span>
 1360 |     | <span class='neutral'></span>
 1361 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, bool p3) internal pure {</span>
 1362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,bool)&quot;, p0, p1, p2, p3));</span>
 1363 |     | <span class='neutral'>    }</span>
 1364 |     | <span class='neutral'></span>
 1365 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, address p3) internal pure {</span>
 1366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint256,address,address)&quot;, p0, p1, p2, p3));</span>
 1367 |     | <span class='neutral'>    }</span>
 1368 |     | <span class='neutral'></span>
 1369 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {</span>
 1370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1371 |     | <span class='neutral'>    }</span>
 1372 |     | <span class='neutral'></span>
 1373 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {</span>
 1374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1375 |     | <span class='neutral'>    }</span>
 1376 |     | <span class='neutral'></span>
 1377 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {</span>
 1378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1379 |     | <span class='neutral'>    }</span>
 1380 |     | <span class='neutral'></span>
 1381 |     | <span class='neutral'>    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {</span>
 1382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1383 |     | <span class='neutral'>    }</span>
 1384 |     | <span class='neutral'></span>
 1385 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {</span>
 1386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1387 |     | <span class='neutral'>    }</span>
 1388 |     | <span class='neutral'></span>
 1389 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
 1390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1391 |     | <span class='neutral'>    }</span>
 1392 |     | <span class='neutral'></span>
 1393 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {</span>
 1394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1395 |     | <span class='neutral'>    }</span>
 1396 |     | <span class='neutral'></span>
 1397 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, address p3) internal pure {</span>
 1398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1399 |     | <span class='neutral'>    }</span>
 1400 |     | <span class='neutral'></span>
 1401 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {</span>
 1402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1403 |     | <span class='neutral'>    }</span>
 1404 |     | <span class='neutral'></span>
 1405 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {</span>
 1406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1407 |     | <span class='neutral'>    }</span>
 1408 |     | <span class='neutral'></span>
 1409 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, bool p3) internal pure {</span>
 1410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1411 |     | <span class='neutral'>    }</span>
 1412 |     | <span class='neutral'></span>
 1413 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, address p3) internal pure {</span>
 1414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1415 |     | <span class='neutral'>    }</span>
 1416 |     | <span class='neutral'></span>
 1417 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {</span>
 1418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1419 |     | <span class='neutral'>    }</span>
 1420 |     | <span class='neutral'></span>
 1421 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, string memory p3) internal pure {</span>
 1422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1423 |     | <span class='neutral'>    }</span>
 1424 |     | <span class='neutral'></span>
 1425 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, bool p3) internal pure {</span>
 1426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1427 |     | <span class='neutral'>    }</span>
 1428 |     | <span class='neutral'></span>
 1429 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, address p3) internal pure {</span>
 1430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1431 |     | <span class='neutral'>    }</span>
 1432 |     | <span class='neutral'></span>
 1433 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
 1434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1435 |     | <span class='neutral'>    }</span>
 1436 |     | <span class='neutral'></span>
 1437 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {</span>
 1438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1439 |     | <span class='neutral'>    }</span>
 1440 |     | <span class='neutral'></span>
 1441 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {</span>
 1442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1443 |     | <span class='neutral'>    }</span>
 1444 |     | <span class='neutral'></span>
 1445 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, address p3) internal pure {</span>
 1446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1447 |     | <span class='neutral'>    }</span>
 1448 |     | <span class='neutral'></span>
 1449 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {</span>
 1450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1451 |     | <span class='neutral'>    }</span>
 1452 |     | <span class='neutral'></span>
 1453 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {</span>
 1454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1455 |     | <span class='neutral'>    }</span>
 1456 |     | <span class='neutral'></span>
 1457 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, bool p3) internal pure {</span>
 1458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1459 |     | <span class='neutral'>    }</span>
 1460 |     | <span class='neutral'></span>
 1461 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, address p3) internal pure {</span>
 1462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1463 |     | <span class='neutral'>    }</span>
 1464 |     | <span class='neutral'></span>
 1465 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {</span>
 1466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1467 |     | <span class='neutral'>    }</span>
 1468 |     | <span class='neutral'></span>
 1469 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, string memory p3) internal pure {</span>
 1470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1471 |     | <span class='neutral'>    }</span>
 1472 |     | <span class='neutral'></span>
 1473 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal pure {</span>
 1474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1475 |     | <span class='neutral'>    }</span>
 1476 |     | <span class='neutral'></span>
 1477 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal pure {</span>
 1478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1479 |     | <span class='neutral'>    }</span>
 1480 |     | <span class='neutral'></span>
 1481 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint256 p3) internal pure {</span>
 1482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1483 |     | <span class='neutral'>    }</span>
 1484 |     | <span class='neutral'></span>
 1485 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, string memory p3) internal pure {</span>
 1486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1487 |     | <span class='neutral'>    }</span>
 1488 |     | <span class='neutral'></span>
 1489 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal pure {</span>
 1490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1491 |     | <span class='neutral'>    }</span>
 1492 |     | <span class='neutral'></span>
 1493 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal pure {</span>
 1494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1495 |     | <span class='neutral'>    }</span>
 1496 |     | <span class='neutral'></span>
 1497 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
 1498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,uint256)&quot;, p0, p1, p2, p3));</span>
 1499 |     | <span class='neutral'>    }</span>
 1500 |     | <span class='neutral'></span>
 1501 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {</span>
 1502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,string)&quot;, p0, p1, p2, p3));</span>
 1503 |     | <span class='neutral'>    }</span>
 1504 |     | <span class='neutral'></span>
 1505 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, bool p3) internal pure {</span>
 1506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,bool)&quot;, p0, p1, p2, p3));</span>
 1507 |     | <span class='neutral'>    }</span>
 1508 |     | <span class='neutral'></span>
 1509 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, address p3) internal pure {</span>
 1510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint256,address)&quot;, p0, p1, p2, p3));</span>
 1511 |     | <span class='neutral'>    }</span>
 1512 |     | <span class='neutral'></span>
 1513 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {</span>
 1514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint256)&quot;, p0, p1, p2, p3));</span>
 1515 |     | <span class='neutral'>    }</span>
 1516 |     | <span class='neutral'></span>
 1517 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, string memory p3) internal pure {</span>
 1518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1519 |     | <span class='neutral'>    }</span>
 1520 |     | <span class='neutral'></span>
 1521 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, bool p3) internal pure {</span>
 1522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1523 |     | <span class='neutral'>    }</span>
 1524 |     | <span class='neutral'></span>
 1525 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, address p3) internal pure {</span>
 1526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1527 |     | <span class='neutral'>    }</span>
 1528 |     | <span class='neutral'></span>
 1529 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint256 p3) internal pure {</span>
 1530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint256)&quot;, p0, p1, p2, p3));</span>
 1531 |     | <span class='neutral'>    }</span>
 1532 |     | <span class='neutral'></span>
 1533 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, string memory p3) internal pure {</span>
 1534 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1535 |     | <span class='neutral'>    }</span>
 1536 |     | <span class='neutral'></span>
 1537 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal pure {</span>
 1538 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1539 |     | <span class='neutral'>    }</span>
 1540 |     | <span class='neutral'></span>
 1541 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal pure {</span>
 1542 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1543 |     | <span class='neutral'>    }</span>
 1544 |     | <span class='neutral'></span>
 1545 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint256 p3) internal pure {</span>
 1546 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint256)&quot;, p0, p1, p2, p3));</span>
 1547 |     | <span class='neutral'>    }</span>
 1548 |     | <span class='neutral'></span>
 1549 |     | <span class='neutral'>    function log(address p0, address p1, address p2, string memory p3) internal pure {</span>
 1550 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1551 |     | <span class='neutral'>    }</span>
 1552 |     | <span class='neutral'></span>
 1553 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal pure {</span>
 1554 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1555 |     | <span class='neutral'>    }</span>
 1556 |     | <span class='neutral'></span>
 1557 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal pure {</span>
 1558 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1559 |     | <span class='neutral'>    }</span>
 1560 |     | <span class='neutral'>}</span>
 1561 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/console2.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>import {console as console2} from &quot;./console.sol&quot;;</span>
 5 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/interfaces/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IERC165 {</span>
  5 |     | <span class='neutral'>    /// @notice Query if a contract implements an interface</span>
  6 |     | <span class='neutral'>    /// @param interfaceID The interface identifier, as specified in ERC-165</span>
  7 |     | <span class='neutral'>    /// @dev Interface identification is specified in ERC-165. This function</span>
  8 |     | <span class='neutral'>    /// uses less than 30,000 gas.</span>
  9 |     | <span class='neutral'>    /// @return `true` if the contract implements `interfaceID` and</span>
 10 |     | <span class='neutral'>    /// `interfaceID` is not 0xffffffff, `false` otherwise</span>
 11 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceID) external view returns (bool);</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/interfaces/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @dev Interface of the ERC20 standard as defined in the EIP.</span>
  5 |     | <span class='neutral'>/// @dev This includes the optional name, symbol, and decimals metadata.</span>
  6 |     | <span class='neutral'>interface IERC20 {</span>
  7 |     | <span class='neutral'>    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).</span>
  8 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`</span>
 11 |     | <span class='neutral'>    /// is the new allowance.</span>
 12 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /// @notice Returns the amount of tokens in existence.</span>
 15 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /// @notice Returns the amount of tokens owned by `account`.</span>
 18 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /// @notice Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 21 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice Returns the remaining number of tokens that `spender` is allowed</span>
 24 |     | <span class='neutral'>    /// to spend on behalf of `owner`</span>
 25 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    /// @notice Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 28 |     | <span class='neutral'>    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 29 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.</span>
 32 |     | <span class='neutral'>    /// `amount` is then deducted from the caller&#39;s allowance.</span>
 33 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /// @notice Returns the name of the token.</span>
 36 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    /// @notice Returns the symbol of the token.</span>
 39 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /// @notice Returns the decimals places of the token.</span>
 42 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/interfaces/IERC721.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./IERC165.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @title ERC-721 Non-Fungible Token Standard</span>
   7 |     | <span class='neutral'>/// @dev See https://eips.ethereum.org/EIPS/eip-721</span>
   8 |     | <span class='neutral'>/// Note: the ERC-165 identifier for this interface is 0x80ac58cd.</span>
   9 |     | <span class='neutral'>interface IERC721 is IERC165 {</span>
  10 |     | <span class='neutral'>    /// @dev This emits when ownership of any NFT changes by any mechanism.</span>
  11 |     | <span class='neutral'>    /// This event emits when NFTs are created (`from` == 0) and destroyed</span>
  12 |     | <span class='neutral'>    /// (`to` == 0). Exception: during contract creation, any number of NFTs</span>
  13 |     | <span class='neutral'>    /// may be created and assigned without emitting Transfer. At the time of</span>
  14 |     | <span class='neutral'>    /// any transfer, the approved address for that NFT (if any) is reset to none.</span>
  15 |     | <span class='neutral'>    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @dev This emits when the approved address for an NFT is changed or</span>
  18 |     | <span class='neutral'>    /// reaffirmed. The zero address indicates there is no approved address.</span>
  19 |     | <span class='neutral'>    /// When a Transfer event emits, this also indicates that the approved</span>
  20 |     | <span class='neutral'>    /// address for that NFT (if any) is reset to none.</span>
  21 |     | <span class='neutral'>    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /// @dev This emits when an operator is enabled or disabled for an owner.</span>
  24 |     | <span class='neutral'>    /// The operator can manage all NFTs of the owner.</span>
  25 |     | <span class='neutral'>    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /// @notice Count all NFTs assigned to an owner</span>
  28 |     | <span class='neutral'>    /// @dev NFTs assigned to the zero address are considered invalid, and this</span>
  29 |     | <span class='neutral'>    /// function throws for queries about the zero address.</span>
  30 |     | <span class='neutral'>    /// @param _owner An address for whom to query the balance</span>
  31 |     | <span class='neutral'>    /// @return The number of NFTs owned by `_owner`, possibly zero</span>
  32 |     | <span class='neutral'>    function balanceOf(address _owner) external view returns (uint256);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /// @notice Find the owner of an NFT</span>
  35 |     | <span class='neutral'>    /// @dev NFTs assigned to zero address are considered invalid, and queries</span>
  36 |     | <span class='neutral'>    /// about them do throw.</span>
  37 |     | <span class='neutral'>    /// @param _tokenId The identifier for an NFT</span>
  38 |     | <span class='neutral'>    /// @return The address of the owner of the NFT</span>
  39 |     | <span class='neutral'>    function ownerOf(uint256 _tokenId) external view returns (address);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @notice Transfers the ownership of an NFT from one address to another address</span>
  42 |     | <span class='neutral'>    /// @dev Throws unless `msg.sender` is the current owner, an authorized</span>
  43 |     | <span class='neutral'>    /// operator, or the approved address for this NFT. Throws if `_from` is</span>
  44 |     | <span class='neutral'>    /// not the current owner. Throws if `_to` is the zero address. Throws if</span>
  45 |     | <span class='neutral'>    /// `_tokenId` is not a valid NFT. When transfer is complete, this function</span>
  46 |     | <span class='neutral'>    /// checks if `_to` is a smart contract (code size &gt; 0). If so, it calls</span>
  47 |     | <span class='neutral'>    /// `onERC721Received` on `_to` and throws if the return value is not</span>
  48 |     | <span class='neutral'>    /// `bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;))`.</span>
  49 |     | <span class='neutral'>    /// @param _from The current owner of the NFT</span>
  50 |     | <span class='neutral'>    /// @param _to The new owner</span>
  51 |     | <span class='neutral'>    /// @param _tokenId The NFT to transfer</span>
  52 |     | <span class='neutral'>    /// @param data Additional data with no specified format, sent in call to `_to`</span>
  53 |     | <span class='neutral'>    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /// @notice Transfers the ownership of an NFT from one address to another address</span>
  56 |     | <span class='neutral'>    /// @dev This works identically to the other function with an extra data parameter,</span>
  57 |     | <span class='neutral'>    /// except this function just sets data to &quot;&quot;.</span>
  58 |     | <span class='neutral'>    /// @param _from The current owner of the NFT</span>
  59 |     | <span class='neutral'>    /// @param _to The new owner</span>
  60 |     | <span class='neutral'>    /// @param _tokenId The NFT to transfer</span>
  61 |     | <span class='neutral'>    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE</span>
  64 |     | <span class='neutral'>    /// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE</span>
  65 |     | <span class='neutral'>    /// THEY MAY BE PERMANENTLY LOST</span>
  66 |     | <span class='neutral'>    /// @dev Throws unless `msg.sender` is the current owner, an authorized</span>
  67 |     | <span class='neutral'>    /// operator, or the approved address for this NFT. Throws if `_from` is</span>
  68 |     | <span class='neutral'>    /// not the current owner. Throws if `_to` is the zero address. Throws if</span>
  69 |     | <span class='neutral'>    /// `_tokenId` is not a valid NFT.</span>
  70 |     | <span class='neutral'>    /// @param _from The current owner of the NFT</span>
  71 |     | <span class='neutral'>    /// @param _to The new owner</span>
  72 |     | <span class='neutral'>    /// @param _tokenId The NFT to transfer</span>
  73 |     | <span class='neutral'>    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /// @notice Change or reaffirm the approved address for an NFT</span>
  76 |     | <span class='neutral'>    /// @dev The zero address indicates there is no approved address.</span>
  77 |     | <span class='neutral'>    /// Throws unless `msg.sender` is the current NFT owner, or an authorized</span>
  78 |     | <span class='neutral'>    /// operator of the current owner.</span>
  79 |     | <span class='neutral'>    /// @param _approved The new approved NFT controller</span>
  80 |     | <span class='neutral'>    /// @param _tokenId The NFT to approve</span>
  81 |     | <span class='neutral'>    function approve(address _approved, uint256 _tokenId) external payable;</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /// @notice Enable or disable approval for a third party (&quot;operator&quot;) to manage</span>
  84 |     | <span class='neutral'>    /// all of `msg.sender`&#39;s assets</span>
  85 |     | <span class='neutral'>    /// @dev Emits the ApprovalForAll event. The contract MUST allow</span>
  86 |     | <span class='neutral'>    /// multiple operators per owner.</span>
  87 |     | <span class='neutral'>    /// @param _operator Address to add to the set of authorized operators</span>
  88 |     | <span class='neutral'>    /// @param _approved True if the operator is approved, false to revoke approval</span>
  89 |     | <span class='neutral'>    function setApprovalForAll(address _operator, bool _approved) external;</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /// @notice Get the approved address for a single NFT</span>
  92 |     | <span class='neutral'>    /// @dev Throws if `_tokenId` is not a valid NFT.</span>
  93 |     | <span class='neutral'>    /// @param _tokenId The NFT to find the approved address for</span>
  94 |     | <span class='neutral'>    /// @return The approved address for this NFT, or the zero address if there is none</span>
  95 |     | <span class='neutral'>    function getApproved(uint256 _tokenId) external view returns (address);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /// @notice Query if an address is an authorized operator for another address</span>
  98 |     | <span class='neutral'>    /// @param _owner The address that owns the NFTs</span>
  99 |     | <span class='neutral'>    /// @param _operator The address that acts on behalf of the owner</span>
 100 |     | <span class='neutral'>    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise</span>
 101 |     | <span class='neutral'>    function isApprovedForAll(address _owner, address _operator) external view returns (bool);</span>
 102 |     | <span class='neutral'>}</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.</span>
 105 |     | <span class='neutral'>interface IERC721TokenReceiver {</span>
 106 |     | <span class='neutral'>    /// @notice Handle the receipt of an NFT</span>
 107 |     | <span class='neutral'>    /// @dev The ERC721 smart contract calls this function on the recipient</span>
 108 |     | <span class='neutral'>    /// after a `transfer`. This function MAY throw to revert and reject the</span>
 109 |     | <span class='neutral'>    /// transfer. Return of other than the magic value MUST result in the</span>
 110 |     | <span class='neutral'>    /// transaction being reverted.</span>
 111 |     | <span class='neutral'>    /// Note: the contract address is always the message sender.</span>
 112 |     | <span class='neutral'>    /// @param _operator The address which called `safeTransferFrom` function</span>
 113 |     | <span class='neutral'>    /// @param _from The address which previously owned the token</span>
 114 |     | <span class='neutral'>    /// @param _tokenId The NFT identifier which is being transferred</span>
 115 |     | <span class='neutral'>    /// @param _data Additional data with no specified format</span>
 116 |     | <span class='neutral'>    /// @return `bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;))`</span>
 117 |     | <span class='neutral'>    ///  unless throwing</span>
 118 |     | <span class='neutral'>    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data)</span>
 119 |     | <span class='neutral'>        external</span>
 120 |     | <span class='neutral'>        returns (bytes4);</span>
 121 |     | <span class='neutral'>}</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension</span>
 124 |     | <span class='neutral'>/// @dev See https://eips.ethereum.org/EIPS/eip-721</span>
 125 |     | <span class='neutral'>/// Note: the ERC-165 identifier for this interface is 0x5b5e139f.</span>
 126 |     | <span class='neutral'>interface IERC721Metadata is IERC721 {</span>
 127 |     | <span class='neutral'>    /// @notice A descriptive name for a collection of NFTs in this contract</span>
 128 |     | <span class='neutral'>    function name() external view returns (string memory _name);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /// @notice An abbreviated name for NFTs in this contract</span>
 131 |     | <span class='neutral'>    function symbol() external view returns (string memory _symbol);</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.</span>
 134 |     | <span class='neutral'>    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC</span>
 135 |     | <span class='neutral'>    /// 3986. The URI may point to a JSON file that conforms to the &quot;ERC721</span>
 136 |     | <span class='neutral'>    /// Metadata JSON Schema&quot;.</span>
 137 |     | <span class='neutral'>    function tokenURI(uint256 _tokenId) external view returns (string memory);</span>
 138 |     | <span class='neutral'>}</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension</span>
 141 |     | <span class='neutral'>/// @dev See https://eips.ethereum.org/EIPS/eip-721</span>
 142 |     | <span class='neutral'>/// Note: the ERC-165 identifier for this interface is 0x780e9d63.</span>
 143 |     | <span class='neutral'>interface IERC721Enumerable is IERC721 {</span>
 144 |     | <span class='neutral'>    /// @notice Count NFTs tracked by this contract</span>
 145 |     | <span class='neutral'>    /// @return A count of valid NFTs tracked by this contract, where each one of</span>
 146 |     | <span class='neutral'>    /// them has an assigned and queryable owner not equal to the zero address</span>
 147 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @notice Enumerate valid NFTs</span>
 150 |     | <span class='neutral'>    /// @dev Throws if `_index` &gt;= `totalSupply()`.</span>
 151 |     | <span class='neutral'>    /// @param _index A counter less than `totalSupply()`</span>
 152 |     | <span class='neutral'>    /// @return The token identifier for the `_index`th NFT,</span>
 153 |     | <span class='neutral'>    /// (sort order not specified)</span>
 154 |     | <span class='neutral'>    function tokenByIndex(uint256 _index) external view returns (uint256);</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    /// @notice Enumerate NFTs assigned to an owner</span>
 157 |     | <span class='neutral'>    /// @dev Throws if `_index` &gt;= `balanceOf(_owner)` or if</span>
 158 |     | <span class='neutral'>    /// `_owner` is the zero address, representing invalid NFTs.</span>
 159 |     | <span class='neutral'>    /// @param _owner An address where we are interested in NFTs owned by them</span>
 160 |     | <span class='neutral'>    /// @param _index A counter less than `balanceOf(_owner)`</span>
 161 |     | <span class='neutral'>    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,</span>
 162 |     | <span class='neutral'>    /// (sort order not specified)</span>
 163 |     | <span class='neutral'>    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);</span>
 164 |     | <span class='neutral'>}</span>
 165 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/interfaces/IMulticall3.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IMulticall3 {</span>
  7 |     | <span class='neutral'>    struct Call {</span>
  8 |     | <span class='neutral'>        address target;</span>
  9 |     | <span class='neutral'>        bytes callData;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    struct Call3 {</span>
 13 |     | <span class='neutral'>        address target;</span>
 14 |     | <span class='neutral'>        bool allowFailure;</span>
 15 |     | <span class='neutral'>        bytes callData;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    struct Call3Value {</span>
 19 |     | <span class='neutral'>        address target;</span>
 20 |     | <span class='neutral'>        bool allowFailure;</span>
 21 |     | <span class='neutral'>        uint256 value;</span>
 22 |     | <span class='neutral'>        bytes callData;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    struct Result {</span>
 26 |     | <span class='neutral'>        bool success;</span>
 27 |     | <span class='neutral'>        bytes returnData;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    function aggregate(Call[] calldata calls)</span>
 31 |     | <span class='neutral'>        external</span>
 32 |     | <span class='neutral'>        payable</span>
 33 |     | <span class='neutral'>        returns (uint256 blockNumber, bytes[] memory returnData);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    function blockAndAggregate(Call[] calldata calls)</span>
 40 |     | <span class='neutral'>        external</span>
 41 |     | <span class='neutral'>        payable</span>
 42 |     | <span class='neutral'>        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function getBasefee() external view returns (uint256 basefee);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    function getBlockNumber() external view returns (uint256 blockNumber);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function getChainId() external view returns (uint256 chainid);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    function getCurrentBlockCoinbase() external view returns (address coinbase);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>    function getEthBalance(address addr) external view returns (uint256 balance);</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    function getLastBlockHash() external view returns (bytes32 blockHash);</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>    function tryAggregate(bool requireSuccess, Call[] calldata calls)</span>
 65 |     | <span class='neutral'>        external</span>
 66 |     | <span class='neutral'>        payable</span>
 67 |     | <span class='neutral'>        returns (Result[] memory returnData);</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)</span>
 70 |     | <span class='neutral'>        external</span>
 71 |     | <span class='neutral'>        payable</span>
 72 |     | <span class='neutral'>        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);</span>
 73 |     | <span class='neutral'>}</span>
 74 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/mocks/MockERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &quot;../interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @notice This is a mock contract of the ERC20 standard for testing purposes only, it SHOULD NOT be used in production.</span>
   7 |     | <span class='neutral'>/// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC20.sol</span>
   8 |     | <span class='unexecuted'>contract MockERC20 is IERC20 {</span>
   9 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  10 |     | <span class='neutral'>                            METADATA STORAGE</span>
  11 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    string internal _name;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    string internal _symbol;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    uint8 internal _decimals;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>    function name() external view override returns (string memory) {</span>
  20 |     | <span class='unexecuted'>        return _name;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function symbol() external view override returns (string memory) {</span>
  24 |     | <span class='unexecuted'>        return _symbol;</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>    function decimals() external view override returns (uint8) {</span>
  28 |     | <span class='unexecuted'>        return _decimals;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  32 |     | <span class='neutral'>                              ERC20 STORAGE</span>
  33 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    uint256 internal _totalSupply;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    mapping(address =&gt; uint256) internal _balanceOf;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) internal _allowance;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>    function totalSupply() external view override returns (uint256) {</span>
  42 |     | <span class='unexecuted'>        return _totalSupply;</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>    function balanceOf(address owner) external view override returns (uint256) {</span>
  46 |     | <span class='unexecuted'>        return _balanceOf[owner];</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    function allowance(address owner, address spender) external view override returns (uint256) {</span>
  50 |     | <span class='unexecuted'>        return _allowance[owner][spender];</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  54 |     | <span class='neutral'>                            EIP-2612 STORAGE</span>
  55 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    uint256 internal INITIAL_CHAIN_ID;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    bytes32 internal INITIAL_DOMAIN_SEPARATOR;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public nonces;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  64 |     | <span class='neutral'>                               INITIALIZE</span>
  65 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /// @dev A bool to track whether the contract has been initialized.</span>
  68 |     | <span class='neutral'>    bool private initialized;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and</span>
  71 |     | <span class='neutral'>    /// syntaxes, we add an initialization function that can be called only once.</span>
  72 |     | <span class='unexecuted'>    function initialize(string memory name_, string memory symbol_, uint8 decimals_) public {</span>
  73 |     | <span class='unexecuted'>        require(!initialized, &quot;ALREADY_INITIALIZED&quot;);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        _name = name_;</span>
  76 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  77 |     | <span class='unexecuted'>        _decimals = decimals_;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>        INITIAL_CHAIN_ID = _pureChainId();</span>
  80 |     | <span class='unexecuted'>        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        initialized = true;</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  86 |     | <span class='neutral'>                               ERC20 LOGIC</span>
  87 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
  90 |     | <span class='unexecuted'>        _allowance[msg.sender][spender] = amount;</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>        emit Approval(msg.sender, spender, amount);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        return true;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
  98 |     | <span class='unexecuted'>        _balanceOf[msg.sender] = _sub(_balanceOf[msg.sender], amount);</span>
  99 |     | <span class='unexecuted'>        _balanceOf[to] = _add(_balanceOf[to], amount);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>        emit Transfer(msg.sender, to, amount);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>        return true;</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {</span>
 107 |     | <span class='unexecuted'>        uint256 allowed = _allowance[from][msg.sender]; // Saves gas for limited approvals.</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        if (allowed != ~uint256(0)) _allowance[from][msg.sender] = _sub(allowed, amount);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        _balanceOf[from] = _sub(_balanceOf[from], amount);</span>
 112 |     | <span class='unexecuted'>        _balanceOf[to] = _add(_balanceOf[to], amount);</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>        emit Transfer(from, to, amount);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 120 |     | <span class='neutral'>                             EIP-2612 LOGIC</span>
 121 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)</span>
 124 |     | <span class='neutral'>        public</span>
 125 |     | <span class='neutral'>        virtual</span>
 126 |     | <span class='unexecuted'>    {</span>
 127 |     | <span class='unexecuted'>        require(deadline &gt;= block.timestamp, &quot;PERMIT_DEADLINE_EXPIRED&quot;);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>        address recoveredAddress = ecrecover(</span>
 130 |     | <span class='unexecuted'>            keccak256(</span>
 131 |     | <span class='unexecuted'>                abi.encodePacked(</span>
 132 |     | <span class='neutral'>                    &quot;\x19\x01&quot;,</span>
 133 |     | <span class='unexecuted'>                    DOMAIN_SEPARATOR(),</span>
 134 |     | <span class='unexecuted'>                    keccak256(</span>
 135 |     | <span class='unexecuted'>                        abi.encode(</span>
 136 |     | <span class='unexecuted'>                            keccak256(</span>
 137 |     | <span class='neutral'>                                &quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;</span>
 138 |     | <span class='neutral'>                            ),</span>
 139 |     | <span class='unexecuted'>                            owner,</span>
 140 |     | <span class='unexecuted'>                            spender,</span>
 141 |     | <span class='unexecuted'>                            value,</span>
 142 |     | <span class='unexecuted'>                            nonces[owner]++,</span>
 143 |     | <span class='neutral'>                            deadline</span>
 144 |     | <span class='neutral'>                        )</span>
 145 |     | <span class='neutral'>                    )</span>
 146 |     | <span class='neutral'>                )</span>
 147 |     | <span class='neutral'>            ),</span>
 148 |     | <span class='neutral'>            v,</span>
 149 |     | <span class='neutral'>            r,</span>
 150 |     | <span class='neutral'>            s</span>
 151 |     | <span class='neutral'>        );</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>        require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &quot;INVALID_SIGNER&quot;);</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>        _allowance[recoveredAddress][spender] = value;</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>        emit Approval(owner, spender, value);</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {</span>
 161 |     | <span class='unexecuted'>        return _pureChainId() == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='unexecuted'>    function computeDomainSeparator() internal view virtual returns (bytes32) {</span>
 165 |     | <span class='unexecuted'>        return keccak256(</span>
 166 |     | <span class='unexecuted'>            abi.encode(</span>
 167 |     | <span class='unexecuted'>                keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;),</span>
 168 |     | <span class='unexecuted'>                keccak256(bytes(_name)),</span>
 169 |     | <span class='unexecuted'>                keccak256(&quot;1&quot;),</span>
 170 |     | <span class='unexecuted'>                _pureChainId(),</span>
 171 |     | <span class='unexecuted'>                address(this)</span>
 172 |     | <span class='neutral'>            )</span>
 173 |     | <span class='neutral'>        );</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 177 |     | <span class='neutral'>                        INTERNAL MINT/BURN LOGIC</span>
 178 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    function _mint(address to, uint256 amount) internal virtual {</span>
 181 |     | <span class='neutral'>        _totalSupply = _add(_totalSupply, amount);</span>
 182 |     | <span class='neutral'>        _balanceOf[to] = _add(_balanceOf[to], amount);</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        emit Transfer(address(0), to, amount);</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    function _burn(address from, uint256 amount) internal virtual {</span>
 188 |     | <span class='neutral'>        _balanceOf[from] = _sub(_balanceOf[from], amount);</span>
 189 |     | <span class='neutral'>        _totalSupply = _sub(_totalSupply, amount);</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>        emit Transfer(from, address(0), amount);</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 195 |     | <span class='neutral'>                        INTERNAL SAFE MATH LOGIC</span>
 196 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>    function _add(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 199 |     | <span class='unexecuted'>        uint256 c = a + b;</span>
 200 |     | <span class='unexecuted'>        require(c &gt;= a, &quot;ERC20: addition overflow&quot;);</span>
 201 |     | <span class='neutral'>        return c;</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='unexecuted'>    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 205 |     | <span class='unexecuted'>        require(a &gt;= b, &quot;ERC20: subtraction underflow&quot;);</span>
 206 |     | <span class='unexecuted'>        return a - b;</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 210 |     | <span class='neutral'>                                HELPERS</span>
 211 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no</span>
 214 |     | <span class='neutral'>    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We</span>
 215 |     | <span class='neutral'>    // can&#39;t simply access the chain ID in a normal view or pure function because the solc View Pure</span>
 216 |     | <span class='neutral'>    // Checker changed `chainid` from pure to view in 0.8.0.</span>
 217 |     | <span class='unexecuted'>    function _viewChainId() private view returns (uint256 chainId) {</span>
 218 |     | <span class='neutral'>        // Assembly required since `block.chainid` was introduced in 0.8.0.</span>
 219 |     | <span class='neutral'>        assembly {</span>
 220 |     | <span class='unexecuted'>            chainId := chainid()</span>
 221 |     | <span class='neutral'>        }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>        address(this); // Silence warnings in older Solc versions.</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='unexecuted'>    function _pureChainId() private pure returns (uint256 chainId) {</span>
 227 |     | <span class='unexecuted'>        function() internal view returns (uint256) fnIn = _viewChainId;</span>
 228 |     | <span class='neutral'>        function() internal pure returns (uint256) pureChainId;</span>
 229 |     | <span class='neutral'>        assembly {</span>
 230 |     | <span class='neutral'>            pureChainId := fnIn</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='unexecuted'>        chainId = pureChainId();</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'>}</span>
 235 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/mocks/MockERC721.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC721Metadata, IERC721TokenReceiver} from &quot;../interfaces/IERC721.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @notice This is a mock contract of the ERC721 standard for testing purposes only, it SHOULD NOT be used in production.</span>
   7 |     | <span class='neutral'>/// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC721.sol</span>
   8 |     | <span class='unexecuted'>contract MockERC721 is IERC721Metadata {</span>
   9 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  10 |     | <span class='neutral'>                         METADATA STORAGE/LOGIC</span>
  11 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    string internal _name;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    string internal _symbol;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>    function name() external view override returns (string memory) {</span>
  18 |     | <span class='unexecuted'>        return _name;</span>
  19 |     | <span class='neutral'>    }</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    function symbol() external view override returns (string memory) {</span>
  22 |     | <span class='unexecuted'>        return _symbol;</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    function tokenURI(uint256 id) public view virtual override returns (string memory) {}</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  28 |     | <span class='neutral'>                      ERC721 BALANCE/OWNER STORAGE</span>
  29 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    mapping(uint256 =&gt; address) internal _ownerOf;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    mapping(address =&gt; uint256) internal _balanceOf;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    function ownerOf(uint256 id) public view virtual override returns (address owner) {</span>
  36 |     | <span class='unexecuted'>        require((owner = _ownerOf[id]) != address(0), &quot;NOT_MINTED&quot;);</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    function balanceOf(address owner) public view virtual override returns (uint256) {</span>
  40 |     | <span class='unexecuted'>        require(owner != address(0), &quot;ZERO_ADDRESS&quot;);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>        return _balanceOf[owner];</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  46 |     | <span class='neutral'>                         ERC721 APPROVAL STORAGE</span>
  47 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    mapping(uint256 =&gt; address) internal _getApproved;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; bool)) internal _isApprovedForAll;</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>    function getApproved(uint256 id) public view virtual override returns (address) {</span>
  54 |     | <span class='unexecuted'>        return _getApproved[id];</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {</span>
  58 |     | <span class='unexecuted'>        return _isApprovedForAll[owner][operator];</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  62 |     | <span class='neutral'>                               INITIALIZE</span>
  63 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /// @dev A bool to track whether the contract has been initialized.</span>
  66 |     | <span class='neutral'>    bool private initialized;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and</span>
  69 |     | <span class='neutral'>    /// syntaxes, we add an initialization function that can be called only once.</span>
  70 |     | <span class='unexecuted'>    function initialize(string memory name_, string memory symbol_) public {</span>
  71 |     | <span class='unexecuted'>        require(!initialized, &quot;ALREADY_INITIALIZED&quot;);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        _name = name_;</span>
  74 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>        initialized = true;</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  80 |     | <span class='neutral'>                              ERC721 LOGIC</span>
  81 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>    function approve(address spender, uint256 id) public payable virtual override {</span>
  84 |     | <span class='unexecuted'>        address owner = _ownerOf[id];</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>        require(msg.sender == owner || _isApprovedForAll[owner][msg.sender], &quot;NOT_AUTHORIZED&quot;);</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>        _getApproved[id] = spender;</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>        emit Approval(owner, spender, id);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    function setApprovalForAll(address operator, bool approved) public virtual override {</span>
  94 |     | <span class='unexecuted'>        _isApprovedForAll[msg.sender][operator] = approved;</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        emit ApprovalForAll(msg.sender, operator, approved);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 id) public payable virtual override {</span>
 100 |     | <span class='unexecuted'>        require(from == _ownerOf[id], &quot;WRONG_FROM&quot;);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>        require(to != address(0), &quot;INVALID_RECIPIENT&quot;);</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>        require(</span>
 105 |     | <span class='unexecuted'>            msg.sender == from || _isApprovedForAll[from][msg.sender] || msg.sender == _getApproved[id],</span>
 106 |     | <span class='neutral'>            &quot;NOT_AUTHORIZED&quot;</span>
 107 |     | <span class='neutral'>        );</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        // Underflow of the sender&#39;s balance is impossible because we check for</span>
 110 |     | <span class='neutral'>        // ownership above and the recipient&#39;s balance can&#39;t realistically overflow.</span>
 111 |     | <span class='unexecuted'>        _balanceOf[from]--;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>        _balanceOf[to]++;</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>        _ownerOf[id] = to;</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>        delete _getApproved[id];</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>        emit Transfer(from, to, id);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>    function safeTransferFrom(address from, address to, uint256 id) public payable virtual override {</span>
 123 |     | <span class='unexecuted'>        transferFrom(from, to, id);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        require(</span>
 126 |     | <span class='unexecuted'>            !_isContract(to)</span>
 127 |     | <span class='unexecuted'>                || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, &quot;&quot;)</span>
 128 |     | <span class='unexecuted'>                    == IERC721TokenReceiver.onERC721Received.selector,</span>
 129 |     | <span class='neutral'>            &quot;UNSAFE_RECIPIENT&quot;</span>
 130 |     | <span class='neutral'>        );</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>    function safeTransferFrom(address from, address to, uint256 id, bytes memory data)</span>
 134 |     | <span class='neutral'>        public</span>
 135 |     | <span class='neutral'>        payable</span>
 136 |     | <span class='neutral'>        virtual</span>
 137 |     | <span class='neutral'>        override</span>
 138 |     | <span class='neutral'>    {</span>
 139 |     | <span class='unexecuted'>        transferFrom(from, to, id);</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='unexecuted'>        require(</span>
 142 |     | <span class='unexecuted'>            !_isContract(to)</span>
 143 |     | <span class='unexecuted'>                || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)</span>
 144 |     | <span class='unexecuted'>                    == IERC721TokenReceiver.onERC721Received.selector,</span>
 145 |     | <span class='neutral'>            &quot;UNSAFE_RECIPIENT&quot;</span>
 146 |     | <span class='neutral'>        );</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 150 |     | <span class='neutral'>                              ERC165 LOGIC</span>
 151 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 154 |     | <span class='unexecuted'>        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165</span>
 155 |     | <span class='unexecuted'>            || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721</span>
 156 |     | <span class='unexecuted'>            || interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 160 |     | <span class='neutral'>                        INTERNAL MINT/BURN LOGIC</span>
 161 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    function _mint(address to, uint256 id) internal virtual {</span>
 164 |     | <span class='neutral'>        require(to != address(0), &quot;INVALID_RECIPIENT&quot;);</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>        require(_ownerOf[id] == address(0), &quot;ALREADY_MINTED&quot;);</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>        // Counter overflow is incredibly unrealistic.</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>        _balanceOf[to]++;</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>        _ownerOf[id] = to;</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>        emit Transfer(address(0), to, id);</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    function _burn(uint256 id) internal virtual {</span>
 178 |     | <span class='neutral'>        address owner = _ownerOf[id];</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>        require(owner != address(0), &quot;NOT_MINTED&quot;);</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>        _balanceOf[owner]--;</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        delete _ownerOf[id];</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>        delete _getApproved[id];</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>        emit Transfer(owner, address(0), id);</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 192 |     | <span class='neutral'>                        INTERNAL SAFE MINT LOGIC</span>
 193 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    function _safeMint(address to, uint256 id) internal virtual {</span>
 196 |     | <span class='neutral'>        _mint(to, id);</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>        require(</span>
 199 |     | <span class='neutral'>            !_isContract(to)</span>
 200 |     | <span class='neutral'>                || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, &quot;&quot;)</span>
 201 |     | <span class='neutral'>                    == IERC721TokenReceiver.onERC721Received.selector,</span>
 202 |     | <span class='neutral'>            &quot;UNSAFE_RECIPIENT&quot;</span>
 203 |     | <span class='neutral'>        );</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {</span>
 207 |     | <span class='neutral'>        _mint(to, id);</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>        require(</span>
 210 |     | <span class='neutral'>            !_isContract(to)</span>
 211 |     | <span class='neutral'>                || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)</span>
 212 |     | <span class='neutral'>                    == IERC721TokenReceiver.onERC721Received.selector,</span>
 213 |     | <span class='neutral'>            &quot;UNSAFE_RECIPIENT&quot;</span>
 214 |     | <span class='neutral'>        );</span>
 215 |     | <span class='neutral'>    }</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 218 |     | <span class='neutral'>                                HELPERS</span>
 219 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    function _isContract(address _addr) private view returns (bool) {</span>
 222 |     | <span class='neutral'>        uint256 codeLength;</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>        // Assembly required for versions &lt; 0.8.0 to check extcodesize.</span>
 225 |     | <span class='neutral'>        assembly {</span>
 226 |     | <span class='unexecuted'>            codeLength := extcodesize(_addr)</span>
 227 |     | <span class='neutral'>        }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>        return codeLength &gt; 0;</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'>}</span>
 232 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/forge-std/src/safeconsole.sol</b>
<code>
     1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
     2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
     3 |     | <span class='neutral'></span>
     4 |     | <span class='neutral'>/// @author philogy &lt;https://github.com/philogy&gt;</span>
     5 |     | <span class='neutral'>/// @dev Code generated automatically by script.</span>
     6 |     | <span class='unexecuted'>library safeconsole {</span>
     7 |     | <span class='neutral'>    uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;</span>
     8 |     | <span class='neutral'></span>
     9 |     | <span class='neutral'>    // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)</span>
    10 |     | <span class='neutral'>    // for the view-to-pure log trick.</span>
    11 |     | <span class='neutral'>    function _sendLogPayload(uint256 offset, uint256 size) private pure {</span>
    12 |     | <span class='neutral'>        function(uint256, uint256) internal view fnIn = _sendLogPayloadView;</span>
    13 |     | <span class='neutral'>        function(uint256, uint256) internal pure pureSendLogPayload;</span>
    14 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
    15 |     | <span class='neutral'>        assembly {</span>
    16 |     | <span class='neutral'>            pureSendLogPayload := fnIn</span>
    17 |     | <span class='neutral'>        }</span>
    18 |     | <span class='neutral'>        pureSendLogPayload(offset, size);</span>
    19 |     | <span class='neutral'>    }</span>
    20 |     | <span class='neutral'></span>
    21 |     | <span class='neutral'>    function _sendLogPayloadView(uint256 offset, uint256 size) private view {</span>
    22 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
    23 |     | <span class='neutral'>        assembly {</span>
    24 |     | <span class='neutral'>            pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))</span>
    25 |     | <span class='neutral'>        }</span>
    26 |     | <span class='neutral'>    }</span>
    27 |     | <span class='neutral'></span>
    28 |     | <span class='neutral'>    function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {</span>
    29 |     | <span class='neutral'>        function(uint256, uint256, uint256) internal view fnIn = _memcopyView;</span>
    30 |     | <span class='neutral'>        function(uint256, uint256, uint256) internal pure pureMemcopy;</span>
    31 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
    32 |     | <span class='neutral'>        assembly {</span>
    33 |     | <span class='neutral'>            pureMemcopy := fnIn</span>
    34 |     | <span class='neutral'>        }</span>
    35 |     | <span class='neutral'>        pureMemcopy(fromOffset, toOffset, length);</span>
    36 |     | <span class='neutral'>    }</span>
    37 |     | <span class='neutral'></span>
    38 |     | <span class='neutral'>    function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {</span>
    39 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
    40 |     | <span class='neutral'>        assembly {</span>
    41 |     | <span class='neutral'>            pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))</span>
    42 |     | <span class='neutral'>        }</span>
    43 |     | <span class='neutral'>    }</span>
    44 |     | <span class='neutral'></span>
    45 |     | <span class='neutral'>    function logMemory(uint256 offset, uint256 length) internal pure {</span>
    46 |     | <span class='neutral'>        if (offset &gt;= 0x60) {</span>
    47 |     | <span class='neutral'>            // Sufficient memory before slice to prepare call header.</span>
    48 |     | <span class='neutral'>            bytes32 m0;</span>
    49 |     | <span class='neutral'>            bytes32 m1;</span>
    50 |     | <span class='neutral'>            bytes32 m2;</span>
    51 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
    52 |     | <span class='neutral'>            assembly {</span>
    53 |     | <span class='neutral'>                m0 := mload(sub(offset, 0x60))</span>
    54 |     | <span class='neutral'>                m1 := mload(sub(offset, 0x40))</span>
    55 |     | <span class='neutral'>                m2 := mload(sub(offset, 0x20))</span>
    56 |     | <span class='neutral'>                // Selector of `log(bytes)`.</span>
    57 |     | <span class='neutral'>                mstore(sub(offset, 0x60), 0x0be77f56)</span>
    58 |     | <span class='neutral'>                mstore(sub(offset, 0x40), 0x20)</span>
    59 |     | <span class='neutral'>                mstore(sub(offset, 0x20), length)</span>
    60 |     | <span class='neutral'>            }</span>
    61 |     | <span class='neutral'>            _sendLogPayload(offset - 0x44, length + 0x44);</span>
    62 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
    63 |     | <span class='neutral'>            assembly {</span>
    64 |     | <span class='neutral'>                mstore(sub(offset, 0x60), m0)</span>
    65 |     | <span class='neutral'>                mstore(sub(offset, 0x40), m1)</span>
    66 |     | <span class='neutral'>                mstore(sub(offset, 0x20), m2)</span>
    67 |     | <span class='neutral'>            }</span>
    68 |     | <span class='neutral'>        } else {</span>
    69 |     | <span class='neutral'>            // Insufficient space, so copy slice forward, add header and reverse.</span>
    70 |     | <span class='neutral'>            bytes32 m0;</span>
    71 |     | <span class='neutral'>            bytes32 m1;</span>
    72 |     | <span class='neutral'>            bytes32 m2;</span>
    73 |     | <span class='neutral'>            uint256 endOffset = offset + length;</span>
    74 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
    75 |     | <span class='neutral'>            assembly {</span>
    76 |     | <span class='neutral'>                m0 := mload(add(endOffset, 0x00))</span>
    77 |     | <span class='neutral'>                m1 := mload(add(endOffset, 0x20))</span>
    78 |     | <span class='neutral'>                m2 := mload(add(endOffset, 0x40))</span>
    79 |     | <span class='neutral'>            }</span>
    80 |     | <span class='neutral'>            _memcopy(offset, offset + 0x60, length);</span>
    81 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
    82 |     | <span class='neutral'>            assembly {</span>
    83 |     | <span class='neutral'>                // Selector of `log(bytes)`.</span>
    84 |     | <span class='neutral'>                mstore(add(offset, 0x00), 0x0be77f56)</span>
    85 |     | <span class='neutral'>                mstore(add(offset, 0x20), 0x20)</span>
    86 |     | <span class='neutral'>                mstore(add(offset, 0x40), length)</span>
    87 |     | <span class='neutral'>            }</span>
    88 |     | <span class='neutral'>            _sendLogPayload(offset + 0x1c, length + 0x44);</span>
    89 |     | <span class='neutral'>            _memcopy(offset + 0x60, offset, length);</span>
    90 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
    91 |     | <span class='neutral'>            assembly {</span>
    92 |     | <span class='neutral'>                mstore(add(endOffset, 0x00), m0)</span>
    93 |     | <span class='neutral'>                mstore(add(endOffset, 0x20), m1)</span>
    94 |     | <span class='neutral'>                mstore(add(endOffset, 0x40), m2)</span>
    95 |     | <span class='neutral'>            }</span>
    96 |     | <span class='neutral'>        }</span>
    97 |     | <span class='neutral'>    }</span>
    98 |     | <span class='neutral'></span>
    99 |     | <span class='neutral'>    function log(address p0) internal pure {</span>
   100 |     | <span class='neutral'>        bytes32 m0;</span>
   101 |     | <span class='neutral'>        bytes32 m1;</span>
   102 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   103 |     | <span class='neutral'>        assembly {</span>
   104 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   105 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   106 |     | <span class='neutral'>            // Selector of `log(address)`.</span>
   107 |     | <span class='neutral'>            mstore(0x00, 0x2c2ecbc2)</span>
   108 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   109 |     | <span class='neutral'>        }</span>
   110 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x24);</span>
   111 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   112 |     | <span class='neutral'>        assembly {</span>
   113 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   114 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   115 |     | <span class='neutral'>        }</span>
   116 |     | <span class='neutral'>    }</span>
   117 |     | <span class='neutral'></span>
   118 |     | <span class='neutral'>    function log(bool p0) internal pure {</span>
   119 |     | <span class='neutral'>        bytes32 m0;</span>
   120 |     | <span class='neutral'>        bytes32 m1;</span>
   121 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   122 |     | <span class='neutral'>        assembly {</span>
   123 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   124 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   125 |     | <span class='neutral'>            // Selector of `log(bool)`.</span>
   126 |     | <span class='neutral'>            mstore(0x00, 0x32458eed)</span>
   127 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   128 |     | <span class='neutral'>        }</span>
   129 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x24);</span>
   130 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   131 |     | <span class='neutral'>        assembly {</span>
   132 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   133 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   134 |     | <span class='neutral'>        }</span>
   135 |     | <span class='neutral'>    }</span>
   136 |     | <span class='neutral'></span>
   137 |     | <span class='neutral'>    function log(uint256 p0) internal pure {</span>
   138 |     | <span class='neutral'>        bytes32 m0;</span>
   139 |     | <span class='neutral'>        bytes32 m1;</span>
   140 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   141 |     | <span class='neutral'>        assembly {</span>
   142 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   143 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   144 |     | <span class='neutral'>            // Selector of `log(uint256)`.</span>
   145 |     | <span class='neutral'>            mstore(0x00, 0xf82c50f1)</span>
   146 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   147 |     | <span class='neutral'>        }</span>
   148 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x24);</span>
   149 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   150 |     | <span class='neutral'>        assembly {</span>
   151 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   152 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   153 |     | <span class='neutral'>        }</span>
   154 |     | <span class='neutral'>    }</span>
   155 |     | <span class='neutral'></span>
   156 |     | <span class='neutral'>    function log(bytes32 p0) internal pure {</span>
   157 |     | <span class='neutral'>        bytes32 m0;</span>
   158 |     | <span class='neutral'>        bytes32 m1;</span>
   159 |     | <span class='neutral'>        bytes32 m2;</span>
   160 |     | <span class='neutral'>        bytes32 m3;</span>
   161 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   162 |     | <span class='neutral'>        assembly {</span>
   163 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   164 |     | <span class='neutral'>                let length := 0</span>
   165 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   166 |     | <span class='neutral'>                mstore(pos, length)</span>
   167 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   168 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   169 |     | <span class='neutral'>            }</span>
   170 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   171 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   172 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   173 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   174 |     | <span class='neutral'>            // Selector of `log(string)`.</span>
   175 |     | <span class='neutral'>            mstore(0x00, 0x41304fac)</span>
   176 |     | <span class='neutral'>            mstore(0x20, 0x20)</span>
   177 |     | <span class='neutral'>            writeString(0x40, p0)</span>
   178 |     | <span class='neutral'>        }</span>
   179 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   180 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   181 |     | <span class='neutral'>        assembly {</span>
   182 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   183 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   184 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   185 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   186 |     | <span class='neutral'>        }</span>
   187 |     | <span class='neutral'>    }</span>
   188 |     | <span class='neutral'></span>
   189 |     | <span class='neutral'>    function log(address p0, address p1) internal pure {</span>
   190 |     | <span class='neutral'>        bytes32 m0;</span>
   191 |     | <span class='neutral'>        bytes32 m1;</span>
   192 |     | <span class='neutral'>        bytes32 m2;</span>
   193 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   194 |     | <span class='neutral'>        assembly {</span>
   195 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   196 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   197 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   198 |     | <span class='neutral'>            // Selector of `log(address,address)`.</span>
   199 |     | <span class='neutral'>            mstore(0x00, 0xdaf0d4aa)</span>
   200 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   201 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   202 |     | <span class='neutral'>        }</span>
   203 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   204 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   205 |     | <span class='neutral'>        assembly {</span>
   206 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   207 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   208 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   209 |     | <span class='neutral'>        }</span>
   210 |     | <span class='neutral'>    }</span>
   211 |     | <span class='neutral'></span>
   212 |     | <span class='neutral'>    function log(address p0, bool p1) internal pure {</span>
   213 |     | <span class='neutral'>        bytes32 m0;</span>
   214 |     | <span class='neutral'>        bytes32 m1;</span>
   215 |     | <span class='neutral'>        bytes32 m2;</span>
   216 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   217 |     | <span class='neutral'>        assembly {</span>
   218 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   219 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   220 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   221 |     | <span class='neutral'>            // Selector of `log(address,bool)`.</span>
   222 |     | <span class='neutral'>            mstore(0x00, 0x75b605d3)</span>
   223 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   224 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   225 |     | <span class='neutral'>        }</span>
   226 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   227 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   228 |     | <span class='neutral'>        assembly {</span>
   229 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   230 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   231 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   232 |     | <span class='neutral'>        }</span>
   233 |     | <span class='neutral'>    }</span>
   234 |     | <span class='neutral'></span>
   235 |     | <span class='neutral'>    function log(address p0, uint256 p1) internal pure {</span>
   236 |     | <span class='neutral'>        bytes32 m0;</span>
   237 |     | <span class='neutral'>        bytes32 m1;</span>
   238 |     | <span class='neutral'>        bytes32 m2;</span>
   239 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   240 |     | <span class='neutral'>        assembly {</span>
   241 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   242 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   243 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   244 |     | <span class='neutral'>            // Selector of `log(address,uint256)`.</span>
   245 |     | <span class='neutral'>            mstore(0x00, 0x8309e8a8)</span>
   246 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   247 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   248 |     | <span class='neutral'>        }</span>
   249 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   250 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   251 |     | <span class='neutral'>        assembly {</span>
   252 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   253 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   254 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   255 |     | <span class='neutral'>        }</span>
   256 |     | <span class='neutral'>    }</span>
   257 |     | <span class='neutral'></span>
   258 |     | <span class='neutral'>    function log(address p0, bytes32 p1) internal pure {</span>
   259 |     | <span class='neutral'>        bytes32 m0;</span>
   260 |     | <span class='neutral'>        bytes32 m1;</span>
   261 |     | <span class='neutral'>        bytes32 m2;</span>
   262 |     | <span class='neutral'>        bytes32 m3;</span>
   263 |     | <span class='neutral'>        bytes32 m4;</span>
   264 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   265 |     | <span class='neutral'>        assembly {</span>
   266 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   267 |     | <span class='neutral'>                let length := 0</span>
   268 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   269 |     | <span class='neutral'>                mstore(pos, length)</span>
   270 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   271 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   272 |     | <span class='neutral'>            }</span>
   273 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   274 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   275 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   276 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   277 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   278 |     | <span class='neutral'>            // Selector of `log(address,string)`.</span>
   279 |     | <span class='neutral'>            mstore(0x00, 0x759f86bb)</span>
   280 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   281 |     | <span class='neutral'>            mstore(0x40, 0x40)</span>
   282 |     | <span class='neutral'>            writeString(0x60, p1)</span>
   283 |     | <span class='neutral'>        }</span>
   284 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   285 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   286 |     | <span class='neutral'>        assembly {</span>
   287 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   288 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   289 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   290 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   291 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   292 |     | <span class='neutral'>        }</span>
   293 |     | <span class='neutral'>    }</span>
   294 |     | <span class='neutral'></span>
   295 |     | <span class='neutral'>    function log(bool p0, address p1) internal pure {</span>
   296 |     | <span class='neutral'>        bytes32 m0;</span>
   297 |     | <span class='neutral'>        bytes32 m1;</span>
   298 |     | <span class='neutral'>        bytes32 m2;</span>
   299 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   300 |     | <span class='neutral'>        assembly {</span>
   301 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   302 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   303 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   304 |     | <span class='neutral'>            // Selector of `log(bool,address)`.</span>
   305 |     | <span class='neutral'>            mstore(0x00, 0x853c4849)</span>
   306 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   307 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   308 |     | <span class='neutral'>        }</span>
   309 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   310 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   311 |     | <span class='neutral'>        assembly {</span>
   312 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   313 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   314 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   315 |     | <span class='neutral'>        }</span>
   316 |     | <span class='neutral'>    }</span>
   317 |     | <span class='neutral'></span>
   318 |     | <span class='neutral'>    function log(bool p0, bool p1) internal pure {</span>
   319 |     | <span class='neutral'>        bytes32 m0;</span>
   320 |     | <span class='neutral'>        bytes32 m1;</span>
   321 |     | <span class='neutral'>        bytes32 m2;</span>
   322 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   323 |     | <span class='neutral'>        assembly {</span>
   324 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   325 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   326 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   327 |     | <span class='neutral'>            // Selector of `log(bool,bool)`.</span>
   328 |     | <span class='neutral'>            mstore(0x00, 0x2a110e83)</span>
   329 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   330 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   331 |     | <span class='neutral'>        }</span>
   332 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   333 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   334 |     | <span class='neutral'>        assembly {</span>
   335 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   336 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   337 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   338 |     | <span class='neutral'>        }</span>
   339 |     | <span class='neutral'>    }</span>
   340 |     | <span class='neutral'></span>
   341 |     | <span class='neutral'>    function log(bool p0, uint256 p1) internal pure {</span>
   342 |     | <span class='neutral'>        bytes32 m0;</span>
   343 |     | <span class='neutral'>        bytes32 m1;</span>
   344 |     | <span class='neutral'>        bytes32 m2;</span>
   345 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   346 |     | <span class='neutral'>        assembly {</span>
   347 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   348 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   349 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   350 |     | <span class='neutral'>            // Selector of `log(bool,uint256)`.</span>
   351 |     | <span class='neutral'>            mstore(0x00, 0x399174d3)</span>
   352 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   353 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   354 |     | <span class='neutral'>        }</span>
   355 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   356 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   357 |     | <span class='neutral'>        assembly {</span>
   358 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   359 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   360 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   361 |     | <span class='neutral'>        }</span>
   362 |     | <span class='neutral'>    }</span>
   363 |     | <span class='neutral'></span>
   364 |     | <span class='neutral'>    function log(bool p0, bytes32 p1) internal pure {</span>
   365 |     | <span class='neutral'>        bytes32 m0;</span>
   366 |     | <span class='neutral'>        bytes32 m1;</span>
   367 |     | <span class='neutral'>        bytes32 m2;</span>
   368 |     | <span class='neutral'>        bytes32 m3;</span>
   369 |     | <span class='neutral'>        bytes32 m4;</span>
   370 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   371 |     | <span class='neutral'>        assembly {</span>
   372 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   373 |     | <span class='neutral'>                let length := 0</span>
   374 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   375 |     | <span class='neutral'>                mstore(pos, length)</span>
   376 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   377 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   378 |     | <span class='neutral'>            }</span>
   379 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   380 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   381 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   382 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   383 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   384 |     | <span class='neutral'>            // Selector of `log(bool,string)`.</span>
   385 |     | <span class='neutral'>            mstore(0x00, 0x8feac525)</span>
   386 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   387 |     | <span class='neutral'>            mstore(0x40, 0x40)</span>
   388 |     | <span class='neutral'>            writeString(0x60, p1)</span>
   389 |     | <span class='neutral'>        }</span>
   390 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   391 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   392 |     | <span class='neutral'>        assembly {</span>
   393 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   394 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   395 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   396 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   397 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   398 |     | <span class='neutral'>        }</span>
   399 |     | <span class='neutral'>    }</span>
   400 |     | <span class='neutral'></span>
   401 |     | <span class='neutral'>    function log(uint256 p0, address p1) internal pure {</span>
   402 |     | <span class='neutral'>        bytes32 m0;</span>
   403 |     | <span class='neutral'>        bytes32 m1;</span>
   404 |     | <span class='neutral'>        bytes32 m2;</span>
   405 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   406 |     | <span class='neutral'>        assembly {</span>
   407 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   408 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   409 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   410 |     | <span class='neutral'>            // Selector of `log(uint256,address)`.</span>
   411 |     | <span class='neutral'>            mstore(0x00, 0x69276c86)</span>
   412 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   413 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   414 |     | <span class='neutral'>        }</span>
   415 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   416 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   417 |     | <span class='neutral'>        assembly {</span>
   418 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   419 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   420 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   421 |     | <span class='neutral'>        }</span>
   422 |     | <span class='neutral'>    }</span>
   423 |     | <span class='neutral'></span>
   424 |     | <span class='neutral'>    function log(uint256 p0, bool p1) internal pure {</span>
   425 |     | <span class='neutral'>        bytes32 m0;</span>
   426 |     | <span class='neutral'>        bytes32 m1;</span>
   427 |     | <span class='neutral'>        bytes32 m2;</span>
   428 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   429 |     | <span class='neutral'>        assembly {</span>
   430 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   431 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   432 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   433 |     | <span class='neutral'>            // Selector of `log(uint256,bool)`.</span>
   434 |     | <span class='neutral'>            mstore(0x00, 0x1c9d7eb3)</span>
   435 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   436 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   437 |     | <span class='neutral'>        }</span>
   438 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   439 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   440 |     | <span class='neutral'>        assembly {</span>
   441 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   442 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   443 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   444 |     | <span class='neutral'>        }</span>
   445 |     | <span class='neutral'>    }</span>
   446 |     | <span class='neutral'></span>
   447 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1) internal pure {</span>
   448 |     | <span class='neutral'>        bytes32 m0;</span>
   449 |     | <span class='neutral'>        bytes32 m1;</span>
   450 |     | <span class='neutral'>        bytes32 m2;</span>
   451 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   452 |     | <span class='neutral'>        assembly {</span>
   453 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   454 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   455 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   456 |     | <span class='neutral'>            // Selector of `log(uint256,uint256)`.</span>
   457 |     | <span class='neutral'>            mstore(0x00, 0xf666715a)</span>
   458 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   459 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   460 |     | <span class='neutral'>        }</span>
   461 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   462 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   463 |     | <span class='neutral'>        assembly {</span>
   464 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   465 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   466 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   467 |     | <span class='neutral'>        }</span>
   468 |     | <span class='neutral'>    }</span>
   469 |     | <span class='neutral'></span>
   470 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1) internal pure {</span>
   471 |     | <span class='neutral'>        bytes32 m0;</span>
   472 |     | <span class='neutral'>        bytes32 m1;</span>
   473 |     | <span class='neutral'>        bytes32 m2;</span>
   474 |     | <span class='neutral'>        bytes32 m3;</span>
   475 |     | <span class='neutral'>        bytes32 m4;</span>
   476 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   477 |     | <span class='neutral'>        assembly {</span>
   478 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   479 |     | <span class='neutral'>                let length := 0</span>
   480 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   481 |     | <span class='neutral'>                mstore(pos, length)</span>
   482 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   483 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   484 |     | <span class='neutral'>            }</span>
   485 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   486 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   487 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   488 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   489 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   490 |     | <span class='neutral'>            // Selector of `log(uint256,string)`.</span>
   491 |     | <span class='neutral'>            mstore(0x00, 0x643fd0df)</span>
   492 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   493 |     | <span class='neutral'>            mstore(0x40, 0x40)</span>
   494 |     | <span class='neutral'>            writeString(0x60, p1)</span>
   495 |     | <span class='neutral'>        }</span>
   496 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   497 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   498 |     | <span class='neutral'>        assembly {</span>
   499 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   500 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   501 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   502 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   503 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   504 |     | <span class='neutral'>        }</span>
   505 |     | <span class='neutral'>    }</span>
   506 |     | <span class='neutral'></span>
   507 |     | <span class='neutral'>    function log(bytes32 p0, address p1) internal pure {</span>
   508 |     | <span class='neutral'>        bytes32 m0;</span>
   509 |     | <span class='neutral'>        bytes32 m1;</span>
   510 |     | <span class='neutral'>        bytes32 m2;</span>
   511 |     | <span class='neutral'>        bytes32 m3;</span>
   512 |     | <span class='neutral'>        bytes32 m4;</span>
   513 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   514 |     | <span class='neutral'>        assembly {</span>
   515 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   516 |     | <span class='neutral'>                let length := 0</span>
   517 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   518 |     | <span class='neutral'>                mstore(pos, length)</span>
   519 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   520 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   521 |     | <span class='neutral'>            }</span>
   522 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   523 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   524 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   525 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   526 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   527 |     | <span class='neutral'>            // Selector of `log(string,address)`.</span>
   528 |     | <span class='neutral'>            mstore(0x00, 0x319af333)</span>
   529 |     | <span class='neutral'>            mstore(0x20, 0x40)</span>
   530 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   531 |     | <span class='neutral'>            writeString(0x60, p0)</span>
   532 |     | <span class='neutral'>        }</span>
   533 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   534 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   535 |     | <span class='neutral'>        assembly {</span>
   536 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   537 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   538 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   539 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   540 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   541 |     | <span class='neutral'>        }</span>
   542 |     | <span class='neutral'>    }</span>
   543 |     | <span class='neutral'></span>
   544 |     | <span class='neutral'>    function log(bytes32 p0, bool p1) internal pure {</span>
   545 |     | <span class='neutral'>        bytes32 m0;</span>
   546 |     | <span class='neutral'>        bytes32 m1;</span>
   547 |     | <span class='neutral'>        bytes32 m2;</span>
   548 |     | <span class='neutral'>        bytes32 m3;</span>
   549 |     | <span class='neutral'>        bytes32 m4;</span>
   550 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   551 |     | <span class='neutral'>        assembly {</span>
   552 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   553 |     | <span class='neutral'>                let length := 0</span>
   554 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   555 |     | <span class='neutral'>                mstore(pos, length)</span>
   556 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   557 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   558 |     | <span class='neutral'>            }</span>
   559 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   560 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   561 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   562 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   563 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   564 |     | <span class='neutral'>            // Selector of `log(string,bool)`.</span>
   565 |     | <span class='neutral'>            mstore(0x00, 0xc3b55635)</span>
   566 |     | <span class='neutral'>            mstore(0x20, 0x40)</span>
   567 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   568 |     | <span class='neutral'>            writeString(0x60, p0)</span>
   569 |     | <span class='neutral'>        }</span>
   570 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   571 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   572 |     | <span class='neutral'>        assembly {</span>
   573 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   574 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   575 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   576 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   577 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   578 |     | <span class='neutral'>        }</span>
   579 |     | <span class='neutral'>    }</span>
   580 |     | <span class='neutral'></span>
   581 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1) internal pure {</span>
   582 |     | <span class='neutral'>        bytes32 m0;</span>
   583 |     | <span class='neutral'>        bytes32 m1;</span>
   584 |     | <span class='neutral'>        bytes32 m2;</span>
   585 |     | <span class='neutral'>        bytes32 m3;</span>
   586 |     | <span class='neutral'>        bytes32 m4;</span>
   587 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   588 |     | <span class='neutral'>        assembly {</span>
   589 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   590 |     | <span class='neutral'>                let length := 0</span>
   591 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   592 |     | <span class='neutral'>                mstore(pos, length)</span>
   593 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   594 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   595 |     | <span class='neutral'>            }</span>
   596 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   597 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   598 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   599 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   600 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   601 |     | <span class='neutral'>            // Selector of `log(string,uint256)`.</span>
   602 |     | <span class='neutral'>            mstore(0x00, 0xb60e72cc)</span>
   603 |     | <span class='neutral'>            mstore(0x20, 0x40)</span>
   604 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   605 |     | <span class='neutral'>            writeString(0x60, p0)</span>
   606 |     | <span class='neutral'>        }</span>
   607 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   608 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   609 |     | <span class='neutral'>        assembly {</span>
   610 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   611 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   612 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   613 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   614 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   615 |     | <span class='neutral'>        }</span>
   616 |     | <span class='neutral'>    }</span>
   617 |     | <span class='neutral'></span>
   618 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1) internal pure {</span>
   619 |     | <span class='neutral'>        bytes32 m0;</span>
   620 |     | <span class='neutral'>        bytes32 m1;</span>
   621 |     | <span class='neutral'>        bytes32 m2;</span>
   622 |     | <span class='neutral'>        bytes32 m3;</span>
   623 |     | <span class='neutral'>        bytes32 m4;</span>
   624 |     | <span class='neutral'>        bytes32 m5;</span>
   625 |     | <span class='neutral'>        bytes32 m6;</span>
   626 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   627 |     | <span class='neutral'>        assembly {</span>
   628 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   629 |     | <span class='neutral'>                let length := 0</span>
   630 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   631 |     | <span class='neutral'>                mstore(pos, length)</span>
   632 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   633 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   634 |     | <span class='neutral'>            }</span>
   635 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   636 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   637 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   638 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   639 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   640 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
   641 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
   642 |     | <span class='neutral'>            // Selector of `log(string,string)`.</span>
   643 |     | <span class='neutral'>            mstore(0x00, 0x4b5c4277)</span>
   644 |     | <span class='neutral'>            mstore(0x20, 0x40)</span>
   645 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
   646 |     | <span class='neutral'>            writeString(0x60, p0)</span>
   647 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
   648 |     | <span class='neutral'>        }</span>
   649 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
   650 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   651 |     | <span class='neutral'>        assembly {</span>
   652 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   653 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   654 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   655 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   656 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   657 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
   658 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
   659 |     | <span class='neutral'>        }</span>
   660 |     | <span class='neutral'>    }</span>
   661 |     | <span class='neutral'></span>
   662 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal pure {</span>
   663 |     | <span class='neutral'>        bytes32 m0;</span>
   664 |     | <span class='neutral'>        bytes32 m1;</span>
   665 |     | <span class='neutral'>        bytes32 m2;</span>
   666 |     | <span class='neutral'>        bytes32 m3;</span>
   667 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   668 |     | <span class='neutral'>        assembly {</span>
   669 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   670 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   671 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   672 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   673 |     | <span class='neutral'>            // Selector of `log(address,address,address)`.</span>
   674 |     | <span class='neutral'>            mstore(0x00, 0x018c84c2)</span>
   675 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   676 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   677 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   678 |     | <span class='neutral'>        }</span>
   679 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   680 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   681 |     | <span class='neutral'>        assembly {</span>
   682 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   683 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   684 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   685 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   686 |     | <span class='neutral'>        }</span>
   687 |     | <span class='neutral'>    }</span>
   688 |     | <span class='neutral'></span>
   689 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal pure {</span>
   690 |     | <span class='neutral'>        bytes32 m0;</span>
   691 |     | <span class='neutral'>        bytes32 m1;</span>
   692 |     | <span class='neutral'>        bytes32 m2;</span>
   693 |     | <span class='neutral'>        bytes32 m3;</span>
   694 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   695 |     | <span class='neutral'>        assembly {</span>
   696 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   697 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   698 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   699 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   700 |     | <span class='neutral'>            // Selector of `log(address,address,bool)`.</span>
   701 |     | <span class='neutral'>            mstore(0x00, 0xf2a66286)</span>
   702 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   703 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   704 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   705 |     | <span class='neutral'>        }</span>
   706 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   707 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   708 |     | <span class='neutral'>        assembly {</span>
   709 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   710 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   711 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   712 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   713 |     | <span class='neutral'>        }</span>
   714 |     | <span class='neutral'>    }</span>
   715 |     | <span class='neutral'></span>
   716 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2) internal pure {</span>
   717 |     | <span class='neutral'>        bytes32 m0;</span>
   718 |     | <span class='neutral'>        bytes32 m1;</span>
   719 |     | <span class='neutral'>        bytes32 m2;</span>
   720 |     | <span class='neutral'>        bytes32 m3;</span>
   721 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   722 |     | <span class='neutral'>        assembly {</span>
   723 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   724 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   725 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   726 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   727 |     | <span class='neutral'>            // Selector of `log(address,address,uint256)`.</span>
   728 |     | <span class='neutral'>            mstore(0x00, 0x17fe6185)</span>
   729 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   730 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   731 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   732 |     | <span class='neutral'>        }</span>
   733 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   734 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   735 |     | <span class='neutral'>        assembly {</span>
   736 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   737 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   738 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   739 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   740 |     | <span class='neutral'>        }</span>
   741 |     | <span class='neutral'>    }</span>
   742 |     | <span class='neutral'></span>
   743 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2) internal pure {</span>
   744 |     | <span class='neutral'>        bytes32 m0;</span>
   745 |     | <span class='neutral'>        bytes32 m1;</span>
   746 |     | <span class='neutral'>        bytes32 m2;</span>
   747 |     | <span class='neutral'>        bytes32 m3;</span>
   748 |     | <span class='neutral'>        bytes32 m4;</span>
   749 |     | <span class='neutral'>        bytes32 m5;</span>
   750 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   751 |     | <span class='neutral'>        assembly {</span>
   752 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   753 |     | <span class='neutral'>                let length := 0</span>
   754 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   755 |     | <span class='neutral'>                mstore(pos, length)</span>
   756 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   757 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   758 |     | <span class='neutral'>            }</span>
   759 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   760 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   761 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   762 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   763 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   764 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
   765 |     | <span class='neutral'>            // Selector of `log(address,address,string)`.</span>
   766 |     | <span class='neutral'>            mstore(0x00, 0x007150be)</span>
   767 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   768 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   769 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
   770 |     | <span class='neutral'>            writeString(0x80, p2)</span>
   771 |     | <span class='neutral'>        }</span>
   772 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
   773 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   774 |     | <span class='neutral'>        assembly {</span>
   775 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   776 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   777 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   778 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   779 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   780 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
   781 |     | <span class='neutral'>        }</span>
   782 |     | <span class='neutral'>    }</span>
   783 |     | <span class='neutral'></span>
   784 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal pure {</span>
   785 |     | <span class='neutral'>        bytes32 m0;</span>
   786 |     | <span class='neutral'>        bytes32 m1;</span>
   787 |     | <span class='neutral'>        bytes32 m2;</span>
   788 |     | <span class='neutral'>        bytes32 m3;</span>
   789 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   790 |     | <span class='neutral'>        assembly {</span>
   791 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   792 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   793 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   794 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   795 |     | <span class='neutral'>            // Selector of `log(address,bool,address)`.</span>
   796 |     | <span class='neutral'>            mstore(0x00, 0xf11699ed)</span>
   797 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   798 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   799 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   800 |     | <span class='neutral'>        }</span>
   801 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   802 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   803 |     | <span class='neutral'>        assembly {</span>
   804 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   805 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   806 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   807 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   808 |     | <span class='neutral'>        }</span>
   809 |     | <span class='neutral'>    }</span>
   810 |     | <span class='neutral'></span>
   811 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal pure {</span>
   812 |     | <span class='neutral'>        bytes32 m0;</span>
   813 |     | <span class='neutral'>        bytes32 m1;</span>
   814 |     | <span class='neutral'>        bytes32 m2;</span>
   815 |     | <span class='neutral'>        bytes32 m3;</span>
   816 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   817 |     | <span class='neutral'>        assembly {</span>
   818 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   819 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   820 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   821 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   822 |     | <span class='neutral'>            // Selector of `log(address,bool,bool)`.</span>
   823 |     | <span class='neutral'>            mstore(0x00, 0xeb830c92)</span>
   824 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   825 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   826 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   827 |     | <span class='neutral'>        }</span>
   828 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   829 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   830 |     | <span class='neutral'>        assembly {</span>
   831 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   832 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   833 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   834 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   835 |     | <span class='neutral'>        }</span>
   836 |     | <span class='neutral'>    }</span>
   837 |     | <span class='neutral'></span>
   838 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2) internal pure {</span>
   839 |     | <span class='neutral'>        bytes32 m0;</span>
   840 |     | <span class='neutral'>        bytes32 m1;</span>
   841 |     | <span class='neutral'>        bytes32 m2;</span>
   842 |     | <span class='neutral'>        bytes32 m3;</span>
   843 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   844 |     | <span class='neutral'>        assembly {</span>
   845 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   846 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   847 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   848 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   849 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256)`.</span>
   850 |     | <span class='neutral'>            mstore(0x00, 0x9c4f99fb)</span>
   851 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   852 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   853 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   854 |     | <span class='neutral'>        }</span>
   855 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   856 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   857 |     | <span class='neutral'>        assembly {</span>
   858 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   859 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   860 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   861 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   862 |     | <span class='neutral'>        }</span>
   863 |     | <span class='neutral'>    }</span>
   864 |     | <span class='neutral'></span>
   865 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2) internal pure {</span>
   866 |     | <span class='neutral'>        bytes32 m0;</span>
   867 |     | <span class='neutral'>        bytes32 m1;</span>
   868 |     | <span class='neutral'>        bytes32 m2;</span>
   869 |     | <span class='neutral'>        bytes32 m3;</span>
   870 |     | <span class='neutral'>        bytes32 m4;</span>
   871 |     | <span class='neutral'>        bytes32 m5;</span>
   872 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   873 |     | <span class='neutral'>        assembly {</span>
   874 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   875 |     | <span class='neutral'>                let length := 0</span>
   876 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   877 |     | <span class='neutral'>                mstore(pos, length)</span>
   878 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   879 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   880 |     | <span class='neutral'>            }</span>
   881 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   882 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   883 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   884 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   885 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   886 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
   887 |     | <span class='neutral'>            // Selector of `log(address,bool,string)`.</span>
   888 |     | <span class='neutral'>            mstore(0x00, 0x212255cc)</span>
   889 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   890 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   891 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
   892 |     | <span class='neutral'>            writeString(0x80, p2)</span>
   893 |     | <span class='neutral'>        }</span>
   894 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
   895 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   896 |     | <span class='neutral'>        assembly {</span>
   897 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   898 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   899 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   900 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   901 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   902 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
   903 |     | <span class='neutral'>        }</span>
   904 |     | <span class='neutral'>    }</span>
   905 |     | <span class='neutral'></span>
   906 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2) internal pure {</span>
   907 |     | <span class='neutral'>        bytes32 m0;</span>
   908 |     | <span class='neutral'>        bytes32 m1;</span>
   909 |     | <span class='neutral'>        bytes32 m2;</span>
   910 |     | <span class='neutral'>        bytes32 m3;</span>
   911 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   912 |     | <span class='neutral'>        assembly {</span>
   913 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   914 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   915 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   916 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   917 |     | <span class='neutral'>            // Selector of `log(address,uint256,address)`.</span>
   918 |     | <span class='neutral'>            mstore(0x00, 0x7bc0d848)</span>
   919 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   920 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   921 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   922 |     | <span class='neutral'>        }</span>
   923 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   924 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   925 |     | <span class='neutral'>        assembly {</span>
   926 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   927 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   928 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   929 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   930 |     | <span class='neutral'>        }</span>
   931 |     | <span class='neutral'>    }</span>
   932 |     | <span class='neutral'></span>
   933 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2) internal pure {</span>
   934 |     | <span class='neutral'>        bytes32 m0;</span>
   935 |     | <span class='neutral'>        bytes32 m1;</span>
   936 |     | <span class='neutral'>        bytes32 m2;</span>
   937 |     | <span class='neutral'>        bytes32 m3;</span>
   938 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   939 |     | <span class='neutral'>        assembly {</span>
   940 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   941 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   942 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   943 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   944 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool)`.</span>
   945 |     | <span class='neutral'>            mstore(0x00, 0x678209a8)</span>
   946 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   947 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   948 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   949 |     | <span class='neutral'>        }</span>
   950 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   951 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   952 |     | <span class='neutral'>        assembly {</span>
   953 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   954 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   955 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   956 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   957 |     | <span class='neutral'>        }</span>
   958 |     | <span class='neutral'>    }</span>
   959 |     | <span class='neutral'></span>
   960 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2) internal pure {</span>
   961 |     | <span class='neutral'>        bytes32 m0;</span>
   962 |     | <span class='neutral'>        bytes32 m1;</span>
   963 |     | <span class='neutral'>        bytes32 m2;</span>
   964 |     | <span class='neutral'>        bytes32 m3;</span>
   965 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   966 |     | <span class='neutral'>        assembly {</span>
   967 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   968 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   969 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   970 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   971 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256)`.</span>
   972 |     | <span class='neutral'>            mstore(0x00, 0xb69bcaf6)</span>
   973 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   974 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   975 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   976 |     | <span class='neutral'>        }</span>
   977 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   978 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   979 |     | <span class='neutral'>        assembly {</span>
   980 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   981 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   982 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   983 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   984 |     | <span class='neutral'>        }</span>
   985 |     | <span class='neutral'>    }</span>
   986 |     | <span class='neutral'></span>
   987 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2) internal pure {</span>
   988 |     | <span class='neutral'>        bytes32 m0;</span>
   989 |     | <span class='neutral'>        bytes32 m1;</span>
   990 |     | <span class='neutral'>        bytes32 m2;</span>
   991 |     | <span class='neutral'>        bytes32 m3;</span>
   992 |     | <span class='neutral'>        bytes32 m4;</span>
   993 |     | <span class='neutral'>        bytes32 m5;</span>
   994 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   995 |     | <span class='neutral'>        assembly {</span>
   996 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   997 |     | <span class='neutral'>                let length := 0</span>
   998 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   999 |     | <span class='neutral'>                mstore(pos, length)</span>
  1000 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1001 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1002 |     | <span class='neutral'>            }</span>
  1003 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1004 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1005 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1006 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1007 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1008 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1009 |     | <span class='neutral'>            // Selector of `log(address,uint256,string)`.</span>
  1010 |     | <span class='neutral'>            mstore(0x00, 0xa1f2e8aa)</span>
  1011 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1012 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1013 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1014 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1015 |     | <span class='neutral'>        }</span>
  1016 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1017 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1018 |     | <span class='neutral'>        assembly {</span>
  1019 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1020 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1021 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1022 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1023 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1024 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1025 |     | <span class='neutral'>        }</span>
  1026 |     | <span class='neutral'>    }</span>
  1027 |     | <span class='neutral'></span>
  1028 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2) internal pure {</span>
  1029 |     | <span class='neutral'>        bytes32 m0;</span>
  1030 |     | <span class='neutral'>        bytes32 m1;</span>
  1031 |     | <span class='neutral'>        bytes32 m2;</span>
  1032 |     | <span class='neutral'>        bytes32 m3;</span>
  1033 |     | <span class='neutral'>        bytes32 m4;</span>
  1034 |     | <span class='neutral'>        bytes32 m5;</span>
  1035 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1036 |     | <span class='neutral'>        assembly {</span>
  1037 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1038 |     | <span class='neutral'>                let length := 0</span>
  1039 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1040 |     | <span class='neutral'>                mstore(pos, length)</span>
  1041 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1042 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1043 |     | <span class='neutral'>            }</span>
  1044 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1045 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1046 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1047 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1048 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1049 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1050 |     | <span class='neutral'>            // Selector of `log(address,string,address)`.</span>
  1051 |     | <span class='neutral'>            mstore(0x00, 0xf08744e8)</span>
  1052 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1053 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1054 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1055 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1056 |     | <span class='neutral'>        }</span>
  1057 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1058 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1059 |     | <span class='neutral'>        assembly {</span>
  1060 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1061 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1062 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1063 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1064 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1065 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1066 |     | <span class='neutral'>        }</span>
  1067 |     | <span class='neutral'>    }</span>
  1068 |     | <span class='neutral'></span>
  1069 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2) internal pure {</span>
  1070 |     | <span class='neutral'>        bytes32 m0;</span>
  1071 |     | <span class='neutral'>        bytes32 m1;</span>
  1072 |     | <span class='neutral'>        bytes32 m2;</span>
  1073 |     | <span class='neutral'>        bytes32 m3;</span>
  1074 |     | <span class='neutral'>        bytes32 m4;</span>
  1075 |     | <span class='neutral'>        bytes32 m5;</span>
  1076 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1077 |     | <span class='neutral'>        assembly {</span>
  1078 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1079 |     | <span class='neutral'>                let length := 0</span>
  1080 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1081 |     | <span class='neutral'>                mstore(pos, length)</span>
  1082 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1083 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1084 |     | <span class='neutral'>            }</span>
  1085 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1086 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1087 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1088 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1089 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1090 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1091 |     | <span class='neutral'>            // Selector of `log(address,string,bool)`.</span>
  1092 |     | <span class='neutral'>            mstore(0x00, 0xcf020fb1)</span>
  1093 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1094 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1095 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1096 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1097 |     | <span class='neutral'>        }</span>
  1098 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1099 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1100 |     | <span class='neutral'>        assembly {</span>
  1101 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1102 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1103 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1104 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1105 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1106 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1107 |     | <span class='neutral'>        }</span>
  1108 |     | <span class='neutral'>    }</span>
  1109 |     | <span class='neutral'></span>
  1110 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2) internal pure {</span>
  1111 |     | <span class='neutral'>        bytes32 m0;</span>
  1112 |     | <span class='neutral'>        bytes32 m1;</span>
  1113 |     | <span class='neutral'>        bytes32 m2;</span>
  1114 |     | <span class='neutral'>        bytes32 m3;</span>
  1115 |     | <span class='neutral'>        bytes32 m4;</span>
  1116 |     | <span class='neutral'>        bytes32 m5;</span>
  1117 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1118 |     | <span class='neutral'>        assembly {</span>
  1119 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1120 |     | <span class='neutral'>                let length := 0</span>
  1121 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1122 |     | <span class='neutral'>                mstore(pos, length)</span>
  1123 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1124 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1125 |     | <span class='neutral'>            }</span>
  1126 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1127 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1128 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1129 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1130 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1131 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1132 |     | <span class='neutral'>            // Selector of `log(address,string,uint256)`.</span>
  1133 |     | <span class='neutral'>            mstore(0x00, 0x67dd6ff1)</span>
  1134 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1135 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1136 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1137 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1138 |     | <span class='neutral'>        }</span>
  1139 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1140 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1141 |     | <span class='neutral'>        assembly {</span>
  1142 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1143 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1144 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1145 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1146 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1147 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1148 |     | <span class='neutral'>        }</span>
  1149 |     | <span class='neutral'>    }</span>
  1150 |     | <span class='neutral'></span>
  1151 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2) internal pure {</span>
  1152 |     | <span class='neutral'>        bytes32 m0;</span>
  1153 |     | <span class='neutral'>        bytes32 m1;</span>
  1154 |     | <span class='neutral'>        bytes32 m2;</span>
  1155 |     | <span class='neutral'>        bytes32 m3;</span>
  1156 |     | <span class='neutral'>        bytes32 m4;</span>
  1157 |     | <span class='neutral'>        bytes32 m5;</span>
  1158 |     | <span class='neutral'>        bytes32 m6;</span>
  1159 |     | <span class='neutral'>        bytes32 m7;</span>
  1160 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1161 |     | <span class='neutral'>        assembly {</span>
  1162 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1163 |     | <span class='neutral'>                let length := 0</span>
  1164 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1165 |     | <span class='neutral'>                mstore(pos, length)</span>
  1166 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1167 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1168 |     | <span class='neutral'>            }</span>
  1169 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1170 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1171 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1172 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1173 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1174 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1175 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  1176 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  1177 |     | <span class='neutral'>            // Selector of `log(address,string,string)`.</span>
  1178 |     | <span class='neutral'>            mstore(0x00, 0xfb772265)</span>
  1179 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1180 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1181 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  1182 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1183 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  1184 |     | <span class='neutral'>        }</span>
  1185 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  1186 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1187 |     | <span class='neutral'>        assembly {</span>
  1188 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1189 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1190 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1191 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1192 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1193 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1194 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  1195 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  1196 |     | <span class='neutral'>        }</span>
  1197 |     | <span class='neutral'>    }</span>
  1198 |     | <span class='neutral'></span>
  1199 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal pure {</span>
  1200 |     | <span class='neutral'>        bytes32 m0;</span>
  1201 |     | <span class='neutral'>        bytes32 m1;</span>
  1202 |     | <span class='neutral'>        bytes32 m2;</span>
  1203 |     | <span class='neutral'>        bytes32 m3;</span>
  1204 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1205 |     | <span class='neutral'>        assembly {</span>
  1206 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1207 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1208 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1209 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1210 |     | <span class='neutral'>            // Selector of `log(bool,address,address)`.</span>
  1211 |     | <span class='neutral'>            mstore(0x00, 0xd2763667)</span>
  1212 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1213 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1214 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1215 |     | <span class='neutral'>        }</span>
  1216 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1217 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1218 |     | <span class='neutral'>        assembly {</span>
  1219 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1220 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1221 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1222 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1223 |     | <span class='neutral'>        }</span>
  1224 |     | <span class='neutral'>    }</span>
  1225 |     | <span class='neutral'></span>
  1226 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal pure {</span>
  1227 |     | <span class='neutral'>        bytes32 m0;</span>
  1228 |     | <span class='neutral'>        bytes32 m1;</span>
  1229 |     | <span class='neutral'>        bytes32 m2;</span>
  1230 |     | <span class='neutral'>        bytes32 m3;</span>
  1231 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1232 |     | <span class='neutral'>        assembly {</span>
  1233 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1234 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1235 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1236 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1237 |     | <span class='neutral'>            // Selector of `log(bool,address,bool)`.</span>
  1238 |     | <span class='neutral'>            mstore(0x00, 0x18c9c746)</span>
  1239 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1240 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1241 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1242 |     | <span class='neutral'>        }</span>
  1243 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1244 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1245 |     | <span class='neutral'>        assembly {</span>
  1246 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1247 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1248 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1249 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1250 |     | <span class='neutral'>        }</span>
  1251 |     | <span class='neutral'>    }</span>
  1252 |     | <span class='neutral'></span>
  1253 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2) internal pure {</span>
  1254 |     | <span class='neutral'>        bytes32 m0;</span>
  1255 |     | <span class='neutral'>        bytes32 m1;</span>
  1256 |     | <span class='neutral'>        bytes32 m2;</span>
  1257 |     | <span class='neutral'>        bytes32 m3;</span>
  1258 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1259 |     | <span class='neutral'>        assembly {</span>
  1260 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1261 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1262 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1263 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1264 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256)`.</span>
  1265 |     | <span class='neutral'>            mstore(0x00, 0x5f7b9afb)</span>
  1266 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1267 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1268 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1269 |     | <span class='neutral'>        }</span>
  1270 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1271 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1272 |     | <span class='neutral'>        assembly {</span>
  1273 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1274 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1275 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1276 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1277 |     | <span class='neutral'>        }</span>
  1278 |     | <span class='neutral'>    }</span>
  1279 |     | <span class='neutral'></span>
  1280 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2) internal pure {</span>
  1281 |     | <span class='neutral'>        bytes32 m0;</span>
  1282 |     | <span class='neutral'>        bytes32 m1;</span>
  1283 |     | <span class='neutral'>        bytes32 m2;</span>
  1284 |     | <span class='neutral'>        bytes32 m3;</span>
  1285 |     | <span class='neutral'>        bytes32 m4;</span>
  1286 |     | <span class='neutral'>        bytes32 m5;</span>
  1287 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1288 |     | <span class='neutral'>        assembly {</span>
  1289 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1290 |     | <span class='neutral'>                let length := 0</span>
  1291 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1292 |     | <span class='neutral'>                mstore(pos, length)</span>
  1293 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1294 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1295 |     | <span class='neutral'>            }</span>
  1296 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1297 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1298 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1299 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1300 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1301 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1302 |     | <span class='neutral'>            // Selector of `log(bool,address,string)`.</span>
  1303 |     | <span class='neutral'>            mstore(0x00, 0xde9a9270)</span>
  1304 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1305 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1306 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1307 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1308 |     | <span class='neutral'>        }</span>
  1309 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1310 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1311 |     | <span class='neutral'>        assembly {</span>
  1312 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1313 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1314 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1315 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1316 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1317 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1318 |     | <span class='neutral'>        }</span>
  1319 |     | <span class='neutral'>    }</span>
  1320 |     | <span class='neutral'></span>
  1321 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal pure {</span>
  1322 |     | <span class='neutral'>        bytes32 m0;</span>
  1323 |     | <span class='neutral'>        bytes32 m1;</span>
  1324 |     | <span class='neutral'>        bytes32 m2;</span>
  1325 |     | <span class='neutral'>        bytes32 m3;</span>
  1326 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1327 |     | <span class='neutral'>        assembly {</span>
  1328 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1329 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1330 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1331 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1332 |     | <span class='neutral'>            // Selector of `log(bool,bool,address)`.</span>
  1333 |     | <span class='neutral'>            mstore(0x00, 0x1078f68d)</span>
  1334 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1335 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1336 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1337 |     | <span class='neutral'>        }</span>
  1338 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1339 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1340 |     | <span class='neutral'>        assembly {</span>
  1341 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1342 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1343 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1344 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1345 |     | <span class='neutral'>        }</span>
  1346 |     | <span class='neutral'>    }</span>
  1347 |     | <span class='neutral'></span>
  1348 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal pure {</span>
  1349 |     | <span class='neutral'>        bytes32 m0;</span>
  1350 |     | <span class='neutral'>        bytes32 m1;</span>
  1351 |     | <span class='neutral'>        bytes32 m2;</span>
  1352 |     | <span class='neutral'>        bytes32 m3;</span>
  1353 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1354 |     | <span class='neutral'>        assembly {</span>
  1355 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1356 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1357 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1358 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1359 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool)`.</span>
  1360 |     | <span class='neutral'>            mstore(0x00, 0x50709698)</span>
  1361 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1362 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1363 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1364 |     | <span class='neutral'>        }</span>
  1365 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1366 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1367 |     | <span class='neutral'>        assembly {</span>
  1368 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1369 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1370 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1371 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1372 |     | <span class='neutral'>        }</span>
  1373 |     | <span class='neutral'>    }</span>
  1374 |     | <span class='neutral'></span>
  1375 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2) internal pure {</span>
  1376 |     | <span class='neutral'>        bytes32 m0;</span>
  1377 |     | <span class='neutral'>        bytes32 m1;</span>
  1378 |     | <span class='neutral'>        bytes32 m2;</span>
  1379 |     | <span class='neutral'>        bytes32 m3;</span>
  1380 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1381 |     | <span class='neutral'>        assembly {</span>
  1382 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1383 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1384 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1385 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1386 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256)`.</span>
  1387 |     | <span class='neutral'>            mstore(0x00, 0x12f21602)</span>
  1388 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1389 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1390 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1391 |     | <span class='neutral'>        }</span>
  1392 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1393 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1394 |     | <span class='neutral'>        assembly {</span>
  1395 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1396 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1397 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1398 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1399 |     | <span class='neutral'>        }</span>
  1400 |     | <span class='neutral'>    }</span>
  1401 |     | <span class='neutral'></span>
  1402 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2) internal pure {</span>
  1403 |     | <span class='neutral'>        bytes32 m0;</span>
  1404 |     | <span class='neutral'>        bytes32 m1;</span>
  1405 |     | <span class='neutral'>        bytes32 m2;</span>
  1406 |     | <span class='neutral'>        bytes32 m3;</span>
  1407 |     | <span class='neutral'>        bytes32 m4;</span>
  1408 |     | <span class='neutral'>        bytes32 m5;</span>
  1409 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1410 |     | <span class='neutral'>        assembly {</span>
  1411 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1412 |     | <span class='neutral'>                let length := 0</span>
  1413 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1414 |     | <span class='neutral'>                mstore(pos, length)</span>
  1415 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1416 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1417 |     | <span class='neutral'>            }</span>
  1418 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1419 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1420 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1421 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1422 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1423 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1424 |     | <span class='neutral'>            // Selector of `log(bool,bool,string)`.</span>
  1425 |     | <span class='neutral'>            mstore(0x00, 0x2555fa46)</span>
  1426 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1427 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1428 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1429 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1430 |     | <span class='neutral'>        }</span>
  1431 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1432 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1433 |     | <span class='neutral'>        assembly {</span>
  1434 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1435 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1436 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1437 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1438 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1439 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1440 |     | <span class='neutral'>        }</span>
  1441 |     | <span class='neutral'>    }</span>
  1442 |     | <span class='neutral'></span>
  1443 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2) internal pure {</span>
  1444 |     | <span class='neutral'>        bytes32 m0;</span>
  1445 |     | <span class='neutral'>        bytes32 m1;</span>
  1446 |     | <span class='neutral'>        bytes32 m2;</span>
  1447 |     | <span class='neutral'>        bytes32 m3;</span>
  1448 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1449 |     | <span class='neutral'>        assembly {</span>
  1450 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1451 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1452 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1453 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1454 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address)`.</span>
  1455 |     | <span class='neutral'>            mstore(0x00, 0x088ef9d2)</span>
  1456 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1457 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1458 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1459 |     | <span class='neutral'>        }</span>
  1460 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1461 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1462 |     | <span class='neutral'>        assembly {</span>
  1463 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1464 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1465 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1466 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1467 |     | <span class='neutral'>        }</span>
  1468 |     | <span class='neutral'>    }</span>
  1469 |     | <span class='neutral'></span>
  1470 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2) internal pure {</span>
  1471 |     | <span class='neutral'>        bytes32 m0;</span>
  1472 |     | <span class='neutral'>        bytes32 m1;</span>
  1473 |     | <span class='neutral'>        bytes32 m2;</span>
  1474 |     | <span class='neutral'>        bytes32 m3;</span>
  1475 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1476 |     | <span class='neutral'>        assembly {</span>
  1477 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1478 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1479 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1480 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1481 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool)`.</span>
  1482 |     | <span class='neutral'>            mstore(0x00, 0xe8defba9)</span>
  1483 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1484 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1485 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1486 |     | <span class='neutral'>        }</span>
  1487 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1488 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1489 |     | <span class='neutral'>        assembly {</span>
  1490 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1491 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1492 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1493 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1494 |     | <span class='neutral'>        }</span>
  1495 |     | <span class='neutral'>    }</span>
  1496 |     | <span class='neutral'></span>
  1497 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2) internal pure {</span>
  1498 |     | <span class='neutral'>        bytes32 m0;</span>
  1499 |     | <span class='neutral'>        bytes32 m1;</span>
  1500 |     | <span class='neutral'>        bytes32 m2;</span>
  1501 |     | <span class='neutral'>        bytes32 m3;</span>
  1502 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1503 |     | <span class='neutral'>        assembly {</span>
  1504 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1505 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1506 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1507 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1508 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256)`.</span>
  1509 |     | <span class='neutral'>            mstore(0x00, 0x37103367)</span>
  1510 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1511 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1512 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1513 |     | <span class='neutral'>        }</span>
  1514 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1515 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1516 |     | <span class='neutral'>        assembly {</span>
  1517 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1518 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1519 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1520 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1521 |     | <span class='neutral'>        }</span>
  1522 |     | <span class='neutral'>    }</span>
  1523 |     | <span class='neutral'></span>
  1524 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2) internal pure {</span>
  1525 |     | <span class='neutral'>        bytes32 m0;</span>
  1526 |     | <span class='neutral'>        bytes32 m1;</span>
  1527 |     | <span class='neutral'>        bytes32 m2;</span>
  1528 |     | <span class='neutral'>        bytes32 m3;</span>
  1529 |     | <span class='neutral'>        bytes32 m4;</span>
  1530 |     | <span class='neutral'>        bytes32 m5;</span>
  1531 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1532 |     | <span class='neutral'>        assembly {</span>
  1533 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1534 |     | <span class='neutral'>                let length := 0</span>
  1535 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1536 |     | <span class='neutral'>                mstore(pos, length)</span>
  1537 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1538 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1539 |     | <span class='neutral'>            }</span>
  1540 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1541 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1542 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1543 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1544 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1545 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1546 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string)`.</span>
  1547 |     | <span class='neutral'>            mstore(0x00, 0xc3fc3970)</span>
  1548 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1549 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1550 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1551 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1552 |     | <span class='neutral'>        }</span>
  1553 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1554 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1555 |     | <span class='neutral'>        assembly {</span>
  1556 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1557 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1558 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1559 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1560 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1561 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1562 |     | <span class='neutral'>        }</span>
  1563 |     | <span class='neutral'>    }</span>
  1564 |     | <span class='neutral'></span>
  1565 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2) internal pure {</span>
  1566 |     | <span class='neutral'>        bytes32 m0;</span>
  1567 |     | <span class='neutral'>        bytes32 m1;</span>
  1568 |     | <span class='neutral'>        bytes32 m2;</span>
  1569 |     | <span class='neutral'>        bytes32 m3;</span>
  1570 |     | <span class='neutral'>        bytes32 m4;</span>
  1571 |     | <span class='neutral'>        bytes32 m5;</span>
  1572 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1573 |     | <span class='neutral'>        assembly {</span>
  1574 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1575 |     | <span class='neutral'>                let length := 0</span>
  1576 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1577 |     | <span class='neutral'>                mstore(pos, length)</span>
  1578 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1579 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1580 |     | <span class='neutral'>            }</span>
  1581 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1582 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1583 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1584 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1585 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1586 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1587 |     | <span class='neutral'>            // Selector of `log(bool,string,address)`.</span>
  1588 |     | <span class='neutral'>            mstore(0x00, 0x9591b953)</span>
  1589 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1590 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1591 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1592 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1593 |     | <span class='neutral'>        }</span>
  1594 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1595 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1596 |     | <span class='neutral'>        assembly {</span>
  1597 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1598 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1599 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1600 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1601 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1602 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1603 |     | <span class='neutral'>        }</span>
  1604 |     | <span class='neutral'>    }</span>
  1605 |     | <span class='neutral'></span>
  1606 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2) internal pure {</span>
  1607 |     | <span class='neutral'>        bytes32 m0;</span>
  1608 |     | <span class='neutral'>        bytes32 m1;</span>
  1609 |     | <span class='neutral'>        bytes32 m2;</span>
  1610 |     | <span class='neutral'>        bytes32 m3;</span>
  1611 |     | <span class='neutral'>        bytes32 m4;</span>
  1612 |     | <span class='neutral'>        bytes32 m5;</span>
  1613 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1614 |     | <span class='neutral'>        assembly {</span>
  1615 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1616 |     | <span class='neutral'>                let length := 0</span>
  1617 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1618 |     | <span class='neutral'>                mstore(pos, length)</span>
  1619 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1620 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1621 |     | <span class='neutral'>            }</span>
  1622 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1623 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1624 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1625 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1626 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1627 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1628 |     | <span class='neutral'>            // Selector of `log(bool,string,bool)`.</span>
  1629 |     | <span class='neutral'>            mstore(0x00, 0xdbb4c247)</span>
  1630 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1631 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1632 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1633 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1634 |     | <span class='neutral'>        }</span>
  1635 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1636 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1637 |     | <span class='neutral'>        assembly {</span>
  1638 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1639 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1640 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1641 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1642 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1643 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1644 |     | <span class='neutral'>        }</span>
  1645 |     | <span class='neutral'>    }</span>
  1646 |     | <span class='neutral'></span>
  1647 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2) internal pure {</span>
  1648 |     | <span class='neutral'>        bytes32 m0;</span>
  1649 |     | <span class='neutral'>        bytes32 m1;</span>
  1650 |     | <span class='neutral'>        bytes32 m2;</span>
  1651 |     | <span class='neutral'>        bytes32 m3;</span>
  1652 |     | <span class='neutral'>        bytes32 m4;</span>
  1653 |     | <span class='neutral'>        bytes32 m5;</span>
  1654 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1655 |     | <span class='neutral'>        assembly {</span>
  1656 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1657 |     | <span class='neutral'>                let length := 0</span>
  1658 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1659 |     | <span class='neutral'>                mstore(pos, length)</span>
  1660 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1661 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1662 |     | <span class='neutral'>            }</span>
  1663 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1664 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1665 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1666 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1667 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1668 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1669 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256)`.</span>
  1670 |     | <span class='neutral'>            mstore(0x00, 0x1093ee11)</span>
  1671 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1672 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1673 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1674 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1675 |     | <span class='neutral'>        }</span>
  1676 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1677 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1678 |     | <span class='neutral'>        assembly {</span>
  1679 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1680 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1681 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1682 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1683 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1684 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1685 |     | <span class='neutral'>        }</span>
  1686 |     | <span class='neutral'>    }</span>
  1687 |     | <span class='neutral'></span>
  1688 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2) internal pure {</span>
  1689 |     | <span class='neutral'>        bytes32 m0;</span>
  1690 |     | <span class='neutral'>        bytes32 m1;</span>
  1691 |     | <span class='neutral'>        bytes32 m2;</span>
  1692 |     | <span class='neutral'>        bytes32 m3;</span>
  1693 |     | <span class='neutral'>        bytes32 m4;</span>
  1694 |     | <span class='neutral'>        bytes32 m5;</span>
  1695 |     | <span class='neutral'>        bytes32 m6;</span>
  1696 |     | <span class='neutral'>        bytes32 m7;</span>
  1697 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1698 |     | <span class='neutral'>        assembly {</span>
  1699 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1700 |     | <span class='neutral'>                let length := 0</span>
  1701 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1702 |     | <span class='neutral'>                mstore(pos, length)</span>
  1703 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1704 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1705 |     | <span class='neutral'>            }</span>
  1706 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1707 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1708 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1709 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1710 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1711 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1712 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  1713 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  1714 |     | <span class='neutral'>            // Selector of `log(bool,string,string)`.</span>
  1715 |     | <span class='neutral'>            mstore(0x00, 0xb076847f)</span>
  1716 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1717 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1718 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  1719 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1720 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  1721 |     | <span class='neutral'>        }</span>
  1722 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  1723 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1724 |     | <span class='neutral'>        assembly {</span>
  1725 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1726 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1727 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1728 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1729 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1730 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1731 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  1732 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  1733 |     | <span class='neutral'>        }</span>
  1734 |     | <span class='neutral'>    }</span>
  1735 |     | <span class='neutral'></span>
  1736 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2) internal pure {</span>
  1737 |     | <span class='neutral'>        bytes32 m0;</span>
  1738 |     | <span class='neutral'>        bytes32 m1;</span>
  1739 |     | <span class='neutral'>        bytes32 m2;</span>
  1740 |     | <span class='neutral'>        bytes32 m3;</span>
  1741 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1742 |     | <span class='neutral'>        assembly {</span>
  1743 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1744 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1745 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1746 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1747 |     | <span class='neutral'>            // Selector of `log(uint256,address,address)`.</span>
  1748 |     | <span class='neutral'>            mstore(0x00, 0xbcfd9be0)</span>
  1749 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1750 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1751 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1752 |     | <span class='neutral'>        }</span>
  1753 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1754 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1755 |     | <span class='neutral'>        assembly {</span>
  1756 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1757 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1758 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1759 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1760 |     | <span class='neutral'>        }</span>
  1761 |     | <span class='neutral'>    }</span>
  1762 |     | <span class='neutral'></span>
  1763 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2) internal pure {</span>
  1764 |     | <span class='neutral'>        bytes32 m0;</span>
  1765 |     | <span class='neutral'>        bytes32 m1;</span>
  1766 |     | <span class='neutral'>        bytes32 m2;</span>
  1767 |     | <span class='neutral'>        bytes32 m3;</span>
  1768 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1769 |     | <span class='neutral'>        assembly {</span>
  1770 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1771 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1772 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1773 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1774 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool)`.</span>
  1775 |     | <span class='neutral'>            mstore(0x00, 0x9b6ec042)</span>
  1776 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1777 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1778 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1779 |     | <span class='neutral'>        }</span>
  1780 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1781 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1782 |     | <span class='neutral'>        assembly {</span>
  1783 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1784 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1785 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1786 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1787 |     | <span class='neutral'>        }</span>
  1788 |     | <span class='neutral'>    }</span>
  1789 |     | <span class='neutral'></span>
  1790 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2) internal pure {</span>
  1791 |     | <span class='neutral'>        bytes32 m0;</span>
  1792 |     | <span class='neutral'>        bytes32 m1;</span>
  1793 |     | <span class='neutral'>        bytes32 m2;</span>
  1794 |     | <span class='neutral'>        bytes32 m3;</span>
  1795 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1796 |     | <span class='neutral'>        assembly {</span>
  1797 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1798 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1799 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1800 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1801 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256)`.</span>
  1802 |     | <span class='neutral'>            mstore(0x00, 0x5a9b5ed5)</span>
  1803 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1804 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1805 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1806 |     | <span class='neutral'>        }</span>
  1807 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1808 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1809 |     | <span class='neutral'>        assembly {</span>
  1810 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1811 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1812 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1813 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1814 |     | <span class='neutral'>        }</span>
  1815 |     | <span class='neutral'>    }</span>
  1816 |     | <span class='neutral'></span>
  1817 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2) internal pure {</span>
  1818 |     | <span class='neutral'>        bytes32 m0;</span>
  1819 |     | <span class='neutral'>        bytes32 m1;</span>
  1820 |     | <span class='neutral'>        bytes32 m2;</span>
  1821 |     | <span class='neutral'>        bytes32 m3;</span>
  1822 |     | <span class='neutral'>        bytes32 m4;</span>
  1823 |     | <span class='neutral'>        bytes32 m5;</span>
  1824 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1825 |     | <span class='neutral'>        assembly {</span>
  1826 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1827 |     | <span class='neutral'>                let length := 0</span>
  1828 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1829 |     | <span class='neutral'>                mstore(pos, length)</span>
  1830 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1831 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1832 |     | <span class='neutral'>            }</span>
  1833 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1834 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1835 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1836 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1837 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1838 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1839 |     | <span class='neutral'>            // Selector of `log(uint256,address,string)`.</span>
  1840 |     | <span class='neutral'>            mstore(0x00, 0x63cb41f9)</span>
  1841 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1842 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1843 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1844 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1845 |     | <span class='neutral'>        }</span>
  1846 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1847 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1848 |     | <span class='neutral'>        assembly {</span>
  1849 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1850 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1851 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1852 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1853 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1854 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1855 |     | <span class='neutral'>        }</span>
  1856 |     | <span class='neutral'>    }</span>
  1857 |     | <span class='neutral'></span>
  1858 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2) internal pure {</span>
  1859 |     | <span class='neutral'>        bytes32 m0;</span>
  1860 |     | <span class='neutral'>        bytes32 m1;</span>
  1861 |     | <span class='neutral'>        bytes32 m2;</span>
  1862 |     | <span class='neutral'>        bytes32 m3;</span>
  1863 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1864 |     | <span class='neutral'>        assembly {</span>
  1865 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1866 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1867 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1868 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1869 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address)`.</span>
  1870 |     | <span class='neutral'>            mstore(0x00, 0x35085f7b)</span>
  1871 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1872 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1873 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1874 |     | <span class='neutral'>        }</span>
  1875 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1876 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1877 |     | <span class='neutral'>        assembly {</span>
  1878 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1879 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1880 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1881 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1882 |     | <span class='neutral'>        }</span>
  1883 |     | <span class='neutral'>    }</span>
  1884 |     | <span class='neutral'></span>
  1885 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2) internal pure {</span>
  1886 |     | <span class='neutral'>        bytes32 m0;</span>
  1887 |     | <span class='neutral'>        bytes32 m1;</span>
  1888 |     | <span class='neutral'>        bytes32 m2;</span>
  1889 |     | <span class='neutral'>        bytes32 m3;</span>
  1890 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1891 |     | <span class='neutral'>        assembly {</span>
  1892 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1893 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1894 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1895 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1896 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool)`.</span>
  1897 |     | <span class='neutral'>            mstore(0x00, 0x20718650)</span>
  1898 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1899 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1900 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1901 |     | <span class='neutral'>        }</span>
  1902 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1903 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1904 |     | <span class='neutral'>        assembly {</span>
  1905 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1906 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1907 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1908 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1909 |     | <span class='neutral'>        }</span>
  1910 |     | <span class='neutral'>    }</span>
  1911 |     | <span class='neutral'></span>
  1912 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2) internal pure {</span>
  1913 |     | <span class='neutral'>        bytes32 m0;</span>
  1914 |     | <span class='neutral'>        bytes32 m1;</span>
  1915 |     | <span class='neutral'>        bytes32 m2;</span>
  1916 |     | <span class='neutral'>        bytes32 m3;</span>
  1917 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1918 |     | <span class='neutral'>        assembly {</span>
  1919 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1920 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1921 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1922 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1923 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256)`.</span>
  1924 |     | <span class='neutral'>            mstore(0x00, 0x20098014)</span>
  1925 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1926 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1927 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1928 |     | <span class='neutral'>        }</span>
  1929 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1930 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1931 |     | <span class='neutral'>        assembly {</span>
  1932 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1933 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1934 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1935 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1936 |     | <span class='neutral'>        }</span>
  1937 |     | <span class='neutral'>    }</span>
  1938 |     | <span class='neutral'></span>
  1939 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2) internal pure {</span>
  1940 |     | <span class='neutral'>        bytes32 m0;</span>
  1941 |     | <span class='neutral'>        bytes32 m1;</span>
  1942 |     | <span class='neutral'>        bytes32 m2;</span>
  1943 |     | <span class='neutral'>        bytes32 m3;</span>
  1944 |     | <span class='neutral'>        bytes32 m4;</span>
  1945 |     | <span class='neutral'>        bytes32 m5;</span>
  1946 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1947 |     | <span class='neutral'>        assembly {</span>
  1948 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1949 |     | <span class='neutral'>                let length := 0</span>
  1950 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1951 |     | <span class='neutral'>                mstore(pos, length)</span>
  1952 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1953 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1954 |     | <span class='neutral'>            }</span>
  1955 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1956 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1957 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1958 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1959 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1960 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1961 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string)`.</span>
  1962 |     | <span class='neutral'>            mstore(0x00, 0x85775021)</span>
  1963 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1964 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1965 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1966 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1967 |     | <span class='neutral'>        }</span>
  1968 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1969 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1970 |     | <span class='neutral'>        assembly {</span>
  1971 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1972 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1973 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1974 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1975 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1976 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1977 |     | <span class='neutral'>        }</span>
  1978 |     | <span class='neutral'>    }</span>
  1979 |     | <span class='neutral'></span>
  1980 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2) internal pure {</span>
  1981 |     | <span class='neutral'>        bytes32 m0;</span>
  1982 |     | <span class='neutral'>        bytes32 m1;</span>
  1983 |     | <span class='neutral'>        bytes32 m2;</span>
  1984 |     | <span class='neutral'>        bytes32 m3;</span>
  1985 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1986 |     | <span class='neutral'>        assembly {</span>
  1987 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1988 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1989 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1990 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1991 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address)`.</span>
  1992 |     | <span class='neutral'>            mstore(0x00, 0x5c96b331)</span>
  1993 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1994 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1995 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1996 |     | <span class='neutral'>        }</span>
  1997 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1998 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  1999 |     | <span class='neutral'>        assembly {</span>
  2000 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2001 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2002 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2003 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2004 |     | <span class='neutral'>        }</span>
  2005 |     | <span class='neutral'>    }</span>
  2006 |     | <span class='neutral'></span>
  2007 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2) internal pure {</span>
  2008 |     | <span class='neutral'>        bytes32 m0;</span>
  2009 |     | <span class='neutral'>        bytes32 m1;</span>
  2010 |     | <span class='neutral'>        bytes32 m2;</span>
  2011 |     | <span class='neutral'>        bytes32 m3;</span>
  2012 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2013 |     | <span class='neutral'>        assembly {</span>
  2014 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2015 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2016 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2017 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2018 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool)`.</span>
  2019 |     | <span class='neutral'>            mstore(0x00, 0x4766da72)</span>
  2020 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2021 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2022 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2023 |     | <span class='neutral'>        }</span>
  2024 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  2025 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2026 |     | <span class='neutral'>        assembly {</span>
  2027 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2028 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2029 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2030 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2031 |     | <span class='neutral'>        }</span>
  2032 |     | <span class='neutral'>    }</span>
  2033 |     | <span class='neutral'></span>
  2034 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {</span>
  2035 |     | <span class='neutral'>        bytes32 m0;</span>
  2036 |     | <span class='neutral'>        bytes32 m1;</span>
  2037 |     | <span class='neutral'>        bytes32 m2;</span>
  2038 |     | <span class='neutral'>        bytes32 m3;</span>
  2039 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2040 |     | <span class='neutral'>        assembly {</span>
  2041 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2042 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2043 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2044 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2045 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256)`.</span>
  2046 |     | <span class='neutral'>            mstore(0x00, 0xd1ed7a3c)</span>
  2047 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2048 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2049 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2050 |     | <span class='neutral'>        }</span>
  2051 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  2052 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2053 |     | <span class='neutral'>        assembly {</span>
  2054 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2055 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2056 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2057 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2058 |     | <span class='neutral'>        }</span>
  2059 |     | <span class='neutral'>    }</span>
  2060 |     | <span class='neutral'></span>
  2061 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {</span>
  2062 |     | <span class='neutral'>        bytes32 m0;</span>
  2063 |     | <span class='neutral'>        bytes32 m1;</span>
  2064 |     | <span class='neutral'>        bytes32 m2;</span>
  2065 |     | <span class='neutral'>        bytes32 m3;</span>
  2066 |     | <span class='neutral'>        bytes32 m4;</span>
  2067 |     | <span class='neutral'>        bytes32 m5;</span>
  2068 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2069 |     | <span class='neutral'>        assembly {</span>
  2070 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2071 |     | <span class='neutral'>                let length := 0</span>
  2072 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2073 |     | <span class='neutral'>                mstore(pos, length)</span>
  2074 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2075 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2076 |     | <span class='neutral'>            }</span>
  2077 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2078 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2079 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2080 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2081 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2082 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2083 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string)`.</span>
  2084 |     | <span class='neutral'>            mstore(0x00, 0x71d04af2)</span>
  2085 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2086 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2087 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  2088 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  2089 |     | <span class='neutral'>        }</span>
  2090 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2091 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2092 |     | <span class='neutral'>        assembly {</span>
  2093 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2094 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2095 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2096 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2097 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2098 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2099 |     | <span class='neutral'>        }</span>
  2100 |     | <span class='neutral'>    }</span>
  2101 |     | <span class='neutral'></span>
  2102 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2) internal pure {</span>
  2103 |     | <span class='neutral'>        bytes32 m0;</span>
  2104 |     | <span class='neutral'>        bytes32 m1;</span>
  2105 |     | <span class='neutral'>        bytes32 m2;</span>
  2106 |     | <span class='neutral'>        bytes32 m3;</span>
  2107 |     | <span class='neutral'>        bytes32 m4;</span>
  2108 |     | <span class='neutral'>        bytes32 m5;</span>
  2109 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2110 |     | <span class='neutral'>        assembly {</span>
  2111 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2112 |     | <span class='neutral'>                let length := 0</span>
  2113 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2114 |     | <span class='neutral'>                mstore(pos, length)</span>
  2115 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2116 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2117 |     | <span class='neutral'>            }</span>
  2118 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2119 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2120 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2121 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2122 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2123 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2124 |     | <span class='neutral'>            // Selector of `log(uint256,string,address)`.</span>
  2125 |     | <span class='neutral'>            mstore(0x00, 0x7afac959)</span>
  2126 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2127 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  2128 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2129 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  2130 |     | <span class='neutral'>        }</span>
  2131 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2132 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2133 |     | <span class='neutral'>        assembly {</span>
  2134 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2135 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2136 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2137 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2138 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2139 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2140 |     | <span class='neutral'>        }</span>
  2141 |     | <span class='neutral'>    }</span>
  2142 |     | <span class='neutral'></span>
  2143 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2) internal pure {</span>
  2144 |     | <span class='neutral'>        bytes32 m0;</span>
  2145 |     | <span class='neutral'>        bytes32 m1;</span>
  2146 |     | <span class='neutral'>        bytes32 m2;</span>
  2147 |     | <span class='neutral'>        bytes32 m3;</span>
  2148 |     | <span class='neutral'>        bytes32 m4;</span>
  2149 |     | <span class='neutral'>        bytes32 m5;</span>
  2150 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2151 |     | <span class='neutral'>        assembly {</span>
  2152 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2153 |     | <span class='neutral'>                let length := 0</span>
  2154 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2155 |     | <span class='neutral'>                mstore(pos, length)</span>
  2156 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2157 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2158 |     | <span class='neutral'>            }</span>
  2159 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2160 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2161 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2162 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2163 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2164 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2165 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool)`.</span>
  2166 |     | <span class='neutral'>            mstore(0x00, 0x4ceda75a)</span>
  2167 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2168 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  2169 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2170 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  2171 |     | <span class='neutral'>        }</span>
  2172 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2173 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2174 |     | <span class='neutral'>        assembly {</span>
  2175 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2176 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2177 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2178 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2179 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2180 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2181 |     | <span class='neutral'>        }</span>
  2182 |     | <span class='neutral'>    }</span>
  2183 |     | <span class='neutral'></span>
  2184 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {</span>
  2185 |     | <span class='neutral'>        bytes32 m0;</span>
  2186 |     | <span class='neutral'>        bytes32 m1;</span>
  2187 |     | <span class='neutral'>        bytes32 m2;</span>
  2188 |     | <span class='neutral'>        bytes32 m3;</span>
  2189 |     | <span class='neutral'>        bytes32 m4;</span>
  2190 |     | <span class='neutral'>        bytes32 m5;</span>
  2191 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2192 |     | <span class='neutral'>        assembly {</span>
  2193 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2194 |     | <span class='neutral'>                let length := 0</span>
  2195 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2196 |     | <span class='neutral'>                mstore(pos, length)</span>
  2197 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2198 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2199 |     | <span class='neutral'>            }</span>
  2200 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2201 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2202 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2203 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2204 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2205 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2206 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256)`.</span>
  2207 |     | <span class='neutral'>            mstore(0x00, 0x37aa7d4c)</span>
  2208 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2209 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  2210 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2211 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  2212 |     | <span class='neutral'>        }</span>
  2213 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2214 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2215 |     | <span class='neutral'>        assembly {</span>
  2216 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2217 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2218 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2219 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2220 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2221 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2222 |     | <span class='neutral'>        }</span>
  2223 |     | <span class='neutral'>    }</span>
  2224 |     | <span class='neutral'></span>
  2225 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {</span>
  2226 |     | <span class='neutral'>        bytes32 m0;</span>
  2227 |     | <span class='neutral'>        bytes32 m1;</span>
  2228 |     | <span class='neutral'>        bytes32 m2;</span>
  2229 |     | <span class='neutral'>        bytes32 m3;</span>
  2230 |     | <span class='neutral'>        bytes32 m4;</span>
  2231 |     | <span class='neutral'>        bytes32 m5;</span>
  2232 |     | <span class='neutral'>        bytes32 m6;</span>
  2233 |     | <span class='neutral'>        bytes32 m7;</span>
  2234 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2235 |     | <span class='neutral'>        assembly {</span>
  2236 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2237 |     | <span class='neutral'>                let length := 0</span>
  2238 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2239 |     | <span class='neutral'>                mstore(pos, length)</span>
  2240 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2241 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2242 |     | <span class='neutral'>            }</span>
  2243 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2244 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2245 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2246 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2247 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2248 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2249 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2250 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2251 |     | <span class='neutral'>            // Selector of `log(uint256,string,string)`.</span>
  2252 |     | <span class='neutral'>            mstore(0x00, 0xb115611f)</span>
  2253 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2254 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  2255 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  2256 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  2257 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  2258 |     | <span class='neutral'>        }</span>
  2259 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2260 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2261 |     | <span class='neutral'>        assembly {</span>
  2262 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2263 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2264 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2265 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2266 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2267 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2268 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2269 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2270 |     | <span class='neutral'>        }</span>
  2271 |     | <span class='neutral'>    }</span>
  2272 |     | <span class='neutral'></span>
  2273 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2) internal pure {</span>
  2274 |     | <span class='neutral'>        bytes32 m0;</span>
  2275 |     | <span class='neutral'>        bytes32 m1;</span>
  2276 |     | <span class='neutral'>        bytes32 m2;</span>
  2277 |     | <span class='neutral'>        bytes32 m3;</span>
  2278 |     | <span class='neutral'>        bytes32 m4;</span>
  2279 |     | <span class='neutral'>        bytes32 m5;</span>
  2280 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2281 |     | <span class='neutral'>        assembly {</span>
  2282 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2283 |     | <span class='neutral'>                let length := 0</span>
  2284 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2285 |     | <span class='neutral'>                mstore(pos, length)</span>
  2286 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2287 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2288 |     | <span class='neutral'>            }</span>
  2289 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2290 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2291 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2292 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2293 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2294 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2295 |     | <span class='neutral'>            // Selector of `log(string,address,address)`.</span>
  2296 |     | <span class='neutral'>            mstore(0x00, 0xfcec75e0)</span>
  2297 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2298 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2299 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2300 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2301 |     | <span class='neutral'>        }</span>
  2302 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2303 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2304 |     | <span class='neutral'>        assembly {</span>
  2305 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2306 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2307 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2308 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2309 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2310 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2311 |     | <span class='neutral'>        }</span>
  2312 |     | <span class='neutral'>    }</span>
  2313 |     | <span class='neutral'></span>
  2314 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2) internal pure {</span>
  2315 |     | <span class='neutral'>        bytes32 m0;</span>
  2316 |     | <span class='neutral'>        bytes32 m1;</span>
  2317 |     | <span class='neutral'>        bytes32 m2;</span>
  2318 |     | <span class='neutral'>        bytes32 m3;</span>
  2319 |     | <span class='neutral'>        bytes32 m4;</span>
  2320 |     | <span class='neutral'>        bytes32 m5;</span>
  2321 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2322 |     | <span class='neutral'>        assembly {</span>
  2323 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2324 |     | <span class='neutral'>                let length := 0</span>
  2325 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2326 |     | <span class='neutral'>                mstore(pos, length)</span>
  2327 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2328 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2329 |     | <span class='neutral'>            }</span>
  2330 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2331 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2332 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2333 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2334 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2335 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2336 |     | <span class='neutral'>            // Selector of `log(string,address,bool)`.</span>
  2337 |     | <span class='neutral'>            mstore(0x00, 0xc91d5ed4)</span>
  2338 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2339 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2340 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2341 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2342 |     | <span class='neutral'>        }</span>
  2343 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2344 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2345 |     | <span class='neutral'>        assembly {</span>
  2346 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2347 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2348 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2349 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2350 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2351 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2352 |     | <span class='neutral'>        }</span>
  2353 |     | <span class='neutral'>    }</span>
  2354 |     | <span class='neutral'></span>
  2355 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2) internal pure {</span>
  2356 |     | <span class='neutral'>        bytes32 m0;</span>
  2357 |     | <span class='neutral'>        bytes32 m1;</span>
  2358 |     | <span class='neutral'>        bytes32 m2;</span>
  2359 |     | <span class='neutral'>        bytes32 m3;</span>
  2360 |     | <span class='neutral'>        bytes32 m4;</span>
  2361 |     | <span class='neutral'>        bytes32 m5;</span>
  2362 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2363 |     | <span class='neutral'>        assembly {</span>
  2364 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2365 |     | <span class='neutral'>                let length := 0</span>
  2366 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2367 |     | <span class='neutral'>                mstore(pos, length)</span>
  2368 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2369 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2370 |     | <span class='neutral'>            }</span>
  2371 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2372 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2373 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2374 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2375 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2376 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2377 |     | <span class='neutral'>            // Selector of `log(string,address,uint256)`.</span>
  2378 |     | <span class='neutral'>            mstore(0x00, 0x0d26b925)</span>
  2379 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2380 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2381 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2382 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2383 |     | <span class='neutral'>        }</span>
  2384 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2385 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2386 |     | <span class='neutral'>        assembly {</span>
  2387 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2388 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2389 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2390 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2391 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2392 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2393 |     | <span class='neutral'>        }</span>
  2394 |     | <span class='neutral'>    }</span>
  2395 |     | <span class='neutral'></span>
  2396 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2) internal pure {</span>
  2397 |     | <span class='neutral'>        bytes32 m0;</span>
  2398 |     | <span class='neutral'>        bytes32 m1;</span>
  2399 |     | <span class='neutral'>        bytes32 m2;</span>
  2400 |     | <span class='neutral'>        bytes32 m3;</span>
  2401 |     | <span class='neutral'>        bytes32 m4;</span>
  2402 |     | <span class='neutral'>        bytes32 m5;</span>
  2403 |     | <span class='neutral'>        bytes32 m6;</span>
  2404 |     | <span class='neutral'>        bytes32 m7;</span>
  2405 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2406 |     | <span class='neutral'>        assembly {</span>
  2407 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2408 |     | <span class='neutral'>                let length := 0</span>
  2409 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2410 |     | <span class='neutral'>                mstore(pos, length)</span>
  2411 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2412 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2413 |     | <span class='neutral'>            }</span>
  2414 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2415 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2416 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2417 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2418 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2419 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2420 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2421 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2422 |     | <span class='neutral'>            // Selector of `log(string,address,string)`.</span>
  2423 |     | <span class='neutral'>            mstore(0x00, 0xe0e9ad4f)</span>
  2424 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2425 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2426 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  2427 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2428 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  2429 |     | <span class='neutral'>        }</span>
  2430 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2431 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2432 |     | <span class='neutral'>        assembly {</span>
  2433 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2434 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2435 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2436 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2437 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2438 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2439 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2440 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2441 |     | <span class='neutral'>        }</span>
  2442 |     | <span class='neutral'>    }</span>
  2443 |     | <span class='neutral'></span>
  2444 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2) internal pure {</span>
  2445 |     | <span class='neutral'>        bytes32 m0;</span>
  2446 |     | <span class='neutral'>        bytes32 m1;</span>
  2447 |     | <span class='neutral'>        bytes32 m2;</span>
  2448 |     | <span class='neutral'>        bytes32 m3;</span>
  2449 |     | <span class='neutral'>        bytes32 m4;</span>
  2450 |     | <span class='neutral'>        bytes32 m5;</span>
  2451 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2452 |     | <span class='neutral'>        assembly {</span>
  2453 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2454 |     | <span class='neutral'>                let length := 0</span>
  2455 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2456 |     | <span class='neutral'>                mstore(pos, length)</span>
  2457 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2458 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2459 |     | <span class='neutral'>            }</span>
  2460 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2461 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2462 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2463 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2464 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2465 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2466 |     | <span class='neutral'>            // Selector of `log(string,bool,address)`.</span>
  2467 |     | <span class='neutral'>            mstore(0x00, 0x932bbb38)</span>
  2468 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2469 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2470 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2471 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2472 |     | <span class='neutral'>        }</span>
  2473 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2474 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2475 |     | <span class='neutral'>        assembly {</span>
  2476 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2477 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2478 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2479 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2480 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2481 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2482 |     | <span class='neutral'>        }</span>
  2483 |     | <span class='neutral'>    }</span>
  2484 |     | <span class='neutral'></span>
  2485 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2) internal pure {</span>
  2486 |     | <span class='neutral'>        bytes32 m0;</span>
  2487 |     | <span class='neutral'>        bytes32 m1;</span>
  2488 |     | <span class='neutral'>        bytes32 m2;</span>
  2489 |     | <span class='neutral'>        bytes32 m3;</span>
  2490 |     | <span class='neutral'>        bytes32 m4;</span>
  2491 |     | <span class='neutral'>        bytes32 m5;</span>
  2492 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2493 |     | <span class='neutral'>        assembly {</span>
  2494 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2495 |     | <span class='neutral'>                let length := 0</span>
  2496 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2497 |     | <span class='neutral'>                mstore(pos, length)</span>
  2498 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2499 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2500 |     | <span class='neutral'>            }</span>
  2501 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2502 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2503 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2504 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2505 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2506 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2507 |     | <span class='neutral'>            // Selector of `log(string,bool,bool)`.</span>
  2508 |     | <span class='neutral'>            mstore(0x00, 0x850b7ad6)</span>
  2509 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2510 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2511 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2512 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2513 |     | <span class='neutral'>        }</span>
  2514 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2515 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2516 |     | <span class='neutral'>        assembly {</span>
  2517 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2518 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2519 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2520 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2521 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2522 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2523 |     | <span class='neutral'>        }</span>
  2524 |     | <span class='neutral'>    }</span>
  2525 |     | <span class='neutral'></span>
  2526 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2) internal pure {</span>
  2527 |     | <span class='neutral'>        bytes32 m0;</span>
  2528 |     | <span class='neutral'>        bytes32 m1;</span>
  2529 |     | <span class='neutral'>        bytes32 m2;</span>
  2530 |     | <span class='neutral'>        bytes32 m3;</span>
  2531 |     | <span class='neutral'>        bytes32 m4;</span>
  2532 |     | <span class='neutral'>        bytes32 m5;</span>
  2533 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2534 |     | <span class='neutral'>        assembly {</span>
  2535 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2536 |     | <span class='neutral'>                let length := 0</span>
  2537 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2538 |     | <span class='neutral'>                mstore(pos, length)</span>
  2539 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2540 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2541 |     | <span class='neutral'>            }</span>
  2542 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2543 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2544 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2545 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2546 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2547 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2548 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256)`.</span>
  2549 |     | <span class='neutral'>            mstore(0x00, 0xc95958d6)</span>
  2550 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2551 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2552 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2553 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2554 |     | <span class='neutral'>        }</span>
  2555 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2556 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2557 |     | <span class='neutral'>        assembly {</span>
  2558 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2559 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2560 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2561 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2562 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2563 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2564 |     | <span class='neutral'>        }</span>
  2565 |     | <span class='neutral'>    }</span>
  2566 |     | <span class='neutral'></span>
  2567 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2) internal pure {</span>
  2568 |     | <span class='neutral'>        bytes32 m0;</span>
  2569 |     | <span class='neutral'>        bytes32 m1;</span>
  2570 |     | <span class='neutral'>        bytes32 m2;</span>
  2571 |     | <span class='neutral'>        bytes32 m3;</span>
  2572 |     | <span class='neutral'>        bytes32 m4;</span>
  2573 |     | <span class='neutral'>        bytes32 m5;</span>
  2574 |     | <span class='neutral'>        bytes32 m6;</span>
  2575 |     | <span class='neutral'>        bytes32 m7;</span>
  2576 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2577 |     | <span class='neutral'>        assembly {</span>
  2578 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2579 |     | <span class='neutral'>                let length := 0</span>
  2580 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2581 |     | <span class='neutral'>                mstore(pos, length)</span>
  2582 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2583 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2584 |     | <span class='neutral'>            }</span>
  2585 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2586 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2587 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2588 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2589 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2590 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2591 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2592 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2593 |     | <span class='neutral'>            // Selector of `log(string,bool,string)`.</span>
  2594 |     | <span class='neutral'>            mstore(0x00, 0xe298f47d)</span>
  2595 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2596 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2597 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  2598 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2599 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  2600 |     | <span class='neutral'>        }</span>
  2601 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2602 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2603 |     | <span class='neutral'>        assembly {</span>
  2604 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2605 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2606 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2607 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2608 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2609 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2610 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2611 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2612 |     | <span class='neutral'>        }</span>
  2613 |     | <span class='neutral'>    }</span>
  2614 |     | <span class='neutral'></span>
  2615 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2) internal pure {</span>
  2616 |     | <span class='neutral'>        bytes32 m0;</span>
  2617 |     | <span class='neutral'>        bytes32 m1;</span>
  2618 |     | <span class='neutral'>        bytes32 m2;</span>
  2619 |     | <span class='neutral'>        bytes32 m3;</span>
  2620 |     | <span class='neutral'>        bytes32 m4;</span>
  2621 |     | <span class='neutral'>        bytes32 m5;</span>
  2622 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2623 |     | <span class='neutral'>        assembly {</span>
  2624 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2625 |     | <span class='neutral'>                let length := 0</span>
  2626 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2627 |     | <span class='neutral'>                mstore(pos, length)</span>
  2628 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2629 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2630 |     | <span class='neutral'>            }</span>
  2631 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2632 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2633 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2634 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2635 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2636 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2637 |     | <span class='neutral'>            // Selector of `log(string,uint256,address)`.</span>
  2638 |     | <span class='neutral'>            mstore(0x00, 0x1c7ec448)</span>
  2639 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2640 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2641 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2642 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2643 |     | <span class='neutral'>        }</span>
  2644 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2645 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2646 |     | <span class='neutral'>        assembly {</span>
  2647 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2648 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2649 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2650 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2651 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2652 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2653 |     | <span class='neutral'>        }</span>
  2654 |     | <span class='neutral'>    }</span>
  2655 |     | <span class='neutral'></span>
  2656 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2) internal pure {</span>
  2657 |     | <span class='neutral'>        bytes32 m0;</span>
  2658 |     | <span class='neutral'>        bytes32 m1;</span>
  2659 |     | <span class='neutral'>        bytes32 m2;</span>
  2660 |     | <span class='neutral'>        bytes32 m3;</span>
  2661 |     | <span class='neutral'>        bytes32 m4;</span>
  2662 |     | <span class='neutral'>        bytes32 m5;</span>
  2663 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2664 |     | <span class='neutral'>        assembly {</span>
  2665 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2666 |     | <span class='neutral'>                let length := 0</span>
  2667 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2668 |     | <span class='neutral'>                mstore(pos, length)</span>
  2669 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2670 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2671 |     | <span class='neutral'>            }</span>
  2672 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2673 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2674 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2675 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2676 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2677 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2678 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool)`.</span>
  2679 |     | <span class='neutral'>            mstore(0x00, 0xca7733b1)</span>
  2680 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2681 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2682 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2683 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2684 |     | <span class='neutral'>        }</span>
  2685 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2686 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2687 |     | <span class='neutral'>        assembly {</span>
  2688 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2689 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2690 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2691 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2692 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2693 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2694 |     | <span class='neutral'>        }</span>
  2695 |     | <span class='neutral'>    }</span>
  2696 |     | <span class='neutral'></span>
  2697 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {</span>
  2698 |     | <span class='neutral'>        bytes32 m0;</span>
  2699 |     | <span class='neutral'>        bytes32 m1;</span>
  2700 |     | <span class='neutral'>        bytes32 m2;</span>
  2701 |     | <span class='neutral'>        bytes32 m3;</span>
  2702 |     | <span class='neutral'>        bytes32 m4;</span>
  2703 |     | <span class='neutral'>        bytes32 m5;</span>
  2704 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2705 |     | <span class='neutral'>        assembly {</span>
  2706 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2707 |     | <span class='neutral'>                let length := 0</span>
  2708 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2709 |     | <span class='neutral'>                mstore(pos, length)</span>
  2710 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2711 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2712 |     | <span class='neutral'>            }</span>
  2713 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2714 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2715 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2716 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2717 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2718 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2719 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256)`.</span>
  2720 |     | <span class='neutral'>            mstore(0x00, 0xca47c4eb)</span>
  2721 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2722 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2723 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2724 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2725 |     | <span class='neutral'>        }</span>
  2726 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2727 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2728 |     | <span class='neutral'>        assembly {</span>
  2729 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2730 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2731 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2732 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2733 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2734 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2735 |     | <span class='neutral'>        }</span>
  2736 |     | <span class='neutral'>    }</span>
  2737 |     | <span class='neutral'></span>
  2738 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {</span>
  2739 |     | <span class='neutral'>        bytes32 m0;</span>
  2740 |     | <span class='neutral'>        bytes32 m1;</span>
  2741 |     | <span class='neutral'>        bytes32 m2;</span>
  2742 |     | <span class='neutral'>        bytes32 m3;</span>
  2743 |     | <span class='neutral'>        bytes32 m4;</span>
  2744 |     | <span class='neutral'>        bytes32 m5;</span>
  2745 |     | <span class='neutral'>        bytes32 m6;</span>
  2746 |     | <span class='neutral'>        bytes32 m7;</span>
  2747 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2748 |     | <span class='neutral'>        assembly {</span>
  2749 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2750 |     | <span class='neutral'>                let length := 0</span>
  2751 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2752 |     | <span class='neutral'>                mstore(pos, length)</span>
  2753 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2754 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2755 |     | <span class='neutral'>            }</span>
  2756 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2757 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2758 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2759 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2760 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2761 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2762 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2763 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2764 |     | <span class='neutral'>            // Selector of `log(string,uint256,string)`.</span>
  2765 |     | <span class='neutral'>            mstore(0x00, 0x5970e089)</span>
  2766 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2767 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2768 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  2769 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2770 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  2771 |     | <span class='neutral'>        }</span>
  2772 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2773 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2774 |     | <span class='neutral'>        assembly {</span>
  2775 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2776 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2777 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2778 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2779 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2780 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2781 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2782 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2783 |     | <span class='neutral'>        }</span>
  2784 |     | <span class='neutral'>    }</span>
  2785 |     | <span class='neutral'></span>
  2786 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2) internal pure {</span>
  2787 |     | <span class='neutral'>        bytes32 m0;</span>
  2788 |     | <span class='neutral'>        bytes32 m1;</span>
  2789 |     | <span class='neutral'>        bytes32 m2;</span>
  2790 |     | <span class='neutral'>        bytes32 m3;</span>
  2791 |     | <span class='neutral'>        bytes32 m4;</span>
  2792 |     | <span class='neutral'>        bytes32 m5;</span>
  2793 |     | <span class='neutral'>        bytes32 m6;</span>
  2794 |     | <span class='neutral'>        bytes32 m7;</span>
  2795 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2796 |     | <span class='neutral'>        assembly {</span>
  2797 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2798 |     | <span class='neutral'>                let length := 0</span>
  2799 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2800 |     | <span class='neutral'>                mstore(pos, length)</span>
  2801 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2802 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2803 |     | <span class='neutral'>            }</span>
  2804 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2805 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2806 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2807 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2808 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2809 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2810 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2811 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2812 |     | <span class='neutral'>            // Selector of `log(string,string,address)`.</span>
  2813 |     | <span class='neutral'>            mstore(0x00, 0x95ed0195)</span>
  2814 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2815 |     | <span class='neutral'>            mstore(0x40, 0xa0)</span>
  2816 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2817 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2818 |     | <span class='neutral'>            writeString(0xc0, p1)</span>
  2819 |     | <span class='neutral'>        }</span>
  2820 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2821 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2822 |     | <span class='neutral'>        assembly {</span>
  2823 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2824 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2825 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2826 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2827 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2828 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2829 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2830 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2831 |     | <span class='neutral'>        }</span>
  2832 |     | <span class='neutral'>    }</span>
  2833 |     | <span class='neutral'></span>
  2834 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2) internal pure {</span>
  2835 |     | <span class='neutral'>        bytes32 m0;</span>
  2836 |     | <span class='neutral'>        bytes32 m1;</span>
  2837 |     | <span class='neutral'>        bytes32 m2;</span>
  2838 |     | <span class='neutral'>        bytes32 m3;</span>
  2839 |     | <span class='neutral'>        bytes32 m4;</span>
  2840 |     | <span class='neutral'>        bytes32 m5;</span>
  2841 |     | <span class='neutral'>        bytes32 m6;</span>
  2842 |     | <span class='neutral'>        bytes32 m7;</span>
  2843 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2844 |     | <span class='neutral'>        assembly {</span>
  2845 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2846 |     | <span class='neutral'>                let length := 0</span>
  2847 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2848 |     | <span class='neutral'>                mstore(pos, length)</span>
  2849 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2850 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2851 |     | <span class='neutral'>            }</span>
  2852 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2853 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2854 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2855 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2856 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2857 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2858 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2859 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2860 |     | <span class='neutral'>            // Selector of `log(string,string,bool)`.</span>
  2861 |     | <span class='neutral'>            mstore(0x00, 0xb0e0f9b5)</span>
  2862 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2863 |     | <span class='neutral'>            mstore(0x40, 0xa0)</span>
  2864 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2865 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2866 |     | <span class='neutral'>            writeString(0xc0, p1)</span>
  2867 |     | <span class='neutral'>        }</span>
  2868 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2869 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2870 |     | <span class='neutral'>        assembly {</span>
  2871 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2872 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2873 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2874 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2875 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2876 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2877 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2878 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2879 |     | <span class='neutral'>        }</span>
  2880 |     | <span class='neutral'>    }</span>
  2881 |     | <span class='neutral'></span>
  2882 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {</span>
  2883 |     | <span class='neutral'>        bytes32 m0;</span>
  2884 |     | <span class='neutral'>        bytes32 m1;</span>
  2885 |     | <span class='neutral'>        bytes32 m2;</span>
  2886 |     | <span class='neutral'>        bytes32 m3;</span>
  2887 |     | <span class='neutral'>        bytes32 m4;</span>
  2888 |     | <span class='neutral'>        bytes32 m5;</span>
  2889 |     | <span class='neutral'>        bytes32 m6;</span>
  2890 |     | <span class='neutral'>        bytes32 m7;</span>
  2891 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2892 |     | <span class='neutral'>        assembly {</span>
  2893 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2894 |     | <span class='neutral'>                let length := 0</span>
  2895 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2896 |     | <span class='neutral'>                mstore(pos, length)</span>
  2897 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2898 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2899 |     | <span class='neutral'>            }</span>
  2900 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2901 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2902 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2903 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2904 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2905 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2906 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2907 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2908 |     | <span class='neutral'>            // Selector of `log(string,string,uint256)`.</span>
  2909 |     | <span class='neutral'>            mstore(0x00, 0x5821efa1)</span>
  2910 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2911 |     | <span class='neutral'>            mstore(0x40, 0xa0)</span>
  2912 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2913 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2914 |     | <span class='neutral'>            writeString(0xc0, p1)</span>
  2915 |     | <span class='neutral'>        }</span>
  2916 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2917 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2918 |     | <span class='neutral'>        assembly {</span>
  2919 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2920 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2921 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2922 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2923 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2924 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2925 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2926 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2927 |     | <span class='neutral'>        }</span>
  2928 |     | <span class='neutral'>    }</span>
  2929 |     | <span class='neutral'></span>
  2930 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {</span>
  2931 |     | <span class='neutral'>        bytes32 m0;</span>
  2932 |     | <span class='neutral'>        bytes32 m1;</span>
  2933 |     | <span class='neutral'>        bytes32 m2;</span>
  2934 |     | <span class='neutral'>        bytes32 m3;</span>
  2935 |     | <span class='neutral'>        bytes32 m4;</span>
  2936 |     | <span class='neutral'>        bytes32 m5;</span>
  2937 |     | <span class='neutral'>        bytes32 m6;</span>
  2938 |     | <span class='neutral'>        bytes32 m7;</span>
  2939 |     | <span class='neutral'>        bytes32 m8;</span>
  2940 |     | <span class='neutral'>        bytes32 m9;</span>
  2941 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2942 |     | <span class='neutral'>        assembly {</span>
  2943 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2944 |     | <span class='neutral'>                let length := 0</span>
  2945 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2946 |     | <span class='neutral'>                mstore(pos, length)</span>
  2947 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2948 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2949 |     | <span class='neutral'>            }</span>
  2950 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2951 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2952 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2953 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2954 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2955 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2956 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2957 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2958 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  2959 |     | <span class='neutral'>            m9 := mload(0x120)</span>
  2960 |     | <span class='neutral'>            // Selector of `log(string,string,string)`.</span>
  2961 |     | <span class='neutral'>            mstore(0x00, 0x2ced7cef)</span>
  2962 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2963 |     | <span class='neutral'>            mstore(0x40, 0xa0)</span>
  2964 |     | <span class='neutral'>            mstore(0x60, 0xe0)</span>
  2965 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2966 |     | <span class='neutral'>            writeString(0xc0, p1)</span>
  2967 |     | <span class='neutral'>            writeString(0x100, p2)</span>
  2968 |     | <span class='neutral'>        }</span>
  2969 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x124);</span>
  2970 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2971 |     | <span class='neutral'>        assembly {</span>
  2972 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2973 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2974 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2975 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2976 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2977 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2978 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2979 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2980 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  2981 |     | <span class='neutral'>            mstore(0x120, m9)</span>
  2982 |     | <span class='neutral'>        }</span>
  2983 |     | <span class='neutral'>    }</span>
  2984 |     | <span class='neutral'></span>
  2985 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal pure {</span>
  2986 |     | <span class='neutral'>        bytes32 m0;</span>
  2987 |     | <span class='neutral'>        bytes32 m1;</span>
  2988 |     | <span class='neutral'>        bytes32 m2;</span>
  2989 |     | <span class='neutral'>        bytes32 m3;</span>
  2990 |     | <span class='neutral'>        bytes32 m4;</span>
  2991 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  2992 |     | <span class='neutral'>        assembly {</span>
  2993 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2994 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2995 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2996 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2997 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2998 |     | <span class='neutral'>            // Selector of `log(address,address,address,address)`.</span>
  2999 |     | <span class='neutral'>            mstore(0x00, 0x665bf134)</span>
  3000 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3001 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3002 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3003 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3004 |     | <span class='neutral'>        }</span>
  3005 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3006 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3007 |     | <span class='neutral'>        assembly {</span>
  3008 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3009 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3010 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3011 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3012 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3013 |     | <span class='neutral'>        }</span>
  3014 |     | <span class='neutral'>    }</span>
  3015 |     | <span class='neutral'></span>
  3016 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal pure {</span>
  3017 |     | <span class='neutral'>        bytes32 m0;</span>
  3018 |     | <span class='neutral'>        bytes32 m1;</span>
  3019 |     | <span class='neutral'>        bytes32 m2;</span>
  3020 |     | <span class='neutral'>        bytes32 m3;</span>
  3021 |     | <span class='neutral'>        bytes32 m4;</span>
  3022 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3023 |     | <span class='neutral'>        assembly {</span>
  3024 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3025 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3026 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3027 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3028 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3029 |     | <span class='neutral'>            // Selector of `log(address,address,address,bool)`.</span>
  3030 |     | <span class='neutral'>            mstore(0x00, 0x0e378994)</span>
  3031 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3032 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3033 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3034 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3035 |     | <span class='neutral'>        }</span>
  3036 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3037 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3038 |     | <span class='neutral'>        assembly {</span>
  3039 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3040 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3041 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3042 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3043 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3044 |     | <span class='neutral'>        }</span>
  3045 |     | <span class='neutral'>    }</span>
  3046 |     | <span class='neutral'></span>
  3047 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint256 p3) internal pure {</span>
  3048 |     | <span class='neutral'>        bytes32 m0;</span>
  3049 |     | <span class='neutral'>        bytes32 m1;</span>
  3050 |     | <span class='neutral'>        bytes32 m2;</span>
  3051 |     | <span class='neutral'>        bytes32 m3;</span>
  3052 |     | <span class='neutral'>        bytes32 m4;</span>
  3053 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3054 |     | <span class='neutral'>        assembly {</span>
  3055 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3056 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3057 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3058 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3059 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3060 |     | <span class='neutral'>            // Selector of `log(address,address,address,uint256)`.</span>
  3061 |     | <span class='neutral'>            mstore(0x00, 0x94250d77)</span>
  3062 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3063 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3064 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3065 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3066 |     | <span class='neutral'>        }</span>
  3067 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3068 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3069 |     | <span class='neutral'>        assembly {</span>
  3070 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3071 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3072 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3073 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3074 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3075 |     | <span class='neutral'>        }</span>
  3076 |     | <span class='neutral'>    }</span>
  3077 |     | <span class='neutral'></span>
  3078 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bytes32 p3) internal pure {</span>
  3079 |     | <span class='neutral'>        bytes32 m0;</span>
  3080 |     | <span class='neutral'>        bytes32 m1;</span>
  3081 |     | <span class='neutral'>        bytes32 m2;</span>
  3082 |     | <span class='neutral'>        bytes32 m3;</span>
  3083 |     | <span class='neutral'>        bytes32 m4;</span>
  3084 |     | <span class='neutral'>        bytes32 m5;</span>
  3085 |     | <span class='neutral'>        bytes32 m6;</span>
  3086 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3087 |     | <span class='neutral'>        assembly {</span>
  3088 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3089 |     | <span class='neutral'>                let length := 0</span>
  3090 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3091 |     | <span class='neutral'>                mstore(pos, length)</span>
  3092 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3093 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3094 |     | <span class='neutral'>            }</span>
  3095 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3096 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3097 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3098 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3099 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3100 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3101 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3102 |     | <span class='neutral'>            // Selector of `log(address,address,address,string)`.</span>
  3103 |     | <span class='neutral'>            mstore(0x00, 0xf808da20)</span>
  3104 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3105 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3106 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3107 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3108 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3109 |     | <span class='neutral'>        }</span>
  3110 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3111 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3112 |     | <span class='neutral'>        assembly {</span>
  3113 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3114 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3115 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3116 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3117 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3118 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3119 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3120 |     | <span class='neutral'>        }</span>
  3121 |     | <span class='neutral'>    }</span>
  3122 |     | <span class='neutral'></span>
  3123 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal pure {</span>
  3124 |     | <span class='neutral'>        bytes32 m0;</span>
  3125 |     | <span class='neutral'>        bytes32 m1;</span>
  3126 |     | <span class='neutral'>        bytes32 m2;</span>
  3127 |     | <span class='neutral'>        bytes32 m3;</span>
  3128 |     | <span class='neutral'>        bytes32 m4;</span>
  3129 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3130 |     | <span class='neutral'>        assembly {</span>
  3131 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3132 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3133 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3134 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3135 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3136 |     | <span class='neutral'>            // Selector of `log(address,address,bool,address)`.</span>
  3137 |     | <span class='neutral'>            mstore(0x00, 0x9f1bc36e)</span>
  3138 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3139 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3140 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3141 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3142 |     | <span class='neutral'>        }</span>
  3143 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3144 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3145 |     | <span class='neutral'>        assembly {</span>
  3146 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3147 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3148 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3149 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3150 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3151 |     | <span class='neutral'>        }</span>
  3152 |     | <span class='neutral'>    }</span>
  3153 |     | <span class='neutral'></span>
  3154 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal pure {</span>
  3155 |     | <span class='neutral'>        bytes32 m0;</span>
  3156 |     | <span class='neutral'>        bytes32 m1;</span>
  3157 |     | <span class='neutral'>        bytes32 m2;</span>
  3158 |     | <span class='neutral'>        bytes32 m3;</span>
  3159 |     | <span class='neutral'>        bytes32 m4;</span>
  3160 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3161 |     | <span class='neutral'>        assembly {</span>
  3162 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3163 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3164 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3165 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3166 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3167 |     | <span class='neutral'>            // Selector of `log(address,address,bool,bool)`.</span>
  3168 |     | <span class='neutral'>            mstore(0x00, 0x2cd4134a)</span>
  3169 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3170 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3171 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3172 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3173 |     | <span class='neutral'>        }</span>
  3174 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3175 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3176 |     | <span class='neutral'>        assembly {</span>
  3177 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3178 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3179 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3180 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3181 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3182 |     | <span class='neutral'>        }</span>
  3183 |     | <span class='neutral'>    }</span>
  3184 |     | <span class='neutral'></span>
  3185 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint256 p3) internal pure {</span>
  3186 |     | <span class='neutral'>        bytes32 m0;</span>
  3187 |     | <span class='neutral'>        bytes32 m1;</span>
  3188 |     | <span class='neutral'>        bytes32 m2;</span>
  3189 |     | <span class='neutral'>        bytes32 m3;</span>
  3190 |     | <span class='neutral'>        bytes32 m4;</span>
  3191 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3192 |     | <span class='neutral'>        assembly {</span>
  3193 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3194 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3195 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3196 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3197 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3198 |     | <span class='neutral'>            // Selector of `log(address,address,bool,uint256)`.</span>
  3199 |     | <span class='neutral'>            mstore(0x00, 0x3971e78c)</span>
  3200 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3201 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3202 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3203 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3204 |     | <span class='neutral'>        }</span>
  3205 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3206 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3207 |     | <span class='neutral'>        assembly {</span>
  3208 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3209 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3210 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3211 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3212 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3213 |     | <span class='neutral'>        }</span>
  3214 |     | <span class='neutral'>    }</span>
  3215 |     | <span class='neutral'></span>
  3216 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bytes32 p3) internal pure {</span>
  3217 |     | <span class='neutral'>        bytes32 m0;</span>
  3218 |     | <span class='neutral'>        bytes32 m1;</span>
  3219 |     | <span class='neutral'>        bytes32 m2;</span>
  3220 |     | <span class='neutral'>        bytes32 m3;</span>
  3221 |     | <span class='neutral'>        bytes32 m4;</span>
  3222 |     | <span class='neutral'>        bytes32 m5;</span>
  3223 |     | <span class='neutral'>        bytes32 m6;</span>
  3224 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3225 |     | <span class='neutral'>        assembly {</span>
  3226 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3227 |     | <span class='neutral'>                let length := 0</span>
  3228 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3229 |     | <span class='neutral'>                mstore(pos, length)</span>
  3230 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3231 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3232 |     | <span class='neutral'>            }</span>
  3233 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3234 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3235 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3236 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3237 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3238 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3239 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3240 |     | <span class='neutral'>            // Selector of `log(address,address,bool,string)`.</span>
  3241 |     | <span class='neutral'>            mstore(0x00, 0xaa6540c8)</span>
  3242 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3243 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3244 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3245 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3246 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3247 |     | <span class='neutral'>        }</span>
  3248 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3249 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3250 |     | <span class='neutral'>        assembly {</span>
  3251 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3252 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3253 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3254 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3255 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3256 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3257 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3258 |     | <span class='neutral'>        }</span>
  3259 |     | <span class='neutral'>    }</span>
  3260 |     | <span class='neutral'></span>
  3261 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, address p3) internal pure {</span>
  3262 |     | <span class='neutral'>        bytes32 m0;</span>
  3263 |     | <span class='neutral'>        bytes32 m1;</span>
  3264 |     | <span class='neutral'>        bytes32 m2;</span>
  3265 |     | <span class='neutral'>        bytes32 m3;</span>
  3266 |     | <span class='neutral'>        bytes32 m4;</span>
  3267 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3268 |     | <span class='neutral'>        assembly {</span>
  3269 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3270 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3271 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3272 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3273 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3274 |     | <span class='neutral'>            // Selector of `log(address,address,uint256,address)`.</span>
  3275 |     | <span class='neutral'>            mstore(0x00, 0x8da6def5)</span>
  3276 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3277 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3278 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3279 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3280 |     | <span class='neutral'>        }</span>
  3281 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3282 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3283 |     | <span class='neutral'>        assembly {</span>
  3284 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3285 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3286 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3287 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3288 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3289 |     | <span class='neutral'>        }</span>
  3290 |     | <span class='neutral'>    }</span>
  3291 |     | <span class='neutral'></span>
  3292 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, bool p3) internal pure {</span>
  3293 |     | <span class='neutral'>        bytes32 m0;</span>
  3294 |     | <span class='neutral'>        bytes32 m1;</span>
  3295 |     | <span class='neutral'>        bytes32 m2;</span>
  3296 |     | <span class='neutral'>        bytes32 m3;</span>
  3297 |     | <span class='neutral'>        bytes32 m4;</span>
  3298 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3299 |     | <span class='neutral'>        assembly {</span>
  3300 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3301 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3302 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3303 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3304 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3305 |     | <span class='neutral'>            // Selector of `log(address,address,uint256,bool)`.</span>
  3306 |     | <span class='neutral'>            mstore(0x00, 0x9b4254e2)</span>
  3307 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3308 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3309 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3310 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3311 |     | <span class='neutral'>        }</span>
  3312 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3313 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3314 |     | <span class='neutral'>        assembly {</span>
  3315 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3316 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3317 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3318 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3319 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3320 |     | <span class='neutral'>        }</span>
  3321 |     | <span class='neutral'>    }</span>
  3322 |     | <span class='neutral'></span>
  3323 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  3324 |     | <span class='neutral'>        bytes32 m0;</span>
  3325 |     | <span class='neutral'>        bytes32 m1;</span>
  3326 |     | <span class='neutral'>        bytes32 m2;</span>
  3327 |     | <span class='neutral'>        bytes32 m3;</span>
  3328 |     | <span class='neutral'>        bytes32 m4;</span>
  3329 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3330 |     | <span class='neutral'>        assembly {</span>
  3331 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3332 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3333 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3334 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3335 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3336 |     | <span class='neutral'>            // Selector of `log(address,address,uint256,uint256)`.</span>
  3337 |     | <span class='neutral'>            mstore(0x00, 0xbe553481)</span>
  3338 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3339 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3340 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3341 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3342 |     | <span class='neutral'>        }</span>
  3343 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3344 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3345 |     | <span class='neutral'>        assembly {</span>
  3346 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3347 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3348 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3349 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3350 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3351 |     | <span class='neutral'>        }</span>
  3352 |     | <span class='neutral'>    }</span>
  3353 |     | <span class='neutral'></span>
  3354 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {</span>
  3355 |     | <span class='neutral'>        bytes32 m0;</span>
  3356 |     | <span class='neutral'>        bytes32 m1;</span>
  3357 |     | <span class='neutral'>        bytes32 m2;</span>
  3358 |     | <span class='neutral'>        bytes32 m3;</span>
  3359 |     | <span class='neutral'>        bytes32 m4;</span>
  3360 |     | <span class='neutral'>        bytes32 m5;</span>
  3361 |     | <span class='neutral'>        bytes32 m6;</span>
  3362 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3363 |     | <span class='neutral'>        assembly {</span>
  3364 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3365 |     | <span class='neutral'>                let length := 0</span>
  3366 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3367 |     | <span class='neutral'>                mstore(pos, length)</span>
  3368 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3369 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3370 |     | <span class='neutral'>            }</span>
  3371 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3372 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3373 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3374 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3375 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3376 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3377 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3378 |     | <span class='neutral'>            // Selector of `log(address,address,uint256,string)`.</span>
  3379 |     | <span class='neutral'>            mstore(0x00, 0xfdb4f990)</span>
  3380 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3381 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3382 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3383 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3384 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3385 |     | <span class='neutral'>        }</span>
  3386 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3387 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3388 |     | <span class='neutral'>        assembly {</span>
  3389 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3390 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3391 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3392 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3393 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3394 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3395 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3396 |     | <span class='neutral'>        }</span>
  3397 |     | <span class='neutral'>    }</span>
  3398 |     | <span class='neutral'></span>
  3399 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2, address p3) internal pure {</span>
  3400 |     | <span class='neutral'>        bytes32 m0;</span>
  3401 |     | <span class='neutral'>        bytes32 m1;</span>
  3402 |     | <span class='neutral'>        bytes32 m2;</span>
  3403 |     | <span class='neutral'>        bytes32 m3;</span>
  3404 |     | <span class='neutral'>        bytes32 m4;</span>
  3405 |     | <span class='neutral'>        bytes32 m5;</span>
  3406 |     | <span class='neutral'>        bytes32 m6;</span>
  3407 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3408 |     | <span class='neutral'>        assembly {</span>
  3409 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3410 |     | <span class='neutral'>                let length := 0</span>
  3411 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3412 |     | <span class='neutral'>                mstore(pos, length)</span>
  3413 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3414 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3415 |     | <span class='neutral'>            }</span>
  3416 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3417 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3418 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3419 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3420 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3421 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3422 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3423 |     | <span class='neutral'>            // Selector of `log(address,address,string,address)`.</span>
  3424 |     | <span class='neutral'>            mstore(0x00, 0x8f736d16)</span>
  3425 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3426 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3427 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3428 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3429 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3430 |     | <span class='neutral'>        }</span>
  3431 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3432 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3433 |     | <span class='neutral'>        assembly {</span>
  3434 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3435 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3436 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3437 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3438 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3439 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3440 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3441 |     | <span class='neutral'>        }</span>
  3442 |     | <span class='neutral'>    }</span>
  3443 |     | <span class='neutral'></span>
  3444 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2, bool p3) internal pure {</span>
  3445 |     | <span class='neutral'>        bytes32 m0;</span>
  3446 |     | <span class='neutral'>        bytes32 m1;</span>
  3447 |     | <span class='neutral'>        bytes32 m2;</span>
  3448 |     | <span class='neutral'>        bytes32 m3;</span>
  3449 |     | <span class='neutral'>        bytes32 m4;</span>
  3450 |     | <span class='neutral'>        bytes32 m5;</span>
  3451 |     | <span class='neutral'>        bytes32 m6;</span>
  3452 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3453 |     | <span class='neutral'>        assembly {</span>
  3454 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3455 |     | <span class='neutral'>                let length := 0</span>
  3456 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3457 |     | <span class='neutral'>                mstore(pos, length)</span>
  3458 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3459 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3460 |     | <span class='neutral'>            }</span>
  3461 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3462 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3463 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3464 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3465 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3466 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3467 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3468 |     | <span class='neutral'>            // Selector of `log(address,address,string,bool)`.</span>
  3469 |     | <span class='neutral'>            mstore(0x00, 0x6f1a594e)</span>
  3470 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3471 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3472 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3473 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3474 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3475 |     | <span class='neutral'>        }</span>
  3476 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3477 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3478 |     | <span class='neutral'>        assembly {</span>
  3479 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3480 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3481 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3482 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3483 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3484 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3485 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3486 |     | <span class='neutral'>        }</span>
  3487 |     | <span class='neutral'>    }</span>
  3488 |     | <span class='neutral'></span>
  3489 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {</span>
  3490 |     | <span class='neutral'>        bytes32 m0;</span>
  3491 |     | <span class='neutral'>        bytes32 m1;</span>
  3492 |     | <span class='neutral'>        bytes32 m2;</span>
  3493 |     | <span class='neutral'>        bytes32 m3;</span>
  3494 |     | <span class='neutral'>        bytes32 m4;</span>
  3495 |     | <span class='neutral'>        bytes32 m5;</span>
  3496 |     | <span class='neutral'>        bytes32 m6;</span>
  3497 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3498 |     | <span class='neutral'>        assembly {</span>
  3499 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3500 |     | <span class='neutral'>                let length := 0</span>
  3501 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3502 |     | <span class='neutral'>                mstore(pos, length)</span>
  3503 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3504 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3505 |     | <span class='neutral'>            }</span>
  3506 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3507 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3508 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3509 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3510 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3511 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3512 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3513 |     | <span class='neutral'>            // Selector of `log(address,address,string,uint256)`.</span>
  3514 |     | <span class='neutral'>            mstore(0x00, 0xef1cefe7)</span>
  3515 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3516 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3517 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3518 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3519 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3520 |     | <span class='neutral'>        }</span>
  3521 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3522 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3523 |     | <span class='neutral'>        assembly {</span>
  3524 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3525 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3526 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3527 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3528 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3529 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3530 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3531 |     | <span class='neutral'>        }</span>
  3532 |     | <span class='neutral'>    }</span>
  3533 |     | <span class='neutral'></span>
  3534 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {</span>
  3535 |     | <span class='neutral'>        bytes32 m0;</span>
  3536 |     | <span class='neutral'>        bytes32 m1;</span>
  3537 |     | <span class='neutral'>        bytes32 m2;</span>
  3538 |     | <span class='neutral'>        bytes32 m3;</span>
  3539 |     | <span class='neutral'>        bytes32 m4;</span>
  3540 |     | <span class='neutral'>        bytes32 m5;</span>
  3541 |     | <span class='neutral'>        bytes32 m6;</span>
  3542 |     | <span class='neutral'>        bytes32 m7;</span>
  3543 |     | <span class='neutral'>        bytes32 m8;</span>
  3544 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3545 |     | <span class='neutral'>        assembly {</span>
  3546 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3547 |     | <span class='neutral'>                let length := 0</span>
  3548 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3549 |     | <span class='neutral'>                mstore(pos, length)</span>
  3550 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3551 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3552 |     | <span class='neutral'>            }</span>
  3553 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3554 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3555 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3556 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3557 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3558 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3559 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3560 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  3561 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  3562 |     | <span class='neutral'>            // Selector of `log(address,address,string,string)`.</span>
  3563 |     | <span class='neutral'>            mstore(0x00, 0x21bdaf25)</span>
  3564 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3565 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3566 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3567 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  3568 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3569 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  3570 |     | <span class='neutral'>        }</span>
  3571 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  3572 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3573 |     | <span class='neutral'>        assembly {</span>
  3574 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3575 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3576 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3577 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3578 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3579 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3580 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3581 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  3582 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  3583 |     | <span class='neutral'>        }</span>
  3584 |     | <span class='neutral'>    }</span>
  3585 |     | <span class='neutral'></span>
  3586 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal pure {</span>
  3587 |     | <span class='neutral'>        bytes32 m0;</span>
  3588 |     | <span class='neutral'>        bytes32 m1;</span>
  3589 |     | <span class='neutral'>        bytes32 m2;</span>
  3590 |     | <span class='neutral'>        bytes32 m3;</span>
  3591 |     | <span class='neutral'>        bytes32 m4;</span>
  3592 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3593 |     | <span class='neutral'>        assembly {</span>
  3594 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3595 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3596 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3597 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3598 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3599 |     | <span class='neutral'>            // Selector of `log(address,bool,address,address)`.</span>
  3600 |     | <span class='neutral'>            mstore(0x00, 0x660375dd)</span>
  3601 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3602 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3603 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3604 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3605 |     | <span class='neutral'>        }</span>
  3606 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3607 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3608 |     | <span class='neutral'>        assembly {</span>
  3609 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3610 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3611 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3612 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3613 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3614 |     | <span class='neutral'>        }</span>
  3615 |     | <span class='neutral'>    }</span>
  3616 |     | <span class='neutral'></span>
  3617 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal pure {</span>
  3618 |     | <span class='neutral'>        bytes32 m0;</span>
  3619 |     | <span class='neutral'>        bytes32 m1;</span>
  3620 |     | <span class='neutral'>        bytes32 m2;</span>
  3621 |     | <span class='neutral'>        bytes32 m3;</span>
  3622 |     | <span class='neutral'>        bytes32 m4;</span>
  3623 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3624 |     | <span class='neutral'>        assembly {</span>
  3625 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3626 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3627 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3628 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3629 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3630 |     | <span class='neutral'>            // Selector of `log(address,bool,address,bool)`.</span>
  3631 |     | <span class='neutral'>            mstore(0x00, 0xa6f50b0f)</span>
  3632 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3633 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3634 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3635 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3636 |     | <span class='neutral'>        }</span>
  3637 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3638 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3639 |     | <span class='neutral'>        assembly {</span>
  3640 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3641 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3642 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3643 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3644 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3645 |     | <span class='neutral'>        }</span>
  3646 |     | <span class='neutral'>    }</span>
  3647 |     | <span class='neutral'></span>
  3648 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint256 p3) internal pure {</span>
  3649 |     | <span class='neutral'>        bytes32 m0;</span>
  3650 |     | <span class='neutral'>        bytes32 m1;</span>
  3651 |     | <span class='neutral'>        bytes32 m2;</span>
  3652 |     | <span class='neutral'>        bytes32 m3;</span>
  3653 |     | <span class='neutral'>        bytes32 m4;</span>
  3654 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3655 |     | <span class='neutral'>        assembly {</span>
  3656 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3657 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3658 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3659 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3660 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3661 |     | <span class='neutral'>            // Selector of `log(address,bool,address,uint256)`.</span>
  3662 |     | <span class='neutral'>            mstore(0x00, 0xa75c59de)</span>
  3663 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3664 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3665 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3666 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3667 |     | <span class='neutral'>        }</span>
  3668 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3669 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3670 |     | <span class='neutral'>        assembly {</span>
  3671 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3672 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3673 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3674 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3675 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3676 |     | <span class='neutral'>        }</span>
  3677 |     | <span class='neutral'>    }</span>
  3678 |     | <span class='neutral'></span>
  3679 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bytes32 p3) internal pure {</span>
  3680 |     | <span class='neutral'>        bytes32 m0;</span>
  3681 |     | <span class='neutral'>        bytes32 m1;</span>
  3682 |     | <span class='neutral'>        bytes32 m2;</span>
  3683 |     | <span class='neutral'>        bytes32 m3;</span>
  3684 |     | <span class='neutral'>        bytes32 m4;</span>
  3685 |     | <span class='neutral'>        bytes32 m5;</span>
  3686 |     | <span class='neutral'>        bytes32 m6;</span>
  3687 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3688 |     | <span class='neutral'>        assembly {</span>
  3689 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3690 |     | <span class='neutral'>                let length := 0</span>
  3691 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3692 |     | <span class='neutral'>                mstore(pos, length)</span>
  3693 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3694 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3695 |     | <span class='neutral'>            }</span>
  3696 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3697 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3698 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3699 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3700 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3701 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3702 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3703 |     | <span class='neutral'>            // Selector of `log(address,bool,address,string)`.</span>
  3704 |     | <span class='neutral'>            mstore(0x00, 0x2dd778e6)</span>
  3705 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3706 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3707 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3708 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3709 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3710 |     | <span class='neutral'>        }</span>
  3711 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3712 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3713 |     | <span class='neutral'>        assembly {</span>
  3714 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3715 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3716 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3717 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3718 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3719 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3720 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3721 |     | <span class='neutral'>        }</span>
  3722 |     | <span class='neutral'>    }</span>
  3723 |     | <span class='neutral'></span>
  3724 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal pure {</span>
  3725 |     | <span class='neutral'>        bytes32 m0;</span>
  3726 |     | <span class='neutral'>        bytes32 m1;</span>
  3727 |     | <span class='neutral'>        bytes32 m2;</span>
  3728 |     | <span class='neutral'>        bytes32 m3;</span>
  3729 |     | <span class='neutral'>        bytes32 m4;</span>
  3730 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3731 |     | <span class='neutral'>        assembly {</span>
  3732 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3733 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3734 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3735 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3736 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3737 |     | <span class='neutral'>            // Selector of `log(address,bool,bool,address)`.</span>
  3738 |     | <span class='neutral'>            mstore(0x00, 0xcf394485)</span>
  3739 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3740 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3741 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3742 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3743 |     | <span class='neutral'>        }</span>
  3744 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3745 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3746 |     | <span class='neutral'>        assembly {</span>
  3747 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3748 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3749 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3750 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3751 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3752 |     | <span class='neutral'>        }</span>
  3753 |     | <span class='neutral'>    }</span>
  3754 |     | <span class='neutral'></span>
  3755 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal pure {</span>
  3756 |     | <span class='neutral'>        bytes32 m0;</span>
  3757 |     | <span class='neutral'>        bytes32 m1;</span>
  3758 |     | <span class='neutral'>        bytes32 m2;</span>
  3759 |     | <span class='neutral'>        bytes32 m3;</span>
  3760 |     | <span class='neutral'>        bytes32 m4;</span>
  3761 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3762 |     | <span class='neutral'>        assembly {</span>
  3763 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3764 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3765 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3766 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3767 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3768 |     | <span class='neutral'>            // Selector of `log(address,bool,bool,bool)`.</span>
  3769 |     | <span class='neutral'>            mstore(0x00, 0xcac43479)</span>
  3770 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3771 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3772 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3773 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3774 |     | <span class='neutral'>        }</span>
  3775 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3776 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3777 |     | <span class='neutral'>        assembly {</span>
  3778 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3779 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3780 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3781 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3782 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3783 |     | <span class='neutral'>        }</span>
  3784 |     | <span class='neutral'>    }</span>
  3785 |     | <span class='neutral'></span>
  3786 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  3787 |     | <span class='neutral'>        bytes32 m0;</span>
  3788 |     | <span class='neutral'>        bytes32 m1;</span>
  3789 |     | <span class='neutral'>        bytes32 m2;</span>
  3790 |     | <span class='neutral'>        bytes32 m3;</span>
  3791 |     | <span class='neutral'>        bytes32 m4;</span>
  3792 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3793 |     | <span class='neutral'>        assembly {</span>
  3794 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3795 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3796 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3797 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3798 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3799 |     | <span class='neutral'>            // Selector of `log(address,bool,bool,uint256)`.</span>
  3800 |     | <span class='neutral'>            mstore(0x00, 0x8c4e5de6)</span>
  3801 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3802 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3803 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3804 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3805 |     | <span class='neutral'>        }</span>
  3806 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3807 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3808 |     | <span class='neutral'>        assembly {</span>
  3809 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3810 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3811 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3812 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3813 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3814 |     | <span class='neutral'>        }</span>
  3815 |     | <span class='neutral'>    }</span>
  3816 |     | <span class='neutral'></span>
  3817 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {</span>
  3818 |     | <span class='neutral'>        bytes32 m0;</span>
  3819 |     | <span class='neutral'>        bytes32 m1;</span>
  3820 |     | <span class='neutral'>        bytes32 m2;</span>
  3821 |     | <span class='neutral'>        bytes32 m3;</span>
  3822 |     | <span class='neutral'>        bytes32 m4;</span>
  3823 |     | <span class='neutral'>        bytes32 m5;</span>
  3824 |     | <span class='neutral'>        bytes32 m6;</span>
  3825 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3826 |     | <span class='neutral'>        assembly {</span>
  3827 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3828 |     | <span class='neutral'>                let length := 0</span>
  3829 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3830 |     | <span class='neutral'>                mstore(pos, length)</span>
  3831 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3832 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3833 |     | <span class='neutral'>            }</span>
  3834 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3835 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3836 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3837 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3838 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3839 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3840 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3841 |     | <span class='neutral'>            // Selector of `log(address,bool,bool,string)`.</span>
  3842 |     | <span class='neutral'>            mstore(0x00, 0xdfc4a2e8)</span>
  3843 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3844 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3845 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3846 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3847 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3848 |     | <span class='neutral'>        }</span>
  3849 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3850 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3851 |     | <span class='neutral'>        assembly {</span>
  3852 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3853 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3854 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3855 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3856 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3857 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3858 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3859 |     | <span class='neutral'>        }</span>
  3860 |     | <span class='neutral'>    }</span>
  3861 |     | <span class='neutral'></span>
  3862 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, address p3) internal pure {</span>
  3863 |     | <span class='neutral'>        bytes32 m0;</span>
  3864 |     | <span class='neutral'>        bytes32 m1;</span>
  3865 |     | <span class='neutral'>        bytes32 m2;</span>
  3866 |     | <span class='neutral'>        bytes32 m3;</span>
  3867 |     | <span class='neutral'>        bytes32 m4;</span>
  3868 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3869 |     | <span class='neutral'>        assembly {</span>
  3870 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3871 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3872 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3873 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3874 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3875 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256,address)`.</span>
  3876 |     | <span class='neutral'>            mstore(0x00, 0xccf790a1)</span>
  3877 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3878 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3879 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3880 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3881 |     | <span class='neutral'>        }</span>
  3882 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3883 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3884 |     | <span class='neutral'>        assembly {</span>
  3885 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3886 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3887 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3888 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3889 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3890 |     | <span class='neutral'>        }</span>
  3891 |     | <span class='neutral'>    }</span>
  3892 |     | <span class='neutral'></span>
  3893 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  3894 |     | <span class='neutral'>        bytes32 m0;</span>
  3895 |     | <span class='neutral'>        bytes32 m1;</span>
  3896 |     | <span class='neutral'>        bytes32 m2;</span>
  3897 |     | <span class='neutral'>        bytes32 m3;</span>
  3898 |     | <span class='neutral'>        bytes32 m4;</span>
  3899 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3900 |     | <span class='neutral'>        assembly {</span>
  3901 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3902 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3903 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3904 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3905 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3906 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256,bool)`.</span>
  3907 |     | <span class='neutral'>            mstore(0x00, 0xc4643e20)</span>
  3908 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3909 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3910 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3911 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3912 |     | <span class='neutral'>        }</span>
  3913 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3914 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3915 |     | <span class='neutral'>        assembly {</span>
  3916 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3917 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3918 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3919 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3920 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3921 |     | <span class='neutral'>        }</span>
  3922 |     | <span class='neutral'>    }</span>
  3923 |     | <span class='neutral'></span>
  3924 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  3925 |     | <span class='neutral'>        bytes32 m0;</span>
  3926 |     | <span class='neutral'>        bytes32 m1;</span>
  3927 |     | <span class='neutral'>        bytes32 m2;</span>
  3928 |     | <span class='neutral'>        bytes32 m3;</span>
  3929 |     | <span class='neutral'>        bytes32 m4;</span>
  3930 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3931 |     | <span class='neutral'>        assembly {</span>
  3932 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3933 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3934 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3935 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3936 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3937 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256,uint256)`.</span>
  3938 |     | <span class='neutral'>            mstore(0x00, 0x386ff5f4)</span>
  3939 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3940 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3941 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3942 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3943 |     | <span class='neutral'>        }</span>
  3944 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3945 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3946 |     | <span class='neutral'>        assembly {</span>
  3947 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3948 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3949 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3950 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3951 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3952 |     | <span class='neutral'>        }</span>
  3953 |     | <span class='neutral'>    }</span>
  3954 |     | <span class='neutral'></span>
  3955 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {</span>
  3956 |     | <span class='neutral'>        bytes32 m0;</span>
  3957 |     | <span class='neutral'>        bytes32 m1;</span>
  3958 |     | <span class='neutral'>        bytes32 m2;</span>
  3959 |     | <span class='neutral'>        bytes32 m3;</span>
  3960 |     | <span class='neutral'>        bytes32 m4;</span>
  3961 |     | <span class='neutral'>        bytes32 m5;</span>
  3962 |     | <span class='neutral'>        bytes32 m6;</span>
  3963 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3964 |     | <span class='neutral'>        assembly {</span>
  3965 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3966 |     | <span class='neutral'>                let length := 0</span>
  3967 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3968 |     | <span class='neutral'>                mstore(pos, length)</span>
  3969 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3970 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3971 |     | <span class='neutral'>            }</span>
  3972 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3973 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3974 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3975 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3976 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3977 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3978 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3979 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256,string)`.</span>
  3980 |     | <span class='neutral'>            mstore(0x00, 0x0aa6cfad)</span>
  3981 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3982 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3983 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3984 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3985 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3986 |     | <span class='neutral'>        }</span>
  3987 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3988 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  3989 |     | <span class='neutral'>        assembly {</span>
  3990 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3991 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3992 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3993 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3994 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3995 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3996 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3997 |     | <span class='neutral'>        }</span>
  3998 |     | <span class='neutral'>    }</span>
  3999 |     | <span class='neutral'></span>
  4000 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2, address p3) internal pure {</span>
  4001 |     | <span class='neutral'>        bytes32 m0;</span>
  4002 |     | <span class='neutral'>        bytes32 m1;</span>
  4003 |     | <span class='neutral'>        bytes32 m2;</span>
  4004 |     | <span class='neutral'>        bytes32 m3;</span>
  4005 |     | <span class='neutral'>        bytes32 m4;</span>
  4006 |     | <span class='neutral'>        bytes32 m5;</span>
  4007 |     | <span class='neutral'>        bytes32 m6;</span>
  4008 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4009 |     | <span class='neutral'>        assembly {</span>
  4010 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4011 |     | <span class='neutral'>                let length := 0</span>
  4012 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4013 |     | <span class='neutral'>                mstore(pos, length)</span>
  4014 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4015 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4016 |     | <span class='neutral'>            }</span>
  4017 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4018 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4019 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4020 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4021 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4022 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4023 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4024 |     | <span class='neutral'>            // Selector of `log(address,bool,string,address)`.</span>
  4025 |     | <span class='neutral'>            mstore(0x00, 0x19fd4956)</span>
  4026 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4027 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4028 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4029 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4030 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4031 |     | <span class='neutral'>        }</span>
  4032 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4033 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4034 |     | <span class='neutral'>        assembly {</span>
  4035 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4036 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4037 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4038 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4039 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4040 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4041 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4042 |     | <span class='neutral'>        }</span>
  4043 |     | <span class='neutral'>    }</span>
  4044 |     | <span class='neutral'></span>
  4045 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {</span>
  4046 |     | <span class='neutral'>        bytes32 m0;</span>
  4047 |     | <span class='neutral'>        bytes32 m1;</span>
  4048 |     | <span class='neutral'>        bytes32 m2;</span>
  4049 |     | <span class='neutral'>        bytes32 m3;</span>
  4050 |     | <span class='neutral'>        bytes32 m4;</span>
  4051 |     | <span class='neutral'>        bytes32 m5;</span>
  4052 |     | <span class='neutral'>        bytes32 m6;</span>
  4053 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4054 |     | <span class='neutral'>        assembly {</span>
  4055 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4056 |     | <span class='neutral'>                let length := 0</span>
  4057 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4058 |     | <span class='neutral'>                mstore(pos, length)</span>
  4059 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4060 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4061 |     | <span class='neutral'>            }</span>
  4062 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4063 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4064 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4065 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4066 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4067 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4068 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4069 |     | <span class='neutral'>            // Selector of `log(address,bool,string,bool)`.</span>
  4070 |     | <span class='neutral'>            mstore(0x00, 0x50ad461d)</span>
  4071 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4072 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4073 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4074 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4075 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4076 |     | <span class='neutral'>        }</span>
  4077 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4078 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4079 |     | <span class='neutral'>        assembly {</span>
  4080 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4081 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4082 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4083 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4084 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4085 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4086 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4087 |     | <span class='neutral'>        }</span>
  4088 |     | <span class='neutral'>    }</span>
  4089 |     | <span class='neutral'></span>
  4090 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {</span>
  4091 |     | <span class='neutral'>        bytes32 m0;</span>
  4092 |     | <span class='neutral'>        bytes32 m1;</span>
  4093 |     | <span class='neutral'>        bytes32 m2;</span>
  4094 |     | <span class='neutral'>        bytes32 m3;</span>
  4095 |     | <span class='neutral'>        bytes32 m4;</span>
  4096 |     | <span class='neutral'>        bytes32 m5;</span>
  4097 |     | <span class='neutral'>        bytes32 m6;</span>
  4098 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4099 |     | <span class='neutral'>        assembly {</span>
  4100 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4101 |     | <span class='neutral'>                let length := 0</span>
  4102 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4103 |     | <span class='neutral'>                mstore(pos, length)</span>
  4104 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4105 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4106 |     | <span class='neutral'>            }</span>
  4107 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4108 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4109 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4110 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4111 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4112 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4113 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4114 |     | <span class='neutral'>            // Selector of `log(address,bool,string,uint256)`.</span>
  4115 |     | <span class='neutral'>            mstore(0x00, 0x80e6a20b)</span>
  4116 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4117 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4118 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4119 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4120 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4121 |     | <span class='neutral'>        }</span>
  4122 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4123 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4124 |     | <span class='neutral'>        assembly {</span>
  4125 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4126 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4127 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4128 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4129 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4130 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4131 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4132 |     | <span class='neutral'>        }</span>
  4133 |     | <span class='neutral'>    }</span>
  4134 |     | <span class='neutral'></span>
  4135 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {</span>
  4136 |     | <span class='neutral'>        bytes32 m0;</span>
  4137 |     | <span class='neutral'>        bytes32 m1;</span>
  4138 |     | <span class='neutral'>        bytes32 m2;</span>
  4139 |     | <span class='neutral'>        bytes32 m3;</span>
  4140 |     | <span class='neutral'>        bytes32 m4;</span>
  4141 |     | <span class='neutral'>        bytes32 m5;</span>
  4142 |     | <span class='neutral'>        bytes32 m6;</span>
  4143 |     | <span class='neutral'>        bytes32 m7;</span>
  4144 |     | <span class='neutral'>        bytes32 m8;</span>
  4145 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4146 |     | <span class='neutral'>        assembly {</span>
  4147 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4148 |     | <span class='neutral'>                let length := 0</span>
  4149 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4150 |     | <span class='neutral'>                mstore(pos, length)</span>
  4151 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4152 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4153 |     | <span class='neutral'>            }</span>
  4154 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4155 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4156 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4157 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4158 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4159 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4160 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4161 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  4162 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  4163 |     | <span class='neutral'>            // Selector of `log(address,bool,string,string)`.</span>
  4164 |     | <span class='neutral'>            mstore(0x00, 0x475c5c33)</span>
  4165 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4166 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4167 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4168 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  4169 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4170 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  4171 |     | <span class='neutral'>        }</span>
  4172 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  4173 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4174 |     | <span class='neutral'>        assembly {</span>
  4175 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4176 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4177 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4178 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4179 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4180 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4181 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4182 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  4183 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  4184 |     | <span class='neutral'>        }</span>
  4185 |     | <span class='neutral'>    }</span>
  4186 |     | <span class='neutral'></span>
  4187 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, address p3) internal pure {</span>
  4188 |     | <span class='neutral'>        bytes32 m0;</span>
  4189 |     | <span class='neutral'>        bytes32 m1;</span>
  4190 |     | <span class='neutral'>        bytes32 m2;</span>
  4191 |     | <span class='neutral'>        bytes32 m3;</span>
  4192 |     | <span class='neutral'>        bytes32 m4;</span>
  4193 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4194 |     | <span class='neutral'>        assembly {</span>
  4195 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4196 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4197 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4198 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4199 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4200 |     | <span class='neutral'>            // Selector of `log(address,uint256,address,address)`.</span>
  4201 |     | <span class='neutral'>            mstore(0x00, 0x478d1c62)</span>
  4202 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4203 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4204 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4205 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4206 |     | <span class='neutral'>        }</span>
  4207 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4208 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4209 |     | <span class='neutral'>        assembly {</span>
  4210 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4211 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4212 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4213 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4214 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4215 |     | <span class='neutral'>        }</span>
  4216 |     | <span class='neutral'>    }</span>
  4217 |     | <span class='neutral'></span>
  4218 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, bool p3) internal pure {</span>
  4219 |     | <span class='neutral'>        bytes32 m0;</span>
  4220 |     | <span class='neutral'>        bytes32 m1;</span>
  4221 |     | <span class='neutral'>        bytes32 m2;</span>
  4222 |     | <span class='neutral'>        bytes32 m3;</span>
  4223 |     | <span class='neutral'>        bytes32 m4;</span>
  4224 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4225 |     | <span class='neutral'>        assembly {</span>
  4226 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4227 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4228 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4229 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4230 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4231 |     | <span class='neutral'>            // Selector of `log(address,uint256,address,bool)`.</span>
  4232 |     | <span class='neutral'>            mstore(0x00, 0xa1bcc9b3)</span>
  4233 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4234 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4235 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4236 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4237 |     | <span class='neutral'>        }</span>
  4238 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4239 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4240 |     | <span class='neutral'>        assembly {</span>
  4241 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4242 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4243 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4244 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4245 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4246 |     | <span class='neutral'>        }</span>
  4247 |     | <span class='neutral'>    }</span>
  4248 |     | <span class='neutral'></span>
  4249 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  4250 |     | <span class='neutral'>        bytes32 m0;</span>
  4251 |     | <span class='neutral'>        bytes32 m1;</span>
  4252 |     | <span class='neutral'>        bytes32 m2;</span>
  4253 |     | <span class='neutral'>        bytes32 m3;</span>
  4254 |     | <span class='neutral'>        bytes32 m4;</span>
  4255 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4256 |     | <span class='neutral'>        assembly {</span>
  4257 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4258 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4259 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4260 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4261 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4262 |     | <span class='neutral'>            // Selector of `log(address,uint256,address,uint256)`.</span>
  4263 |     | <span class='neutral'>            mstore(0x00, 0x100f650e)</span>
  4264 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4265 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4266 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4267 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4268 |     | <span class='neutral'>        }</span>
  4269 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4270 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4271 |     | <span class='neutral'>        assembly {</span>
  4272 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4273 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4274 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4275 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4276 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4277 |     | <span class='neutral'>        }</span>
  4278 |     | <span class='neutral'>    }</span>
  4279 |     | <span class='neutral'></span>
  4280 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {</span>
  4281 |     | <span class='neutral'>        bytes32 m0;</span>
  4282 |     | <span class='neutral'>        bytes32 m1;</span>
  4283 |     | <span class='neutral'>        bytes32 m2;</span>
  4284 |     | <span class='neutral'>        bytes32 m3;</span>
  4285 |     | <span class='neutral'>        bytes32 m4;</span>
  4286 |     | <span class='neutral'>        bytes32 m5;</span>
  4287 |     | <span class='neutral'>        bytes32 m6;</span>
  4288 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4289 |     | <span class='neutral'>        assembly {</span>
  4290 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4291 |     | <span class='neutral'>                let length := 0</span>
  4292 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4293 |     | <span class='neutral'>                mstore(pos, length)</span>
  4294 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4295 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4296 |     | <span class='neutral'>            }</span>
  4297 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4298 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4299 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4300 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4301 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4302 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4303 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4304 |     | <span class='neutral'>            // Selector of `log(address,uint256,address,string)`.</span>
  4305 |     | <span class='neutral'>            mstore(0x00, 0x1da986ea)</span>
  4306 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4307 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4308 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4309 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  4310 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  4311 |     | <span class='neutral'>        }</span>
  4312 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4313 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4314 |     | <span class='neutral'>        assembly {</span>
  4315 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4316 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4317 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4318 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4319 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4320 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4321 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4322 |     | <span class='neutral'>        }</span>
  4323 |     | <span class='neutral'>    }</span>
  4324 |     | <span class='neutral'></span>
  4325 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, address p3) internal pure {</span>
  4326 |     | <span class='neutral'>        bytes32 m0;</span>
  4327 |     | <span class='neutral'>        bytes32 m1;</span>
  4328 |     | <span class='neutral'>        bytes32 m2;</span>
  4329 |     | <span class='neutral'>        bytes32 m3;</span>
  4330 |     | <span class='neutral'>        bytes32 m4;</span>
  4331 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4332 |     | <span class='neutral'>        assembly {</span>
  4333 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4334 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4335 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4336 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4337 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4338 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool,address)`.</span>
  4339 |     | <span class='neutral'>            mstore(0x00, 0xa31bfdcc)</span>
  4340 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4341 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4342 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4343 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4344 |     | <span class='neutral'>        }</span>
  4345 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4346 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4347 |     | <span class='neutral'>        assembly {</span>
  4348 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4349 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4350 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4351 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4352 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4353 |     | <span class='neutral'>        }</span>
  4354 |     | <span class='neutral'>    }</span>
  4355 |     | <span class='neutral'></span>
  4356 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  4357 |     | <span class='neutral'>        bytes32 m0;</span>
  4358 |     | <span class='neutral'>        bytes32 m1;</span>
  4359 |     | <span class='neutral'>        bytes32 m2;</span>
  4360 |     | <span class='neutral'>        bytes32 m3;</span>
  4361 |     | <span class='neutral'>        bytes32 m4;</span>
  4362 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4363 |     | <span class='neutral'>        assembly {</span>
  4364 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4365 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4366 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4367 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4368 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4369 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool,bool)`.</span>
  4370 |     | <span class='neutral'>            mstore(0x00, 0x3bf5e537)</span>
  4371 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4372 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4373 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4374 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4375 |     | <span class='neutral'>        }</span>
  4376 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4377 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4378 |     | <span class='neutral'>        assembly {</span>
  4379 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4380 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4381 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4382 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4383 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4384 |     | <span class='neutral'>        }</span>
  4385 |     | <span class='neutral'>    }</span>
  4386 |     | <span class='neutral'></span>
  4387 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  4388 |     | <span class='neutral'>        bytes32 m0;</span>
  4389 |     | <span class='neutral'>        bytes32 m1;</span>
  4390 |     | <span class='neutral'>        bytes32 m2;</span>
  4391 |     | <span class='neutral'>        bytes32 m3;</span>
  4392 |     | <span class='neutral'>        bytes32 m4;</span>
  4393 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4394 |     | <span class='neutral'>        assembly {</span>
  4395 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4396 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4397 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4398 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4399 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4400 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool,uint256)`.</span>
  4401 |     | <span class='neutral'>            mstore(0x00, 0x22f6b999)</span>
  4402 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4403 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4404 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4405 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4406 |     | <span class='neutral'>        }</span>
  4407 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4408 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4409 |     | <span class='neutral'>        assembly {</span>
  4410 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4411 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4412 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4413 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4414 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4415 |     | <span class='neutral'>        }</span>
  4416 |     | <span class='neutral'>    }</span>
  4417 |     | <span class='neutral'></span>
  4418 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {</span>
  4419 |     | <span class='neutral'>        bytes32 m0;</span>
  4420 |     | <span class='neutral'>        bytes32 m1;</span>
  4421 |     | <span class='neutral'>        bytes32 m2;</span>
  4422 |     | <span class='neutral'>        bytes32 m3;</span>
  4423 |     | <span class='neutral'>        bytes32 m4;</span>
  4424 |     | <span class='neutral'>        bytes32 m5;</span>
  4425 |     | <span class='neutral'>        bytes32 m6;</span>
  4426 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4427 |     | <span class='neutral'>        assembly {</span>
  4428 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4429 |     | <span class='neutral'>                let length := 0</span>
  4430 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4431 |     | <span class='neutral'>                mstore(pos, length)</span>
  4432 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4433 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4434 |     | <span class='neutral'>            }</span>
  4435 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4436 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4437 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4438 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4439 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4440 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4441 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4442 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool,string)`.</span>
  4443 |     | <span class='neutral'>            mstore(0x00, 0xc5ad85f9)</span>
  4444 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4445 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4446 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4447 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  4448 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  4449 |     | <span class='neutral'>        }</span>
  4450 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4451 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4452 |     | <span class='neutral'>        assembly {</span>
  4453 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4454 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4455 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4456 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4457 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4458 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4459 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4460 |     | <span class='neutral'>        }</span>
  4461 |     | <span class='neutral'>    }</span>
  4462 |     | <span class='neutral'></span>
  4463 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  4464 |     | <span class='neutral'>        bytes32 m0;</span>
  4465 |     | <span class='neutral'>        bytes32 m1;</span>
  4466 |     | <span class='neutral'>        bytes32 m2;</span>
  4467 |     | <span class='neutral'>        bytes32 m3;</span>
  4468 |     | <span class='neutral'>        bytes32 m4;</span>
  4469 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4470 |     | <span class='neutral'>        assembly {</span>
  4471 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4472 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4473 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4474 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4475 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4476 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256,address)`.</span>
  4477 |     | <span class='neutral'>            mstore(0x00, 0x20e3984d)</span>
  4478 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4479 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4480 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4481 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4482 |     | <span class='neutral'>        }</span>
  4483 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4484 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4485 |     | <span class='neutral'>        assembly {</span>
  4486 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4487 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4488 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4489 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4490 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4491 |     | <span class='neutral'>        }</span>
  4492 |     | <span class='neutral'>    }</span>
  4493 |     | <span class='neutral'></span>
  4494 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  4495 |     | <span class='neutral'>        bytes32 m0;</span>
  4496 |     | <span class='neutral'>        bytes32 m1;</span>
  4497 |     | <span class='neutral'>        bytes32 m2;</span>
  4498 |     | <span class='neutral'>        bytes32 m3;</span>
  4499 |     | <span class='neutral'>        bytes32 m4;</span>
  4500 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4501 |     | <span class='neutral'>        assembly {</span>
  4502 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4503 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4504 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4505 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4506 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4507 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256,bool)`.</span>
  4508 |     | <span class='neutral'>            mstore(0x00, 0x66f1bc67)</span>
  4509 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4510 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4511 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4512 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4513 |     | <span class='neutral'>        }</span>
  4514 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4515 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4516 |     | <span class='neutral'>        assembly {</span>
  4517 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4518 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4519 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4520 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4521 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4522 |     | <span class='neutral'>        }</span>
  4523 |     | <span class='neutral'>    }</span>
  4524 |     | <span class='neutral'></span>
  4525 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  4526 |     | <span class='neutral'>        bytes32 m0;</span>
  4527 |     | <span class='neutral'>        bytes32 m1;</span>
  4528 |     | <span class='neutral'>        bytes32 m2;</span>
  4529 |     | <span class='neutral'>        bytes32 m3;</span>
  4530 |     | <span class='neutral'>        bytes32 m4;</span>
  4531 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4532 |     | <span class='neutral'>        assembly {</span>
  4533 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4534 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4535 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4536 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4537 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4538 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256,uint256)`.</span>
  4539 |     | <span class='neutral'>            mstore(0x00, 0x34f0e636)</span>
  4540 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4541 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4542 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4543 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4544 |     | <span class='neutral'>        }</span>
  4545 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4546 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4547 |     | <span class='neutral'>        assembly {</span>
  4548 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4549 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4550 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4551 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4552 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4553 |     | <span class='neutral'>        }</span>
  4554 |     | <span class='neutral'>    }</span>
  4555 |     | <span class='neutral'></span>
  4556 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {</span>
  4557 |     | <span class='neutral'>        bytes32 m0;</span>
  4558 |     | <span class='neutral'>        bytes32 m1;</span>
  4559 |     | <span class='neutral'>        bytes32 m2;</span>
  4560 |     | <span class='neutral'>        bytes32 m3;</span>
  4561 |     | <span class='neutral'>        bytes32 m4;</span>
  4562 |     | <span class='neutral'>        bytes32 m5;</span>
  4563 |     | <span class='neutral'>        bytes32 m6;</span>
  4564 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4565 |     | <span class='neutral'>        assembly {</span>
  4566 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4567 |     | <span class='neutral'>                let length := 0</span>
  4568 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4569 |     | <span class='neutral'>                mstore(pos, length)</span>
  4570 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4571 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4572 |     | <span class='neutral'>            }</span>
  4573 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4574 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4575 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4576 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4577 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4578 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4579 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4580 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256,string)`.</span>
  4581 |     | <span class='neutral'>            mstore(0x00, 0x4a28c017)</span>
  4582 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4583 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4584 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4585 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  4586 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  4587 |     | <span class='neutral'>        }</span>
  4588 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4589 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4590 |     | <span class='neutral'>        assembly {</span>
  4591 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4592 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4593 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4594 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4595 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4596 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4597 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4598 |     | <span class='neutral'>        }</span>
  4599 |     | <span class='neutral'>    }</span>
  4600 |     | <span class='neutral'></span>
  4601 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {</span>
  4602 |     | <span class='neutral'>        bytes32 m0;</span>
  4603 |     | <span class='neutral'>        bytes32 m1;</span>
  4604 |     | <span class='neutral'>        bytes32 m2;</span>
  4605 |     | <span class='neutral'>        bytes32 m3;</span>
  4606 |     | <span class='neutral'>        bytes32 m4;</span>
  4607 |     | <span class='neutral'>        bytes32 m5;</span>
  4608 |     | <span class='neutral'>        bytes32 m6;</span>
  4609 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4610 |     | <span class='neutral'>        assembly {</span>
  4611 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4612 |     | <span class='neutral'>                let length := 0</span>
  4613 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4614 |     | <span class='neutral'>                mstore(pos, length)</span>
  4615 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4616 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4617 |     | <span class='neutral'>            }</span>
  4618 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4619 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4620 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4621 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4622 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4623 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4624 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4625 |     | <span class='neutral'>            // Selector of `log(address,uint256,string,address)`.</span>
  4626 |     | <span class='neutral'>            mstore(0x00, 0x5c430d47)</span>
  4627 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4628 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4629 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4630 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4631 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4632 |     | <span class='neutral'>        }</span>
  4633 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4634 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4635 |     | <span class='neutral'>        assembly {</span>
  4636 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4637 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4638 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4639 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4640 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4641 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4642 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4643 |     | <span class='neutral'>        }</span>
  4644 |     | <span class='neutral'>    }</span>
  4645 |     | <span class='neutral'></span>
  4646 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {</span>
  4647 |     | <span class='neutral'>        bytes32 m0;</span>
  4648 |     | <span class='neutral'>        bytes32 m1;</span>
  4649 |     | <span class='neutral'>        bytes32 m2;</span>
  4650 |     | <span class='neutral'>        bytes32 m3;</span>
  4651 |     | <span class='neutral'>        bytes32 m4;</span>
  4652 |     | <span class='neutral'>        bytes32 m5;</span>
  4653 |     | <span class='neutral'>        bytes32 m6;</span>
  4654 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4655 |     | <span class='neutral'>        assembly {</span>
  4656 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4657 |     | <span class='neutral'>                let length := 0</span>
  4658 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4659 |     | <span class='neutral'>                mstore(pos, length)</span>
  4660 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4661 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4662 |     | <span class='neutral'>            }</span>
  4663 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4664 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4665 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4666 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4667 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4668 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4669 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4670 |     | <span class='neutral'>            // Selector of `log(address,uint256,string,bool)`.</span>
  4671 |     | <span class='neutral'>            mstore(0x00, 0xcf18105c)</span>
  4672 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4673 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4674 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4675 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4676 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4677 |     | <span class='neutral'>        }</span>
  4678 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4679 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4680 |     | <span class='neutral'>        assembly {</span>
  4681 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4682 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4683 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4684 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4685 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4686 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4687 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4688 |     | <span class='neutral'>        }</span>
  4689 |     | <span class='neutral'>    }</span>
  4690 |     | <span class='neutral'></span>
  4691 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {</span>
  4692 |     | <span class='neutral'>        bytes32 m0;</span>
  4693 |     | <span class='neutral'>        bytes32 m1;</span>
  4694 |     | <span class='neutral'>        bytes32 m2;</span>
  4695 |     | <span class='neutral'>        bytes32 m3;</span>
  4696 |     | <span class='neutral'>        bytes32 m4;</span>
  4697 |     | <span class='neutral'>        bytes32 m5;</span>
  4698 |     | <span class='neutral'>        bytes32 m6;</span>
  4699 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4700 |     | <span class='neutral'>        assembly {</span>
  4701 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4702 |     | <span class='neutral'>                let length := 0</span>
  4703 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4704 |     | <span class='neutral'>                mstore(pos, length)</span>
  4705 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4706 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4707 |     | <span class='neutral'>            }</span>
  4708 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4709 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4710 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4711 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4712 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4713 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4714 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4715 |     | <span class='neutral'>            // Selector of `log(address,uint256,string,uint256)`.</span>
  4716 |     | <span class='neutral'>            mstore(0x00, 0xbf01f891)</span>
  4717 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4718 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4719 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4720 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4721 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4722 |     | <span class='neutral'>        }</span>
  4723 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4724 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4725 |     | <span class='neutral'>        assembly {</span>
  4726 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4727 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4728 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4729 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4730 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4731 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4732 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4733 |     | <span class='neutral'>        }</span>
  4734 |     | <span class='neutral'>    }</span>
  4735 |     | <span class='neutral'></span>
  4736 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  4737 |     | <span class='neutral'>        bytes32 m0;</span>
  4738 |     | <span class='neutral'>        bytes32 m1;</span>
  4739 |     | <span class='neutral'>        bytes32 m2;</span>
  4740 |     | <span class='neutral'>        bytes32 m3;</span>
  4741 |     | <span class='neutral'>        bytes32 m4;</span>
  4742 |     | <span class='neutral'>        bytes32 m5;</span>
  4743 |     | <span class='neutral'>        bytes32 m6;</span>
  4744 |     | <span class='neutral'>        bytes32 m7;</span>
  4745 |     | <span class='neutral'>        bytes32 m8;</span>
  4746 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4747 |     | <span class='neutral'>        assembly {</span>
  4748 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4749 |     | <span class='neutral'>                let length := 0</span>
  4750 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4751 |     | <span class='neutral'>                mstore(pos, length)</span>
  4752 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4753 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4754 |     | <span class='neutral'>            }</span>
  4755 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4756 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4757 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4758 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4759 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4760 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4761 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4762 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  4763 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  4764 |     | <span class='neutral'>            // Selector of `log(address,uint256,string,string)`.</span>
  4765 |     | <span class='neutral'>            mstore(0x00, 0x88a8c406)</span>
  4766 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4767 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4768 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4769 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  4770 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4771 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  4772 |     | <span class='neutral'>        }</span>
  4773 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  4774 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4775 |     | <span class='neutral'>        assembly {</span>
  4776 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4777 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4778 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4779 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4780 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4781 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4782 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4783 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  4784 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  4785 |     | <span class='neutral'>        }</span>
  4786 |     | <span class='neutral'>    }</span>
  4787 |     | <span class='neutral'></span>
  4788 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2, address p3) internal pure {</span>
  4789 |     | <span class='neutral'>        bytes32 m0;</span>
  4790 |     | <span class='neutral'>        bytes32 m1;</span>
  4791 |     | <span class='neutral'>        bytes32 m2;</span>
  4792 |     | <span class='neutral'>        bytes32 m3;</span>
  4793 |     | <span class='neutral'>        bytes32 m4;</span>
  4794 |     | <span class='neutral'>        bytes32 m5;</span>
  4795 |     | <span class='neutral'>        bytes32 m6;</span>
  4796 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4797 |     | <span class='neutral'>        assembly {</span>
  4798 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4799 |     | <span class='neutral'>                let length := 0</span>
  4800 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4801 |     | <span class='neutral'>                mstore(pos, length)</span>
  4802 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4803 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4804 |     | <span class='neutral'>            }</span>
  4805 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4806 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4807 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4808 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4809 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4810 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4811 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4812 |     | <span class='neutral'>            // Selector of `log(address,string,address,address)`.</span>
  4813 |     | <span class='neutral'>            mstore(0x00, 0x0d36fa20)</span>
  4814 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4815 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4816 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4817 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4818 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4819 |     | <span class='neutral'>        }</span>
  4820 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4821 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4822 |     | <span class='neutral'>        assembly {</span>
  4823 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4824 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4825 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4826 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4827 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4828 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4829 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4830 |     | <span class='neutral'>        }</span>
  4831 |     | <span class='neutral'>    }</span>
  4832 |     | <span class='neutral'></span>
  4833 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2, bool p3) internal pure {</span>
  4834 |     | <span class='neutral'>        bytes32 m0;</span>
  4835 |     | <span class='neutral'>        bytes32 m1;</span>
  4836 |     | <span class='neutral'>        bytes32 m2;</span>
  4837 |     | <span class='neutral'>        bytes32 m3;</span>
  4838 |     | <span class='neutral'>        bytes32 m4;</span>
  4839 |     | <span class='neutral'>        bytes32 m5;</span>
  4840 |     | <span class='neutral'>        bytes32 m6;</span>
  4841 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4842 |     | <span class='neutral'>        assembly {</span>
  4843 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4844 |     | <span class='neutral'>                let length := 0</span>
  4845 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4846 |     | <span class='neutral'>                mstore(pos, length)</span>
  4847 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4848 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4849 |     | <span class='neutral'>            }</span>
  4850 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4851 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4852 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4853 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4854 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4855 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4856 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4857 |     | <span class='neutral'>            // Selector of `log(address,string,address,bool)`.</span>
  4858 |     | <span class='neutral'>            mstore(0x00, 0x0df12b76)</span>
  4859 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4860 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4861 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4862 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4863 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4864 |     | <span class='neutral'>        }</span>
  4865 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4866 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4867 |     | <span class='neutral'>        assembly {</span>
  4868 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4869 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4870 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4871 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4872 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4873 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4874 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4875 |     | <span class='neutral'>        }</span>
  4876 |     | <span class='neutral'>    }</span>
  4877 |     | <span class='neutral'></span>
  4878 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {</span>
  4879 |     | <span class='neutral'>        bytes32 m0;</span>
  4880 |     | <span class='neutral'>        bytes32 m1;</span>
  4881 |     | <span class='neutral'>        bytes32 m2;</span>
  4882 |     | <span class='neutral'>        bytes32 m3;</span>
  4883 |     | <span class='neutral'>        bytes32 m4;</span>
  4884 |     | <span class='neutral'>        bytes32 m5;</span>
  4885 |     | <span class='neutral'>        bytes32 m6;</span>
  4886 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4887 |     | <span class='neutral'>        assembly {</span>
  4888 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4889 |     | <span class='neutral'>                let length := 0</span>
  4890 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4891 |     | <span class='neutral'>                mstore(pos, length)</span>
  4892 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4893 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4894 |     | <span class='neutral'>            }</span>
  4895 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4896 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4897 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4898 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4899 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4900 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4901 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4902 |     | <span class='neutral'>            // Selector of `log(address,string,address,uint256)`.</span>
  4903 |     | <span class='neutral'>            mstore(0x00, 0x457fe3cf)</span>
  4904 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4905 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4906 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4907 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4908 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4909 |     | <span class='neutral'>        }</span>
  4910 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4911 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4912 |     | <span class='neutral'>        assembly {</span>
  4913 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4914 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4915 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4916 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4917 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4918 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4919 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4920 |     | <span class='neutral'>        }</span>
  4921 |     | <span class='neutral'>    }</span>
  4922 |     | <span class='neutral'></span>
  4923 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {</span>
  4924 |     | <span class='neutral'>        bytes32 m0;</span>
  4925 |     | <span class='neutral'>        bytes32 m1;</span>
  4926 |     | <span class='neutral'>        bytes32 m2;</span>
  4927 |     | <span class='neutral'>        bytes32 m3;</span>
  4928 |     | <span class='neutral'>        bytes32 m4;</span>
  4929 |     | <span class='neutral'>        bytes32 m5;</span>
  4930 |     | <span class='neutral'>        bytes32 m6;</span>
  4931 |     | <span class='neutral'>        bytes32 m7;</span>
  4932 |     | <span class='neutral'>        bytes32 m8;</span>
  4933 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4934 |     | <span class='neutral'>        assembly {</span>
  4935 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4936 |     | <span class='neutral'>                let length := 0</span>
  4937 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4938 |     | <span class='neutral'>                mstore(pos, length)</span>
  4939 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4940 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4941 |     | <span class='neutral'>            }</span>
  4942 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4943 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4944 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4945 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4946 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4947 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4948 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4949 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  4950 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  4951 |     | <span class='neutral'>            // Selector of `log(address,string,address,string)`.</span>
  4952 |     | <span class='neutral'>            mstore(0x00, 0xf7e36245)</span>
  4953 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4954 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4955 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4956 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  4957 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4958 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  4959 |     | <span class='neutral'>        }</span>
  4960 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  4961 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4962 |     | <span class='neutral'>        assembly {</span>
  4963 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4964 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4965 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4966 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4967 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4968 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4969 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4970 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  4971 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  4972 |     | <span class='neutral'>        }</span>
  4973 |     | <span class='neutral'>    }</span>
  4974 |     | <span class='neutral'></span>
  4975 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2, address p3) internal pure {</span>
  4976 |     | <span class='neutral'>        bytes32 m0;</span>
  4977 |     | <span class='neutral'>        bytes32 m1;</span>
  4978 |     | <span class='neutral'>        bytes32 m2;</span>
  4979 |     | <span class='neutral'>        bytes32 m3;</span>
  4980 |     | <span class='neutral'>        bytes32 m4;</span>
  4981 |     | <span class='neutral'>        bytes32 m5;</span>
  4982 |     | <span class='neutral'>        bytes32 m6;</span>
  4983 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  4984 |     | <span class='neutral'>        assembly {</span>
  4985 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4986 |     | <span class='neutral'>                let length := 0</span>
  4987 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4988 |     | <span class='neutral'>                mstore(pos, length)</span>
  4989 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4990 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4991 |     | <span class='neutral'>            }</span>
  4992 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4993 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4994 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4995 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4996 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4997 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4998 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4999 |     | <span class='neutral'>            // Selector of `log(address,string,bool,address)`.</span>
  5000 |     | <span class='neutral'>            mstore(0x00, 0x205871c2)</span>
  5001 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5002 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5003 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5004 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5005 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5006 |     | <span class='neutral'>        }</span>
  5007 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5008 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5009 |     | <span class='neutral'>        assembly {</span>
  5010 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5011 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5012 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5013 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5014 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5015 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5016 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5017 |     | <span class='neutral'>        }</span>
  5018 |     | <span class='neutral'>    }</span>
  5019 |     | <span class='neutral'></span>
  5020 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {</span>
  5021 |     | <span class='neutral'>        bytes32 m0;</span>
  5022 |     | <span class='neutral'>        bytes32 m1;</span>
  5023 |     | <span class='neutral'>        bytes32 m2;</span>
  5024 |     | <span class='neutral'>        bytes32 m3;</span>
  5025 |     | <span class='neutral'>        bytes32 m4;</span>
  5026 |     | <span class='neutral'>        bytes32 m5;</span>
  5027 |     | <span class='neutral'>        bytes32 m6;</span>
  5028 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5029 |     | <span class='neutral'>        assembly {</span>
  5030 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5031 |     | <span class='neutral'>                let length := 0</span>
  5032 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5033 |     | <span class='neutral'>                mstore(pos, length)</span>
  5034 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5035 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5036 |     | <span class='neutral'>            }</span>
  5037 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5038 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5039 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5040 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5041 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5042 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5043 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5044 |     | <span class='neutral'>            // Selector of `log(address,string,bool,bool)`.</span>
  5045 |     | <span class='neutral'>            mstore(0x00, 0x5f1d5c9f)</span>
  5046 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5047 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5048 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5049 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5050 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5051 |     | <span class='neutral'>        }</span>
  5052 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5053 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5054 |     | <span class='neutral'>        assembly {</span>
  5055 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5056 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5057 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5058 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5059 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5060 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5061 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5062 |     | <span class='neutral'>        }</span>
  5063 |     | <span class='neutral'>    }</span>
  5064 |     | <span class='neutral'></span>
  5065 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {</span>
  5066 |     | <span class='neutral'>        bytes32 m0;</span>
  5067 |     | <span class='neutral'>        bytes32 m1;</span>
  5068 |     | <span class='neutral'>        bytes32 m2;</span>
  5069 |     | <span class='neutral'>        bytes32 m3;</span>
  5070 |     | <span class='neutral'>        bytes32 m4;</span>
  5071 |     | <span class='neutral'>        bytes32 m5;</span>
  5072 |     | <span class='neutral'>        bytes32 m6;</span>
  5073 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5074 |     | <span class='neutral'>        assembly {</span>
  5075 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5076 |     | <span class='neutral'>                let length := 0</span>
  5077 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5078 |     | <span class='neutral'>                mstore(pos, length)</span>
  5079 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5080 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5081 |     | <span class='neutral'>            }</span>
  5082 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5083 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5084 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5085 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5086 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5087 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5088 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5089 |     | <span class='neutral'>            // Selector of `log(address,string,bool,uint256)`.</span>
  5090 |     | <span class='neutral'>            mstore(0x00, 0x515e38b6)</span>
  5091 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5092 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5093 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5094 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5095 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5096 |     | <span class='neutral'>        }</span>
  5097 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5098 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5099 |     | <span class='neutral'>        assembly {</span>
  5100 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5101 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5102 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5103 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5104 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5105 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5106 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5107 |     | <span class='neutral'>        }</span>
  5108 |     | <span class='neutral'>    }</span>
  5109 |     | <span class='neutral'></span>
  5110 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {</span>
  5111 |     | <span class='neutral'>        bytes32 m0;</span>
  5112 |     | <span class='neutral'>        bytes32 m1;</span>
  5113 |     | <span class='neutral'>        bytes32 m2;</span>
  5114 |     | <span class='neutral'>        bytes32 m3;</span>
  5115 |     | <span class='neutral'>        bytes32 m4;</span>
  5116 |     | <span class='neutral'>        bytes32 m5;</span>
  5117 |     | <span class='neutral'>        bytes32 m6;</span>
  5118 |     | <span class='neutral'>        bytes32 m7;</span>
  5119 |     | <span class='neutral'>        bytes32 m8;</span>
  5120 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5121 |     | <span class='neutral'>        assembly {</span>
  5122 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5123 |     | <span class='neutral'>                let length := 0</span>
  5124 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5125 |     | <span class='neutral'>                mstore(pos, length)</span>
  5126 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5127 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5128 |     | <span class='neutral'>            }</span>
  5129 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5130 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5131 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5132 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5133 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5134 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5135 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5136 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5137 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5138 |     | <span class='neutral'>            // Selector of `log(address,string,bool,string)`.</span>
  5139 |     | <span class='neutral'>            mstore(0x00, 0xbc0b61fe)</span>
  5140 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5141 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5142 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5143 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  5144 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5145 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  5146 |     | <span class='neutral'>        }</span>
  5147 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5148 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5149 |     | <span class='neutral'>        assembly {</span>
  5150 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5151 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5152 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5153 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5154 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5155 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5156 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5157 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5158 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5159 |     | <span class='neutral'>        }</span>
  5160 |     | <span class='neutral'>    }</span>
  5161 |     | <span class='neutral'></span>
  5162 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {</span>
  5163 |     | <span class='neutral'>        bytes32 m0;</span>
  5164 |     | <span class='neutral'>        bytes32 m1;</span>
  5165 |     | <span class='neutral'>        bytes32 m2;</span>
  5166 |     | <span class='neutral'>        bytes32 m3;</span>
  5167 |     | <span class='neutral'>        bytes32 m4;</span>
  5168 |     | <span class='neutral'>        bytes32 m5;</span>
  5169 |     | <span class='neutral'>        bytes32 m6;</span>
  5170 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5171 |     | <span class='neutral'>        assembly {</span>
  5172 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5173 |     | <span class='neutral'>                let length := 0</span>
  5174 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5175 |     | <span class='neutral'>                mstore(pos, length)</span>
  5176 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5177 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5178 |     | <span class='neutral'>            }</span>
  5179 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5180 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5181 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5182 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5183 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5184 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5185 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5186 |     | <span class='neutral'>            // Selector of `log(address,string,uint256,address)`.</span>
  5187 |     | <span class='neutral'>            mstore(0x00, 0x63183678)</span>
  5188 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5189 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5190 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5191 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5192 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5193 |     | <span class='neutral'>        }</span>
  5194 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5195 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5196 |     | <span class='neutral'>        assembly {</span>
  5197 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5198 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5199 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5200 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5201 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5202 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5203 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5204 |     | <span class='neutral'>        }</span>
  5205 |     | <span class='neutral'>    }</span>
  5206 |     | <span class='neutral'></span>
  5207 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {</span>
  5208 |     | <span class='neutral'>        bytes32 m0;</span>
  5209 |     | <span class='neutral'>        bytes32 m1;</span>
  5210 |     | <span class='neutral'>        bytes32 m2;</span>
  5211 |     | <span class='neutral'>        bytes32 m3;</span>
  5212 |     | <span class='neutral'>        bytes32 m4;</span>
  5213 |     | <span class='neutral'>        bytes32 m5;</span>
  5214 |     | <span class='neutral'>        bytes32 m6;</span>
  5215 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5216 |     | <span class='neutral'>        assembly {</span>
  5217 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5218 |     | <span class='neutral'>                let length := 0</span>
  5219 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5220 |     | <span class='neutral'>                mstore(pos, length)</span>
  5221 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5222 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5223 |     | <span class='neutral'>            }</span>
  5224 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5225 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5226 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5227 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5228 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5229 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5230 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5231 |     | <span class='neutral'>            // Selector of `log(address,string,uint256,bool)`.</span>
  5232 |     | <span class='neutral'>            mstore(0x00, 0x0ef7e050)</span>
  5233 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5234 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5235 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5236 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5237 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5238 |     | <span class='neutral'>        }</span>
  5239 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5240 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5241 |     | <span class='neutral'>        assembly {</span>
  5242 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5243 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5244 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5245 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5246 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5247 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5248 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5249 |     | <span class='neutral'>        }</span>
  5250 |     | <span class='neutral'>    }</span>
  5251 |     | <span class='neutral'></span>
  5252 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {</span>
  5253 |     | <span class='neutral'>        bytes32 m0;</span>
  5254 |     | <span class='neutral'>        bytes32 m1;</span>
  5255 |     | <span class='neutral'>        bytes32 m2;</span>
  5256 |     | <span class='neutral'>        bytes32 m3;</span>
  5257 |     | <span class='neutral'>        bytes32 m4;</span>
  5258 |     | <span class='neutral'>        bytes32 m5;</span>
  5259 |     | <span class='neutral'>        bytes32 m6;</span>
  5260 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5261 |     | <span class='neutral'>        assembly {</span>
  5262 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5263 |     | <span class='neutral'>                let length := 0</span>
  5264 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5265 |     | <span class='neutral'>                mstore(pos, length)</span>
  5266 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5267 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5268 |     | <span class='neutral'>            }</span>
  5269 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5270 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5271 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5272 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5273 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5274 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5275 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5276 |     | <span class='neutral'>            // Selector of `log(address,string,uint256,uint256)`.</span>
  5277 |     | <span class='neutral'>            mstore(0x00, 0x1dc8e1b8)</span>
  5278 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5279 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5280 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5281 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5282 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5283 |     | <span class='neutral'>        }</span>
  5284 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5285 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5286 |     | <span class='neutral'>        assembly {</span>
  5287 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5288 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5289 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5290 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5291 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5292 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5293 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5294 |     | <span class='neutral'>        }</span>
  5295 |     | <span class='neutral'>    }</span>
  5296 |     | <span class='neutral'></span>
  5297 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {</span>
  5298 |     | <span class='neutral'>        bytes32 m0;</span>
  5299 |     | <span class='neutral'>        bytes32 m1;</span>
  5300 |     | <span class='neutral'>        bytes32 m2;</span>
  5301 |     | <span class='neutral'>        bytes32 m3;</span>
  5302 |     | <span class='neutral'>        bytes32 m4;</span>
  5303 |     | <span class='neutral'>        bytes32 m5;</span>
  5304 |     | <span class='neutral'>        bytes32 m6;</span>
  5305 |     | <span class='neutral'>        bytes32 m7;</span>
  5306 |     | <span class='neutral'>        bytes32 m8;</span>
  5307 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5308 |     | <span class='neutral'>        assembly {</span>
  5309 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5310 |     | <span class='neutral'>                let length := 0</span>
  5311 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5312 |     | <span class='neutral'>                mstore(pos, length)</span>
  5313 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5314 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5315 |     | <span class='neutral'>            }</span>
  5316 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5317 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5318 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5319 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5320 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5321 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5322 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5323 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5324 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5325 |     | <span class='neutral'>            // Selector of `log(address,string,uint256,string)`.</span>
  5326 |     | <span class='neutral'>            mstore(0x00, 0x448830a8)</span>
  5327 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5328 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5329 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5330 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  5331 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5332 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  5333 |     | <span class='neutral'>        }</span>
  5334 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5335 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5336 |     | <span class='neutral'>        assembly {</span>
  5337 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5338 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5339 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5340 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5341 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5342 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5343 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5344 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5345 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5346 |     | <span class='neutral'>        }</span>
  5347 |     | <span class='neutral'>    }</span>
  5348 |     | <span class='neutral'></span>
  5349 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {</span>
  5350 |     | <span class='neutral'>        bytes32 m0;</span>
  5351 |     | <span class='neutral'>        bytes32 m1;</span>
  5352 |     | <span class='neutral'>        bytes32 m2;</span>
  5353 |     | <span class='neutral'>        bytes32 m3;</span>
  5354 |     | <span class='neutral'>        bytes32 m4;</span>
  5355 |     | <span class='neutral'>        bytes32 m5;</span>
  5356 |     | <span class='neutral'>        bytes32 m6;</span>
  5357 |     | <span class='neutral'>        bytes32 m7;</span>
  5358 |     | <span class='neutral'>        bytes32 m8;</span>
  5359 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5360 |     | <span class='neutral'>        assembly {</span>
  5361 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5362 |     | <span class='neutral'>                let length := 0</span>
  5363 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5364 |     | <span class='neutral'>                mstore(pos, length)</span>
  5365 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5366 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5367 |     | <span class='neutral'>            }</span>
  5368 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5369 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5370 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5371 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5372 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5373 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5374 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5375 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5376 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5377 |     | <span class='neutral'>            // Selector of `log(address,string,string,address)`.</span>
  5378 |     | <span class='neutral'>            mstore(0x00, 0xa04e2f87)</span>
  5379 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5380 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5381 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  5382 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5383 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5384 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  5385 |     | <span class='neutral'>        }</span>
  5386 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5387 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5388 |     | <span class='neutral'>        assembly {</span>
  5389 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5390 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5391 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5392 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5393 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5394 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5395 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5396 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5397 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5398 |     | <span class='neutral'>        }</span>
  5399 |     | <span class='neutral'>    }</span>
  5400 |     | <span class='neutral'></span>
  5401 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {</span>
  5402 |     | <span class='neutral'>        bytes32 m0;</span>
  5403 |     | <span class='neutral'>        bytes32 m1;</span>
  5404 |     | <span class='neutral'>        bytes32 m2;</span>
  5405 |     | <span class='neutral'>        bytes32 m3;</span>
  5406 |     | <span class='neutral'>        bytes32 m4;</span>
  5407 |     | <span class='neutral'>        bytes32 m5;</span>
  5408 |     | <span class='neutral'>        bytes32 m6;</span>
  5409 |     | <span class='neutral'>        bytes32 m7;</span>
  5410 |     | <span class='neutral'>        bytes32 m8;</span>
  5411 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5412 |     | <span class='neutral'>        assembly {</span>
  5413 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5414 |     | <span class='neutral'>                let length := 0</span>
  5415 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5416 |     | <span class='neutral'>                mstore(pos, length)</span>
  5417 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5418 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5419 |     | <span class='neutral'>            }</span>
  5420 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5421 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5422 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5423 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5424 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5425 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5426 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5427 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5428 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5429 |     | <span class='neutral'>            // Selector of `log(address,string,string,bool)`.</span>
  5430 |     | <span class='neutral'>            mstore(0x00, 0x35a5071f)</span>
  5431 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5432 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5433 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  5434 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5435 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5436 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  5437 |     | <span class='neutral'>        }</span>
  5438 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5439 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5440 |     | <span class='neutral'>        assembly {</span>
  5441 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5442 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5443 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5444 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5445 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5446 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5447 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5448 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5449 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5450 |     | <span class='neutral'>        }</span>
  5451 |     | <span class='neutral'>    }</span>
  5452 |     | <span class='neutral'></span>
  5453 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {</span>
  5454 |     | <span class='neutral'>        bytes32 m0;</span>
  5455 |     | <span class='neutral'>        bytes32 m1;</span>
  5456 |     | <span class='neutral'>        bytes32 m2;</span>
  5457 |     | <span class='neutral'>        bytes32 m3;</span>
  5458 |     | <span class='neutral'>        bytes32 m4;</span>
  5459 |     | <span class='neutral'>        bytes32 m5;</span>
  5460 |     | <span class='neutral'>        bytes32 m6;</span>
  5461 |     | <span class='neutral'>        bytes32 m7;</span>
  5462 |     | <span class='neutral'>        bytes32 m8;</span>
  5463 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5464 |     | <span class='neutral'>        assembly {</span>
  5465 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5466 |     | <span class='neutral'>                let length := 0</span>
  5467 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5468 |     | <span class='neutral'>                mstore(pos, length)</span>
  5469 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5470 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5471 |     | <span class='neutral'>            }</span>
  5472 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5473 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5474 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5475 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5476 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5477 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5478 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5479 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5480 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5481 |     | <span class='neutral'>            // Selector of `log(address,string,string,uint256)`.</span>
  5482 |     | <span class='neutral'>            mstore(0x00, 0x159f8927)</span>
  5483 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5484 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5485 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  5486 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5487 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5488 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  5489 |     | <span class='neutral'>        }</span>
  5490 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5491 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5492 |     | <span class='neutral'>        assembly {</span>
  5493 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5494 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5495 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5496 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5497 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5498 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5499 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5500 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5501 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5502 |     | <span class='neutral'>        }</span>
  5503 |     | <span class='neutral'>    }</span>
  5504 |     | <span class='neutral'></span>
  5505 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  5506 |     | <span class='neutral'>        bytes32 m0;</span>
  5507 |     | <span class='neutral'>        bytes32 m1;</span>
  5508 |     | <span class='neutral'>        bytes32 m2;</span>
  5509 |     | <span class='neutral'>        bytes32 m3;</span>
  5510 |     | <span class='neutral'>        bytes32 m4;</span>
  5511 |     | <span class='neutral'>        bytes32 m5;</span>
  5512 |     | <span class='neutral'>        bytes32 m6;</span>
  5513 |     | <span class='neutral'>        bytes32 m7;</span>
  5514 |     | <span class='neutral'>        bytes32 m8;</span>
  5515 |     | <span class='neutral'>        bytes32 m9;</span>
  5516 |     | <span class='neutral'>        bytes32 m10;</span>
  5517 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5518 |     | <span class='neutral'>        assembly {</span>
  5519 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5520 |     | <span class='neutral'>                let length := 0</span>
  5521 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5522 |     | <span class='neutral'>                mstore(pos, length)</span>
  5523 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5524 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5525 |     | <span class='neutral'>            }</span>
  5526 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5527 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5528 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5529 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5530 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5531 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5532 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5533 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5534 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5535 |     | <span class='neutral'>            m9 := mload(0x120)</span>
  5536 |     | <span class='neutral'>            m10 := mload(0x140)</span>
  5537 |     | <span class='neutral'>            // Selector of `log(address,string,string,string)`.</span>
  5538 |     | <span class='neutral'>            mstore(0x00, 0x5d02c50b)</span>
  5539 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5540 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5541 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  5542 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
  5543 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5544 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  5545 |     | <span class='neutral'>            writeString(0x120, p3)</span>
  5546 |     | <span class='neutral'>        }</span>
  5547 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
  5548 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5549 |     | <span class='neutral'>        assembly {</span>
  5550 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5551 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5552 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5553 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5554 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5555 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5556 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5557 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5558 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5559 |     | <span class='neutral'>            mstore(0x120, m9)</span>
  5560 |     | <span class='neutral'>            mstore(0x140, m10)</span>
  5561 |     | <span class='neutral'>        }</span>
  5562 |     | <span class='neutral'>    }</span>
  5563 |     | <span class='neutral'></span>
  5564 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal pure {</span>
  5565 |     | <span class='neutral'>        bytes32 m0;</span>
  5566 |     | <span class='neutral'>        bytes32 m1;</span>
  5567 |     | <span class='neutral'>        bytes32 m2;</span>
  5568 |     | <span class='neutral'>        bytes32 m3;</span>
  5569 |     | <span class='neutral'>        bytes32 m4;</span>
  5570 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5571 |     | <span class='neutral'>        assembly {</span>
  5572 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5573 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5574 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5575 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5576 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5577 |     | <span class='neutral'>            // Selector of `log(bool,address,address,address)`.</span>
  5578 |     | <span class='neutral'>            mstore(0x00, 0x1d14d001)</span>
  5579 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5580 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5581 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5582 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5583 |     | <span class='neutral'>        }</span>
  5584 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5585 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5586 |     | <span class='neutral'>        assembly {</span>
  5587 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5588 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5589 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5590 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5591 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5592 |     | <span class='neutral'>        }</span>
  5593 |     | <span class='neutral'>    }</span>
  5594 |     | <span class='neutral'></span>
  5595 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal pure {</span>
  5596 |     | <span class='neutral'>        bytes32 m0;</span>
  5597 |     | <span class='neutral'>        bytes32 m1;</span>
  5598 |     | <span class='neutral'>        bytes32 m2;</span>
  5599 |     | <span class='neutral'>        bytes32 m3;</span>
  5600 |     | <span class='neutral'>        bytes32 m4;</span>
  5601 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5602 |     | <span class='neutral'>        assembly {</span>
  5603 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5604 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5605 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5606 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5607 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5608 |     | <span class='neutral'>            // Selector of `log(bool,address,address,bool)`.</span>
  5609 |     | <span class='neutral'>            mstore(0x00, 0x46600be0)</span>
  5610 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5611 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5612 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5613 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5614 |     | <span class='neutral'>        }</span>
  5615 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5616 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5617 |     | <span class='neutral'>        assembly {</span>
  5618 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5619 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5620 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5621 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5622 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5623 |     | <span class='neutral'>        }</span>
  5624 |     | <span class='neutral'>    }</span>
  5625 |     | <span class='neutral'></span>
  5626 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint256 p3) internal pure {</span>
  5627 |     | <span class='neutral'>        bytes32 m0;</span>
  5628 |     | <span class='neutral'>        bytes32 m1;</span>
  5629 |     | <span class='neutral'>        bytes32 m2;</span>
  5630 |     | <span class='neutral'>        bytes32 m3;</span>
  5631 |     | <span class='neutral'>        bytes32 m4;</span>
  5632 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5633 |     | <span class='neutral'>        assembly {</span>
  5634 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5635 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5636 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5637 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5638 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5639 |     | <span class='neutral'>            // Selector of `log(bool,address,address,uint256)`.</span>
  5640 |     | <span class='neutral'>            mstore(0x00, 0x0c66d1be)</span>
  5641 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5642 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5643 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5644 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5645 |     | <span class='neutral'>        }</span>
  5646 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5647 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5648 |     | <span class='neutral'>        assembly {</span>
  5649 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5650 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5651 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5652 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5653 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5654 |     | <span class='neutral'>        }</span>
  5655 |     | <span class='neutral'>    }</span>
  5656 |     | <span class='neutral'></span>
  5657 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bytes32 p3) internal pure {</span>
  5658 |     | <span class='neutral'>        bytes32 m0;</span>
  5659 |     | <span class='neutral'>        bytes32 m1;</span>
  5660 |     | <span class='neutral'>        bytes32 m2;</span>
  5661 |     | <span class='neutral'>        bytes32 m3;</span>
  5662 |     | <span class='neutral'>        bytes32 m4;</span>
  5663 |     | <span class='neutral'>        bytes32 m5;</span>
  5664 |     | <span class='neutral'>        bytes32 m6;</span>
  5665 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5666 |     | <span class='neutral'>        assembly {</span>
  5667 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5668 |     | <span class='neutral'>                let length := 0</span>
  5669 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5670 |     | <span class='neutral'>                mstore(pos, length)</span>
  5671 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5672 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5673 |     | <span class='neutral'>            }</span>
  5674 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5675 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5676 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5677 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5678 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5679 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5680 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5681 |     | <span class='neutral'>            // Selector of `log(bool,address,address,string)`.</span>
  5682 |     | <span class='neutral'>            mstore(0x00, 0xd812a167)</span>
  5683 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5684 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5685 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5686 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  5687 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  5688 |     | <span class='neutral'>        }</span>
  5689 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5690 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5691 |     | <span class='neutral'>        assembly {</span>
  5692 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5693 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5694 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5695 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5696 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5697 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5698 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5699 |     | <span class='neutral'>        }</span>
  5700 |     | <span class='neutral'>    }</span>
  5701 |     | <span class='neutral'></span>
  5702 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal pure {</span>
  5703 |     | <span class='neutral'>        bytes32 m0;</span>
  5704 |     | <span class='neutral'>        bytes32 m1;</span>
  5705 |     | <span class='neutral'>        bytes32 m2;</span>
  5706 |     | <span class='neutral'>        bytes32 m3;</span>
  5707 |     | <span class='neutral'>        bytes32 m4;</span>
  5708 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5709 |     | <span class='neutral'>        assembly {</span>
  5710 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5711 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5712 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5713 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5714 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5715 |     | <span class='neutral'>            // Selector of `log(bool,address,bool,address)`.</span>
  5716 |     | <span class='neutral'>            mstore(0x00, 0x1c41a336)</span>
  5717 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5718 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5719 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5720 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5721 |     | <span class='neutral'>        }</span>
  5722 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5723 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5724 |     | <span class='neutral'>        assembly {</span>
  5725 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5726 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5727 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5728 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5729 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5730 |     | <span class='neutral'>        }</span>
  5731 |     | <span class='neutral'>    }</span>
  5732 |     | <span class='neutral'></span>
  5733 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal pure {</span>
  5734 |     | <span class='neutral'>        bytes32 m0;</span>
  5735 |     | <span class='neutral'>        bytes32 m1;</span>
  5736 |     | <span class='neutral'>        bytes32 m2;</span>
  5737 |     | <span class='neutral'>        bytes32 m3;</span>
  5738 |     | <span class='neutral'>        bytes32 m4;</span>
  5739 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5740 |     | <span class='neutral'>        assembly {</span>
  5741 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5742 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5743 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5744 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5745 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5746 |     | <span class='neutral'>            // Selector of `log(bool,address,bool,bool)`.</span>
  5747 |     | <span class='neutral'>            mstore(0x00, 0x6a9c478b)</span>
  5748 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5749 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5750 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5751 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5752 |     | <span class='neutral'>        }</span>
  5753 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5754 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5755 |     | <span class='neutral'>        assembly {</span>
  5756 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5757 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5758 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5759 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5760 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5761 |     | <span class='neutral'>        }</span>
  5762 |     | <span class='neutral'>    }</span>
  5763 |     | <span class='neutral'></span>
  5764 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {</span>
  5765 |     | <span class='neutral'>        bytes32 m0;</span>
  5766 |     | <span class='neutral'>        bytes32 m1;</span>
  5767 |     | <span class='neutral'>        bytes32 m2;</span>
  5768 |     | <span class='neutral'>        bytes32 m3;</span>
  5769 |     | <span class='neutral'>        bytes32 m4;</span>
  5770 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5771 |     | <span class='neutral'>        assembly {</span>
  5772 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5773 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5774 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5775 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5776 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5777 |     | <span class='neutral'>            // Selector of `log(bool,address,bool,uint256)`.</span>
  5778 |     | <span class='neutral'>            mstore(0x00, 0x07831502)</span>
  5779 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5780 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5781 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5782 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5783 |     | <span class='neutral'>        }</span>
  5784 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5785 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5786 |     | <span class='neutral'>        assembly {</span>
  5787 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5788 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5789 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5790 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5791 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5792 |     | <span class='neutral'>        }</span>
  5793 |     | <span class='neutral'>    }</span>
  5794 |     | <span class='neutral'></span>
  5795 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {</span>
  5796 |     | <span class='neutral'>        bytes32 m0;</span>
  5797 |     | <span class='neutral'>        bytes32 m1;</span>
  5798 |     | <span class='neutral'>        bytes32 m2;</span>
  5799 |     | <span class='neutral'>        bytes32 m3;</span>
  5800 |     | <span class='neutral'>        bytes32 m4;</span>
  5801 |     | <span class='neutral'>        bytes32 m5;</span>
  5802 |     | <span class='neutral'>        bytes32 m6;</span>
  5803 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5804 |     | <span class='neutral'>        assembly {</span>
  5805 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5806 |     | <span class='neutral'>                let length := 0</span>
  5807 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5808 |     | <span class='neutral'>                mstore(pos, length)</span>
  5809 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5810 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5811 |     | <span class='neutral'>            }</span>
  5812 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5813 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5814 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5815 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5816 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5817 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5818 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5819 |     | <span class='neutral'>            // Selector of `log(bool,address,bool,string)`.</span>
  5820 |     | <span class='neutral'>            mstore(0x00, 0x4a66cb34)</span>
  5821 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5822 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5823 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5824 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  5825 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  5826 |     | <span class='neutral'>        }</span>
  5827 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5828 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5829 |     | <span class='neutral'>        assembly {</span>
  5830 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5831 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5832 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5833 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5834 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5835 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5836 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5837 |     | <span class='neutral'>        }</span>
  5838 |     | <span class='neutral'>    }</span>
  5839 |     | <span class='neutral'></span>
  5840 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, address p3) internal pure {</span>
  5841 |     | <span class='neutral'>        bytes32 m0;</span>
  5842 |     | <span class='neutral'>        bytes32 m1;</span>
  5843 |     | <span class='neutral'>        bytes32 m2;</span>
  5844 |     | <span class='neutral'>        bytes32 m3;</span>
  5845 |     | <span class='neutral'>        bytes32 m4;</span>
  5846 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5847 |     | <span class='neutral'>        assembly {</span>
  5848 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5849 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5850 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5851 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5852 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5853 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256,address)`.</span>
  5854 |     | <span class='neutral'>            mstore(0x00, 0x136b05dd)</span>
  5855 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5856 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5857 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5858 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5859 |     | <span class='neutral'>        }</span>
  5860 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5861 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5862 |     | <span class='neutral'>        assembly {</span>
  5863 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5864 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5865 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5866 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5867 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5868 |     | <span class='neutral'>        }</span>
  5869 |     | <span class='neutral'>    }</span>
  5870 |     | <span class='neutral'></span>
  5871 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {</span>
  5872 |     | <span class='neutral'>        bytes32 m0;</span>
  5873 |     | <span class='neutral'>        bytes32 m1;</span>
  5874 |     | <span class='neutral'>        bytes32 m2;</span>
  5875 |     | <span class='neutral'>        bytes32 m3;</span>
  5876 |     | <span class='neutral'>        bytes32 m4;</span>
  5877 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5878 |     | <span class='neutral'>        assembly {</span>
  5879 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5880 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5881 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5882 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5883 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5884 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256,bool)`.</span>
  5885 |     | <span class='neutral'>            mstore(0x00, 0xd6019f1c)</span>
  5886 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5887 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5888 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5889 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5890 |     | <span class='neutral'>        }</span>
  5891 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5892 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5893 |     | <span class='neutral'>        assembly {</span>
  5894 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5895 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5896 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5897 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5898 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5899 |     | <span class='neutral'>        }</span>
  5900 |     | <span class='neutral'>    }</span>
  5901 |     | <span class='neutral'></span>
  5902 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  5903 |     | <span class='neutral'>        bytes32 m0;</span>
  5904 |     | <span class='neutral'>        bytes32 m1;</span>
  5905 |     | <span class='neutral'>        bytes32 m2;</span>
  5906 |     | <span class='neutral'>        bytes32 m3;</span>
  5907 |     | <span class='neutral'>        bytes32 m4;</span>
  5908 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5909 |     | <span class='neutral'>        assembly {</span>
  5910 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5911 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5912 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5913 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5914 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5915 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256,uint256)`.</span>
  5916 |     | <span class='neutral'>            mstore(0x00, 0x7bf181a1)</span>
  5917 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5918 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5919 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5920 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5921 |     | <span class='neutral'>        }</span>
  5922 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5923 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5924 |     | <span class='neutral'>        assembly {</span>
  5925 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5926 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5927 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5928 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5929 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5930 |     | <span class='neutral'>        }</span>
  5931 |     | <span class='neutral'>    }</span>
  5932 |     | <span class='neutral'></span>
  5933 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {</span>
  5934 |     | <span class='neutral'>        bytes32 m0;</span>
  5935 |     | <span class='neutral'>        bytes32 m1;</span>
  5936 |     | <span class='neutral'>        bytes32 m2;</span>
  5937 |     | <span class='neutral'>        bytes32 m3;</span>
  5938 |     | <span class='neutral'>        bytes32 m4;</span>
  5939 |     | <span class='neutral'>        bytes32 m5;</span>
  5940 |     | <span class='neutral'>        bytes32 m6;</span>
  5941 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5942 |     | <span class='neutral'>        assembly {</span>
  5943 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5944 |     | <span class='neutral'>                let length := 0</span>
  5945 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5946 |     | <span class='neutral'>                mstore(pos, length)</span>
  5947 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5948 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5949 |     | <span class='neutral'>            }</span>
  5950 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5951 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5952 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5953 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5954 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5955 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5956 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5957 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256,string)`.</span>
  5958 |     | <span class='neutral'>            mstore(0x00, 0x51f09ff8)</span>
  5959 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5960 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5961 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5962 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  5963 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  5964 |     | <span class='neutral'>        }</span>
  5965 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5966 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5967 |     | <span class='neutral'>        assembly {</span>
  5968 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5969 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5970 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5971 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5972 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5973 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5974 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5975 |     | <span class='neutral'>        }</span>
  5976 |     | <span class='neutral'>    }</span>
  5977 |     | <span class='neutral'></span>
  5978 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2, address p3) internal pure {</span>
  5979 |     | <span class='neutral'>        bytes32 m0;</span>
  5980 |     | <span class='neutral'>        bytes32 m1;</span>
  5981 |     | <span class='neutral'>        bytes32 m2;</span>
  5982 |     | <span class='neutral'>        bytes32 m3;</span>
  5983 |     | <span class='neutral'>        bytes32 m4;</span>
  5984 |     | <span class='neutral'>        bytes32 m5;</span>
  5985 |     | <span class='neutral'>        bytes32 m6;</span>
  5986 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  5987 |     | <span class='neutral'>        assembly {</span>
  5988 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5989 |     | <span class='neutral'>                let length := 0</span>
  5990 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5991 |     | <span class='neutral'>                mstore(pos, length)</span>
  5992 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5993 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5994 |     | <span class='neutral'>            }</span>
  5995 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5996 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5997 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5998 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5999 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6000 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6001 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6002 |     | <span class='neutral'>            // Selector of `log(bool,address,string,address)`.</span>
  6003 |     | <span class='neutral'>            mstore(0x00, 0x6f7c603e)</span>
  6004 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6005 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6006 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6007 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6008 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6009 |     | <span class='neutral'>        }</span>
  6010 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6011 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6012 |     | <span class='neutral'>        assembly {</span>
  6013 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6014 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6015 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6016 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6017 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6018 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6019 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6020 |     | <span class='neutral'>        }</span>
  6021 |     | <span class='neutral'>    }</span>
  6022 |     | <span class='neutral'></span>
  6023 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {</span>
  6024 |     | <span class='neutral'>        bytes32 m0;</span>
  6025 |     | <span class='neutral'>        bytes32 m1;</span>
  6026 |     | <span class='neutral'>        bytes32 m2;</span>
  6027 |     | <span class='neutral'>        bytes32 m3;</span>
  6028 |     | <span class='neutral'>        bytes32 m4;</span>
  6029 |     | <span class='neutral'>        bytes32 m5;</span>
  6030 |     | <span class='neutral'>        bytes32 m6;</span>
  6031 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6032 |     | <span class='neutral'>        assembly {</span>
  6033 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6034 |     | <span class='neutral'>                let length := 0</span>
  6035 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6036 |     | <span class='neutral'>                mstore(pos, length)</span>
  6037 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6038 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6039 |     | <span class='neutral'>            }</span>
  6040 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6041 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6042 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6043 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6044 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6045 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6046 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6047 |     | <span class='neutral'>            // Selector of `log(bool,address,string,bool)`.</span>
  6048 |     | <span class='neutral'>            mstore(0x00, 0xe2bfd60b)</span>
  6049 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6050 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6051 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6052 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6053 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6054 |     | <span class='neutral'>        }</span>
  6055 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6056 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6057 |     | <span class='neutral'>        assembly {</span>
  6058 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6059 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6060 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6061 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6062 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6063 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6064 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6065 |     | <span class='neutral'>        }</span>
  6066 |     | <span class='neutral'>    }</span>
  6067 |     | <span class='neutral'></span>
  6068 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {</span>
  6069 |     | <span class='neutral'>        bytes32 m0;</span>
  6070 |     | <span class='neutral'>        bytes32 m1;</span>
  6071 |     | <span class='neutral'>        bytes32 m2;</span>
  6072 |     | <span class='neutral'>        bytes32 m3;</span>
  6073 |     | <span class='neutral'>        bytes32 m4;</span>
  6074 |     | <span class='neutral'>        bytes32 m5;</span>
  6075 |     | <span class='neutral'>        bytes32 m6;</span>
  6076 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6077 |     | <span class='neutral'>        assembly {</span>
  6078 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6079 |     | <span class='neutral'>                let length := 0</span>
  6080 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6081 |     | <span class='neutral'>                mstore(pos, length)</span>
  6082 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6083 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6084 |     | <span class='neutral'>            }</span>
  6085 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6086 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6087 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6088 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6089 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6090 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6091 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6092 |     | <span class='neutral'>            // Selector of `log(bool,address,string,uint256)`.</span>
  6093 |     | <span class='neutral'>            mstore(0x00, 0xc21f64c7)</span>
  6094 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6095 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6096 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6097 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6098 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6099 |     | <span class='neutral'>        }</span>
  6100 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6101 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6102 |     | <span class='neutral'>        assembly {</span>
  6103 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6104 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6105 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6106 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6107 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6108 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6109 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6110 |     | <span class='neutral'>        }</span>
  6111 |     | <span class='neutral'>    }</span>
  6112 |     | <span class='neutral'></span>
  6113 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {</span>
  6114 |     | <span class='neutral'>        bytes32 m0;</span>
  6115 |     | <span class='neutral'>        bytes32 m1;</span>
  6116 |     | <span class='neutral'>        bytes32 m2;</span>
  6117 |     | <span class='neutral'>        bytes32 m3;</span>
  6118 |     | <span class='neutral'>        bytes32 m4;</span>
  6119 |     | <span class='neutral'>        bytes32 m5;</span>
  6120 |     | <span class='neutral'>        bytes32 m6;</span>
  6121 |     | <span class='neutral'>        bytes32 m7;</span>
  6122 |     | <span class='neutral'>        bytes32 m8;</span>
  6123 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6124 |     | <span class='neutral'>        assembly {</span>
  6125 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6126 |     | <span class='neutral'>                let length := 0</span>
  6127 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6128 |     | <span class='neutral'>                mstore(pos, length)</span>
  6129 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6130 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6131 |     | <span class='neutral'>            }</span>
  6132 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6133 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6134 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6135 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6136 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6137 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6138 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6139 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  6140 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  6141 |     | <span class='neutral'>            // Selector of `log(bool,address,string,string)`.</span>
  6142 |     | <span class='neutral'>            mstore(0x00, 0xa73c1db6)</span>
  6143 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6144 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6145 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6146 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  6147 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6148 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  6149 |     | <span class='neutral'>        }</span>
  6150 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  6151 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6152 |     | <span class='neutral'>        assembly {</span>
  6153 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6154 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6155 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6156 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6157 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6158 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6159 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6160 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  6161 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  6162 |     | <span class='neutral'>        }</span>
  6163 |     | <span class='neutral'>    }</span>
  6164 |     | <span class='neutral'></span>
  6165 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal pure {</span>
  6166 |     | <span class='neutral'>        bytes32 m0;</span>
  6167 |     | <span class='neutral'>        bytes32 m1;</span>
  6168 |     | <span class='neutral'>        bytes32 m2;</span>
  6169 |     | <span class='neutral'>        bytes32 m3;</span>
  6170 |     | <span class='neutral'>        bytes32 m4;</span>
  6171 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6172 |     | <span class='neutral'>        assembly {</span>
  6173 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6174 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6175 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6176 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6177 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6178 |     | <span class='neutral'>            // Selector of `log(bool,bool,address,address)`.</span>
  6179 |     | <span class='neutral'>            mstore(0x00, 0xf4880ea4)</span>
  6180 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6181 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6182 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6183 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6184 |     | <span class='neutral'>        }</span>
  6185 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6186 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6187 |     | <span class='neutral'>        assembly {</span>
  6188 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6189 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6190 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6191 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6192 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6193 |     | <span class='neutral'>        }</span>
  6194 |     | <span class='neutral'>    }</span>
  6195 |     | <span class='neutral'></span>
  6196 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal pure {</span>
  6197 |     | <span class='neutral'>        bytes32 m0;</span>
  6198 |     | <span class='neutral'>        bytes32 m1;</span>
  6199 |     | <span class='neutral'>        bytes32 m2;</span>
  6200 |     | <span class='neutral'>        bytes32 m3;</span>
  6201 |     | <span class='neutral'>        bytes32 m4;</span>
  6202 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6203 |     | <span class='neutral'>        assembly {</span>
  6204 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6205 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6206 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6207 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6208 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6209 |     | <span class='neutral'>            // Selector of `log(bool,bool,address,bool)`.</span>
  6210 |     | <span class='neutral'>            mstore(0x00, 0xc0a302d8)</span>
  6211 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6212 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6213 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6214 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6215 |     | <span class='neutral'>        }</span>
  6216 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6217 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6218 |     | <span class='neutral'>        assembly {</span>
  6219 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6220 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6221 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6222 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6223 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6224 |     | <span class='neutral'>        }</span>
  6225 |     | <span class='neutral'>    }</span>
  6226 |     | <span class='neutral'></span>
  6227 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {</span>
  6228 |     | <span class='neutral'>        bytes32 m0;</span>
  6229 |     | <span class='neutral'>        bytes32 m1;</span>
  6230 |     | <span class='neutral'>        bytes32 m2;</span>
  6231 |     | <span class='neutral'>        bytes32 m3;</span>
  6232 |     | <span class='neutral'>        bytes32 m4;</span>
  6233 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6234 |     | <span class='neutral'>        assembly {</span>
  6235 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6236 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6237 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6238 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6239 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6240 |     | <span class='neutral'>            // Selector of `log(bool,bool,address,uint256)`.</span>
  6241 |     | <span class='neutral'>            mstore(0x00, 0x4c123d57)</span>
  6242 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6243 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6244 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6245 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6246 |     | <span class='neutral'>        }</span>
  6247 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6248 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6249 |     | <span class='neutral'>        assembly {</span>
  6250 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6251 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6252 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6253 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6254 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6255 |     | <span class='neutral'>        }</span>
  6256 |     | <span class='neutral'>    }</span>
  6257 |     | <span class='neutral'></span>
  6258 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {</span>
  6259 |     | <span class='neutral'>        bytes32 m0;</span>
  6260 |     | <span class='neutral'>        bytes32 m1;</span>
  6261 |     | <span class='neutral'>        bytes32 m2;</span>
  6262 |     | <span class='neutral'>        bytes32 m3;</span>
  6263 |     | <span class='neutral'>        bytes32 m4;</span>
  6264 |     | <span class='neutral'>        bytes32 m5;</span>
  6265 |     | <span class='neutral'>        bytes32 m6;</span>
  6266 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6267 |     | <span class='neutral'>        assembly {</span>
  6268 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6269 |     | <span class='neutral'>                let length := 0</span>
  6270 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6271 |     | <span class='neutral'>                mstore(pos, length)</span>
  6272 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6273 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6274 |     | <span class='neutral'>            }</span>
  6275 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6276 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6277 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6278 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6279 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6280 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6281 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6282 |     | <span class='neutral'>            // Selector of `log(bool,bool,address,string)`.</span>
  6283 |     | <span class='neutral'>            mstore(0x00, 0xa0a47963)</span>
  6284 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6285 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6286 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6287 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6288 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6289 |     | <span class='neutral'>        }</span>
  6290 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6291 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6292 |     | <span class='neutral'>        assembly {</span>
  6293 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6294 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6295 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6296 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6297 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6298 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6299 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6300 |     | <span class='neutral'>        }</span>
  6301 |     | <span class='neutral'>    }</span>
  6302 |     | <span class='neutral'></span>
  6303 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal pure {</span>
  6304 |     | <span class='neutral'>        bytes32 m0;</span>
  6305 |     | <span class='neutral'>        bytes32 m1;</span>
  6306 |     | <span class='neutral'>        bytes32 m2;</span>
  6307 |     | <span class='neutral'>        bytes32 m3;</span>
  6308 |     | <span class='neutral'>        bytes32 m4;</span>
  6309 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6310 |     | <span class='neutral'>        assembly {</span>
  6311 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6312 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6313 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6314 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6315 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6316 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool,address)`.</span>
  6317 |     | <span class='neutral'>            mstore(0x00, 0x8c329b1a)</span>
  6318 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6319 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6320 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6321 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6322 |     | <span class='neutral'>        }</span>
  6323 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6324 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6325 |     | <span class='neutral'>        assembly {</span>
  6326 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6327 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6328 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6329 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6330 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6331 |     | <span class='neutral'>        }</span>
  6332 |     | <span class='neutral'>    }</span>
  6333 |     | <span class='neutral'></span>
  6334 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal pure {</span>
  6335 |     | <span class='neutral'>        bytes32 m0;</span>
  6336 |     | <span class='neutral'>        bytes32 m1;</span>
  6337 |     | <span class='neutral'>        bytes32 m2;</span>
  6338 |     | <span class='neutral'>        bytes32 m3;</span>
  6339 |     | <span class='neutral'>        bytes32 m4;</span>
  6340 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6341 |     | <span class='neutral'>        assembly {</span>
  6342 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6343 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6344 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6345 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6346 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6347 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool,bool)`.</span>
  6348 |     | <span class='neutral'>            mstore(0x00, 0x3b2a5ce0)</span>
  6349 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6350 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6351 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6352 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6353 |     | <span class='neutral'>        }</span>
  6354 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6355 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6356 |     | <span class='neutral'>        assembly {</span>
  6357 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6358 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6359 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6360 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6361 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6362 |     | <span class='neutral'>        }</span>
  6363 |     | <span class='neutral'>    }</span>
  6364 |     | <span class='neutral'></span>
  6365 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  6366 |     | <span class='neutral'>        bytes32 m0;</span>
  6367 |     | <span class='neutral'>        bytes32 m1;</span>
  6368 |     | <span class='neutral'>        bytes32 m2;</span>
  6369 |     | <span class='neutral'>        bytes32 m3;</span>
  6370 |     | <span class='neutral'>        bytes32 m4;</span>
  6371 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6372 |     | <span class='neutral'>        assembly {</span>
  6373 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6374 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6375 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6376 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6377 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6378 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool,uint256)`.</span>
  6379 |     | <span class='neutral'>            mstore(0x00, 0x6d7045c1)</span>
  6380 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6381 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6382 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6383 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6384 |     | <span class='neutral'>        }</span>
  6385 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6386 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6387 |     | <span class='neutral'>        assembly {</span>
  6388 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6389 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6390 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6391 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6392 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6393 |     | <span class='neutral'>        }</span>
  6394 |     | <span class='neutral'>    }</span>
  6395 |     | <span class='neutral'></span>
  6396 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {</span>
  6397 |     | <span class='neutral'>        bytes32 m0;</span>
  6398 |     | <span class='neutral'>        bytes32 m1;</span>
  6399 |     | <span class='neutral'>        bytes32 m2;</span>
  6400 |     | <span class='neutral'>        bytes32 m3;</span>
  6401 |     | <span class='neutral'>        bytes32 m4;</span>
  6402 |     | <span class='neutral'>        bytes32 m5;</span>
  6403 |     | <span class='neutral'>        bytes32 m6;</span>
  6404 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6405 |     | <span class='neutral'>        assembly {</span>
  6406 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6407 |     | <span class='neutral'>                let length := 0</span>
  6408 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6409 |     | <span class='neutral'>                mstore(pos, length)</span>
  6410 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6411 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6412 |     | <span class='neutral'>            }</span>
  6413 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6414 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6415 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6416 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6417 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6418 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6419 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6420 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool,string)`.</span>
  6421 |     | <span class='neutral'>            mstore(0x00, 0x2ae408d4)</span>
  6422 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6423 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6424 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6425 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6426 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6427 |     | <span class='neutral'>        }</span>
  6428 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6429 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6430 |     | <span class='neutral'>        assembly {</span>
  6431 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6432 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6433 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6434 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6435 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6436 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6437 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6438 |     | <span class='neutral'>        }</span>
  6439 |     | <span class='neutral'>    }</span>
  6440 |     | <span class='neutral'></span>
  6441 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {</span>
  6442 |     | <span class='neutral'>        bytes32 m0;</span>
  6443 |     | <span class='neutral'>        bytes32 m1;</span>
  6444 |     | <span class='neutral'>        bytes32 m2;</span>
  6445 |     | <span class='neutral'>        bytes32 m3;</span>
  6446 |     | <span class='neutral'>        bytes32 m4;</span>
  6447 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6448 |     | <span class='neutral'>        assembly {</span>
  6449 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6450 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6451 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6452 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6453 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6454 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256,address)`.</span>
  6455 |     | <span class='neutral'>            mstore(0x00, 0x54a7a9a0)</span>
  6456 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6457 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6458 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6459 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6460 |     | <span class='neutral'>        }</span>
  6461 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6462 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6463 |     | <span class='neutral'>        assembly {</span>
  6464 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6465 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6466 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6467 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6468 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6469 |     | <span class='neutral'>        }</span>
  6470 |     | <span class='neutral'>    }</span>
  6471 |     | <span class='neutral'></span>
  6472 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  6473 |     | <span class='neutral'>        bytes32 m0;</span>
  6474 |     | <span class='neutral'>        bytes32 m1;</span>
  6475 |     | <span class='neutral'>        bytes32 m2;</span>
  6476 |     | <span class='neutral'>        bytes32 m3;</span>
  6477 |     | <span class='neutral'>        bytes32 m4;</span>
  6478 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6479 |     | <span class='neutral'>        assembly {</span>
  6480 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6481 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6482 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6483 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6484 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6485 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256,bool)`.</span>
  6486 |     | <span class='neutral'>            mstore(0x00, 0x619e4d0e)</span>
  6487 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6488 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6489 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6490 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6491 |     | <span class='neutral'>        }</span>
  6492 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6493 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6494 |     | <span class='neutral'>        assembly {</span>
  6495 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6496 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6497 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6498 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6499 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6500 |     | <span class='neutral'>        }</span>
  6501 |     | <span class='neutral'>    }</span>
  6502 |     | <span class='neutral'></span>
  6503 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  6504 |     | <span class='neutral'>        bytes32 m0;</span>
  6505 |     | <span class='neutral'>        bytes32 m1;</span>
  6506 |     | <span class='neutral'>        bytes32 m2;</span>
  6507 |     | <span class='neutral'>        bytes32 m3;</span>
  6508 |     | <span class='neutral'>        bytes32 m4;</span>
  6509 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6510 |     | <span class='neutral'>        assembly {</span>
  6511 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6512 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6513 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6514 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6515 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6516 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256,uint256)`.</span>
  6517 |     | <span class='neutral'>            mstore(0x00, 0x0bb00eab)</span>
  6518 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6519 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6520 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6521 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6522 |     | <span class='neutral'>        }</span>
  6523 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6524 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6525 |     | <span class='neutral'>        assembly {</span>
  6526 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6527 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6528 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6529 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6530 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6531 |     | <span class='neutral'>        }</span>
  6532 |     | <span class='neutral'>    }</span>
  6533 |     | <span class='neutral'></span>
  6534 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {</span>
  6535 |     | <span class='neutral'>        bytes32 m0;</span>
  6536 |     | <span class='neutral'>        bytes32 m1;</span>
  6537 |     | <span class='neutral'>        bytes32 m2;</span>
  6538 |     | <span class='neutral'>        bytes32 m3;</span>
  6539 |     | <span class='neutral'>        bytes32 m4;</span>
  6540 |     | <span class='neutral'>        bytes32 m5;</span>
  6541 |     | <span class='neutral'>        bytes32 m6;</span>
  6542 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6543 |     | <span class='neutral'>        assembly {</span>
  6544 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6545 |     | <span class='neutral'>                let length := 0</span>
  6546 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6547 |     | <span class='neutral'>                mstore(pos, length)</span>
  6548 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6549 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6550 |     | <span class='neutral'>            }</span>
  6551 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6552 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6553 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6554 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6555 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6556 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6557 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6558 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256,string)`.</span>
  6559 |     | <span class='neutral'>            mstore(0x00, 0x7dd4d0e0)</span>
  6560 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6561 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6562 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6563 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6564 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6565 |     | <span class='neutral'>        }</span>
  6566 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6567 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6568 |     | <span class='neutral'>        assembly {</span>
  6569 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6570 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6571 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6572 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6573 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6574 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6575 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6576 |     | <span class='neutral'>        }</span>
  6577 |     | <span class='neutral'>    }</span>
  6578 |     | <span class='neutral'></span>
  6579 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {</span>
  6580 |     | <span class='neutral'>        bytes32 m0;</span>
  6581 |     | <span class='neutral'>        bytes32 m1;</span>
  6582 |     | <span class='neutral'>        bytes32 m2;</span>
  6583 |     | <span class='neutral'>        bytes32 m3;</span>
  6584 |     | <span class='neutral'>        bytes32 m4;</span>
  6585 |     | <span class='neutral'>        bytes32 m5;</span>
  6586 |     | <span class='neutral'>        bytes32 m6;</span>
  6587 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6588 |     | <span class='neutral'>        assembly {</span>
  6589 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6590 |     | <span class='neutral'>                let length := 0</span>
  6591 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6592 |     | <span class='neutral'>                mstore(pos, length)</span>
  6593 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6594 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6595 |     | <span class='neutral'>            }</span>
  6596 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6597 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6598 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6599 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6600 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6601 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6602 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6603 |     | <span class='neutral'>            // Selector of `log(bool,bool,string,address)`.</span>
  6604 |     | <span class='neutral'>            mstore(0x00, 0xf9ad2b89)</span>
  6605 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6606 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6607 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6608 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6609 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6610 |     | <span class='neutral'>        }</span>
  6611 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6612 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6613 |     | <span class='neutral'>        assembly {</span>
  6614 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6615 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6616 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6617 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6618 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6619 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6620 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6621 |     | <span class='neutral'>        }</span>
  6622 |     | <span class='neutral'>    }</span>
  6623 |     | <span class='neutral'></span>
  6624 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {</span>
  6625 |     | <span class='neutral'>        bytes32 m0;</span>
  6626 |     | <span class='neutral'>        bytes32 m1;</span>
  6627 |     | <span class='neutral'>        bytes32 m2;</span>
  6628 |     | <span class='neutral'>        bytes32 m3;</span>
  6629 |     | <span class='neutral'>        bytes32 m4;</span>
  6630 |     | <span class='neutral'>        bytes32 m5;</span>
  6631 |     | <span class='neutral'>        bytes32 m6;</span>
  6632 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6633 |     | <span class='neutral'>        assembly {</span>
  6634 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6635 |     | <span class='neutral'>                let length := 0</span>
  6636 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6637 |     | <span class='neutral'>                mstore(pos, length)</span>
  6638 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6639 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6640 |     | <span class='neutral'>            }</span>
  6641 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6642 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6643 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6644 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6645 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6646 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6647 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6648 |     | <span class='neutral'>            // Selector of `log(bool,bool,string,bool)`.</span>
  6649 |     | <span class='neutral'>            mstore(0x00, 0xb857163a)</span>
  6650 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6651 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6652 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6653 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6654 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6655 |     | <span class='neutral'>        }</span>
  6656 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6657 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6658 |     | <span class='neutral'>        assembly {</span>
  6659 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6660 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6661 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6662 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6663 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6664 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6665 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6666 |     | <span class='neutral'>        }</span>
  6667 |     | <span class='neutral'>    }</span>
  6668 |     | <span class='neutral'></span>
  6669 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {</span>
  6670 |     | <span class='neutral'>        bytes32 m0;</span>
  6671 |     | <span class='neutral'>        bytes32 m1;</span>
  6672 |     | <span class='neutral'>        bytes32 m2;</span>
  6673 |     | <span class='neutral'>        bytes32 m3;</span>
  6674 |     | <span class='neutral'>        bytes32 m4;</span>
  6675 |     | <span class='neutral'>        bytes32 m5;</span>
  6676 |     | <span class='neutral'>        bytes32 m6;</span>
  6677 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6678 |     | <span class='neutral'>        assembly {</span>
  6679 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6680 |     | <span class='neutral'>                let length := 0</span>
  6681 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6682 |     | <span class='neutral'>                mstore(pos, length)</span>
  6683 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6684 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6685 |     | <span class='neutral'>            }</span>
  6686 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6687 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6688 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6689 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6690 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6691 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6692 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6693 |     | <span class='neutral'>            // Selector of `log(bool,bool,string,uint256)`.</span>
  6694 |     | <span class='neutral'>            mstore(0x00, 0xe3a9ca2f)</span>
  6695 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6696 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6697 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6698 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6699 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6700 |     | <span class='neutral'>        }</span>
  6701 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6702 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6703 |     | <span class='neutral'>        assembly {</span>
  6704 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6705 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6706 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6707 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6708 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6709 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6710 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6711 |     | <span class='neutral'>        }</span>
  6712 |     | <span class='neutral'>    }</span>
  6713 |     | <span class='neutral'></span>
  6714 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {</span>
  6715 |     | <span class='neutral'>        bytes32 m0;</span>
  6716 |     | <span class='neutral'>        bytes32 m1;</span>
  6717 |     | <span class='neutral'>        bytes32 m2;</span>
  6718 |     | <span class='neutral'>        bytes32 m3;</span>
  6719 |     | <span class='neutral'>        bytes32 m4;</span>
  6720 |     | <span class='neutral'>        bytes32 m5;</span>
  6721 |     | <span class='neutral'>        bytes32 m6;</span>
  6722 |     | <span class='neutral'>        bytes32 m7;</span>
  6723 |     | <span class='neutral'>        bytes32 m8;</span>
  6724 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6725 |     | <span class='neutral'>        assembly {</span>
  6726 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6727 |     | <span class='neutral'>                let length := 0</span>
  6728 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6729 |     | <span class='neutral'>                mstore(pos, length)</span>
  6730 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6731 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6732 |     | <span class='neutral'>            }</span>
  6733 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6734 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6735 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6736 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6737 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6738 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6739 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6740 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  6741 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  6742 |     | <span class='neutral'>            // Selector of `log(bool,bool,string,string)`.</span>
  6743 |     | <span class='neutral'>            mstore(0x00, 0x6d1e8751)</span>
  6744 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6745 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6746 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6747 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  6748 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6749 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  6750 |     | <span class='neutral'>        }</span>
  6751 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  6752 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6753 |     | <span class='neutral'>        assembly {</span>
  6754 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6755 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6756 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6757 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6758 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6759 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6760 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6761 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  6762 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  6763 |     | <span class='neutral'>        }</span>
  6764 |     | <span class='neutral'>    }</span>
  6765 |     | <span class='neutral'></span>
  6766 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, address p3) internal pure {</span>
  6767 |     | <span class='neutral'>        bytes32 m0;</span>
  6768 |     | <span class='neutral'>        bytes32 m1;</span>
  6769 |     | <span class='neutral'>        bytes32 m2;</span>
  6770 |     | <span class='neutral'>        bytes32 m3;</span>
  6771 |     | <span class='neutral'>        bytes32 m4;</span>
  6772 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6773 |     | <span class='neutral'>        assembly {</span>
  6774 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6775 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6776 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6777 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6778 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6779 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address,address)`.</span>
  6780 |     | <span class='neutral'>            mstore(0x00, 0x26f560a8)</span>
  6781 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6782 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6783 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6784 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6785 |     | <span class='neutral'>        }</span>
  6786 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6787 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6788 |     | <span class='neutral'>        assembly {</span>
  6789 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6790 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6791 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6792 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6793 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6794 |     | <span class='neutral'>        }</span>
  6795 |     | <span class='neutral'>    }</span>
  6796 |     | <span class='neutral'></span>
  6797 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {</span>
  6798 |     | <span class='neutral'>        bytes32 m0;</span>
  6799 |     | <span class='neutral'>        bytes32 m1;</span>
  6800 |     | <span class='neutral'>        bytes32 m2;</span>
  6801 |     | <span class='neutral'>        bytes32 m3;</span>
  6802 |     | <span class='neutral'>        bytes32 m4;</span>
  6803 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6804 |     | <span class='neutral'>        assembly {</span>
  6805 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6806 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6807 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6808 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6809 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6810 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address,bool)`.</span>
  6811 |     | <span class='neutral'>            mstore(0x00, 0xb4c314ff)</span>
  6812 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6813 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6814 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6815 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6816 |     | <span class='neutral'>        }</span>
  6817 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6818 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6819 |     | <span class='neutral'>        assembly {</span>
  6820 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6821 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6822 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6823 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6824 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6825 |     | <span class='neutral'>        }</span>
  6826 |     | <span class='neutral'>    }</span>
  6827 |     | <span class='neutral'></span>
  6828 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  6829 |     | <span class='neutral'>        bytes32 m0;</span>
  6830 |     | <span class='neutral'>        bytes32 m1;</span>
  6831 |     | <span class='neutral'>        bytes32 m2;</span>
  6832 |     | <span class='neutral'>        bytes32 m3;</span>
  6833 |     | <span class='neutral'>        bytes32 m4;</span>
  6834 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6835 |     | <span class='neutral'>        assembly {</span>
  6836 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6837 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6838 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6839 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6840 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6841 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address,uint256)`.</span>
  6842 |     | <span class='neutral'>            mstore(0x00, 0x1537dc87)</span>
  6843 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6844 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6845 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6846 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6847 |     | <span class='neutral'>        }</span>
  6848 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6849 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6850 |     | <span class='neutral'>        assembly {</span>
  6851 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6852 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6853 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6854 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6855 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6856 |     | <span class='neutral'>        }</span>
  6857 |     | <span class='neutral'>    }</span>
  6858 |     | <span class='neutral'></span>
  6859 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {</span>
  6860 |     | <span class='neutral'>        bytes32 m0;</span>
  6861 |     | <span class='neutral'>        bytes32 m1;</span>
  6862 |     | <span class='neutral'>        bytes32 m2;</span>
  6863 |     | <span class='neutral'>        bytes32 m3;</span>
  6864 |     | <span class='neutral'>        bytes32 m4;</span>
  6865 |     | <span class='neutral'>        bytes32 m5;</span>
  6866 |     | <span class='neutral'>        bytes32 m6;</span>
  6867 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6868 |     | <span class='neutral'>        assembly {</span>
  6869 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6870 |     | <span class='neutral'>                let length := 0</span>
  6871 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6872 |     | <span class='neutral'>                mstore(pos, length)</span>
  6873 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6874 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6875 |     | <span class='neutral'>            }</span>
  6876 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6877 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6878 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6879 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6880 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6881 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6882 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6883 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address,string)`.</span>
  6884 |     | <span class='neutral'>            mstore(0x00, 0x1bb3b09a)</span>
  6885 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6886 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6887 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6888 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6889 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6890 |     | <span class='neutral'>        }</span>
  6891 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6892 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6893 |     | <span class='neutral'>        assembly {</span>
  6894 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6895 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6896 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6897 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6898 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6899 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6900 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6901 |     | <span class='neutral'>        }</span>
  6902 |     | <span class='neutral'>    }</span>
  6903 |     | <span class='neutral'></span>
  6904 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {</span>
  6905 |     | <span class='neutral'>        bytes32 m0;</span>
  6906 |     | <span class='neutral'>        bytes32 m1;</span>
  6907 |     | <span class='neutral'>        bytes32 m2;</span>
  6908 |     | <span class='neutral'>        bytes32 m3;</span>
  6909 |     | <span class='neutral'>        bytes32 m4;</span>
  6910 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6911 |     | <span class='neutral'>        assembly {</span>
  6912 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6913 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6914 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6915 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6916 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6917 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool,address)`.</span>
  6918 |     | <span class='neutral'>            mstore(0x00, 0x9acd3616)</span>
  6919 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6920 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6921 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6922 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6923 |     | <span class='neutral'>        }</span>
  6924 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6925 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6926 |     | <span class='neutral'>        assembly {</span>
  6927 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6928 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6929 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6930 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6931 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6932 |     | <span class='neutral'>        }</span>
  6933 |     | <span class='neutral'>    }</span>
  6934 |     | <span class='neutral'></span>
  6935 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  6936 |     | <span class='neutral'>        bytes32 m0;</span>
  6937 |     | <span class='neutral'>        bytes32 m1;</span>
  6938 |     | <span class='neutral'>        bytes32 m2;</span>
  6939 |     | <span class='neutral'>        bytes32 m3;</span>
  6940 |     | <span class='neutral'>        bytes32 m4;</span>
  6941 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6942 |     | <span class='neutral'>        assembly {</span>
  6943 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6944 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6945 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6946 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6947 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6948 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool,bool)`.</span>
  6949 |     | <span class='neutral'>            mstore(0x00, 0xceb5f4d7)</span>
  6950 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6951 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6952 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6953 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6954 |     | <span class='neutral'>        }</span>
  6955 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6956 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6957 |     | <span class='neutral'>        assembly {</span>
  6958 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6959 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6960 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6961 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6962 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6963 |     | <span class='neutral'>        }</span>
  6964 |     | <span class='neutral'>    }</span>
  6965 |     | <span class='neutral'></span>
  6966 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  6967 |     | <span class='neutral'>        bytes32 m0;</span>
  6968 |     | <span class='neutral'>        bytes32 m1;</span>
  6969 |     | <span class='neutral'>        bytes32 m2;</span>
  6970 |     | <span class='neutral'>        bytes32 m3;</span>
  6971 |     | <span class='neutral'>        bytes32 m4;</span>
  6972 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6973 |     | <span class='neutral'>        assembly {</span>
  6974 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6975 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6976 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6977 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6978 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6979 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool,uint256)`.</span>
  6980 |     | <span class='neutral'>            mstore(0x00, 0x7f9bbca2)</span>
  6981 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6982 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6983 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6984 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6985 |     | <span class='neutral'>        }</span>
  6986 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6987 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  6988 |     | <span class='neutral'>        assembly {</span>
  6989 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6990 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6991 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6992 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6993 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6994 |     | <span class='neutral'>        }</span>
  6995 |     | <span class='neutral'>    }</span>
  6996 |     | <span class='neutral'></span>
  6997 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {</span>
  6998 |     | <span class='neutral'>        bytes32 m0;</span>
  6999 |     | <span class='neutral'>        bytes32 m1;</span>
  7000 |     | <span class='neutral'>        bytes32 m2;</span>
  7001 |     | <span class='neutral'>        bytes32 m3;</span>
  7002 |     | <span class='neutral'>        bytes32 m4;</span>
  7003 |     | <span class='neutral'>        bytes32 m5;</span>
  7004 |     | <span class='neutral'>        bytes32 m6;</span>
  7005 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7006 |     | <span class='neutral'>        assembly {</span>
  7007 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7008 |     | <span class='neutral'>                let length := 0</span>
  7009 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7010 |     | <span class='neutral'>                mstore(pos, length)</span>
  7011 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7012 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7013 |     | <span class='neutral'>            }</span>
  7014 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7015 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7016 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7017 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7018 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7019 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7020 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7021 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool,string)`.</span>
  7022 |     | <span class='neutral'>            mstore(0x00, 0x9143dbb1)</span>
  7023 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7024 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7025 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7026 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  7027 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  7028 |     | <span class='neutral'>        }</span>
  7029 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7030 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7031 |     | <span class='neutral'>        assembly {</span>
  7032 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7033 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7034 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7035 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7036 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7037 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7038 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7039 |     | <span class='neutral'>        }</span>
  7040 |     | <span class='neutral'>    }</span>
  7041 |     | <span class='neutral'></span>
  7042 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  7043 |     | <span class='neutral'>        bytes32 m0;</span>
  7044 |     | <span class='neutral'>        bytes32 m1;</span>
  7045 |     | <span class='neutral'>        bytes32 m2;</span>
  7046 |     | <span class='neutral'>        bytes32 m3;</span>
  7047 |     | <span class='neutral'>        bytes32 m4;</span>
  7048 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7049 |     | <span class='neutral'>        assembly {</span>
  7050 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7051 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7052 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7053 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7054 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7055 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256,address)`.</span>
  7056 |     | <span class='neutral'>            mstore(0x00, 0x00dd87b9)</span>
  7057 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7058 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7059 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7060 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7061 |     | <span class='neutral'>        }</span>
  7062 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7063 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7064 |     | <span class='neutral'>        assembly {</span>
  7065 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7066 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7067 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7068 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7069 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7070 |     | <span class='neutral'>        }</span>
  7071 |     | <span class='neutral'>    }</span>
  7072 |     | <span class='neutral'></span>
  7073 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  7074 |     | <span class='neutral'>        bytes32 m0;</span>
  7075 |     | <span class='neutral'>        bytes32 m1;</span>
  7076 |     | <span class='neutral'>        bytes32 m2;</span>
  7077 |     | <span class='neutral'>        bytes32 m3;</span>
  7078 |     | <span class='neutral'>        bytes32 m4;</span>
  7079 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7080 |     | <span class='neutral'>        assembly {</span>
  7081 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7082 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7083 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7084 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7085 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7086 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256,bool)`.</span>
  7087 |     | <span class='neutral'>            mstore(0x00, 0xbe984353)</span>
  7088 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7089 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7090 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7091 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7092 |     | <span class='neutral'>        }</span>
  7093 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7094 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7095 |     | <span class='neutral'>        assembly {</span>
  7096 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7097 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7098 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7099 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7100 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7101 |     | <span class='neutral'>        }</span>
  7102 |     | <span class='neutral'>    }</span>
  7103 |     | <span class='neutral'></span>
  7104 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  7105 |     | <span class='neutral'>        bytes32 m0;</span>
  7106 |     | <span class='neutral'>        bytes32 m1;</span>
  7107 |     | <span class='neutral'>        bytes32 m2;</span>
  7108 |     | <span class='neutral'>        bytes32 m3;</span>
  7109 |     | <span class='neutral'>        bytes32 m4;</span>
  7110 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7111 |     | <span class='neutral'>        assembly {</span>
  7112 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7113 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7114 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7115 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7116 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7117 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256,uint256)`.</span>
  7118 |     | <span class='neutral'>            mstore(0x00, 0x374bb4b2)</span>
  7119 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7120 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7121 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7122 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7123 |     | <span class='neutral'>        }</span>
  7124 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7125 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7126 |     | <span class='neutral'>        assembly {</span>
  7127 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7128 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7129 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7130 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7131 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7132 |     | <span class='neutral'>        }</span>
  7133 |     | <span class='neutral'>    }</span>
  7134 |     | <span class='neutral'></span>
  7135 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {</span>
  7136 |     | <span class='neutral'>        bytes32 m0;</span>
  7137 |     | <span class='neutral'>        bytes32 m1;</span>
  7138 |     | <span class='neutral'>        bytes32 m2;</span>
  7139 |     | <span class='neutral'>        bytes32 m3;</span>
  7140 |     | <span class='neutral'>        bytes32 m4;</span>
  7141 |     | <span class='neutral'>        bytes32 m5;</span>
  7142 |     | <span class='neutral'>        bytes32 m6;</span>
  7143 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7144 |     | <span class='neutral'>        assembly {</span>
  7145 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7146 |     | <span class='neutral'>                let length := 0</span>
  7147 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7148 |     | <span class='neutral'>                mstore(pos, length)</span>
  7149 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7150 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7151 |     | <span class='neutral'>            }</span>
  7152 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7153 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7154 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7155 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7156 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7157 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7158 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7159 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256,string)`.</span>
  7160 |     | <span class='neutral'>            mstore(0x00, 0x8e69fb5d)</span>
  7161 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7162 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7163 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7164 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  7165 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  7166 |     | <span class='neutral'>        }</span>
  7167 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7168 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7169 |     | <span class='neutral'>        assembly {</span>
  7170 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7171 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7172 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7173 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7174 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7175 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7176 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7177 |     | <span class='neutral'>        }</span>
  7178 |     | <span class='neutral'>    }</span>
  7179 |     | <span class='neutral'></span>
  7180 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {</span>
  7181 |     | <span class='neutral'>        bytes32 m0;</span>
  7182 |     | <span class='neutral'>        bytes32 m1;</span>
  7183 |     | <span class='neutral'>        bytes32 m2;</span>
  7184 |     | <span class='neutral'>        bytes32 m3;</span>
  7185 |     | <span class='neutral'>        bytes32 m4;</span>
  7186 |     | <span class='neutral'>        bytes32 m5;</span>
  7187 |     | <span class='neutral'>        bytes32 m6;</span>
  7188 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7189 |     | <span class='neutral'>        assembly {</span>
  7190 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7191 |     | <span class='neutral'>                let length := 0</span>
  7192 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7193 |     | <span class='neutral'>                mstore(pos, length)</span>
  7194 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7195 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7196 |     | <span class='neutral'>            }</span>
  7197 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7198 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7199 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7200 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7201 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7202 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7203 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7204 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string,address)`.</span>
  7205 |     | <span class='neutral'>            mstore(0x00, 0xfedd1fff)</span>
  7206 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7207 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7208 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  7209 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7210 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  7211 |     | <span class='neutral'>        }</span>
  7212 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7213 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7214 |     | <span class='neutral'>        assembly {</span>
  7215 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7216 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7217 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7218 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7219 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7220 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7221 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7222 |     | <span class='neutral'>        }</span>
  7223 |     | <span class='neutral'>    }</span>
  7224 |     | <span class='neutral'></span>
  7225 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {</span>
  7226 |     | <span class='neutral'>        bytes32 m0;</span>
  7227 |     | <span class='neutral'>        bytes32 m1;</span>
  7228 |     | <span class='neutral'>        bytes32 m2;</span>
  7229 |     | <span class='neutral'>        bytes32 m3;</span>
  7230 |     | <span class='neutral'>        bytes32 m4;</span>
  7231 |     | <span class='neutral'>        bytes32 m5;</span>
  7232 |     | <span class='neutral'>        bytes32 m6;</span>
  7233 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7234 |     | <span class='neutral'>        assembly {</span>
  7235 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7236 |     | <span class='neutral'>                let length := 0</span>
  7237 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7238 |     | <span class='neutral'>                mstore(pos, length)</span>
  7239 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7240 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7241 |     | <span class='neutral'>            }</span>
  7242 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7243 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7244 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7245 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7246 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7247 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7248 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7249 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string,bool)`.</span>
  7250 |     | <span class='neutral'>            mstore(0x00, 0xe5e70b2b)</span>
  7251 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7252 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7253 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  7254 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7255 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  7256 |     | <span class='neutral'>        }</span>
  7257 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7258 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7259 |     | <span class='neutral'>        assembly {</span>
  7260 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7261 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7262 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7263 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7264 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7265 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7266 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7267 |     | <span class='neutral'>        }</span>
  7268 |     | <span class='neutral'>    }</span>
  7269 |     | <span class='neutral'></span>
  7270 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {</span>
  7271 |     | <span class='neutral'>        bytes32 m0;</span>
  7272 |     | <span class='neutral'>        bytes32 m1;</span>
  7273 |     | <span class='neutral'>        bytes32 m2;</span>
  7274 |     | <span class='neutral'>        bytes32 m3;</span>
  7275 |     | <span class='neutral'>        bytes32 m4;</span>
  7276 |     | <span class='neutral'>        bytes32 m5;</span>
  7277 |     | <span class='neutral'>        bytes32 m6;</span>
  7278 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7279 |     | <span class='neutral'>        assembly {</span>
  7280 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7281 |     | <span class='neutral'>                let length := 0</span>
  7282 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7283 |     | <span class='neutral'>                mstore(pos, length)</span>
  7284 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7285 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7286 |     | <span class='neutral'>            }</span>
  7287 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7288 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7289 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7290 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7291 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7292 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7293 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7294 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string,uint256)`.</span>
  7295 |     | <span class='neutral'>            mstore(0x00, 0x6a1199e2)</span>
  7296 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7297 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7298 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  7299 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7300 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  7301 |     | <span class='neutral'>        }</span>
  7302 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7303 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7304 |     | <span class='neutral'>        assembly {</span>
  7305 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7306 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7307 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7308 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7309 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7310 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7311 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7312 |     | <span class='neutral'>        }</span>
  7313 |     | <span class='neutral'>    }</span>
  7314 |     | <span class='neutral'></span>
  7315 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  7316 |     | <span class='neutral'>        bytes32 m0;</span>
  7317 |     | <span class='neutral'>        bytes32 m1;</span>
  7318 |     | <span class='neutral'>        bytes32 m2;</span>
  7319 |     | <span class='neutral'>        bytes32 m3;</span>
  7320 |     | <span class='neutral'>        bytes32 m4;</span>
  7321 |     | <span class='neutral'>        bytes32 m5;</span>
  7322 |     | <span class='neutral'>        bytes32 m6;</span>
  7323 |     | <span class='neutral'>        bytes32 m7;</span>
  7324 |     | <span class='neutral'>        bytes32 m8;</span>
  7325 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7326 |     | <span class='neutral'>        assembly {</span>
  7327 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7328 |     | <span class='neutral'>                let length := 0</span>
  7329 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7330 |     | <span class='neutral'>                mstore(pos, length)</span>
  7331 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7332 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7333 |     | <span class='neutral'>            }</span>
  7334 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7335 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7336 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7337 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7338 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7339 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7340 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7341 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7342 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7343 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string,string)`.</span>
  7344 |     | <span class='neutral'>            mstore(0x00, 0xf5bc2249)</span>
  7345 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7346 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7347 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  7348 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  7349 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  7350 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  7351 |     | <span class='neutral'>        }</span>
  7352 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7353 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7354 |     | <span class='neutral'>        assembly {</span>
  7355 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7356 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7357 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7358 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7359 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7360 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7361 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7362 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7363 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7364 |     | <span class='neutral'>        }</span>
  7365 |     | <span class='neutral'>    }</span>
  7366 |     | <span class='neutral'></span>
  7367 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2, address p3) internal pure {</span>
  7368 |     | <span class='neutral'>        bytes32 m0;</span>
  7369 |     | <span class='neutral'>        bytes32 m1;</span>
  7370 |     | <span class='neutral'>        bytes32 m2;</span>
  7371 |     | <span class='neutral'>        bytes32 m3;</span>
  7372 |     | <span class='neutral'>        bytes32 m4;</span>
  7373 |     | <span class='neutral'>        bytes32 m5;</span>
  7374 |     | <span class='neutral'>        bytes32 m6;</span>
  7375 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7376 |     | <span class='neutral'>        assembly {</span>
  7377 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7378 |     | <span class='neutral'>                let length := 0</span>
  7379 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7380 |     | <span class='neutral'>                mstore(pos, length)</span>
  7381 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7382 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7383 |     | <span class='neutral'>            }</span>
  7384 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7385 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7386 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7387 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7388 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7389 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7390 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7391 |     | <span class='neutral'>            // Selector of `log(bool,string,address,address)`.</span>
  7392 |     | <span class='neutral'>            mstore(0x00, 0x2b2b18dc)</span>
  7393 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7394 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7395 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7396 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7397 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7398 |     | <span class='neutral'>        }</span>
  7399 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7400 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7401 |     | <span class='neutral'>        assembly {</span>
  7402 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7403 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7404 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7405 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7406 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7407 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7408 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7409 |     | <span class='neutral'>        }</span>
  7410 |     | <span class='neutral'>    }</span>
  7411 |     | <span class='neutral'></span>
  7412 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {</span>
  7413 |     | <span class='neutral'>        bytes32 m0;</span>
  7414 |     | <span class='neutral'>        bytes32 m1;</span>
  7415 |     | <span class='neutral'>        bytes32 m2;</span>
  7416 |     | <span class='neutral'>        bytes32 m3;</span>
  7417 |     | <span class='neutral'>        bytes32 m4;</span>
  7418 |     | <span class='neutral'>        bytes32 m5;</span>
  7419 |     | <span class='neutral'>        bytes32 m6;</span>
  7420 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7421 |     | <span class='neutral'>        assembly {</span>
  7422 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7423 |     | <span class='neutral'>                let length := 0</span>
  7424 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7425 |     | <span class='neutral'>                mstore(pos, length)</span>
  7426 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7427 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7428 |     | <span class='neutral'>            }</span>
  7429 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7430 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7431 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7432 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7433 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7434 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7435 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7436 |     | <span class='neutral'>            // Selector of `log(bool,string,address,bool)`.</span>
  7437 |     | <span class='neutral'>            mstore(0x00, 0x6dd434ca)</span>
  7438 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7439 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7440 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7441 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7442 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7443 |     | <span class='neutral'>        }</span>
  7444 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7445 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7446 |     | <span class='neutral'>        assembly {</span>
  7447 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7448 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7449 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7450 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7451 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7452 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7453 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7454 |     | <span class='neutral'>        }</span>
  7455 |     | <span class='neutral'>    }</span>
  7456 |     | <span class='neutral'></span>
  7457 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {</span>
  7458 |     | <span class='neutral'>        bytes32 m0;</span>
  7459 |     | <span class='neutral'>        bytes32 m1;</span>
  7460 |     | <span class='neutral'>        bytes32 m2;</span>
  7461 |     | <span class='neutral'>        bytes32 m3;</span>
  7462 |     | <span class='neutral'>        bytes32 m4;</span>
  7463 |     | <span class='neutral'>        bytes32 m5;</span>
  7464 |     | <span class='neutral'>        bytes32 m6;</span>
  7465 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7466 |     | <span class='neutral'>        assembly {</span>
  7467 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7468 |     | <span class='neutral'>                let length := 0</span>
  7469 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7470 |     | <span class='neutral'>                mstore(pos, length)</span>
  7471 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7472 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7473 |     | <span class='neutral'>            }</span>
  7474 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7475 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7476 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7477 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7478 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7479 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7480 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7481 |     | <span class='neutral'>            // Selector of `log(bool,string,address,uint256)`.</span>
  7482 |     | <span class='neutral'>            mstore(0x00, 0xa5cada94)</span>
  7483 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7484 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7485 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7486 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7487 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7488 |     | <span class='neutral'>        }</span>
  7489 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7490 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7491 |     | <span class='neutral'>        assembly {</span>
  7492 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7493 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7494 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7495 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7496 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7497 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7498 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7499 |     | <span class='neutral'>        }</span>
  7500 |     | <span class='neutral'>    }</span>
  7501 |     | <span class='neutral'></span>
  7502 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {</span>
  7503 |     | <span class='neutral'>        bytes32 m0;</span>
  7504 |     | <span class='neutral'>        bytes32 m1;</span>
  7505 |     | <span class='neutral'>        bytes32 m2;</span>
  7506 |     | <span class='neutral'>        bytes32 m3;</span>
  7507 |     | <span class='neutral'>        bytes32 m4;</span>
  7508 |     | <span class='neutral'>        bytes32 m5;</span>
  7509 |     | <span class='neutral'>        bytes32 m6;</span>
  7510 |     | <span class='neutral'>        bytes32 m7;</span>
  7511 |     | <span class='neutral'>        bytes32 m8;</span>
  7512 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7513 |     | <span class='neutral'>        assembly {</span>
  7514 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7515 |     | <span class='neutral'>                let length := 0</span>
  7516 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7517 |     | <span class='neutral'>                mstore(pos, length)</span>
  7518 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7519 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7520 |     | <span class='neutral'>            }</span>
  7521 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7522 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7523 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7524 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7525 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7526 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7527 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7528 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7529 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7530 |     | <span class='neutral'>            // Selector of `log(bool,string,address,string)`.</span>
  7531 |     | <span class='neutral'>            mstore(0x00, 0x12d6c788)</span>
  7532 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7533 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7534 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7535 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  7536 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7537 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  7538 |     | <span class='neutral'>        }</span>
  7539 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7540 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7541 |     | <span class='neutral'>        assembly {</span>
  7542 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7543 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7544 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7545 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7546 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7547 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7548 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7549 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7550 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7551 |     | <span class='neutral'>        }</span>
  7552 |     | <span class='neutral'>    }</span>
  7553 |     | <span class='neutral'></span>
  7554 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {</span>
  7555 |     | <span class='neutral'>        bytes32 m0;</span>
  7556 |     | <span class='neutral'>        bytes32 m1;</span>
  7557 |     | <span class='neutral'>        bytes32 m2;</span>
  7558 |     | <span class='neutral'>        bytes32 m3;</span>
  7559 |     | <span class='neutral'>        bytes32 m4;</span>
  7560 |     | <span class='neutral'>        bytes32 m5;</span>
  7561 |     | <span class='neutral'>        bytes32 m6;</span>
  7562 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7563 |     | <span class='neutral'>        assembly {</span>
  7564 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7565 |     | <span class='neutral'>                let length := 0</span>
  7566 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7567 |     | <span class='neutral'>                mstore(pos, length)</span>
  7568 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7569 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7570 |     | <span class='neutral'>            }</span>
  7571 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7572 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7573 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7574 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7575 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7576 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7577 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7578 |     | <span class='neutral'>            // Selector of `log(bool,string,bool,address)`.</span>
  7579 |     | <span class='neutral'>            mstore(0x00, 0x538e06ab)</span>
  7580 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7581 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7582 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7583 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7584 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7585 |     | <span class='neutral'>        }</span>
  7586 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7587 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7588 |     | <span class='neutral'>        assembly {</span>
  7589 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7590 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7591 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7592 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7593 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7594 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7595 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7596 |     | <span class='neutral'>        }</span>
  7597 |     | <span class='neutral'>    }</span>
  7598 |     | <span class='neutral'></span>
  7599 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {</span>
  7600 |     | <span class='neutral'>        bytes32 m0;</span>
  7601 |     | <span class='neutral'>        bytes32 m1;</span>
  7602 |     | <span class='neutral'>        bytes32 m2;</span>
  7603 |     | <span class='neutral'>        bytes32 m3;</span>
  7604 |     | <span class='neutral'>        bytes32 m4;</span>
  7605 |     | <span class='neutral'>        bytes32 m5;</span>
  7606 |     | <span class='neutral'>        bytes32 m6;</span>
  7607 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7608 |     | <span class='neutral'>        assembly {</span>
  7609 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7610 |     | <span class='neutral'>                let length := 0</span>
  7611 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7612 |     | <span class='neutral'>                mstore(pos, length)</span>
  7613 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7614 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7615 |     | <span class='neutral'>            }</span>
  7616 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7617 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7618 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7619 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7620 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7621 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7622 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7623 |     | <span class='neutral'>            // Selector of `log(bool,string,bool,bool)`.</span>
  7624 |     | <span class='neutral'>            mstore(0x00, 0xdc5e935b)</span>
  7625 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7626 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7627 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7628 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7629 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7630 |     | <span class='neutral'>        }</span>
  7631 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7632 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7633 |     | <span class='neutral'>        assembly {</span>
  7634 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7635 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7636 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7637 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7638 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7639 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7640 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7641 |     | <span class='neutral'>        }</span>
  7642 |     | <span class='neutral'>    }</span>
  7643 |     | <span class='neutral'></span>
  7644 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {</span>
  7645 |     | <span class='neutral'>        bytes32 m0;</span>
  7646 |     | <span class='neutral'>        bytes32 m1;</span>
  7647 |     | <span class='neutral'>        bytes32 m2;</span>
  7648 |     | <span class='neutral'>        bytes32 m3;</span>
  7649 |     | <span class='neutral'>        bytes32 m4;</span>
  7650 |     | <span class='neutral'>        bytes32 m5;</span>
  7651 |     | <span class='neutral'>        bytes32 m6;</span>
  7652 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7653 |     | <span class='neutral'>        assembly {</span>
  7654 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7655 |     | <span class='neutral'>                let length := 0</span>
  7656 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7657 |     | <span class='neutral'>                mstore(pos, length)</span>
  7658 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7659 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7660 |     | <span class='neutral'>            }</span>
  7661 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7662 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7663 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7664 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7665 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7666 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7667 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7668 |     | <span class='neutral'>            // Selector of `log(bool,string,bool,uint256)`.</span>
  7669 |     | <span class='neutral'>            mstore(0x00, 0x1606a393)</span>
  7670 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7671 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7672 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7673 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7674 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7675 |     | <span class='neutral'>        }</span>
  7676 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7677 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7678 |     | <span class='neutral'>        assembly {</span>
  7679 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7680 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7681 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7682 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7683 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7684 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7685 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7686 |     | <span class='neutral'>        }</span>
  7687 |     | <span class='neutral'>    }</span>
  7688 |     | <span class='neutral'></span>
  7689 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {</span>
  7690 |     | <span class='neutral'>        bytes32 m0;</span>
  7691 |     | <span class='neutral'>        bytes32 m1;</span>
  7692 |     | <span class='neutral'>        bytes32 m2;</span>
  7693 |     | <span class='neutral'>        bytes32 m3;</span>
  7694 |     | <span class='neutral'>        bytes32 m4;</span>
  7695 |     | <span class='neutral'>        bytes32 m5;</span>
  7696 |     | <span class='neutral'>        bytes32 m6;</span>
  7697 |     | <span class='neutral'>        bytes32 m7;</span>
  7698 |     | <span class='neutral'>        bytes32 m8;</span>
  7699 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7700 |     | <span class='neutral'>        assembly {</span>
  7701 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7702 |     | <span class='neutral'>                let length := 0</span>
  7703 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7704 |     | <span class='neutral'>                mstore(pos, length)</span>
  7705 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7706 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7707 |     | <span class='neutral'>            }</span>
  7708 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7709 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7710 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7711 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7712 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7713 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7714 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7715 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7716 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7717 |     | <span class='neutral'>            // Selector of `log(bool,string,bool,string)`.</span>
  7718 |     | <span class='neutral'>            mstore(0x00, 0x483d0416)</span>
  7719 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7720 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7721 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7722 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  7723 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7724 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  7725 |     | <span class='neutral'>        }</span>
  7726 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7727 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7728 |     | <span class='neutral'>        assembly {</span>
  7729 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7730 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7731 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7732 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7733 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7734 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7735 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7736 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7737 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7738 |     | <span class='neutral'>        }</span>
  7739 |     | <span class='neutral'>    }</span>
  7740 |     | <span class='neutral'></span>
  7741 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {</span>
  7742 |     | <span class='neutral'>        bytes32 m0;</span>
  7743 |     | <span class='neutral'>        bytes32 m1;</span>
  7744 |     | <span class='neutral'>        bytes32 m2;</span>
  7745 |     | <span class='neutral'>        bytes32 m3;</span>
  7746 |     | <span class='neutral'>        bytes32 m4;</span>
  7747 |     | <span class='neutral'>        bytes32 m5;</span>
  7748 |     | <span class='neutral'>        bytes32 m6;</span>
  7749 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7750 |     | <span class='neutral'>        assembly {</span>
  7751 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7752 |     | <span class='neutral'>                let length := 0</span>
  7753 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7754 |     | <span class='neutral'>                mstore(pos, length)</span>
  7755 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7756 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7757 |     | <span class='neutral'>            }</span>
  7758 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7759 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7760 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7761 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7762 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7763 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7764 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7765 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256,address)`.</span>
  7766 |     | <span class='neutral'>            mstore(0x00, 0x1596a1ce)</span>
  7767 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7768 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7769 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7770 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7771 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7772 |     | <span class='neutral'>        }</span>
  7773 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7774 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7775 |     | <span class='neutral'>        assembly {</span>
  7776 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7777 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7778 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7779 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7780 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7781 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7782 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7783 |     | <span class='neutral'>        }</span>
  7784 |     | <span class='neutral'>    }</span>
  7785 |     | <span class='neutral'></span>
  7786 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {</span>
  7787 |     | <span class='neutral'>        bytes32 m0;</span>
  7788 |     | <span class='neutral'>        bytes32 m1;</span>
  7789 |     | <span class='neutral'>        bytes32 m2;</span>
  7790 |     | <span class='neutral'>        bytes32 m3;</span>
  7791 |     | <span class='neutral'>        bytes32 m4;</span>
  7792 |     | <span class='neutral'>        bytes32 m5;</span>
  7793 |     | <span class='neutral'>        bytes32 m6;</span>
  7794 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7795 |     | <span class='neutral'>        assembly {</span>
  7796 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7797 |     | <span class='neutral'>                let length := 0</span>
  7798 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7799 |     | <span class='neutral'>                mstore(pos, length)</span>
  7800 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7801 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7802 |     | <span class='neutral'>            }</span>
  7803 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7804 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7805 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7806 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7807 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7808 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7809 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7810 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256,bool)`.</span>
  7811 |     | <span class='neutral'>            mstore(0x00, 0x6b0e5d53)</span>
  7812 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7813 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7814 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7815 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7816 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7817 |     | <span class='neutral'>        }</span>
  7818 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7819 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7820 |     | <span class='neutral'>        assembly {</span>
  7821 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7822 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7823 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7824 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7825 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7826 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7827 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7828 |     | <span class='neutral'>        }</span>
  7829 |     | <span class='neutral'>    }</span>
  7830 |     | <span class='neutral'></span>
  7831 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {</span>
  7832 |     | <span class='neutral'>        bytes32 m0;</span>
  7833 |     | <span class='neutral'>        bytes32 m1;</span>
  7834 |     | <span class='neutral'>        bytes32 m2;</span>
  7835 |     | <span class='neutral'>        bytes32 m3;</span>
  7836 |     | <span class='neutral'>        bytes32 m4;</span>
  7837 |     | <span class='neutral'>        bytes32 m5;</span>
  7838 |     | <span class='neutral'>        bytes32 m6;</span>
  7839 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7840 |     | <span class='neutral'>        assembly {</span>
  7841 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7842 |     | <span class='neutral'>                let length := 0</span>
  7843 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7844 |     | <span class='neutral'>                mstore(pos, length)</span>
  7845 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7846 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7847 |     | <span class='neutral'>            }</span>
  7848 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7849 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7850 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7851 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7852 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7853 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7854 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7855 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256,uint256)`.</span>
  7856 |     | <span class='neutral'>            mstore(0x00, 0x28863fcb)</span>
  7857 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7858 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7859 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7860 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7861 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7862 |     | <span class='neutral'>        }</span>
  7863 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7864 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7865 |     | <span class='neutral'>        assembly {</span>
  7866 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7867 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7868 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7869 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7870 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7871 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7872 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7873 |     | <span class='neutral'>        }</span>
  7874 |     | <span class='neutral'>    }</span>
  7875 |     | <span class='neutral'></span>
  7876 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {</span>
  7877 |     | <span class='neutral'>        bytes32 m0;</span>
  7878 |     | <span class='neutral'>        bytes32 m1;</span>
  7879 |     | <span class='neutral'>        bytes32 m2;</span>
  7880 |     | <span class='neutral'>        bytes32 m3;</span>
  7881 |     | <span class='neutral'>        bytes32 m4;</span>
  7882 |     | <span class='neutral'>        bytes32 m5;</span>
  7883 |     | <span class='neutral'>        bytes32 m6;</span>
  7884 |     | <span class='neutral'>        bytes32 m7;</span>
  7885 |     | <span class='neutral'>        bytes32 m8;</span>
  7886 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7887 |     | <span class='neutral'>        assembly {</span>
  7888 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7889 |     | <span class='neutral'>                let length := 0</span>
  7890 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7891 |     | <span class='neutral'>                mstore(pos, length)</span>
  7892 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7893 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7894 |     | <span class='neutral'>            }</span>
  7895 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7896 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7897 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7898 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7899 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7900 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7901 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7902 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7903 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7904 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256,string)`.</span>
  7905 |     | <span class='neutral'>            mstore(0x00, 0x1ad96de6)</span>
  7906 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7907 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7908 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7909 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  7910 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7911 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  7912 |     | <span class='neutral'>        }</span>
  7913 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7914 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7915 |     | <span class='neutral'>        assembly {</span>
  7916 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7917 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7918 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7919 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7920 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7921 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7922 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7923 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7924 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7925 |     | <span class='neutral'>        }</span>
  7926 |     | <span class='neutral'>    }</span>
  7927 |     | <span class='neutral'></span>
  7928 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {</span>
  7929 |     | <span class='neutral'>        bytes32 m0;</span>
  7930 |     | <span class='neutral'>        bytes32 m1;</span>
  7931 |     | <span class='neutral'>        bytes32 m2;</span>
  7932 |     | <span class='neutral'>        bytes32 m3;</span>
  7933 |     | <span class='neutral'>        bytes32 m4;</span>
  7934 |     | <span class='neutral'>        bytes32 m5;</span>
  7935 |     | <span class='neutral'>        bytes32 m6;</span>
  7936 |     | <span class='neutral'>        bytes32 m7;</span>
  7937 |     | <span class='neutral'>        bytes32 m8;</span>
  7938 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7939 |     | <span class='neutral'>        assembly {</span>
  7940 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7941 |     | <span class='neutral'>                let length := 0</span>
  7942 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7943 |     | <span class='neutral'>                mstore(pos, length)</span>
  7944 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7945 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7946 |     | <span class='neutral'>            }</span>
  7947 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7948 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7949 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7950 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7951 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7952 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7953 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7954 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7955 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7956 |     | <span class='neutral'>            // Selector of `log(bool,string,string,address)`.</span>
  7957 |     | <span class='neutral'>            mstore(0x00, 0x97d394d8)</span>
  7958 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7959 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7960 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  7961 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7962 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7963 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  7964 |     | <span class='neutral'>        }</span>
  7965 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7966 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7967 |     | <span class='neutral'>        assembly {</span>
  7968 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7969 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7970 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7971 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7972 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7973 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7974 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7975 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7976 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7977 |     | <span class='neutral'>        }</span>
  7978 |     | <span class='neutral'>    }</span>
  7979 |     | <span class='neutral'></span>
  7980 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {</span>
  7981 |     | <span class='neutral'>        bytes32 m0;</span>
  7982 |     | <span class='neutral'>        bytes32 m1;</span>
  7983 |     | <span class='neutral'>        bytes32 m2;</span>
  7984 |     | <span class='neutral'>        bytes32 m3;</span>
  7985 |     | <span class='neutral'>        bytes32 m4;</span>
  7986 |     | <span class='neutral'>        bytes32 m5;</span>
  7987 |     | <span class='neutral'>        bytes32 m6;</span>
  7988 |     | <span class='neutral'>        bytes32 m7;</span>
  7989 |     | <span class='neutral'>        bytes32 m8;</span>
  7990 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  7991 |     | <span class='neutral'>        assembly {</span>
  7992 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7993 |     | <span class='neutral'>                let length := 0</span>
  7994 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7995 |     | <span class='neutral'>                mstore(pos, length)</span>
  7996 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7997 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7998 |     | <span class='neutral'>            }</span>
  7999 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8000 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8001 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8002 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8003 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8004 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8005 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8006 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  8007 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  8008 |     | <span class='neutral'>            // Selector of `log(bool,string,string,bool)`.</span>
  8009 |     | <span class='neutral'>            mstore(0x00, 0x1e4b87e5)</span>
  8010 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8011 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  8012 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  8013 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8014 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  8015 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  8016 |     | <span class='neutral'>        }</span>
  8017 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  8018 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8019 |     | <span class='neutral'>        assembly {</span>
  8020 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8021 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8022 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8023 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8024 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8025 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8026 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8027 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  8028 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  8029 |     | <span class='neutral'>        }</span>
  8030 |     | <span class='neutral'>    }</span>
  8031 |     | <span class='neutral'></span>
  8032 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {</span>
  8033 |     | <span class='neutral'>        bytes32 m0;</span>
  8034 |     | <span class='neutral'>        bytes32 m1;</span>
  8035 |     | <span class='neutral'>        bytes32 m2;</span>
  8036 |     | <span class='neutral'>        bytes32 m3;</span>
  8037 |     | <span class='neutral'>        bytes32 m4;</span>
  8038 |     | <span class='neutral'>        bytes32 m5;</span>
  8039 |     | <span class='neutral'>        bytes32 m6;</span>
  8040 |     | <span class='neutral'>        bytes32 m7;</span>
  8041 |     | <span class='neutral'>        bytes32 m8;</span>
  8042 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8043 |     | <span class='neutral'>        assembly {</span>
  8044 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8045 |     | <span class='neutral'>                let length := 0</span>
  8046 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8047 |     | <span class='neutral'>                mstore(pos, length)</span>
  8048 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8049 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8050 |     | <span class='neutral'>            }</span>
  8051 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8052 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8053 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8054 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8055 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8056 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8057 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8058 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  8059 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  8060 |     | <span class='neutral'>            // Selector of `log(bool,string,string,uint256)`.</span>
  8061 |     | <span class='neutral'>            mstore(0x00, 0x7be0c3eb)</span>
  8062 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8063 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  8064 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  8065 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8066 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  8067 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  8068 |     | <span class='neutral'>        }</span>
  8069 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  8070 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8071 |     | <span class='neutral'>        assembly {</span>
  8072 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8073 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8074 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8075 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8076 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8077 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8078 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8079 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  8080 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  8081 |     | <span class='neutral'>        }</span>
  8082 |     | <span class='neutral'>    }</span>
  8083 |     | <span class='neutral'></span>
  8084 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  8085 |     | <span class='neutral'>        bytes32 m0;</span>
  8086 |     | <span class='neutral'>        bytes32 m1;</span>
  8087 |     | <span class='neutral'>        bytes32 m2;</span>
  8088 |     | <span class='neutral'>        bytes32 m3;</span>
  8089 |     | <span class='neutral'>        bytes32 m4;</span>
  8090 |     | <span class='neutral'>        bytes32 m5;</span>
  8091 |     | <span class='neutral'>        bytes32 m6;</span>
  8092 |     | <span class='neutral'>        bytes32 m7;</span>
  8093 |     | <span class='neutral'>        bytes32 m8;</span>
  8094 |     | <span class='neutral'>        bytes32 m9;</span>
  8095 |     | <span class='neutral'>        bytes32 m10;</span>
  8096 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8097 |     | <span class='neutral'>        assembly {</span>
  8098 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8099 |     | <span class='neutral'>                let length := 0</span>
  8100 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8101 |     | <span class='neutral'>                mstore(pos, length)</span>
  8102 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8103 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8104 |     | <span class='neutral'>            }</span>
  8105 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8106 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8107 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8108 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8109 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8110 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8111 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8112 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  8113 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  8114 |     | <span class='neutral'>            m9 := mload(0x120)</span>
  8115 |     | <span class='neutral'>            m10 := mload(0x140)</span>
  8116 |     | <span class='neutral'>            // Selector of `log(bool,string,string,string)`.</span>
  8117 |     | <span class='neutral'>            mstore(0x00, 0x1762e32a)</span>
  8118 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8119 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  8120 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  8121 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
  8122 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  8123 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  8124 |     | <span class='neutral'>            writeString(0x120, p3)</span>
  8125 |     | <span class='neutral'>        }</span>
  8126 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
  8127 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8128 |     | <span class='neutral'>        assembly {</span>
  8129 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8130 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8131 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8132 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8133 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8134 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8135 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8136 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  8137 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  8138 |     | <span class='neutral'>            mstore(0x120, m9)</span>
  8139 |     | <span class='neutral'>            mstore(0x140, m10)</span>
  8140 |     | <span class='neutral'>        }</span>
  8141 |     | <span class='neutral'>    }</span>
  8142 |     | <span class='neutral'></span>
  8143 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, address p3) internal pure {</span>
  8144 |     | <span class='neutral'>        bytes32 m0;</span>
  8145 |     | <span class='neutral'>        bytes32 m1;</span>
  8146 |     | <span class='neutral'>        bytes32 m2;</span>
  8147 |     | <span class='neutral'>        bytes32 m3;</span>
  8148 |     | <span class='neutral'>        bytes32 m4;</span>
  8149 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8150 |     | <span class='neutral'>        assembly {</span>
  8151 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8152 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8153 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8154 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8155 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8156 |     | <span class='neutral'>            // Selector of `log(uint256,address,address,address)`.</span>
  8157 |     | <span class='neutral'>            mstore(0x00, 0x2488b414)</span>
  8158 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8159 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8160 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8161 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8162 |     | <span class='neutral'>        }</span>
  8163 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8164 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8165 |     | <span class='neutral'>        assembly {</span>
  8166 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8167 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8168 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8169 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8170 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8171 |     | <span class='neutral'>        }</span>
  8172 |     | <span class='neutral'>    }</span>
  8173 |     | <span class='neutral'></span>
  8174 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, bool p3) internal pure {</span>
  8175 |     | <span class='neutral'>        bytes32 m0;</span>
  8176 |     | <span class='neutral'>        bytes32 m1;</span>
  8177 |     | <span class='neutral'>        bytes32 m2;</span>
  8178 |     | <span class='neutral'>        bytes32 m3;</span>
  8179 |     | <span class='neutral'>        bytes32 m4;</span>
  8180 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8181 |     | <span class='neutral'>        assembly {</span>
  8182 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8183 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8184 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8185 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8186 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8187 |     | <span class='neutral'>            // Selector of `log(uint256,address,address,bool)`.</span>
  8188 |     | <span class='neutral'>            mstore(0x00, 0x091ffaf5)</span>
  8189 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8190 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8191 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8192 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8193 |     | <span class='neutral'>        }</span>
  8194 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8195 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8196 |     | <span class='neutral'>        assembly {</span>
  8197 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8198 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8199 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8200 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8201 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8202 |     | <span class='neutral'>        }</span>
  8203 |     | <span class='neutral'>    }</span>
  8204 |     | <span class='neutral'></span>
  8205 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {</span>
  8206 |     | <span class='neutral'>        bytes32 m0;</span>
  8207 |     | <span class='neutral'>        bytes32 m1;</span>
  8208 |     | <span class='neutral'>        bytes32 m2;</span>
  8209 |     | <span class='neutral'>        bytes32 m3;</span>
  8210 |     | <span class='neutral'>        bytes32 m4;</span>
  8211 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8212 |     | <span class='neutral'>        assembly {</span>
  8213 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8214 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8215 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8216 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8217 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8218 |     | <span class='neutral'>            // Selector of `log(uint256,address,address,uint256)`.</span>
  8219 |     | <span class='neutral'>            mstore(0x00, 0x736efbb6)</span>
  8220 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8221 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8222 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8223 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8224 |     | <span class='neutral'>        }</span>
  8225 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8226 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8227 |     | <span class='neutral'>        assembly {</span>
  8228 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8229 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8230 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8231 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8232 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8233 |     | <span class='neutral'>        }</span>
  8234 |     | <span class='neutral'>    }</span>
  8235 |     | <span class='neutral'></span>
  8236 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {</span>
  8237 |     | <span class='neutral'>        bytes32 m0;</span>
  8238 |     | <span class='neutral'>        bytes32 m1;</span>
  8239 |     | <span class='neutral'>        bytes32 m2;</span>
  8240 |     | <span class='neutral'>        bytes32 m3;</span>
  8241 |     | <span class='neutral'>        bytes32 m4;</span>
  8242 |     | <span class='neutral'>        bytes32 m5;</span>
  8243 |     | <span class='neutral'>        bytes32 m6;</span>
  8244 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8245 |     | <span class='neutral'>        assembly {</span>
  8246 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8247 |     | <span class='neutral'>                let length := 0</span>
  8248 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8249 |     | <span class='neutral'>                mstore(pos, length)</span>
  8250 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8251 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8252 |     | <span class='neutral'>            }</span>
  8253 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8254 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8255 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8256 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8257 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8258 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8259 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8260 |     | <span class='neutral'>            // Selector of `log(uint256,address,address,string)`.</span>
  8261 |     | <span class='neutral'>            mstore(0x00, 0x031c6f73)</span>
  8262 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8263 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8264 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8265 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8266 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8267 |     | <span class='neutral'>        }</span>
  8268 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8269 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8270 |     | <span class='neutral'>        assembly {</span>
  8271 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8272 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8273 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8274 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8275 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8276 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8277 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8278 |     | <span class='neutral'>        }</span>
  8279 |     | <span class='neutral'>    }</span>
  8280 |     | <span class='neutral'></span>
  8281 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, address p3) internal pure {</span>
  8282 |     | <span class='neutral'>        bytes32 m0;</span>
  8283 |     | <span class='neutral'>        bytes32 m1;</span>
  8284 |     | <span class='neutral'>        bytes32 m2;</span>
  8285 |     | <span class='neutral'>        bytes32 m3;</span>
  8286 |     | <span class='neutral'>        bytes32 m4;</span>
  8287 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8288 |     | <span class='neutral'>        assembly {</span>
  8289 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8290 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8291 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8292 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8293 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8294 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool,address)`.</span>
  8295 |     | <span class='neutral'>            mstore(0x00, 0xef72c513)</span>
  8296 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8297 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8298 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8299 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8300 |     | <span class='neutral'>        }</span>
  8301 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8302 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8303 |     | <span class='neutral'>        assembly {</span>
  8304 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8305 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8306 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8307 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8308 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8309 |     | <span class='neutral'>        }</span>
  8310 |     | <span class='neutral'>    }</span>
  8311 |     | <span class='neutral'></span>
  8312 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {</span>
  8313 |     | <span class='neutral'>        bytes32 m0;</span>
  8314 |     | <span class='neutral'>        bytes32 m1;</span>
  8315 |     | <span class='neutral'>        bytes32 m2;</span>
  8316 |     | <span class='neutral'>        bytes32 m3;</span>
  8317 |     | <span class='neutral'>        bytes32 m4;</span>
  8318 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8319 |     | <span class='neutral'>        assembly {</span>
  8320 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8321 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8322 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8323 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8324 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8325 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool,bool)`.</span>
  8326 |     | <span class='neutral'>            mstore(0x00, 0xe351140f)</span>
  8327 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8328 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8329 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8330 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8331 |     | <span class='neutral'>        }</span>
  8332 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8333 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8334 |     | <span class='neutral'>        assembly {</span>
  8335 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8336 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8337 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8338 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8339 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8340 |     | <span class='neutral'>        }</span>
  8341 |     | <span class='neutral'>    }</span>
  8342 |     | <span class='neutral'></span>
  8343 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {</span>
  8344 |     | <span class='neutral'>        bytes32 m0;</span>
  8345 |     | <span class='neutral'>        bytes32 m1;</span>
  8346 |     | <span class='neutral'>        bytes32 m2;</span>
  8347 |     | <span class='neutral'>        bytes32 m3;</span>
  8348 |     | <span class='neutral'>        bytes32 m4;</span>
  8349 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8350 |     | <span class='neutral'>        assembly {</span>
  8351 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8352 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8353 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8354 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8355 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8356 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool,uint256)`.</span>
  8357 |     | <span class='neutral'>            mstore(0x00, 0x5abd992a)</span>
  8358 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8359 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8360 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8361 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8362 |     | <span class='neutral'>        }</span>
  8363 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8364 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8365 |     | <span class='neutral'>        assembly {</span>
  8366 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8367 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8368 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8369 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8370 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8371 |     | <span class='neutral'>        }</span>
  8372 |     | <span class='neutral'>    }</span>
  8373 |     | <span class='neutral'></span>
  8374 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {</span>
  8375 |     | <span class='neutral'>        bytes32 m0;</span>
  8376 |     | <span class='neutral'>        bytes32 m1;</span>
  8377 |     | <span class='neutral'>        bytes32 m2;</span>
  8378 |     | <span class='neutral'>        bytes32 m3;</span>
  8379 |     | <span class='neutral'>        bytes32 m4;</span>
  8380 |     | <span class='neutral'>        bytes32 m5;</span>
  8381 |     | <span class='neutral'>        bytes32 m6;</span>
  8382 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8383 |     | <span class='neutral'>        assembly {</span>
  8384 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8385 |     | <span class='neutral'>                let length := 0</span>
  8386 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8387 |     | <span class='neutral'>                mstore(pos, length)</span>
  8388 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8389 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8390 |     | <span class='neutral'>            }</span>
  8391 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8392 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8393 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8394 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8395 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8396 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8397 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8398 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool,string)`.</span>
  8399 |     | <span class='neutral'>            mstore(0x00, 0x90fb06aa)</span>
  8400 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8401 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8402 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8403 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8404 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8405 |     | <span class='neutral'>        }</span>
  8406 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8407 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8408 |     | <span class='neutral'>        assembly {</span>
  8409 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8410 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8411 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8412 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8413 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8414 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8415 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8416 |     | <span class='neutral'>        }</span>
  8417 |     | <span class='neutral'>    }</span>
  8418 |     | <span class='neutral'></span>
  8419 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {</span>
  8420 |     | <span class='neutral'>        bytes32 m0;</span>
  8421 |     | <span class='neutral'>        bytes32 m1;</span>
  8422 |     | <span class='neutral'>        bytes32 m2;</span>
  8423 |     | <span class='neutral'>        bytes32 m3;</span>
  8424 |     | <span class='neutral'>        bytes32 m4;</span>
  8425 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8426 |     | <span class='neutral'>        assembly {</span>
  8427 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8428 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8429 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8430 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8431 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8432 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256,address)`.</span>
  8433 |     | <span class='neutral'>            mstore(0x00, 0x15c127b5)</span>
  8434 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8435 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8436 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8437 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8438 |     | <span class='neutral'>        }</span>
  8439 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8440 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8441 |     | <span class='neutral'>        assembly {</span>
  8442 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8443 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8444 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8445 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8446 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8447 |     | <span class='neutral'>        }</span>
  8448 |     | <span class='neutral'>    }</span>
  8449 |     | <span class='neutral'></span>
  8450 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {</span>
  8451 |     | <span class='neutral'>        bytes32 m0;</span>
  8452 |     | <span class='neutral'>        bytes32 m1;</span>
  8453 |     | <span class='neutral'>        bytes32 m2;</span>
  8454 |     | <span class='neutral'>        bytes32 m3;</span>
  8455 |     | <span class='neutral'>        bytes32 m4;</span>
  8456 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8457 |     | <span class='neutral'>        assembly {</span>
  8458 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8459 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8460 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8461 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8462 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8463 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256,bool)`.</span>
  8464 |     | <span class='neutral'>            mstore(0x00, 0x5f743a7c)</span>
  8465 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8466 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8467 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8468 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8469 |     | <span class='neutral'>        }</span>
  8470 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8471 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8472 |     | <span class='neutral'>        assembly {</span>
  8473 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8474 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8475 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8476 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8477 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8478 |     | <span class='neutral'>        }</span>
  8479 |     | <span class='neutral'>    }</span>
  8480 |     | <span class='neutral'></span>
  8481 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  8482 |     | <span class='neutral'>        bytes32 m0;</span>
  8483 |     | <span class='neutral'>        bytes32 m1;</span>
  8484 |     | <span class='neutral'>        bytes32 m2;</span>
  8485 |     | <span class='neutral'>        bytes32 m3;</span>
  8486 |     | <span class='neutral'>        bytes32 m4;</span>
  8487 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8488 |     | <span class='neutral'>        assembly {</span>
  8489 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8490 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8491 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8492 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8493 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8494 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256,uint256)`.</span>
  8495 |     | <span class='neutral'>            mstore(0x00, 0x0c9cd9c1)</span>
  8496 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8497 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8498 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8499 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8500 |     | <span class='neutral'>        }</span>
  8501 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8502 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8503 |     | <span class='neutral'>        assembly {</span>
  8504 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8505 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8506 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8507 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8508 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8509 |     | <span class='neutral'>        }</span>
  8510 |     | <span class='neutral'>    }</span>
  8511 |     | <span class='neutral'></span>
  8512 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {</span>
  8513 |     | <span class='neutral'>        bytes32 m0;</span>
  8514 |     | <span class='neutral'>        bytes32 m1;</span>
  8515 |     | <span class='neutral'>        bytes32 m2;</span>
  8516 |     | <span class='neutral'>        bytes32 m3;</span>
  8517 |     | <span class='neutral'>        bytes32 m4;</span>
  8518 |     | <span class='neutral'>        bytes32 m5;</span>
  8519 |     | <span class='neutral'>        bytes32 m6;</span>
  8520 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8521 |     | <span class='neutral'>        assembly {</span>
  8522 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8523 |     | <span class='neutral'>                let length := 0</span>
  8524 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8525 |     | <span class='neutral'>                mstore(pos, length)</span>
  8526 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8527 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8528 |     | <span class='neutral'>            }</span>
  8529 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8530 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8531 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8532 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8533 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8534 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8535 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8536 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256,string)`.</span>
  8537 |     | <span class='neutral'>            mstore(0x00, 0xddb06521)</span>
  8538 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8539 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8540 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8541 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8542 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8543 |     | <span class='neutral'>        }</span>
  8544 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8545 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8546 |     | <span class='neutral'>        assembly {</span>
  8547 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8548 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8549 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8550 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8551 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8552 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8553 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8554 |     | <span class='neutral'>        }</span>
  8555 |     | <span class='neutral'>    }</span>
  8556 |     | <span class='neutral'></span>
  8557 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {</span>
  8558 |     | <span class='neutral'>        bytes32 m0;</span>
  8559 |     | <span class='neutral'>        bytes32 m1;</span>
  8560 |     | <span class='neutral'>        bytes32 m2;</span>
  8561 |     | <span class='neutral'>        bytes32 m3;</span>
  8562 |     | <span class='neutral'>        bytes32 m4;</span>
  8563 |     | <span class='neutral'>        bytes32 m5;</span>
  8564 |     | <span class='neutral'>        bytes32 m6;</span>
  8565 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8566 |     | <span class='neutral'>        assembly {</span>
  8567 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8568 |     | <span class='neutral'>                let length := 0</span>
  8569 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8570 |     | <span class='neutral'>                mstore(pos, length)</span>
  8571 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8572 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8573 |     | <span class='neutral'>            }</span>
  8574 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8575 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8576 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8577 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8578 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8579 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8580 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8581 |     | <span class='neutral'>            // Selector of `log(uint256,address,string,address)`.</span>
  8582 |     | <span class='neutral'>            mstore(0x00, 0x9cba8fff)</span>
  8583 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8584 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8585 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8586 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8587 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8588 |     | <span class='neutral'>        }</span>
  8589 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8590 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8591 |     | <span class='neutral'>        assembly {</span>
  8592 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8593 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8594 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8595 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8596 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8597 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8598 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8599 |     | <span class='neutral'>        }</span>
  8600 |     | <span class='neutral'>    }</span>
  8601 |     | <span class='neutral'></span>
  8602 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {</span>
  8603 |     | <span class='neutral'>        bytes32 m0;</span>
  8604 |     | <span class='neutral'>        bytes32 m1;</span>
  8605 |     | <span class='neutral'>        bytes32 m2;</span>
  8606 |     | <span class='neutral'>        bytes32 m3;</span>
  8607 |     | <span class='neutral'>        bytes32 m4;</span>
  8608 |     | <span class='neutral'>        bytes32 m5;</span>
  8609 |     | <span class='neutral'>        bytes32 m6;</span>
  8610 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8611 |     | <span class='neutral'>        assembly {</span>
  8612 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8613 |     | <span class='neutral'>                let length := 0</span>
  8614 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8615 |     | <span class='neutral'>                mstore(pos, length)</span>
  8616 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8617 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8618 |     | <span class='neutral'>            }</span>
  8619 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8620 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8621 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8622 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8623 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8624 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8625 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8626 |     | <span class='neutral'>            // Selector of `log(uint256,address,string,bool)`.</span>
  8627 |     | <span class='neutral'>            mstore(0x00, 0xcc32ab07)</span>
  8628 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8629 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8630 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8631 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8632 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8633 |     | <span class='neutral'>        }</span>
  8634 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8635 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8636 |     | <span class='neutral'>        assembly {</span>
  8637 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8638 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8639 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8640 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8641 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8642 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8643 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8644 |     | <span class='neutral'>        }</span>
  8645 |     | <span class='neutral'>    }</span>
  8646 |     | <span class='neutral'></span>
  8647 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {</span>
  8648 |     | <span class='neutral'>        bytes32 m0;</span>
  8649 |     | <span class='neutral'>        bytes32 m1;</span>
  8650 |     | <span class='neutral'>        bytes32 m2;</span>
  8651 |     | <span class='neutral'>        bytes32 m3;</span>
  8652 |     | <span class='neutral'>        bytes32 m4;</span>
  8653 |     | <span class='neutral'>        bytes32 m5;</span>
  8654 |     | <span class='neutral'>        bytes32 m6;</span>
  8655 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8656 |     | <span class='neutral'>        assembly {</span>
  8657 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8658 |     | <span class='neutral'>                let length := 0</span>
  8659 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8660 |     | <span class='neutral'>                mstore(pos, length)</span>
  8661 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8662 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8663 |     | <span class='neutral'>            }</span>
  8664 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8665 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8666 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8667 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8668 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8669 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8670 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8671 |     | <span class='neutral'>            // Selector of `log(uint256,address,string,uint256)`.</span>
  8672 |     | <span class='neutral'>            mstore(0x00, 0x46826b5d)</span>
  8673 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8674 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8675 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8676 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8677 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8678 |     | <span class='neutral'>        }</span>
  8679 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8680 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8681 |     | <span class='neutral'>        assembly {</span>
  8682 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8683 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8684 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8685 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8686 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8687 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8688 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8689 |     | <span class='neutral'>        }</span>
  8690 |     | <span class='neutral'>    }</span>
  8691 |     | <span class='neutral'></span>
  8692 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {</span>
  8693 |     | <span class='neutral'>        bytes32 m0;</span>
  8694 |     | <span class='neutral'>        bytes32 m1;</span>
  8695 |     | <span class='neutral'>        bytes32 m2;</span>
  8696 |     | <span class='neutral'>        bytes32 m3;</span>
  8697 |     | <span class='neutral'>        bytes32 m4;</span>
  8698 |     | <span class='neutral'>        bytes32 m5;</span>
  8699 |     | <span class='neutral'>        bytes32 m6;</span>
  8700 |     | <span class='neutral'>        bytes32 m7;</span>
  8701 |     | <span class='neutral'>        bytes32 m8;</span>
  8702 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8703 |     | <span class='neutral'>        assembly {</span>
  8704 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8705 |     | <span class='neutral'>                let length := 0</span>
  8706 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8707 |     | <span class='neutral'>                mstore(pos, length)</span>
  8708 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8709 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8710 |     | <span class='neutral'>            }</span>
  8711 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8712 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8713 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8714 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8715 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8716 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8717 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8718 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  8719 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  8720 |     | <span class='neutral'>            // Selector of `log(uint256,address,string,string)`.</span>
  8721 |     | <span class='neutral'>            mstore(0x00, 0x3e128ca3)</span>
  8722 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8723 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8724 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8725 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  8726 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8727 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  8728 |     | <span class='neutral'>        }</span>
  8729 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  8730 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8731 |     | <span class='neutral'>        assembly {</span>
  8732 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8733 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8734 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8735 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8736 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8737 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8738 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8739 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  8740 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  8741 |     | <span class='neutral'>        }</span>
  8742 |     | <span class='neutral'>    }</span>
  8743 |     | <span class='neutral'></span>
  8744 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, address p3) internal pure {</span>
  8745 |     | <span class='neutral'>        bytes32 m0;</span>
  8746 |     | <span class='neutral'>        bytes32 m1;</span>
  8747 |     | <span class='neutral'>        bytes32 m2;</span>
  8748 |     | <span class='neutral'>        bytes32 m3;</span>
  8749 |     | <span class='neutral'>        bytes32 m4;</span>
  8750 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8751 |     | <span class='neutral'>        assembly {</span>
  8752 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8753 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8754 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8755 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8756 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8757 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address,address)`.</span>
  8758 |     | <span class='neutral'>            mstore(0x00, 0xa1ef4cbb)</span>
  8759 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8760 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8761 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8762 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8763 |     | <span class='neutral'>        }</span>
  8764 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8765 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8766 |     | <span class='neutral'>        assembly {</span>
  8767 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8768 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8769 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8770 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8771 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8772 |     | <span class='neutral'>        }</span>
  8773 |     | <span class='neutral'>    }</span>
  8774 |     | <span class='neutral'></span>
  8775 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {</span>
  8776 |     | <span class='neutral'>        bytes32 m0;</span>
  8777 |     | <span class='neutral'>        bytes32 m1;</span>
  8778 |     | <span class='neutral'>        bytes32 m2;</span>
  8779 |     | <span class='neutral'>        bytes32 m3;</span>
  8780 |     | <span class='neutral'>        bytes32 m4;</span>
  8781 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8782 |     | <span class='neutral'>        assembly {</span>
  8783 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8784 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8785 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8786 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8787 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8788 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address,bool)`.</span>
  8789 |     | <span class='neutral'>            mstore(0x00, 0x454d54a5)</span>
  8790 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8791 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8792 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8793 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8794 |     | <span class='neutral'>        }</span>
  8795 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8796 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8797 |     | <span class='neutral'>        assembly {</span>
  8798 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8799 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8800 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8801 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8802 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8803 |     | <span class='neutral'>        }</span>
  8804 |     | <span class='neutral'>    }</span>
  8805 |     | <span class='neutral'></span>
  8806 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {</span>
  8807 |     | <span class='neutral'>        bytes32 m0;</span>
  8808 |     | <span class='neutral'>        bytes32 m1;</span>
  8809 |     | <span class='neutral'>        bytes32 m2;</span>
  8810 |     | <span class='neutral'>        bytes32 m3;</span>
  8811 |     | <span class='neutral'>        bytes32 m4;</span>
  8812 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8813 |     | <span class='neutral'>        assembly {</span>
  8814 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8815 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8816 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8817 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8818 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8819 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address,uint256)`.</span>
  8820 |     | <span class='neutral'>            mstore(0x00, 0x078287f5)</span>
  8821 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8822 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8823 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8824 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8825 |     | <span class='neutral'>        }</span>
  8826 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8827 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8828 |     | <span class='neutral'>        assembly {</span>
  8829 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8830 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8831 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8832 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8833 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8834 |     | <span class='neutral'>        }</span>
  8835 |     | <span class='neutral'>    }</span>
  8836 |     | <span class='neutral'></span>
  8837 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {</span>
  8838 |     | <span class='neutral'>        bytes32 m0;</span>
  8839 |     | <span class='neutral'>        bytes32 m1;</span>
  8840 |     | <span class='neutral'>        bytes32 m2;</span>
  8841 |     | <span class='neutral'>        bytes32 m3;</span>
  8842 |     | <span class='neutral'>        bytes32 m4;</span>
  8843 |     | <span class='neutral'>        bytes32 m5;</span>
  8844 |     | <span class='neutral'>        bytes32 m6;</span>
  8845 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8846 |     | <span class='neutral'>        assembly {</span>
  8847 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8848 |     | <span class='neutral'>                let length := 0</span>
  8849 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8850 |     | <span class='neutral'>                mstore(pos, length)</span>
  8851 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8852 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8853 |     | <span class='neutral'>            }</span>
  8854 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8855 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8856 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8857 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8858 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8859 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8860 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8861 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address,string)`.</span>
  8862 |     | <span class='neutral'>            mstore(0x00, 0xade052c7)</span>
  8863 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8864 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8865 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8866 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8867 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8868 |     | <span class='neutral'>        }</span>
  8869 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8870 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8871 |     | <span class='neutral'>        assembly {</span>
  8872 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8873 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8874 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8875 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8876 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8877 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8878 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8879 |     | <span class='neutral'>        }</span>
  8880 |     | <span class='neutral'>    }</span>
  8881 |     | <span class='neutral'></span>
  8882 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {</span>
  8883 |     | <span class='neutral'>        bytes32 m0;</span>
  8884 |     | <span class='neutral'>        bytes32 m1;</span>
  8885 |     | <span class='neutral'>        bytes32 m2;</span>
  8886 |     | <span class='neutral'>        bytes32 m3;</span>
  8887 |     | <span class='neutral'>        bytes32 m4;</span>
  8888 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8889 |     | <span class='neutral'>        assembly {</span>
  8890 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8891 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8892 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8893 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8894 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8895 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool,address)`.</span>
  8896 |     | <span class='neutral'>            mstore(0x00, 0x69640b59)</span>
  8897 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8898 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8899 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8900 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8901 |     | <span class='neutral'>        }</span>
  8902 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8903 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8904 |     | <span class='neutral'>        assembly {</span>
  8905 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8906 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8907 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8908 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8909 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8910 |     | <span class='neutral'>        }</span>
  8911 |     | <span class='neutral'>    }</span>
  8912 |     | <span class='neutral'></span>
  8913 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {</span>
  8914 |     | <span class='neutral'>        bytes32 m0;</span>
  8915 |     | <span class='neutral'>        bytes32 m1;</span>
  8916 |     | <span class='neutral'>        bytes32 m2;</span>
  8917 |     | <span class='neutral'>        bytes32 m3;</span>
  8918 |     | <span class='neutral'>        bytes32 m4;</span>
  8919 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8920 |     | <span class='neutral'>        assembly {</span>
  8921 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8922 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8923 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8924 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8925 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8926 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool,bool)`.</span>
  8927 |     | <span class='neutral'>            mstore(0x00, 0xb6f577a1)</span>
  8928 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8929 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8930 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8931 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8932 |     | <span class='neutral'>        }</span>
  8933 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8934 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8935 |     | <span class='neutral'>        assembly {</span>
  8936 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8937 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8938 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8939 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8940 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8941 |     | <span class='neutral'>        }</span>
  8942 |     | <span class='neutral'>    }</span>
  8943 |     | <span class='neutral'></span>
  8944 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  8945 |     | <span class='neutral'>        bytes32 m0;</span>
  8946 |     | <span class='neutral'>        bytes32 m1;</span>
  8947 |     | <span class='neutral'>        bytes32 m2;</span>
  8948 |     | <span class='neutral'>        bytes32 m3;</span>
  8949 |     | <span class='neutral'>        bytes32 m4;</span>
  8950 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8951 |     | <span class='neutral'>        assembly {</span>
  8952 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8953 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8954 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8955 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8956 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8957 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool,uint256)`.</span>
  8958 |     | <span class='neutral'>            mstore(0x00, 0x7464ce23)</span>
  8959 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8960 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8961 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8962 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8963 |     | <span class='neutral'>        }</span>
  8964 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8965 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8966 |     | <span class='neutral'>        assembly {</span>
  8967 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8968 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8969 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8970 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8971 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8972 |     | <span class='neutral'>        }</span>
  8973 |     | <span class='neutral'>    }</span>
  8974 |     | <span class='neutral'></span>
  8975 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {</span>
  8976 |     | <span class='neutral'>        bytes32 m0;</span>
  8977 |     | <span class='neutral'>        bytes32 m1;</span>
  8978 |     | <span class='neutral'>        bytes32 m2;</span>
  8979 |     | <span class='neutral'>        bytes32 m3;</span>
  8980 |     | <span class='neutral'>        bytes32 m4;</span>
  8981 |     | <span class='neutral'>        bytes32 m5;</span>
  8982 |     | <span class='neutral'>        bytes32 m6;</span>
  8983 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  8984 |     | <span class='neutral'>        assembly {</span>
  8985 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8986 |     | <span class='neutral'>                let length := 0</span>
  8987 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8988 |     | <span class='neutral'>                mstore(pos, length)</span>
  8989 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8990 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8991 |     | <span class='neutral'>            }</span>
  8992 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8993 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8994 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8995 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8996 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8997 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8998 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8999 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool,string)`.</span>
  9000 |     | <span class='neutral'>            mstore(0x00, 0xdddb9561)</span>
  9001 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9002 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9003 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9004 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  9005 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  9006 |     | <span class='neutral'>        }</span>
  9007 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9008 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9009 |     | <span class='neutral'>        assembly {</span>
  9010 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9011 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9012 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9013 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9014 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9015 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9016 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9017 |     | <span class='neutral'>        }</span>
  9018 |     | <span class='neutral'>    }</span>
  9019 |     | <span class='neutral'></span>
  9020 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {</span>
  9021 |     | <span class='neutral'>        bytes32 m0;</span>
  9022 |     | <span class='neutral'>        bytes32 m1;</span>
  9023 |     | <span class='neutral'>        bytes32 m2;</span>
  9024 |     | <span class='neutral'>        bytes32 m3;</span>
  9025 |     | <span class='neutral'>        bytes32 m4;</span>
  9026 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9027 |     | <span class='neutral'>        assembly {</span>
  9028 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9029 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9030 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9031 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9032 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9033 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256,address)`.</span>
  9034 |     | <span class='neutral'>            mstore(0x00, 0x88cb6041)</span>
  9035 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9036 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9037 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9038 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9039 |     | <span class='neutral'>        }</span>
  9040 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9041 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9042 |     | <span class='neutral'>        assembly {</span>
  9043 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9044 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9045 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9046 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9047 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9048 |     | <span class='neutral'>        }</span>
  9049 |     | <span class='neutral'>    }</span>
  9050 |     | <span class='neutral'></span>
  9051 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  9052 |     | <span class='neutral'>        bytes32 m0;</span>
  9053 |     | <span class='neutral'>        bytes32 m1;</span>
  9054 |     | <span class='neutral'>        bytes32 m2;</span>
  9055 |     | <span class='neutral'>        bytes32 m3;</span>
  9056 |     | <span class='neutral'>        bytes32 m4;</span>
  9057 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9058 |     | <span class='neutral'>        assembly {</span>
  9059 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9060 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9061 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9062 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9063 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9064 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256,bool)`.</span>
  9065 |     | <span class='neutral'>            mstore(0x00, 0x91a02e2a)</span>
  9066 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9067 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9068 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9069 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9070 |     | <span class='neutral'>        }</span>
  9071 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9072 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9073 |     | <span class='neutral'>        assembly {</span>
  9074 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9075 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9076 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9077 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9078 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9079 |     | <span class='neutral'>        }</span>
  9080 |     | <span class='neutral'>    }</span>
  9081 |     | <span class='neutral'></span>
  9082 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  9083 |     | <span class='neutral'>        bytes32 m0;</span>
  9084 |     | <span class='neutral'>        bytes32 m1;</span>
  9085 |     | <span class='neutral'>        bytes32 m2;</span>
  9086 |     | <span class='neutral'>        bytes32 m3;</span>
  9087 |     | <span class='neutral'>        bytes32 m4;</span>
  9088 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9089 |     | <span class='neutral'>        assembly {</span>
  9090 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9091 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9092 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9093 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9094 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9095 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256,uint256)`.</span>
  9096 |     | <span class='neutral'>            mstore(0x00, 0xc6acc7a8)</span>
  9097 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9098 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9099 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9100 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9101 |     | <span class='neutral'>        }</span>
  9102 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9103 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9104 |     | <span class='neutral'>        assembly {</span>
  9105 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9106 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9107 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9108 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9109 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9110 |     | <span class='neutral'>        }</span>
  9111 |     | <span class='neutral'>    }</span>
  9112 |     | <span class='neutral'></span>
  9113 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {</span>
  9114 |     | <span class='neutral'>        bytes32 m0;</span>
  9115 |     | <span class='neutral'>        bytes32 m1;</span>
  9116 |     | <span class='neutral'>        bytes32 m2;</span>
  9117 |     | <span class='neutral'>        bytes32 m3;</span>
  9118 |     | <span class='neutral'>        bytes32 m4;</span>
  9119 |     | <span class='neutral'>        bytes32 m5;</span>
  9120 |     | <span class='neutral'>        bytes32 m6;</span>
  9121 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9122 |     | <span class='neutral'>        assembly {</span>
  9123 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9124 |     | <span class='neutral'>                let length := 0</span>
  9125 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9126 |     | <span class='neutral'>                mstore(pos, length)</span>
  9127 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9128 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9129 |     | <span class='neutral'>            }</span>
  9130 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9131 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9132 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9133 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9134 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9135 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9136 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9137 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256,string)`.</span>
  9138 |     | <span class='neutral'>            mstore(0x00, 0xde03e774)</span>
  9139 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9140 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9141 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9142 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  9143 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  9144 |     | <span class='neutral'>        }</span>
  9145 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9146 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9147 |     | <span class='neutral'>        assembly {</span>
  9148 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9149 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9150 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9151 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9152 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9153 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9154 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9155 |     | <span class='neutral'>        }</span>
  9156 |     | <span class='neutral'>    }</span>
  9157 |     | <span class='neutral'></span>
  9158 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {</span>
  9159 |     | <span class='neutral'>        bytes32 m0;</span>
  9160 |     | <span class='neutral'>        bytes32 m1;</span>
  9161 |     | <span class='neutral'>        bytes32 m2;</span>
  9162 |     | <span class='neutral'>        bytes32 m3;</span>
  9163 |     | <span class='neutral'>        bytes32 m4;</span>
  9164 |     | <span class='neutral'>        bytes32 m5;</span>
  9165 |     | <span class='neutral'>        bytes32 m6;</span>
  9166 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9167 |     | <span class='neutral'>        assembly {</span>
  9168 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9169 |     | <span class='neutral'>                let length := 0</span>
  9170 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9171 |     | <span class='neutral'>                mstore(pos, length)</span>
  9172 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9173 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9174 |     | <span class='neutral'>            }</span>
  9175 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9176 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9177 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9178 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9179 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9180 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9181 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9182 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string,address)`.</span>
  9183 |     | <span class='neutral'>            mstore(0x00, 0xef529018)</span>
  9184 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9185 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9186 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9187 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9188 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9189 |     | <span class='neutral'>        }</span>
  9190 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9191 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9192 |     | <span class='neutral'>        assembly {</span>
  9193 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9194 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9195 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9196 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9197 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9198 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9199 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9200 |     | <span class='neutral'>        }</span>
  9201 |     | <span class='neutral'>    }</span>
  9202 |     | <span class='neutral'></span>
  9203 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {</span>
  9204 |     | <span class='neutral'>        bytes32 m0;</span>
  9205 |     | <span class='neutral'>        bytes32 m1;</span>
  9206 |     | <span class='neutral'>        bytes32 m2;</span>
  9207 |     | <span class='neutral'>        bytes32 m3;</span>
  9208 |     | <span class='neutral'>        bytes32 m4;</span>
  9209 |     | <span class='neutral'>        bytes32 m5;</span>
  9210 |     | <span class='neutral'>        bytes32 m6;</span>
  9211 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9212 |     | <span class='neutral'>        assembly {</span>
  9213 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9214 |     | <span class='neutral'>                let length := 0</span>
  9215 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9216 |     | <span class='neutral'>                mstore(pos, length)</span>
  9217 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9218 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9219 |     | <span class='neutral'>            }</span>
  9220 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9221 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9222 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9223 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9224 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9225 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9226 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9227 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string,bool)`.</span>
  9228 |     | <span class='neutral'>            mstore(0x00, 0xeb928d7f)</span>
  9229 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9230 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9231 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9232 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9233 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9234 |     | <span class='neutral'>        }</span>
  9235 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9236 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9237 |     | <span class='neutral'>        assembly {</span>
  9238 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9239 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9240 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9241 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9242 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9243 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9244 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9245 |     | <span class='neutral'>        }</span>
  9246 |     | <span class='neutral'>    }</span>
  9247 |     | <span class='neutral'></span>
  9248 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {</span>
  9249 |     | <span class='neutral'>        bytes32 m0;</span>
  9250 |     | <span class='neutral'>        bytes32 m1;</span>
  9251 |     | <span class='neutral'>        bytes32 m2;</span>
  9252 |     | <span class='neutral'>        bytes32 m3;</span>
  9253 |     | <span class='neutral'>        bytes32 m4;</span>
  9254 |     | <span class='neutral'>        bytes32 m5;</span>
  9255 |     | <span class='neutral'>        bytes32 m6;</span>
  9256 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9257 |     | <span class='neutral'>        assembly {</span>
  9258 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9259 |     | <span class='neutral'>                let length := 0</span>
  9260 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9261 |     | <span class='neutral'>                mstore(pos, length)</span>
  9262 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9263 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9264 |     | <span class='neutral'>            }</span>
  9265 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9266 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9267 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9268 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9269 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9270 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9271 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9272 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string,uint256)`.</span>
  9273 |     | <span class='neutral'>            mstore(0x00, 0x2c1d0746)</span>
  9274 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9275 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9276 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9277 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9278 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9279 |     | <span class='neutral'>        }</span>
  9280 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9281 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9282 |     | <span class='neutral'>        assembly {</span>
  9283 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9284 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9285 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9286 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9287 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9288 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9289 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9290 |     | <span class='neutral'>        }</span>
  9291 |     | <span class='neutral'>    }</span>
  9292 |     | <span class='neutral'></span>
  9293 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {</span>
  9294 |     | <span class='neutral'>        bytes32 m0;</span>
  9295 |     | <span class='neutral'>        bytes32 m1;</span>
  9296 |     | <span class='neutral'>        bytes32 m2;</span>
  9297 |     | <span class='neutral'>        bytes32 m3;</span>
  9298 |     | <span class='neutral'>        bytes32 m4;</span>
  9299 |     | <span class='neutral'>        bytes32 m5;</span>
  9300 |     | <span class='neutral'>        bytes32 m6;</span>
  9301 |     | <span class='neutral'>        bytes32 m7;</span>
  9302 |     | <span class='neutral'>        bytes32 m8;</span>
  9303 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9304 |     | <span class='neutral'>        assembly {</span>
  9305 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9306 |     | <span class='neutral'>                let length := 0</span>
  9307 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9308 |     | <span class='neutral'>                mstore(pos, length)</span>
  9309 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9310 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9311 |     | <span class='neutral'>            }</span>
  9312 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9313 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9314 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9315 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9316 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9317 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9318 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9319 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  9320 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  9321 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string,string)`.</span>
  9322 |     | <span class='neutral'>            mstore(0x00, 0x68c8b8bd)</span>
  9323 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9324 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9325 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9326 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  9327 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9328 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  9329 |     | <span class='neutral'>        }</span>
  9330 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  9331 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9332 |     | <span class='neutral'>        assembly {</span>
  9333 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9334 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9335 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9336 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9337 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9338 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9339 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9340 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  9341 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  9342 |     | <span class='neutral'>        }</span>
  9343 |     | <span class='neutral'>    }</span>
  9344 |     | <span class='neutral'></span>
  9345 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {</span>
  9346 |     | <span class='neutral'>        bytes32 m0;</span>
  9347 |     | <span class='neutral'>        bytes32 m1;</span>
  9348 |     | <span class='neutral'>        bytes32 m2;</span>
  9349 |     | <span class='neutral'>        bytes32 m3;</span>
  9350 |     | <span class='neutral'>        bytes32 m4;</span>
  9351 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9352 |     | <span class='neutral'>        assembly {</span>
  9353 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9354 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9355 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9356 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9357 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9358 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address,address)`.</span>
  9359 |     | <span class='neutral'>            mstore(0x00, 0x56a5d1b1)</span>
  9360 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9361 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9362 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9363 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9364 |     | <span class='neutral'>        }</span>
  9365 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9366 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9367 |     | <span class='neutral'>        assembly {</span>
  9368 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9369 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9370 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9371 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9372 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9373 |     | <span class='neutral'>        }</span>
  9374 |     | <span class='neutral'>    }</span>
  9375 |     | <span class='neutral'></span>
  9376 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {</span>
  9377 |     | <span class='neutral'>        bytes32 m0;</span>
  9378 |     | <span class='neutral'>        bytes32 m1;</span>
  9379 |     | <span class='neutral'>        bytes32 m2;</span>
  9380 |     | <span class='neutral'>        bytes32 m3;</span>
  9381 |     | <span class='neutral'>        bytes32 m4;</span>
  9382 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9383 |     | <span class='neutral'>        assembly {</span>
  9384 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9385 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9386 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9387 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9388 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9389 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address,bool)`.</span>
  9390 |     | <span class='neutral'>            mstore(0x00, 0x15cac476)</span>
  9391 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9392 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9393 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9394 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9395 |     | <span class='neutral'>        }</span>
  9396 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9397 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9398 |     | <span class='neutral'>        assembly {</span>
  9399 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9400 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9401 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9402 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9403 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9404 |     | <span class='neutral'>        }</span>
  9405 |     | <span class='neutral'>    }</span>
  9406 |     | <span class='neutral'></span>
  9407 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  9408 |     | <span class='neutral'>        bytes32 m0;</span>
  9409 |     | <span class='neutral'>        bytes32 m1;</span>
  9410 |     | <span class='neutral'>        bytes32 m2;</span>
  9411 |     | <span class='neutral'>        bytes32 m3;</span>
  9412 |     | <span class='neutral'>        bytes32 m4;</span>
  9413 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9414 |     | <span class='neutral'>        assembly {</span>
  9415 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9416 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9417 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9418 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9419 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9420 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address,uint256)`.</span>
  9421 |     | <span class='neutral'>            mstore(0x00, 0x88f6e4b2)</span>
  9422 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9423 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9424 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9425 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9426 |     | <span class='neutral'>        }</span>
  9427 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9428 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9429 |     | <span class='neutral'>        assembly {</span>
  9430 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9431 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9432 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9433 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9434 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9435 |     | <span class='neutral'>        }</span>
  9436 |     | <span class='neutral'>    }</span>
  9437 |     | <span class='neutral'></span>
  9438 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {</span>
  9439 |     | <span class='neutral'>        bytes32 m0;</span>
  9440 |     | <span class='neutral'>        bytes32 m1;</span>
  9441 |     | <span class='neutral'>        bytes32 m2;</span>
  9442 |     | <span class='neutral'>        bytes32 m3;</span>
  9443 |     | <span class='neutral'>        bytes32 m4;</span>
  9444 |     | <span class='neutral'>        bytes32 m5;</span>
  9445 |     | <span class='neutral'>        bytes32 m6;</span>
  9446 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9447 |     | <span class='neutral'>        assembly {</span>
  9448 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9449 |     | <span class='neutral'>                let length := 0</span>
  9450 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9451 |     | <span class='neutral'>                mstore(pos, length)</span>
  9452 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9453 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9454 |     | <span class='neutral'>            }</span>
  9455 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9456 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9457 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9458 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9459 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9460 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9461 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9462 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address,string)`.</span>
  9463 |     | <span class='neutral'>            mstore(0x00, 0x6cde40b8)</span>
  9464 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9465 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9466 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9467 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  9468 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  9469 |     | <span class='neutral'>        }</span>
  9470 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9471 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9472 |     | <span class='neutral'>        assembly {</span>
  9473 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9474 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9475 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9476 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9477 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9478 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9479 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9480 |     | <span class='neutral'>        }</span>
  9481 |     | <span class='neutral'>    }</span>
  9482 |     | <span class='neutral'></span>
  9483 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {</span>
  9484 |     | <span class='neutral'>        bytes32 m0;</span>
  9485 |     | <span class='neutral'>        bytes32 m1;</span>
  9486 |     | <span class='neutral'>        bytes32 m2;</span>
  9487 |     | <span class='neutral'>        bytes32 m3;</span>
  9488 |     | <span class='neutral'>        bytes32 m4;</span>
  9489 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9490 |     | <span class='neutral'>        assembly {</span>
  9491 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9492 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9493 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9494 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9495 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9496 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool,address)`.</span>
  9497 |     | <span class='neutral'>            mstore(0x00, 0x9a816a83)</span>
  9498 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9499 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9500 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9501 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9502 |     | <span class='neutral'>        }</span>
  9503 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9504 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9505 |     | <span class='neutral'>        assembly {</span>
  9506 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9507 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9508 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9509 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9510 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9511 |     | <span class='neutral'>        }</span>
  9512 |     | <span class='neutral'>    }</span>
  9513 |     | <span class='neutral'></span>
  9514 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  9515 |     | <span class='neutral'>        bytes32 m0;</span>
  9516 |     | <span class='neutral'>        bytes32 m1;</span>
  9517 |     | <span class='neutral'>        bytes32 m2;</span>
  9518 |     | <span class='neutral'>        bytes32 m3;</span>
  9519 |     | <span class='neutral'>        bytes32 m4;</span>
  9520 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9521 |     | <span class='neutral'>        assembly {</span>
  9522 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9523 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9524 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9525 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9526 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9527 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool,bool)`.</span>
  9528 |     | <span class='neutral'>            mstore(0x00, 0xab085ae6)</span>
  9529 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9530 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9531 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9532 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9533 |     | <span class='neutral'>        }</span>
  9534 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9535 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9536 |     | <span class='neutral'>        assembly {</span>
  9537 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9538 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9539 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9540 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9541 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9542 |     | <span class='neutral'>        }</span>
  9543 |     | <span class='neutral'>    }</span>
  9544 |     | <span class='neutral'></span>
  9545 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  9546 |     | <span class='neutral'>        bytes32 m0;</span>
  9547 |     | <span class='neutral'>        bytes32 m1;</span>
  9548 |     | <span class='neutral'>        bytes32 m2;</span>
  9549 |     | <span class='neutral'>        bytes32 m3;</span>
  9550 |     | <span class='neutral'>        bytes32 m4;</span>
  9551 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9552 |     | <span class='neutral'>        assembly {</span>
  9553 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9554 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9555 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9556 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9557 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9558 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool,uint256)`.</span>
  9559 |     | <span class='neutral'>            mstore(0x00, 0xeb7f6fd2)</span>
  9560 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9561 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9562 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9563 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9564 |     | <span class='neutral'>        }</span>
  9565 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9566 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9567 |     | <span class='neutral'>        assembly {</span>
  9568 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9569 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9570 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9571 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9572 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9573 |     | <span class='neutral'>        }</span>
  9574 |     | <span class='neutral'>    }</span>
  9575 |     | <span class='neutral'></span>
  9576 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {</span>
  9577 |     | <span class='neutral'>        bytes32 m0;</span>
  9578 |     | <span class='neutral'>        bytes32 m1;</span>
  9579 |     | <span class='neutral'>        bytes32 m2;</span>
  9580 |     | <span class='neutral'>        bytes32 m3;</span>
  9581 |     | <span class='neutral'>        bytes32 m4;</span>
  9582 |     | <span class='neutral'>        bytes32 m5;</span>
  9583 |     | <span class='neutral'>        bytes32 m6;</span>
  9584 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9585 |     | <span class='neutral'>        assembly {</span>
  9586 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9587 |     | <span class='neutral'>                let length := 0</span>
  9588 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9589 |     | <span class='neutral'>                mstore(pos, length)</span>
  9590 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9591 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9592 |     | <span class='neutral'>            }</span>
  9593 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9594 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9595 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9596 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9597 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9598 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9599 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9600 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool,string)`.</span>
  9601 |     | <span class='neutral'>            mstore(0x00, 0xa5b4fc99)</span>
  9602 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9603 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9604 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9605 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  9606 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  9607 |     | <span class='neutral'>        }</span>
  9608 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9609 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9610 |     | <span class='neutral'>        assembly {</span>
  9611 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9612 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9613 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9614 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9615 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9616 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9617 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9618 |     | <span class='neutral'>        }</span>
  9619 |     | <span class='neutral'>    }</span>
  9620 |     | <span class='neutral'></span>
  9621 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  9622 |     | <span class='neutral'>        bytes32 m0;</span>
  9623 |     | <span class='neutral'>        bytes32 m1;</span>
  9624 |     | <span class='neutral'>        bytes32 m2;</span>
  9625 |     | <span class='neutral'>        bytes32 m3;</span>
  9626 |     | <span class='neutral'>        bytes32 m4;</span>
  9627 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9628 |     | <span class='neutral'>        assembly {</span>
  9629 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9630 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9631 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9632 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9633 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9634 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256,address)`.</span>
  9635 |     | <span class='neutral'>            mstore(0x00, 0xfa8185af)</span>
  9636 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9637 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9638 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9639 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9640 |     | <span class='neutral'>        }</span>
  9641 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9642 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9643 |     | <span class='neutral'>        assembly {</span>
  9644 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9645 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9646 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9647 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9648 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9649 |     | <span class='neutral'>        }</span>
  9650 |     | <span class='neutral'>    }</span>
  9651 |     | <span class='neutral'></span>
  9652 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  9653 |     | <span class='neutral'>        bytes32 m0;</span>
  9654 |     | <span class='neutral'>        bytes32 m1;</span>
  9655 |     | <span class='neutral'>        bytes32 m2;</span>
  9656 |     | <span class='neutral'>        bytes32 m3;</span>
  9657 |     | <span class='neutral'>        bytes32 m4;</span>
  9658 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9659 |     | <span class='neutral'>        assembly {</span>
  9660 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9661 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9662 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9663 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9664 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9665 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256,bool)`.</span>
  9666 |     | <span class='neutral'>            mstore(0x00, 0xc598d185)</span>
  9667 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9668 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9669 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9670 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9671 |     | <span class='neutral'>        }</span>
  9672 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9673 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9674 |     | <span class='neutral'>        assembly {</span>
  9675 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9676 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9677 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9678 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9679 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9680 |     | <span class='neutral'>        }</span>
  9681 |     | <span class='neutral'>    }</span>
  9682 |     | <span class='neutral'></span>
  9683 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  9684 |     | <span class='neutral'>        bytes32 m0;</span>
  9685 |     | <span class='neutral'>        bytes32 m1;</span>
  9686 |     | <span class='neutral'>        bytes32 m2;</span>
  9687 |     | <span class='neutral'>        bytes32 m3;</span>
  9688 |     | <span class='neutral'>        bytes32 m4;</span>
  9689 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9690 |     | <span class='neutral'>        assembly {</span>
  9691 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9692 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9693 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9694 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9695 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9696 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256,uint256)`.</span>
  9697 |     | <span class='neutral'>            mstore(0x00, 0x193fb800)</span>
  9698 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9699 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9700 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9701 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9702 |     | <span class='neutral'>        }</span>
  9703 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9704 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9705 |     | <span class='neutral'>        assembly {</span>
  9706 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9707 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9708 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9709 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9710 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9711 |     | <span class='neutral'>        }</span>
  9712 |     | <span class='neutral'>    }</span>
  9713 |     | <span class='neutral'></span>
  9714 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {</span>
  9715 |     | <span class='neutral'>        bytes32 m0;</span>
  9716 |     | <span class='neutral'>        bytes32 m1;</span>
  9717 |     | <span class='neutral'>        bytes32 m2;</span>
  9718 |     | <span class='neutral'>        bytes32 m3;</span>
  9719 |     | <span class='neutral'>        bytes32 m4;</span>
  9720 |     | <span class='neutral'>        bytes32 m5;</span>
  9721 |     | <span class='neutral'>        bytes32 m6;</span>
  9722 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9723 |     | <span class='neutral'>        assembly {</span>
  9724 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9725 |     | <span class='neutral'>                let length := 0</span>
  9726 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9727 |     | <span class='neutral'>                mstore(pos, length)</span>
  9728 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9729 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9730 |     | <span class='neutral'>            }</span>
  9731 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9732 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9733 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9734 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9735 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9736 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9737 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9738 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256,string)`.</span>
  9739 |     | <span class='neutral'>            mstore(0x00, 0x59cfcbe3)</span>
  9740 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9741 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9742 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9743 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  9744 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  9745 |     | <span class='neutral'>        }</span>
  9746 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9747 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9748 |     | <span class='neutral'>        assembly {</span>
  9749 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9750 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9751 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9752 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9753 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9754 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9755 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9756 |     | <span class='neutral'>        }</span>
  9757 |     | <span class='neutral'>    }</span>
  9758 |     | <span class='neutral'></span>
  9759 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {</span>
  9760 |     | <span class='neutral'>        bytes32 m0;</span>
  9761 |     | <span class='neutral'>        bytes32 m1;</span>
  9762 |     | <span class='neutral'>        bytes32 m2;</span>
  9763 |     | <span class='neutral'>        bytes32 m3;</span>
  9764 |     | <span class='neutral'>        bytes32 m4;</span>
  9765 |     | <span class='neutral'>        bytes32 m5;</span>
  9766 |     | <span class='neutral'>        bytes32 m6;</span>
  9767 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9768 |     | <span class='neutral'>        assembly {</span>
  9769 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9770 |     | <span class='neutral'>                let length := 0</span>
  9771 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9772 |     | <span class='neutral'>                mstore(pos, length)</span>
  9773 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9774 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9775 |     | <span class='neutral'>            }</span>
  9776 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9777 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9778 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9779 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9780 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9781 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9782 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9783 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string,address)`.</span>
  9784 |     | <span class='neutral'>            mstore(0x00, 0x42d21db7)</span>
  9785 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9786 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9787 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9788 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9789 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9790 |     | <span class='neutral'>        }</span>
  9791 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9792 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9793 |     | <span class='neutral'>        assembly {</span>
  9794 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9795 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9796 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9797 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9798 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9799 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9800 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9801 |     | <span class='neutral'>        }</span>
  9802 |     | <span class='neutral'>    }</span>
  9803 |     | <span class='neutral'></span>
  9804 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {</span>
  9805 |     | <span class='neutral'>        bytes32 m0;</span>
  9806 |     | <span class='neutral'>        bytes32 m1;</span>
  9807 |     | <span class='neutral'>        bytes32 m2;</span>
  9808 |     | <span class='neutral'>        bytes32 m3;</span>
  9809 |     | <span class='neutral'>        bytes32 m4;</span>
  9810 |     | <span class='neutral'>        bytes32 m5;</span>
  9811 |     | <span class='neutral'>        bytes32 m6;</span>
  9812 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9813 |     | <span class='neutral'>        assembly {</span>
  9814 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9815 |     | <span class='neutral'>                let length := 0</span>
  9816 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9817 |     | <span class='neutral'>                mstore(pos, length)</span>
  9818 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9819 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9820 |     | <span class='neutral'>            }</span>
  9821 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9822 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9823 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9824 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9825 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9826 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9827 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9828 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string,bool)`.</span>
  9829 |     | <span class='neutral'>            mstore(0x00, 0x7af6ab25)</span>
  9830 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9831 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9832 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9833 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9834 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9835 |     | <span class='neutral'>        }</span>
  9836 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9837 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9838 |     | <span class='neutral'>        assembly {</span>
  9839 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9840 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9841 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9842 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9843 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9844 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9845 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9846 |     | <span class='neutral'>        }</span>
  9847 |     | <span class='neutral'>    }</span>
  9848 |     | <span class='neutral'></span>
  9849 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {</span>
  9850 |     | <span class='neutral'>        bytes32 m0;</span>
  9851 |     | <span class='neutral'>        bytes32 m1;</span>
  9852 |     | <span class='neutral'>        bytes32 m2;</span>
  9853 |     | <span class='neutral'>        bytes32 m3;</span>
  9854 |     | <span class='neutral'>        bytes32 m4;</span>
  9855 |     | <span class='neutral'>        bytes32 m5;</span>
  9856 |     | <span class='neutral'>        bytes32 m6;</span>
  9857 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9858 |     | <span class='neutral'>        assembly {</span>
  9859 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9860 |     | <span class='neutral'>                let length := 0</span>
  9861 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9862 |     | <span class='neutral'>                mstore(pos, length)</span>
  9863 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9864 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9865 |     | <span class='neutral'>            }</span>
  9866 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9867 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9868 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9869 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9870 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9871 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9872 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9873 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string,uint256)`.</span>
  9874 |     | <span class='neutral'>            mstore(0x00, 0x5da297eb)</span>
  9875 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9876 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9877 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9878 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9879 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9880 |     | <span class='neutral'>        }</span>
  9881 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9882 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9883 |     | <span class='neutral'>        assembly {</span>
  9884 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9885 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9886 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9887 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9888 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9889 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9890 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9891 |     | <span class='neutral'>        }</span>
  9892 |     | <span class='neutral'>    }</span>
  9893 |     | <span class='neutral'></span>
  9894 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  9895 |     | <span class='neutral'>        bytes32 m0;</span>
  9896 |     | <span class='neutral'>        bytes32 m1;</span>
  9897 |     | <span class='neutral'>        bytes32 m2;</span>
  9898 |     | <span class='neutral'>        bytes32 m3;</span>
  9899 |     | <span class='neutral'>        bytes32 m4;</span>
  9900 |     | <span class='neutral'>        bytes32 m5;</span>
  9901 |     | <span class='neutral'>        bytes32 m6;</span>
  9902 |     | <span class='neutral'>        bytes32 m7;</span>
  9903 |     | <span class='neutral'>        bytes32 m8;</span>
  9904 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9905 |     | <span class='neutral'>        assembly {</span>
  9906 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9907 |     | <span class='neutral'>                let length := 0</span>
  9908 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9909 |     | <span class='neutral'>                mstore(pos, length)</span>
  9910 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9911 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9912 |     | <span class='neutral'>            }</span>
  9913 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9914 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9915 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9916 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9917 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9918 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9919 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9920 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  9921 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  9922 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string,string)`.</span>
  9923 |     | <span class='neutral'>            mstore(0x00, 0x27d8afd2)</span>
  9924 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9925 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9926 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9927 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  9928 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9929 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  9930 |     | <span class='neutral'>        }</span>
  9931 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  9932 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9933 |     | <span class='neutral'>        assembly {</span>
  9934 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9935 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9936 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9937 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9938 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9939 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9940 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9941 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  9942 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  9943 |     | <span class='neutral'>        }</span>
  9944 |     | <span class='neutral'>    }</span>
  9945 |     | <span class='neutral'></span>
  9946 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {</span>
  9947 |     | <span class='neutral'>        bytes32 m0;</span>
  9948 |     | <span class='neutral'>        bytes32 m1;</span>
  9949 |     | <span class='neutral'>        bytes32 m2;</span>
  9950 |     | <span class='neutral'>        bytes32 m3;</span>
  9951 |     | <span class='neutral'>        bytes32 m4;</span>
  9952 |     | <span class='neutral'>        bytes32 m5;</span>
  9953 |     | <span class='neutral'>        bytes32 m6;</span>
  9954 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9955 |     | <span class='neutral'>        assembly {</span>
  9956 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9957 |     | <span class='neutral'>                let length := 0</span>
  9958 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9959 |     | <span class='neutral'>                mstore(pos, length)</span>
  9960 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9961 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9962 |     | <span class='neutral'>            }</span>
  9963 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9964 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9965 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9966 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9967 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9968 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9969 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9970 |     | <span class='neutral'>            // Selector of `log(uint256,string,address,address)`.</span>
  9971 |     | <span class='neutral'>            mstore(0x00, 0x6168ed61)</span>
  9972 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9973 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9974 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9975 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9976 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9977 |     | <span class='neutral'>        }</span>
  9978 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9979 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  9980 |     | <span class='neutral'>        assembly {</span>
  9981 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9982 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9983 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9984 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9985 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9986 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9987 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9988 |     | <span class='neutral'>        }</span>
  9989 |     | <span class='neutral'>    }</span>
  9990 |     | <span class='neutral'></span>
  9991 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {</span>
  9992 |     | <span class='neutral'>        bytes32 m0;</span>
  9993 |     | <span class='neutral'>        bytes32 m1;</span>
  9994 |     | <span class='neutral'>        bytes32 m2;</span>
  9995 |     | <span class='neutral'>        bytes32 m3;</span>
  9996 |     | <span class='neutral'>        bytes32 m4;</span>
  9997 |     | <span class='neutral'>        bytes32 m5;</span>
  9998 |     | <span class='neutral'>        bytes32 m6;</span>
  9999 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10000 |     | <span class='neutral'>        assembly {</span>
 10001 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10002 |     | <span class='neutral'>                let length := 0</span>
 10003 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10004 |     | <span class='neutral'>                mstore(pos, length)</span>
 10005 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10006 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10007 |     | <span class='neutral'>            }</span>
 10008 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10009 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10010 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10011 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10012 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10013 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10014 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10015 |     | <span class='neutral'>            // Selector of `log(uint256,string,address,bool)`.</span>
 10016 |     | <span class='neutral'>            mstore(0x00, 0x90c30a56)</span>
 10017 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10018 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10019 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10020 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10021 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10022 |     | <span class='neutral'>        }</span>
 10023 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10024 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10025 |     | <span class='neutral'>        assembly {</span>
 10026 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10027 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10028 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10029 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10030 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10031 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10032 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10033 |     | <span class='neutral'>        }</span>
 10034 |     | <span class='neutral'>    }</span>
 10035 |     | <span class='neutral'></span>
 10036 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {</span>
 10037 |     | <span class='neutral'>        bytes32 m0;</span>
 10038 |     | <span class='neutral'>        bytes32 m1;</span>
 10039 |     | <span class='neutral'>        bytes32 m2;</span>
 10040 |     | <span class='neutral'>        bytes32 m3;</span>
 10041 |     | <span class='neutral'>        bytes32 m4;</span>
 10042 |     | <span class='neutral'>        bytes32 m5;</span>
 10043 |     | <span class='neutral'>        bytes32 m6;</span>
 10044 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10045 |     | <span class='neutral'>        assembly {</span>
 10046 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10047 |     | <span class='neutral'>                let length := 0</span>
 10048 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10049 |     | <span class='neutral'>                mstore(pos, length)</span>
 10050 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10051 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10052 |     | <span class='neutral'>            }</span>
 10053 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10054 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10055 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10056 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10057 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10058 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10059 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10060 |     | <span class='neutral'>            // Selector of `log(uint256,string,address,uint256)`.</span>
 10061 |     | <span class='neutral'>            mstore(0x00, 0xe8d3018d)</span>
 10062 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10063 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10064 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10065 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10066 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10067 |     | <span class='neutral'>        }</span>
 10068 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10069 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10070 |     | <span class='neutral'>        assembly {</span>
 10071 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10072 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10073 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10074 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10075 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10076 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10077 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10078 |     | <span class='neutral'>        }</span>
 10079 |     | <span class='neutral'>    }</span>
 10080 |     | <span class='neutral'></span>
 10081 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {</span>
 10082 |     | <span class='neutral'>        bytes32 m0;</span>
 10083 |     | <span class='neutral'>        bytes32 m1;</span>
 10084 |     | <span class='neutral'>        bytes32 m2;</span>
 10085 |     | <span class='neutral'>        bytes32 m3;</span>
 10086 |     | <span class='neutral'>        bytes32 m4;</span>
 10087 |     | <span class='neutral'>        bytes32 m5;</span>
 10088 |     | <span class='neutral'>        bytes32 m6;</span>
 10089 |     | <span class='neutral'>        bytes32 m7;</span>
 10090 |     | <span class='neutral'>        bytes32 m8;</span>
 10091 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10092 |     | <span class='neutral'>        assembly {</span>
 10093 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10094 |     | <span class='neutral'>                let length := 0</span>
 10095 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10096 |     | <span class='neutral'>                mstore(pos, length)</span>
 10097 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10098 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10099 |     | <span class='neutral'>            }</span>
 10100 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10101 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10102 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10103 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10104 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10105 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10106 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10107 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10108 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10109 |     | <span class='neutral'>            // Selector of `log(uint256,string,address,string)`.</span>
 10110 |     | <span class='neutral'>            mstore(0x00, 0x9c3adfa1)</span>
 10111 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10112 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10113 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10114 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 10115 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10116 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 10117 |     | <span class='neutral'>        }</span>
 10118 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10119 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10120 |     | <span class='neutral'>        assembly {</span>
 10121 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10122 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10123 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10124 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10125 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10126 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10127 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10128 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10129 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10130 |     | <span class='neutral'>        }</span>
 10131 |     | <span class='neutral'>    }</span>
 10132 |     | <span class='neutral'></span>
 10133 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {</span>
 10134 |     | <span class='neutral'>        bytes32 m0;</span>
 10135 |     | <span class='neutral'>        bytes32 m1;</span>
 10136 |     | <span class='neutral'>        bytes32 m2;</span>
 10137 |     | <span class='neutral'>        bytes32 m3;</span>
 10138 |     | <span class='neutral'>        bytes32 m4;</span>
 10139 |     | <span class='neutral'>        bytes32 m5;</span>
 10140 |     | <span class='neutral'>        bytes32 m6;</span>
 10141 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10142 |     | <span class='neutral'>        assembly {</span>
 10143 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10144 |     | <span class='neutral'>                let length := 0</span>
 10145 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10146 |     | <span class='neutral'>                mstore(pos, length)</span>
 10147 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10148 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10149 |     | <span class='neutral'>            }</span>
 10150 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10151 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10152 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10153 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10154 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10155 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10156 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10157 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool,address)`.</span>
 10158 |     | <span class='neutral'>            mstore(0x00, 0xae2ec581)</span>
 10159 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10160 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10161 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10162 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10163 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10164 |     | <span class='neutral'>        }</span>
 10165 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10166 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10167 |     | <span class='neutral'>        assembly {</span>
 10168 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10169 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10170 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10171 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10172 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10173 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10174 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10175 |     | <span class='neutral'>        }</span>
 10176 |     | <span class='neutral'>    }</span>
 10177 |     | <span class='neutral'></span>
 10178 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {</span>
 10179 |     | <span class='neutral'>        bytes32 m0;</span>
 10180 |     | <span class='neutral'>        bytes32 m1;</span>
 10181 |     | <span class='neutral'>        bytes32 m2;</span>
 10182 |     | <span class='neutral'>        bytes32 m3;</span>
 10183 |     | <span class='neutral'>        bytes32 m4;</span>
 10184 |     | <span class='neutral'>        bytes32 m5;</span>
 10185 |     | <span class='neutral'>        bytes32 m6;</span>
 10186 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10187 |     | <span class='neutral'>        assembly {</span>
 10188 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10189 |     | <span class='neutral'>                let length := 0</span>
 10190 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10191 |     | <span class='neutral'>                mstore(pos, length)</span>
 10192 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10193 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10194 |     | <span class='neutral'>            }</span>
 10195 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10196 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10197 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10198 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10199 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10200 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10201 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10202 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool,bool)`.</span>
 10203 |     | <span class='neutral'>            mstore(0x00, 0xba535d9c)</span>
 10204 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10205 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10206 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10207 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10208 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10209 |     | <span class='neutral'>        }</span>
 10210 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10211 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10212 |     | <span class='neutral'>        assembly {</span>
 10213 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10214 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10215 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10216 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10217 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10218 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10219 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10220 |     | <span class='neutral'>        }</span>
 10221 |     | <span class='neutral'>    }</span>
 10222 |     | <span class='neutral'></span>
 10223 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {</span>
 10224 |     | <span class='neutral'>        bytes32 m0;</span>
 10225 |     | <span class='neutral'>        bytes32 m1;</span>
 10226 |     | <span class='neutral'>        bytes32 m2;</span>
 10227 |     | <span class='neutral'>        bytes32 m3;</span>
 10228 |     | <span class='neutral'>        bytes32 m4;</span>
 10229 |     | <span class='neutral'>        bytes32 m5;</span>
 10230 |     | <span class='neutral'>        bytes32 m6;</span>
 10231 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10232 |     | <span class='neutral'>        assembly {</span>
 10233 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10234 |     | <span class='neutral'>                let length := 0</span>
 10235 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10236 |     | <span class='neutral'>                mstore(pos, length)</span>
 10237 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10238 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10239 |     | <span class='neutral'>            }</span>
 10240 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10241 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10242 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10243 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10244 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10245 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10246 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10247 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool,uint256)`.</span>
 10248 |     | <span class='neutral'>            mstore(0x00, 0xcf009880)</span>
 10249 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10250 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10251 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10252 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10253 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10254 |     | <span class='neutral'>        }</span>
 10255 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10256 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10257 |     | <span class='neutral'>        assembly {</span>
 10258 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10259 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10260 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10261 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10262 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10263 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10264 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10265 |     | <span class='neutral'>        }</span>
 10266 |     | <span class='neutral'>    }</span>
 10267 |     | <span class='neutral'></span>
 10268 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {</span>
 10269 |     | <span class='neutral'>        bytes32 m0;</span>
 10270 |     | <span class='neutral'>        bytes32 m1;</span>
 10271 |     | <span class='neutral'>        bytes32 m2;</span>
 10272 |     | <span class='neutral'>        bytes32 m3;</span>
 10273 |     | <span class='neutral'>        bytes32 m4;</span>
 10274 |     | <span class='neutral'>        bytes32 m5;</span>
 10275 |     | <span class='neutral'>        bytes32 m6;</span>
 10276 |     | <span class='neutral'>        bytes32 m7;</span>
 10277 |     | <span class='neutral'>        bytes32 m8;</span>
 10278 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10279 |     | <span class='neutral'>        assembly {</span>
 10280 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10281 |     | <span class='neutral'>                let length := 0</span>
 10282 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10283 |     | <span class='neutral'>                mstore(pos, length)</span>
 10284 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10285 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10286 |     | <span class='neutral'>            }</span>
 10287 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10288 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10289 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10290 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10291 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10292 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10293 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10294 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10295 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10296 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool,string)`.</span>
 10297 |     | <span class='neutral'>            mstore(0x00, 0xd2d423cd)</span>
 10298 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10299 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10300 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10301 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 10302 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10303 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 10304 |     | <span class='neutral'>        }</span>
 10305 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10306 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10307 |     | <span class='neutral'>        assembly {</span>
 10308 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10309 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10310 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10311 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10312 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10313 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10314 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10315 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10316 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10317 |     | <span class='neutral'>        }</span>
 10318 |     | <span class='neutral'>    }</span>
 10319 |     | <span class='neutral'></span>
 10320 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {</span>
 10321 |     | <span class='neutral'>        bytes32 m0;</span>
 10322 |     | <span class='neutral'>        bytes32 m1;</span>
 10323 |     | <span class='neutral'>        bytes32 m2;</span>
 10324 |     | <span class='neutral'>        bytes32 m3;</span>
 10325 |     | <span class='neutral'>        bytes32 m4;</span>
 10326 |     | <span class='neutral'>        bytes32 m5;</span>
 10327 |     | <span class='neutral'>        bytes32 m6;</span>
 10328 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10329 |     | <span class='neutral'>        assembly {</span>
 10330 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10331 |     | <span class='neutral'>                let length := 0</span>
 10332 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10333 |     | <span class='neutral'>                mstore(pos, length)</span>
 10334 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10335 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10336 |     | <span class='neutral'>            }</span>
 10337 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10338 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10339 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10340 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10341 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10342 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10343 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10344 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256,address)`.</span>
 10345 |     | <span class='neutral'>            mstore(0x00, 0x3b2279b4)</span>
 10346 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10347 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10348 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10349 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10350 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10351 |     | <span class='neutral'>        }</span>
 10352 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10353 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10354 |     | <span class='neutral'>        assembly {</span>
 10355 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10356 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10357 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10358 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10359 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10360 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10361 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10362 |     | <span class='neutral'>        }</span>
 10363 |     | <span class='neutral'>    }</span>
 10364 |     | <span class='neutral'></span>
 10365 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {</span>
 10366 |     | <span class='neutral'>        bytes32 m0;</span>
 10367 |     | <span class='neutral'>        bytes32 m1;</span>
 10368 |     | <span class='neutral'>        bytes32 m2;</span>
 10369 |     | <span class='neutral'>        bytes32 m3;</span>
 10370 |     | <span class='neutral'>        bytes32 m4;</span>
 10371 |     | <span class='neutral'>        bytes32 m5;</span>
 10372 |     | <span class='neutral'>        bytes32 m6;</span>
 10373 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10374 |     | <span class='neutral'>        assembly {</span>
 10375 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10376 |     | <span class='neutral'>                let length := 0</span>
 10377 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10378 |     | <span class='neutral'>                mstore(pos, length)</span>
 10379 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10380 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10381 |     | <span class='neutral'>            }</span>
 10382 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10383 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10384 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10385 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10386 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10387 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10388 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10389 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256,bool)`.</span>
 10390 |     | <span class='neutral'>            mstore(0x00, 0x691a8f74)</span>
 10391 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10392 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10393 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10394 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10395 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10396 |     | <span class='neutral'>        }</span>
 10397 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10398 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10399 |     | <span class='neutral'>        assembly {</span>
 10400 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10401 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10402 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10403 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10404 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10405 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10406 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10407 |     | <span class='neutral'>        }</span>
 10408 |     | <span class='neutral'>    }</span>
 10409 |     | <span class='neutral'></span>
 10410 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {</span>
 10411 |     | <span class='neutral'>        bytes32 m0;</span>
 10412 |     | <span class='neutral'>        bytes32 m1;</span>
 10413 |     | <span class='neutral'>        bytes32 m2;</span>
 10414 |     | <span class='neutral'>        bytes32 m3;</span>
 10415 |     | <span class='neutral'>        bytes32 m4;</span>
 10416 |     | <span class='neutral'>        bytes32 m5;</span>
 10417 |     | <span class='neutral'>        bytes32 m6;</span>
 10418 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10419 |     | <span class='neutral'>        assembly {</span>
 10420 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10421 |     | <span class='neutral'>                let length := 0</span>
 10422 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10423 |     | <span class='neutral'>                mstore(pos, length)</span>
 10424 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10425 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10426 |     | <span class='neutral'>            }</span>
 10427 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10428 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10429 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10430 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10431 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10432 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10433 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10434 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256,uint256)`.</span>
 10435 |     | <span class='neutral'>            mstore(0x00, 0x82c25b74)</span>
 10436 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10437 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10438 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10439 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10440 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10441 |     | <span class='neutral'>        }</span>
 10442 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10443 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10444 |     | <span class='neutral'>        assembly {</span>
 10445 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10446 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10447 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10448 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10449 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10450 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10451 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10452 |     | <span class='neutral'>        }</span>
 10453 |     | <span class='neutral'>    }</span>
 10454 |     | <span class='neutral'></span>
 10455 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {</span>
 10456 |     | <span class='neutral'>        bytes32 m0;</span>
 10457 |     | <span class='neutral'>        bytes32 m1;</span>
 10458 |     | <span class='neutral'>        bytes32 m2;</span>
 10459 |     | <span class='neutral'>        bytes32 m3;</span>
 10460 |     | <span class='neutral'>        bytes32 m4;</span>
 10461 |     | <span class='neutral'>        bytes32 m5;</span>
 10462 |     | <span class='neutral'>        bytes32 m6;</span>
 10463 |     | <span class='neutral'>        bytes32 m7;</span>
 10464 |     | <span class='neutral'>        bytes32 m8;</span>
 10465 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10466 |     | <span class='neutral'>        assembly {</span>
 10467 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10468 |     | <span class='neutral'>                let length := 0</span>
 10469 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10470 |     | <span class='neutral'>                mstore(pos, length)</span>
 10471 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10472 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10473 |     | <span class='neutral'>            }</span>
 10474 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10475 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10476 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10477 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10478 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10479 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10480 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10481 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10482 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10483 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256,string)`.</span>
 10484 |     | <span class='neutral'>            mstore(0x00, 0xb7b914ca)</span>
 10485 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10486 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10487 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10488 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 10489 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10490 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 10491 |     | <span class='neutral'>        }</span>
 10492 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10493 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10494 |     | <span class='neutral'>        assembly {</span>
 10495 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10496 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10497 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10498 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10499 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10500 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10501 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10502 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10503 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10504 |     | <span class='neutral'>        }</span>
 10505 |     | <span class='neutral'>    }</span>
 10506 |     | <span class='neutral'></span>
 10507 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {</span>
 10508 |     | <span class='neutral'>        bytes32 m0;</span>
 10509 |     | <span class='neutral'>        bytes32 m1;</span>
 10510 |     | <span class='neutral'>        bytes32 m2;</span>
 10511 |     | <span class='neutral'>        bytes32 m3;</span>
 10512 |     | <span class='neutral'>        bytes32 m4;</span>
 10513 |     | <span class='neutral'>        bytes32 m5;</span>
 10514 |     | <span class='neutral'>        bytes32 m6;</span>
 10515 |     | <span class='neutral'>        bytes32 m7;</span>
 10516 |     | <span class='neutral'>        bytes32 m8;</span>
 10517 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10518 |     | <span class='neutral'>        assembly {</span>
 10519 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10520 |     | <span class='neutral'>                let length := 0</span>
 10521 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10522 |     | <span class='neutral'>                mstore(pos, length)</span>
 10523 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10524 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10525 |     | <span class='neutral'>            }</span>
 10526 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10527 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10528 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10529 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10530 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10531 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10532 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10533 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10534 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10535 |     | <span class='neutral'>            // Selector of `log(uint256,string,string,address)`.</span>
 10536 |     | <span class='neutral'>            mstore(0x00, 0xd583c602)</span>
 10537 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10538 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10539 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10540 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10541 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10542 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10543 |     | <span class='neutral'>        }</span>
 10544 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10545 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10546 |     | <span class='neutral'>        assembly {</span>
 10547 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10548 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10549 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10550 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10551 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10552 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10553 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10554 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10555 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10556 |     | <span class='neutral'>        }</span>
 10557 |     | <span class='neutral'>    }</span>
 10558 |     | <span class='neutral'></span>
 10559 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {</span>
 10560 |     | <span class='neutral'>        bytes32 m0;</span>
 10561 |     | <span class='neutral'>        bytes32 m1;</span>
 10562 |     | <span class='neutral'>        bytes32 m2;</span>
 10563 |     | <span class='neutral'>        bytes32 m3;</span>
 10564 |     | <span class='neutral'>        bytes32 m4;</span>
 10565 |     | <span class='neutral'>        bytes32 m5;</span>
 10566 |     | <span class='neutral'>        bytes32 m6;</span>
 10567 |     | <span class='neutral'>        bytes32 m7;</span>
 10568 |     | <span class='neutral'>        bytes32 m8;</span>
 10569 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10570 |     | <span class='neutral'>        assembly {</span>
 10571 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10572 |     | <span class='neutral'>                let length := 0</span>
 10573 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10574 |     | <span class='neutral'>                mstore(pos, length)</span>
 10575 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10576 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10577 |     | <span class='neutral'>            }</span>
 10578 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10579 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10580 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10581 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10582 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10583 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10584 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10585 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10586 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10587 |     | <span class='neutral'>            // Selector of `log(uint256,string,string,bool)`.</span>
 10588 |     | <span class='neutral'>            mstore(0x00, 0xb3a6b6bd)</span>
 10589 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10590 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10591 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10592 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10593 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10594 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10595 |     | <span class='neutral'>        }</span>
 10596 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10597 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10598 |     | <span class='neutral'>        assembly {</span>
 10599 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10600 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10601 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10602 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10603 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10604 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10605 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10606 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10607 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10608 |     | <span class='neutral'>        }</span>
 10609 |     | <span class='neutral'>    }</span>
 10610 |     | <span class='neutral'></span>
 10611 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {</span>
 10612 |     | <span class='neutral'>        bytes32 m0;</span>
 10613 |     | <span class='neutral'>        bytes32 m1;</span>
 10614 |     | <span class='neutral'>        bytes32 m2;</span>
 10615 |     | <span class='neutral'>        bytes32 m3;</span>
 10616 |     | <span class='neutral'>        bytes32 m4;</span>
 10617 |     | <span class='neutral'>        bytes32 m5;</span>
 10618 |     | <span class='neutral'>        bytes32 m6;</span>
 10619 |     | <span class='neutral'>        bytes32 m7;</span>
 10620 |     | <span class='neutral'>        bytes32 m8;</span>
 10621 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10622 |     | <span class='neutral'>        assembly {</span>
 10623 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10624 |     | <span class='neutral'>                let length := 0</span>
 10625 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10626 |     | <span class='neutral'>                mstore(pos, length)</span>
 10627 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10628 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10629 |     | <span class='neutral'>            }</span>
 10630 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10631 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10632 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10633 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10634 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10635 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10636 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10637 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10638 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10639 |     | <span class='neutral'>            // Selector of `log(uint256,string,string,uint256)`.</span>
 10640 |     | <span class='neutral'>            mstore(0x00, 0xb028c9bd)</span>
 10641 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10642 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10643 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10644 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10645 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10646 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10647 |     | <span class='neutral'>        }</span>
 10648 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10649 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10650 |     | <span class='neutral'>        assembly {</span>
 10651 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10652 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10653 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10654 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10655 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10656 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10657 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10658 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10659 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10660 |     | <span class='neutral'>        }</span>
 10661 |     | <span class='neutral'>    }</span>
 10662 |     | <span class='neutral'></span>
 10663 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {</span>
 10664 |     | <span class='neutral'>        bytes32 m0;</span>
 10665 |     | <span class='neutral'>        bytes32 m1;</span>
 10666 |     | <span class='neutral'>        bytes32 m2;</span>
 10667 |     | <span class='neutral'>        bytes32 m3;</span>
 10668 |     | <span class='neutral'>        bytes32 m4;</span>
 10669 |     | <span class='neutral'>        bytes32 m5;</span>
 10670 |     | <span class='neutral'>        bytes32 m6;</span>
 10671 |     | <span class='neutral'>        bytes32 m7;</span>
 10672 |     | <span class='neutral'>        bytes32 m8;</span>
 10673 |     | <span class='neutral'>        bytes32 m9;</span>
 10674 |     | <span class='neutral'>        bytes32 m10;</span>
 10675 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10676 |     | <span class='neutral'>        assembly {</span>
 10677 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10678 |     | <span class='neutral'>                let length := 0</span>
 10679 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10680 |     | <span class='neutral'>                mstore(pos, length)</span>
 10681 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10682 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10683 |     | <span class='neutral'>            }</span>
 10684 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10685 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10686 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10687 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10688 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10689 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10690 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10691 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10692 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10693 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 10694 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 10695 |     | <span class='neutral'>            // Selector of `log(uint256,string,string,string)`.</span>
 10696 |     | <span class='neutral'>            mstore(0x00, 0x21ad0683)</span>
 10697 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10698 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10699 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10700 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 10701 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10702 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10703 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 10704 |     | <span class='neutral'>        }</span>
 10705 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 10706 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10707 |     | <span class='neutral'>        assembly {</span>
 10708 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10709 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10710 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10711 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10712 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10713 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10714 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10715 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10716 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10717 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 10718 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 10719 |     | <span class='neutral'>        }</span>
 10720 |     | <span class='neutral'>    }</span>
 10721 |     | <span class='neutral'></span>
 10722 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2, address p3) internal pure {</span>
 10723 |     | <span class='neutral'>        bytes32 m0;</span>
 10724 |     | <span class='neutral'>        bytes32 m1;</span>
 10725 |     | <span class='neutral'>        bytes32 m2;</span>
 10726 |     | <span class='neutral'>        bytes32 m3;</span>
 10727 |     | <span class='neutral'>        bytes32 m4;</span>
 10728 |     | <span class='neutral'>        bytes32 m5;</span>
 10729 |     | <span class='neutral'>        bytes32 m6;</span>
 10730 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10731 |     | <span class='neutral'>        assembly {</span>
 10732 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10733 |     | <span class='neutral'>                let length := 0</span>
 10734 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10735 |     | <span class='neutral'>                mstore(pos, length)</span>
 10736 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10737 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10738 |     | <span class='neutral'>            }</span>
 10739 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10740 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10741 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10742 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10743 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10744 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10745 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10746 |     | <span class='neutral'>            // Selector of `log(string,address,address,address)`.</span>
 10747 |     | <span class='neutral'>            mstore(0x00, 0xed8f28f6)</span>
 10748 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10749 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10750 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10751 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10752 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10753 |     | <span class='neutral'>        }</span>
 10754 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10755 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10756 |     | <span class='neutral'>        assembly {</span>
 10757 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10758 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10759 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10760 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10761 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10762 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10763 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10764 |     | <span class='neutral'>        }</span>
 10765 |     | <span class='neutral'>    }</span>
 10766 |     | <span class='neutral'></span>
 10767 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2, bool p3) internal pure {</span>
 10768 |     | <span class='neutral'>        bytes32 m0;</span>
 10769 |     | <span class='neutral'>        bytes32 m1;</span>
 10770 |     | <span class='neutral'>        bytes32 m2;</span>
 10771 |     | <span class='neutral'>        bytes32 m3;</span>
 10772 |     | <span class='neutral'>        bytes32 m4;</span>
 10773 |     | <span class='neutral'>        bytes32 m5;</span>
 10774 |     | <span class='neutral'>        bytes32 m6;</span>
 10775 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10776 |     | <span class='neutral'>        assembly {</span>
 10777 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10778 |     | <span class='neutral'>                let length := 0</span>
 10779 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10780 |     | <span class='neutral'>                mstore(pos, length)</span>
 10781 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10782 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10783 |     | <span class='neutral'>            }</span>
 10784 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10785 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10786 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10787 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10788 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10789 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10790 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10791 |     | <span class='neutral'>            // Selector of `log(string,address,address,bool)`.</span>
 10792 |     | <span class='neutral'>            mstore(0x00, 0xb59dbd60)</span>
 10793 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10794 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10795 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10796 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10797 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10798 |     | <span class='neutral'>        }</span>
 10799 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10800 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10801 |     | <span class='neutral'>        assembly {</span>
 10802 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10803 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10804 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10805 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10806 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10807 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10808 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10809 |     | <span class='neutral'>        }</span>
 10810 |     | <span class='neutral'>    }</span>
 10811 |     | <span class='neutral'></span>
 10812 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {</span>
 10813 |     | <span class='neutral'>        bytes32 m0;</span>
 10814 |     | <span class='neutral'>        bytes32 m1;</span>
 10815 |     | <span class='neutral'>        bytes32 m2;</span>
 10816 |     | <span class='neutral'>        bytes32 m3;</span>
 10817 |     | <span class='neutral'>        bytes32 m4;</span>
 10818 |     | <span class='neutral'>        bytes32 m5;</span>
 10819 |     | <span class='neutral'>        bytes32 m6;</span>
 10820 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10821 |     | <span class='neutral'>        assembly {</span>
 10822 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10823 |     | <span class='neutral'>                let length := 0</span>
 10824 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10825 |     | <span class='neutral'>                mstore(pos, length)</span>
 10826 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10827 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10828 |     | <span class='neutral'>            }</span>
 10829 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10830 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10831 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10832 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10833 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10834 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10835 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10836 |     | <span class='neutral'>            // Selector of `log(string,address,address,uint256)`.</span>
 10837 |     | <span class='neutral'>            mstore(0x00, 0x8ef3f399)</span>
 10838 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10839 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10840 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10841 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10842 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10843 |     | <span class='neutral'>        }</span>
 10844 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10845 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10846 |     | <span class='neutral'>        assembly {</span>
 10847 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10848 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10849 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10850 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10851 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10852 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10853 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10854 |     | <span class='neutral'>        }</span>
 10855 |     | <span class='neutral'>    }</span>
 10856 |     | <span class='neutral'></span>
 10857 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {</span>
 10858 |     | <span class='neutral'>        bytes32 m0;</span>
 10859 |     | <span class='neutral'>        bytes32 m1;</span>
 10860 |     | <span class='neutral'>        bytes32 m2;</span>
 10861 |     | <span class='neutral'>        bytes32 m3;</span>
 10862 |     | <span class='neutral'>        bytes32 m4;</span>
 10863 |     | <span class='neutral'>        bytes32 m5;</span>
 10864 |     | <span class='neutral'>        bytes32 m6;</span>
 10865 |     | <span class='neutral'>        bytes32 m7;</span>
 10866 |     | <span class='neutral'>        bytes32 m8;</span>
 10867 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10868 |     | <span class='neutral'>        assembly {</span>
 10869 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10870 |     | <span class='neutral'>                let length := 0</span>
 10871 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10872 |     | <span class='neutral'>                mstore(pos, length)</span>
 10873 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10874 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10875 |     | <span class='neutral'>            }</span>
 10876 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10877 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10878 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10879 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10880 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10881 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10882 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10883 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10884 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10885 |     | <span class='neutral'>            // Selector of `log(string,address,address,string)`.</span>
 10886 |     | <span class='neutral'>            mstore(0x00, 0x800a1c67)</span>
 10887 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10888 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10889 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10890 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 10891 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10892 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 10893 |     | <span class='neutral'>        }</span>
 10894 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10895 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10896 |     | <span class='neutral'>        assembly {</span>
 10897 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10898 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10899 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10900 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10901 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10902 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10903 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10904 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10905 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10906 |     | <span class='neutral'>        }</span>
 10907 |     | <span class='neutral'>    }</span>
 10908 |     | <span class='neutral'></span>
 10909 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2, address p3) internal pure {</span>
 10910 |     | <span class='neutral'>        bytes32 m0;</span>
 10911 |     | <span class='neutral'>        bytes32 m1;</span>
 10912 |     | <span class='neutral'>        bytes32 m2;</span>
 10913 |     | <span class='neutral'>        bytes32 m3;</span>
 10914 |     | <span class='neutral'>        bytes32 m4;</span>
 10915 |     | <span class='neutral'>        bytes32 m5;</span>
 10916 |     | <span class='neutral'>        bytes32 m6;</span>
 10917 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10918 |     | <span class='neutral'>        assembly {</span>
 10919 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10920 |     | <span class='neutral'>                let length := 0</span>
 10921 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10922 |     | <span class='neutral'>                mstore(pos, length)</span>
 10923 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10924 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10925 |     | <span class='neutral'>            }</span>
 10926 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10927 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10928 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10929 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10930 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10931 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10932 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10933 |     | <span class='neutral'>            // Selector of `log(string,address,bool,address)`.</span>
 10934 |     | <span class='neutral'>            mstore(0x00, 0x223603bd)</span>
 10935 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10936 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10937 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10938 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10939 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10940 |     | <span class='neutral'>        }</span>
 10941 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10942 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10943 |     | <span class='neutral'>        assembly {</span>
 10944 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10945 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10946 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10947 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10948 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10949 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10950 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10951 |     | <span class='neutral'>        }</span>
 10952 |     | <span class='neutral'>    }</span>
 10953 |     | <span class='neutral'></span>
 10954 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {</span>
 10955 |     | <span class='neutral'>        bytes32 m0;</span>
 10956 |     | <span class='neutral'>        bytes32 m1;</span>
 10957 |     | <span class='neutral'>        bytes32 m2;</span>
 10958 |     | <span class='neutral'>        bytes32 m3;</span>
 10959 |     | <span class='neutral'>        bytes32 m4;</span>
 10960 |     | <span class='neutral'>        bytes32 m5;</span>
 10961 |     | <span class='neutral'>        bytes32 m6;</span>
 10962 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10963 |     | <span class='neutral'>        assembly {</span>
 10964 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10965 |     | <span class='neutral'>                let length := 0</span>
 10966 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10967 |     | <span class='neutral'>                mstore(pos, length)</span>
 10968 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10969 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10970 |     | <span class='neutral'>            }</span>
 10971 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10972 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10973 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10974 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10975 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10976 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10977 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10978 |     | <span class='neutral'>            // Selector of `log(string,address,bool,bool)`.</span>
 10979 |     | <span class='neutral'>            mstore(0x00, 0x79884c2b)</span>
 10980 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10981 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10982 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10983 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10984 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10985 |     | <span class='neutral'>        }</span>
 10986 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10987 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 10988 |     | <span class='neutral'>        assembly {</span>
 10989 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10990 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10991 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10992 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10993 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10994 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10995 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10996 |     | <span class='neutral'>        }</span>
 10997 |     | <span class='neutral'>    }</span>
 10998 |     | <span class='neutral'></span>
 10999 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {</span>
 11000 |     | <span class='neutral'>        bytes32 m0;</span>
 11001 |     | <span class='neutral'>        bytes32 m1;</span>
 11002 |     | <span class='neutral'>        bytes32 m2;</span>
 11003 |     | <span class='neutral'>        bytes32 m3;</span>
 11004 |     | <span class='neutral'>        bytes32 m4;</span>
 11005 |     | <span class='neutral'>        bytes32 m5;</span>
 11006 |     | <span class='neutral'>        bytes32 m6;</span>
 11007 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11008 |     | <span class='neutral'>        assembly {</span>
 11009 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11010 |     | <span class='neutral'>                let length := 0</span>
 11011 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11012 |     | <span class='neutral'>                mstore(pos, length)</span>
 11013 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11014 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11015 |     | <span class='neutral'>            }</span>
 11016 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11017 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11018 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11019 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11020 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11021 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11022 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11023 |     | <span class='neutral'>            // Selector of `log(string,address,bool,uint256)`.</span>
 11024 |     | <span class='neutral'>            mstore(0x00, 0x3e9f866a)</span>
 11025 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11026 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11027 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11028 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11029 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11030 |     | <span class='neutral'>        }</span>
 11031 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11032 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11033 |     | <span class='neutral'>        assembly {</span>
 11034 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11035 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11036 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11037 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11038 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11039 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11040 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11041 |     | <span class='neutral'>        }</span>
 11042 |     | <span class='neutral'>    }</span>
 11043 |     | <span class='neutral'></span>
 11044 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {</span>
 11045 |     | <span class='neutral'>        bytes32 m0;</span>
 11046 |     | <span class='neutral'>        bytes32 m1;</span>
 11047 |     | <span class='neutral'>        bytes32 m2;</span>
 11048 |     | <span class='neutral'>        bytes32 m3;</span>
 11049 |     | <span class='neutral'>        bytes32 m4;</span>
 11050 |     | <span class='neutral'>        bytes32 m5;</span>
 11051 |     | <span class='neutral'>        bytes32 m6;</span>
 11052 |     | <span class='neutral'>        bytes32 m7;</span>
 11053 |     | <span class='neutral'>        bytes32 m8;</span>
 11054 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11055 |     | <span class='neutral'>        assembly {</span>
 11056 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11057 |     | <span class='neutral'>                let length := 0</span>
 11058 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11059 |     | <span class='neutral'>                mstore(pos, length)</span>
 11060 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11061 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11062 |     | <span class='neutral'>            }</span>
 11063 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11064 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11065 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11066 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11067 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11068 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11069 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11070 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11071 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11072 |     | <span class='neutral'>            // Selector of `log(string,address,bool,string)`.</span>
 11073 |     | <span class='neutral'>            mstore(0x00, 0x0454c079)</span>
 11074 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11075 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11076 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11077 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11078 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11079 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11080 |     | <span class='neutral'>        }</span>
 11081 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11082 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11083 |     | <span class='neutral'>        assembly {</span>
 11084 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11085 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11086 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11087 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11088 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11089 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11090 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11091 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11092 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11093 |     | <span class='neutral'>        }</span>
 11094 |     | <span class='neutral'>    }</span>
 11095 |     | <span class='neutral'></span>
 11096 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {</span>
 11097 |     | <span class='neutral'>        bytes32 m0;</span>
 11098 |     | <span class='neutral'>        bytes32 m1;</span>
 11099 |     | <span class='neutral'>        bytes32 m2;</span>
 11100 |     | <span class='neutral'>        bytes32 m3;</span>
 11101 |     | <span class='neutral'>        bytes32 m4;</span>
 11102 |     | <span class='neutral'>        bytes32 m5;</span>
 11103 |     | <span class='neutral'>        bytes32 m6;</span>
 11104 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11105 |     | <span class='neutral'>        assembly {</span>
 11106 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11107 |     | <span class='neutral'>                let length := 0</span>
 11108 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11109 |     | <span class='neutral'>                mstore(pos, length)</span>
 11110 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11111 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11112 |     | <span class='neutral'>            }</span>
 11113 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11114 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11115 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11116 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11117 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11118 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11119 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11120 |     | <span class='neutral'>            // Selector of `log(string,address,uint256,address)`.</span>
 11121 |     | <span class='neutral'>            mstore(0x00, 0x63fb8bc5)</span>
 11122 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11123 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11124 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11125 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11126 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11127 |     | <span class='neutral'>        }</span>
 11128 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11129 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11130 |     | <span class='neutral'>        assembly {</span>
 11131 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11132 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11133 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11134 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11135 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11136 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11137 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11138 |     | <span class='neutral'>        }</span>
 11139 |     | <span class='neutral'>    }</span>
 11140 |     | <span class='neutral'></span>
 11141 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {</span>
 11142 |     | <span class='neutral'>        bytes32 m0;</span>
 11143 |     | <span class='neutral'>        bytes32 m1;</span>
 11144 |     | <span class='neutral'>        bytes32 m2;</span>
 11145 |     | <span class='neutral'>        bytes32 m3;</span>
 11146 |     | <span class='neutral'>        bytes32 m4;</span>
 11147 |     | <span class='neutral'>        bytes32 m5;</span>
 11148 |     | <span class='neutral'>        bytes32 m6;</span>
 11149 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11150 |     | <span class='neutral'>        assembly {</span>
 11151 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11152 |     | <span class='neutral'>                let length := 0</span>
 11153 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11154 |     | <span class='neutral'>                mstore(pos, length)</span>
 11155 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11156 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11157 |     | <span class='neutral'>            }</span>
 11158 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11159 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11160 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11161 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11162 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11163 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11164 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11165 |     | <span class='neutral'>            // Selector of `log(string,address,uint256,bool)`.</span>
 11166 |     | <span class='neutral'>            mstore(0x00, 0xfc4845f0)</span>
 11167 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11168 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11169 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11170 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11171 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11172 |     | <span class='neutral'>        }</span>
 11173 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11174 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11175 |     | <span class='neutral'>        assembly {</span>
 11176 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11177 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11178 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11179 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11180 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11181 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11182 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11183 |     | <span class='neutral'>        }</span>
 11184 |     | <span class='neutral'>    }</span>
 11185 |     | <span class='neutral'></span>
 11186 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
 11187 |     | <span class='neutral'>        bytes32 m0;</span>
 11188 |     | <span class='neutral'>        bytes32 m1;</span>
 11189 |     | <span class='neutral'>        bytes32 m2;</span>
 11190 |     | <span class='neutral'>        bytes32 m3;</span>
 11191 |     | <span class='neutral'>        bytes32 m4;</span>
 11192 |     | <span class='neutral'>        bytes32 m5;</span>
 11193 |     | <span class='neutral'>        bytes32 m6;</span>
 11194 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11195 |     | <span class='neutral'>        assembly {</span>
 11196 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11197 |     | <span class='neutral'>                let length := 0</span>
 11198 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11199 |     | <span class='neutral'>                mstore(pos, length)</span>
 11200 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11201 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11202 |     | <span class='neutral'>            }</span>
 11203 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11204 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11205 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11206 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11207 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11208 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11209 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11210 |     | <span class='neutral'>            // Selector of `log(string,address,uint256,uint256)`.</span>
 11211 |     | <span class='neutral'>            mstore(0x00, 0xf8f51b1e)</span>
 11212 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11213 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11214 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11215 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11216 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11217 |     | <span class='neutral'>        }</span>
 11218 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11219 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11220 |     | <span class='neutral'>        assembly {</span>
 11221 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11222 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11223 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11224 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11225 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11226 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11227 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11228 |     | <span class='neutral'>        }</span>
 11229 |     | <span class='neutral'>    }</span>
 11230 |     | <span class='neutral'></span>
 11231 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {</span>
 11232 |     | <span class='neutral'>        bytes32 m0;</span>
 11233 |     | <span class='neutral'>        bytes32 m1;</span>
 11234 |     | <span class='neutral'>        bytes32 m2;</span>
 11235 |     | <span class='neutral'>        bytes32 m3;</span>
 11236 |     | <span class='neutral'>        bytes32 m4;</span>
 11237 |     | <span class='neutral'>        bytes32 m5;</span>
 11238 |     | <span class='neutral'>        bytes32 m6;</span>
 11239 |     | <span class='neutral'>        bytes32 m7;</span>
 11240 |     | <span class='neutral'>        bytes32 m8;</span>
 11241 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11242 |     | <span class='neutral'>        assembly {</span>
 11243 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11244 |     | <span class='neutral'>                let length := 0</span>
 11245 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11246 |     | <span class='neutral'>                mstore(pos, length)</span>
 11247 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11248 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11249 |     | <span class='neutral'>            }</span>
 11250 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11251 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11252 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11253 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11254 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11255 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11256 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11257 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11258 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11259 |     | <span class='neutral'>            // Selector of `log(string,address,uint256,string)`.</span>
 11260 |     | <span class='neutral'>            mstore(0x00, 0x5a477632)</span>
 11261 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11262 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11263 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11264 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11265 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11266 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11267 |     | <span class='neutral'>        }</span>
 11268 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11269 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11270 |     | <span class='neutral'>        assembly {</span>
 11271 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11272 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11273 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11274 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11275 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11276 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11277 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11278 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11279 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11280 |     | <span class='neutral'>        }</span>
 11281 |     | <span class='neutral'>    }</span>
 11282 |     | <span class='neutral'></span>
 11283 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {</span>
 11284 |     | <span class='neutral'>        bytes32 m0;</span>
 11285 |     | <span class='neutral'>        bytes32 m1;</span>
 11286 |     | <span class='neutral'>        bytes32 m2;</span>
 11287 |     | <span class='neutral'>        bytes32 m3;</span>
 11288 |     | <span class='neutral'>        bytes32 m4;</span>
 11289 |     | <span class='neutral'>        bytes32 m5;</span>
 11290 |     | <span class='neutral'>        bytes32 m6;</span>
 11291 |     | <span class='neutral'>        bytes32 m7;</span>
 11292 |     | <span class='neutral'>        bytes32 m8;</span>
 11293 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11294 |     | <span class='neutral'>        assembly {</span>
 11295 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11296 |     | <span class='neutral'>                let length := 0</span>
 11297 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11298 |     | <span class='neutral'>                mstore(pos, length)</span>
 11299 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11300 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11301 |     | <span class='neutral'>            }</span>
 11302 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11303 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11304 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11305 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11306 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11307 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11308 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11309 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11310 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11311 |     | <span class='neutral'>            // Selector of `log(string,address,string,address)`.</span>
 11312 |     | <span class='neutral'>            mstore(0x00, 0xaabc9a31)</span>
 11313 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11314 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11315 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 11316 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11317 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11318 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 11319 |     | <span class='neutral'>        }</span>
 11320 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11321 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11322 |     | <span class='neutral'>        assembly {</span>
 11323 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11324 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11325 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11326 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11327 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11328 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11329 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11330 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11331 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11332 |     | <span class='neutral'>        }</span>
 11333 |     | <span class='neutral'>    }</span>
 11334 |     | <span class='neutral'></span>
 11335 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {</span>
 11336 |     | <span class='neutral'>        bytes32 m0;</span>
 11337 |     | <span class='neutral'>        bytes32 m1;</span>
 11338 |     | <span class='neutral'>        bytes32 m2;</span>
 11339 |     | <span class='neutral'>        bytes32 m3;</span>
 11340 |     | <span class='neutral'>        bytes32 m4;</span>
 11341 |     | <span class='neutral'>        bytes32 m5;</span>
 11342 |     | <span class='neutral'>        bytes32 m6;</span>
 11343 |     | <span class='neutral'>        bytes32 m7;</span>
 11344 |     | <span class='neutral'>        bytes32 m8;</span>
 11345 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11346 |     | <span class='neutral'>        assembly {</span>
 11347 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11348 |     | <span class='neutral'>                let length := 0</span>
 11349 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11350 |     | <span class='neutral'>                mstore(pos, length)</span>
 11351 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11352 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11353 |     | <span class='neutral'>            }</span>
 11354 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11355 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11356 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11357 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11358 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11359 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11360 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11361 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11362 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11363 |     | <span class='neutral'>            // Selector of `log(string,address,string,bool)`.</span>
 11364 |     | <span class='neutral'>            mstore(0x00, 0x5f15d28c)</span>
 11365 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11366 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11367 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 11368 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11369 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11370 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 11371 |     | <span class='neutral'>        }</span>
 11372 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11373 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11374 |     | <span class='neutral'>        assembly {</span>
 11375 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11376 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11377 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11378 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11379 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11380 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11381 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11382 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11383 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11384 |     | <span class='neutral'>        }</span>
 11385 |     | <span class='neutral'>    }</span>
 11386 |     | <span class='neutral'></span>
 11387 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {</span>
 11388 |     | <span class='neutral'>        bytes32 m0;</span>
 11389 |     | <span class='neutral'>        bytes32 m1;</span>
 11390 |     | <span class='neutral'>        bytes32 m2;</span>
 11391 |     | <span class='neutral'>        bytes32 m3;</span>
 11392 |     | <span class='neutral'>        bytes32 m4;</span>
 11393 |     | <span class='neutral'>        bytes32 m5;</span>
 11394 |     | <span class='neutral'>        bytes32 m6;</span>
 11395 |     | <span class='neutral'>        bytes32 m7;</span>
 11396 |     | <span class='neutral'>        bytes32 m8;</span>
 11397 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11398 |     | <span class='neutral'>        assembly {</span>
 11399 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11400 |     | <span class='neutral'>                let length := 0</span>
 11401 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11402 |     | <span class='neutral'>                mstore(pos, length)</span>
 11403 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11404 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11405 |     | <span class='neutral'>            }</span>
 11406 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11407 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11408 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11409 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11410 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11411 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11412 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11413 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11414 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11415 |     | <span class='neutral'>            // Selector of `log(string,address,string,uint256)`.</span>
 11416 |     | <span class='neutral'>            mstore(0x00, 0x91d1112e)</span>
 11417 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11418 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11419 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 11420 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11421 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11422 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 11423 |     | <span class='neutral'>        }</span>
 11424 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11425 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11426 |     | <span class='neutral'>        assembly {</span>
 11427 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11428 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11429 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11430 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11431 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11432 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11433 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11434 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11435 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11436 |     | <span class='neutral'>        }</span>
 11437 |     | <span class='neutral'>    }</span>
 11438 |     | <span class='neutral'></span>
 11439 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {</span>
 11440 |     | <span class='neutral'>        bytes32 m0;</span>
 11441 |     | <span class='neutral'>        bytes32 m1;</span>
 11442 |     | <span class='neutral'>        bytes32 m2;</span>
 11443 |     | <span class='neutral'>        bytes32 m3;</span>
 11444 |     | <span class='neutral'>        bytes32 m4;</span>
 11445 |     | <span class='neutral'>        bytes32 m5;</span>
 11446 |     | <span class='neutral'>        bytes32 m6;</span>
 11447 |     | <span class='neutral'>        bytes32 m7;</span>
 11448 |     | <span class='neutral'>        bytes32 m8;</span>
 11449 |     | <span class='neutral'>        bytes32 m9;</span>
 11450 |     | <span class='neutral'>        bytes32 m10;</span>
 11451 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11452 |     | <span class='neutral'>        assembly {</span>
 11453 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11454 |     | <span class='neutral'>                let length := 0</span>
 11455 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11456 |     | <span class='neutral'>                mstore(pos, length)</span>
 11457 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11458 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11459 |     | <span class='neutral'>            }</span>
 11460 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11461 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11462 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11463 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11464 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11465 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11466 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11467 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11468 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11469 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 11470 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 11471 |     | <span class='neutral'>            // Selector of `log(string,address,string,string)`.</span>
 11472 |     | <span class='neutral'>            mstore(0x00, 0x245986f2)</span>
 11473 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11474 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11475 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 11476 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 11477 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11478 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 11479 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 11480 |     | <span class='neutral'>        }</span>
 11481 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 11482 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11483 |     | <span class='neutral'>        assembly {</span>
 11484 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11485 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11486 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11487 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11488 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11489 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11490 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11491 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11492 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11493 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 11494 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 11495 |     | <span class='neutral'>        }</span>
 11496 |     | <span class='neutral'>    }</span>
 11497 |     | <span class='neutral'></span>
 11498 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2, address p3) internal pure {</span>
 11499 |     | <span class='neutral'>        bytes32 m0;</span>
 11500 |     | <span class='neutral'>        bytes32 m1;</span>
 11501 |     | <span class='neutral'>        bytes32 m2;</span>
 11502 |     | <span class='neutral'>        bytes32 m3;</span>
 11503 |     | <span class='neutral'>        bytes32 m4;</span>
 11504 |     | <span class='neutral'>        bytes32 m5;</span>
 11505 |     | <span class='neutral'>        bytes32 m6;</span>
 11506 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11507 |     | <span class='neutral'>        assembly {</span>
 11508 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11509 |     | <span class='neutral'>                let length := 0</span>
 11510 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11511 |     | <span class='neutral'>                mstore(pos, length)</span>
 11512 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11513 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11514 |     | <span class='neutral'>            }</span>
 11515 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11516 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11517 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11518 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11519 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11520 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11521 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11522 |     | <span class='neutral'>            // Selector of `log(string,bool,address,address)`.</span>
 11523 |     | <span class='neutral'>            mstore(0x00, 0x33e9dd1d)</span>
 11524 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11525 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11526 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11527 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11528 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11529 |     | <span class='neutral'>        }</span>
 11530 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11531 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11532 |     | <span class='neutral'>        assembly {</span>
 11533 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11534 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11535 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11536 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11537 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11538 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11539 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11540 |     | <span class='neutral'>        }</span>
 11541 |     | <span class='neutral'>    }</span>
 11542 |     | <span class='neutral'></span>
 11543 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {</span>
 11544 |     | <span class='neutral'>        bytes32 m0;</span>
 11545 |     | <span class='neutral'>        bytes32 m1;</span>
 11546 |     | <span class='neutral'>        bytes32 m2;</span>
 11547 |     | <span class='neutral'>        bytes32 m3;</span>
 11548 |     | <span class='neutral'>        bytes32 m4;</span>
 11549 |     | <span class='neutral'>        bytes32 m5;</span>
 11550 |     | <span class='neutral'>        bytes32 m6;</span>
 11551 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11552 |     | <span class='neutral'>        assembly {</span>
 11553 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11554 |     | <span class='neutral'>                let length := 0</span>
 11555 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11556 |     | <span class='neutral'>                mstore(pos, length)</span>
 11557 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11558 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11559 |     | <span class='neutral'>            }</span>
 11560 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11561 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11562 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11563 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11564 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11565 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11566 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11567 |     | <span class='neutral'>            // Selector of `log(string,bool,address,bool)`.</span>
 11568 |     | <span class='neutral'>            mstore(0x00, 0x958c28c6)</span>
 11569 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11570 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11571 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11572 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11573 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11574 |     | <span class='neutral'>        }</span>
 11575 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11576 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11577 |     | <span class='neutral'>        assembly {</span>
 11578 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11579 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11580 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11581 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11582 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11583 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11584 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11585 |     | <span class='neutral'>        }</span>
 11586 |     | <span class='neutral'>    }</span>
 11587 |     | <span class='neutral'></span>
 11588 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {</span>
 11589 |     | <span class='neutral'>        bytes32 m0;</span>
 11590 |     | <span class='neutral'>        bytes32 m1;</span>
 11591 |     | <span class='neutral'>        bytes32 m2;</span>
 11592 |     | <span class='neutral'>        bytes32 m3;</span>
 11593 |     | <span class='neutral'>        bytes32 m4;</span>
 11594 |     | <span class='neutral'>        bytes32 m5;</span>
 11595 |     | <span class='neutral'>        bytes32 m6;</span>
 11596 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11597 |     | <span class='neutral'>        assembly {</span>
 11598 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11599 |     | <span class='neutral'>                let length := 0</span>
 11600 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11601 |     | <span class='neutral'>                mstore(pos, length)</span>
 11602 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11603 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11604 |     | <span class='neutral'>            }</span>
 11605 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11606 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11607 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11608 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11609 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11610 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11611 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11612 |     | <span class='neutral'>            // Selector of `log(string,bool,address,uint256)`.</span>
 11613 |     | <span class='neutral'>            mstore(0x00, 0x5d08bb05)</span>
 11614 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11615 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11616 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11617 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11618 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11619 |     | <span class='neutral'>        }</span>
 11620 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11621 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11622 |     | <span class='neutral'>        assembly {</span>
 11623 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11624 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11625 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11626 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11627 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11628 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11629 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11630 |     | <span class='neutral'>        }</span>
 11631 |     | <span class='neutral'>    }</span>
 11632 |     | <span class='neutral'></span>
 11633 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {</span>
 11634 |     | <span class='neutral'>        bytes32 m0;</span>
 11635 |     | <span class='neutral'>        bytes32 m1;</span>
 11636 |     | <span class='neutral'>        bytes32 m2;</span>
 11637 |     | <span class='neutral'>        bytes32 m3;</span>
 11638 |     | <span class='neutral'>        bytes32 m4;</span>
 11639 |     | <span class='neutral'>        bytes32 m5;</span>
 11640 |     | <span class='neutral'>        bytes32 m6;</span>
 11641 |     | <span class='neutral'>        bytes32 m7;</span>
 11642 |     | <span class='neutral'>        bytes32 m8;</span>
 11643 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11644 |     | <span class='neutral'>        assembly {</span>
 11645 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11646 |     | <span class='neutral'>                let length := 0</span>
 11647 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11648 |     | <span class='neutral'>                mstore(pos, length)</span>
 11649 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11650 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11651 |     | <span class='neutral'>            }</span>
 11652 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11653 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11654 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11655 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11656 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11657 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11658 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11659 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11660 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11661 |     | <span class='neutral'>            // Selector of `log(string,bool,address,string)`.</span>
 11662 |     | <span class='neutral'>            mstore(0x00, 0x2d8e33a4)</span>
 11663 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11664 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11665 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11666 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11667 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11668 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11669 |     | <span class='neutral'>        }</span>
 11670 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11671 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11672 |     | <span class='neutral'>        assembly {</span>
 11673 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11674 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11675 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11676 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11677 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11678 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11679 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11680 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11681 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11682 |     | <span class='neutral'>        }</span>
 11683 |     | <span class='neutral'>    }</span>
 11684 |     | <span class='neutral'></span>
 11685 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {</span>
 11686 |     | <span class='neutral'>        bytes32 m0;</span>
 11687 |     | <span class='neutral'>        bytes32 m1;</span>
 11688 |     | <span class='neutral'>        bytes32 m2;</span>
 11689 |     | <span class='neutral'>        bytes32 m3;</span>
 11690 |     | <span class='neutral'>        bytes32 m4;</span>
 11691 |     | <span class='neutral'>        bytes32 m5;</span>
 11692 |     | <span class='neutral'>        bytes32 m6;</span>
 11693 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11694 |     | <span class='neutral'>        assembly {</span>
 11695 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11696 |     | <span class='neutral'>                let length := 0</span>
 11697 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11698 |     | <span class='neutral'>                mstore(pos, length)</span>
 11699 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11700 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11701 |     | <span class='neutral'>            }</span>
 11702 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11703 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11704 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11705 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11706 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11707 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11708 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11709 |     | <span class='neutral'>            // Selector of `log(string,bool,bool,address)`.</span>
 11710 |     | <span class='neutral'>            mstore(0x00, 0x7190a529)</span>
 11711 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11712 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11713 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11714 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11715 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11716 |     | <span class='neutral'>        }</span>
 11717 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11718 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11719 |     | <span class='neutral'>        assembly {</span>
 11720 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11721 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11722 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11723 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11724 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11725 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11726 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11727 |     | <span class='neutral'>        }</span>
 11728 |     | <span class='neutral'>    }</span>
 11729 |     | <span class='neutral'></span>
 11730 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {</span>
 11731 |     | <span class='neutral'>        bytes32 m0;</span>
 11732 |     | <span class='neutral'>        bytes32 m1;</span>
 11733 |     | <span class='neutral'>        bytes32 m2;</span>
 11734 |     | <span class='neutral'>        bytes32 m3;</span>
 11735 |     | <span class='neutral'>        bytes32 m4;</span>
 11736 |     | <span class='neutral'>        bytes32 m5;</span>
 11737 |     | <span class='neutral'>        bytes32 m6;</span>
 11738 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11739 |     | <span class='neutral'>        assembly {</span>
 11740 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11741 |     | <span class='neutral'>                let length := 0</span>
 11742 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11743 |     | <span class='neutral'>                mstore(pos, length)</span>
 11744 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11745 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11746 |     | <span class='neutral'>            }</span>
 11747 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11748 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11749 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11750 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11751 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11752 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11753 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11754 |     | <span class='neutral'>            // Selector of `log(string,bool,bool,bool)`.</span>
 11755 |     | <span class='neutral'>            mstore(0x00, 0x895af8c5)</span>
 11756 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11757 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11758 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11759 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11760 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11761 |     | <span class='neutral'>        }</span>
 11762 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11763 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11764 |     | <span class='neutral'>        assembly {</span>
 11765 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11766 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11767 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11768 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11769 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11770 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11771 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11772 |     | <span class='neutral'>        }</span>
 11773 |     | <span class='neutral'>    }</span>
 11774 |     | <span class='neutral'></span>
 11775 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {</span>
 11776 |     | <span class='neutral'>        bytes32 m0;</span>
 11777 |     | <span class='neutral'>        bytes32 m1;</span>
 11778 |     | <span class='neutral'>        bytes32 m2;</span>
 11779 |     | <span class='neutral'>        bytes32 m3;</span>
 11780 |     | <span class='neutral'>        bytes32 m4;</span>
 11781 |     | <span class='neutral'>        bytes32 m5;</span>
 11782 |     | <span class='neutral'>        bytes32 m6;</span>
 11783 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11784 |     | <span class='neutral'>        assembly {</span>
 11785 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11786 |     | <span class='neutral'>                let length := 0</span>
 11787 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11788 |     | <span class='neutral'>                mstore(pos, length)</span>
 11789 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11790 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11791 |     | <span class='neutral'>            }</span>
 11792 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11793 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11794 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11795 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11796 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11797 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11798 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11799 |     | <span class='neutral'>            // Selector of `log(string,bool,bool,uint256)`.</span>
 11800 |     | <span class='neutral'>            mstore(0x00, 0x8e3f78a9)</span>
 11801 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11802 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11803 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11804 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11805 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11806 |     | <span class='neutral'>        }</span>
 11807 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11808 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11809 |     | <span class='neutral'>        assembly {</span>
 11810 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11811 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11812 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11813 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11814 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11815 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11816 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11817 |     | <span class='neutral'>        }</span>
 11818 |     | <span class='neutral'>    }</span>
 11819 |     | <span class='neutral'></span>
 11820 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {</span>
 11821 |     | <span class='neutral'>        bytes32 m0;</span>
 11822 |     | <span class='neutral'>        bytes32 m1;</span>
 11823 |     | <span class='neutral'>        bytes32 m2;</span>
 11824 |     | <span class='neutral'>        bytes32 m3;</span>
 11825 |     | <span class='neutral'>        bytes32 m4;</span>
 11826 |     | <span class='neutral'>        bytes32 m5;</span>
 11827 |     | <span class='neutral'>        bytes32 m6;</span>
 11828 |     | <span class='neutral'>        bytes32 m7;</span>
 11829 |     | <span class='neutral'>        bytes32 m8;</span>
 11830 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11831 |     | <span class='neutral'>        assembly {</span>
 11832 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11833 |     | <span class='neutral'>                let length := 0</span>
 11834 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11835 |     | <span class='neutral'>                mstore(pos, length)</span>
 11836 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11837 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11838 |     | <span class='neutral'>            }</span>
 11839 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11840 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11841 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11842 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11843 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11844 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11845 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11846 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11847 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11848 |     | <span class='neutral'>            // Selector of `log(string,bool,bool,string)`.</span>
 11849 |     | <span class='neutral'>            mstore(0x00, 0x9d22d5dd)</span>
 11850 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11851 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11852 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11853 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11854 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11855 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11856 |     | <span class='neutral'>        }</span>
 11857 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11858 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11859 |     | <span class='neutral'>        assembly {</span>
 11860 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11861 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11862 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11863 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11864 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11865 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11866 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11867 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11868 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11869 |     | <span class='neutral'>        }</span>
 11870 |     | <span class='neutral'>    }</span>
 11871 |     | <span class='neutral'></span>
 11872 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {</span>
 11873 |     | <span class='neutral'>        bytes32 m0;</span>
 11874 |     | <span class='neutral'>        bytes32 m1;</span>
 11875 |     | <span class='neutral'>        bytes32 m2;</span>
 11876 |     | <span class='neutral'>        bytes32 m3;</span>
 11877 |     | <span class='neutral'>        bytes32 m4;</span>
 11878 |     | <span class='neutral'>        bytes32 m5;</span>
 11879 |     | <span class='neutral'>        bytes32 m6;</span>
 11880 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11881 |     | <span class='neutral'>        assembly {</span>
 11882 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11883 |     | <span class='neutral'>                let length := 0</span>
 11884 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11885 |     | <span class='neutral'>                mstore(pos, length)</span>
 11886 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11887 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11888 |     | <span class='neutral'>            }</span>
 11889 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11890 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11891 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11892 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11893 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11894 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11895 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11896 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256,address)`.</span>
 11897 |     | <span class='neutral'>            mstore(0x00, 0x935e09bf)</span>
 11898 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11899 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11900 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11901 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11902 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11903 |     | <span class='neutral'>        }</span>
 11904 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11905 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11906 |     | <span class='neutral'>        assembly {</span>
 11907 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11908 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11909 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11910 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11911 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11912 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11913 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11914 |     | <span class='neutral'>        }</span>
 11915 |     | <span class='neutral'>    }</span>
 11916 |     | <span class='neutral'></span>
 11917 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {</span>
 11918 |     | <span class='neutral'>        bytes32 m0;</span>
 11919 |     | <span class='neutral'>        bytes32 m1;</span>
 11920 |     | <span class='neutral'>        bytes32 m2;</span>
 11921 |     | <span class='neutral'>        bytes32 m3;</span>
 11922 |     | <span class='neutral'>        bytes32 m4;</span>
 11923 |     | <span class='neutral'>        bytes32 m5;</span>
 11924 |     | <span class='neutral'>        bytes32 m6;</span>
 11925 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11926 |     | <span class='neutral'>        assembly {</span>
 11927 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11928 |     | <span class='neutral'>                let length := 0</span>
 11929 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11930 |     | <span class='neutral'>                mstore(pos, length)</span>
 11931 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11932 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11933 |     | <span class='neutral'>            }</span>
 11934 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11935 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11936 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11937 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11938 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11939 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11940 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11941 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256,bool)`.</span>
 11942 |     | <span class='neutral'>            mstore(0x00, 0x8af7cf8a)</span>
 11943 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11944 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11945 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11946 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11947 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11948 |     | <span class='neutral'>        }</span>
 11949 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11950 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11951 |     | <span class='neutral'>        assembly {</span>
 11952 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11953 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11954 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11955 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11956 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11957 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11958 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11959 |     | <span class='neutral'>        }</span>
 11960 |     | <span class='neutral'>    }</span>
 11961 |     | <span class='neutral'></span>
 11962 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
 11963 |     | <span class='neutral'>        bytes32 m0;</span>
 11964 |     | <span class='neutral'>        bytes32 m1;</span>
 11965 |     | <span class='neutral'>        bytes32 m2;</span>
 11966 |     | <span class='neutral'>        bytes32 m3;</span>
 11967 |     | <span class='neutral'>        bytes32 m4;</span>
 11968 |     | <span class='neutral'>        bytes32 m5;</span>
 11969 |     | <span class='neutral'>        bytes32 m6;</span>
 11970 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11971 |     | <span class='neutral'>        assembly {</span>
 11972 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11973 |     | <span class='neutral'>                let length := 0</span>
 11974 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11975 |     | <span class='neutral'>                mstore(pos, length)</span>
 11976 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11977 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11978 |     | <span class='neutral'>            }</span>
 11979 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11980 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11981 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11982 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11983 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11984 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11985 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11986 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256,uint256)`.</span>
 11987 |     | <span class='neutral'>            mstore(0x00, 0x64b5bb67)</span>
 11988 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11989 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11990 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11991 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11992 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11993 |     | <span class='neutral'>        }</span>
 11994 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11995 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 11996 |     | <span class='neutral'>        assembly {</span>
 11997 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11998 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11999 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12000 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12001 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12002 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12003 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12004 |     | <span class='neutral'>        }</span>
 12005 |     | <span class='neutral'>    }</span>
 12006 |     | <span class='neutral'></span>
 12007 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {</span>
 12008 |     | <span class='neutral'>        bytes32 m0;</span>
 12009 |     | <span class='neutral'>        bytes32 m1;</span>
 12010 |     | <span class='neutral'>        bytes32 m2;</span>
 12011 |     | <span class='neutral'>        bytes32 m3;</span>
 12012 |     | <span class='neutral'>        bytes32 m4;</span>
 12013 |     | <span class='neutral'>        bytes32 m5;</span>
 12014 |     | <span class='neutral'>        bytes32 m6;</span>
 12015 |     | <span class='neutral'>        bytes32 m7;</span>
 12016 |     | <span class='neutral'>        bytes32 m8;</span>
 12017 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12018 |     | <span class='neutral'>        assembly {</span>
 12019 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12020 |     | <span class='neutral'>                let length := 0</span>
 12021 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12022 |     | <span class='neutral'>                mstore(pos, length)</span>
 12023 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12024 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12025 |     | <span class='neutral'>            }</span>
 12026 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12027 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12028 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12029 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12030 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12031 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12032 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12033 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12034 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12035 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256,string)`.</span>
 12036 |     | <span class='neutral'>            mstore(0x00, 0x742d6ee7)</span>
 12037 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12038 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12039 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12040 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 12041 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12042 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 12043 |     | <span class='neutral'>        }</span>
 12044 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12045 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12046 |     | <span class='neutral'>        assembly {</span>
 12047 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12048 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12049 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12050 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12051 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12052 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12053 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12054 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12055 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12056 |     | <span class='neutral'>        }</span>
 12057 |     | <span class='neutral'>    }</span>
 12058 |     | <span class='neutral'></span>
 12059 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {</span>
 12060 |     | <span class='neutral'>        bytes32 m0;</span>
 12061 |     | <span class='neutral'>        bytes32 m1;</span>
 12062 |     | <span class='neutral'>        bytes32 m2;</span>
 12063 |     | <span class='neutral'>        bytes32 m3;</span>
 12064 |     | <span class='neutral'>        bytes32 m4;</span>
 12065 |     | <span class='neutral'>        bytes32 m5;</span>
 12066 |     | <span class='neutral'>        bytes32 m6;</span>
 12067 |     | <span class='neutral'>        bytes32 m7;</span>
 12068 |     | <span class='neutral'>        bytes32 m8;</span>
 12069 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12070 |     | <span class='neutral'>        assembly {</span>
 12071 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12072 |     | <span class='neutral'>                let length := 0</span>
 12073 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12074 |     | <span class='neutral'>                mstore(pos, length)</span>
 12075 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12076 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12077 |     | <span class='neutral'>            }</span>
 12078 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12079 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12080 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12081 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12082 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12083 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12084 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12085 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12086 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12087 |     | <span class='neutral'>            // Selector of `log(string,bool,string,address)`.</span>
 12088 |     | <span class='neutral'>            mstore(0x00, 0xe0625b29)</span>
 12089 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12090 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12091 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12092 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12093 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12094 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12095 |     | <span class='neutral'>        }</span>
 12096 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12097 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12098 |     | <span class='neutral'>        assembly {</span>
 12099 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12100 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12101 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12102 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12103 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12104 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12105 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12106 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12107 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12108 |     | <span class='neutral'>        }</span>
 12109 |     | <span class='neutral'>    }</span>
 12110 |     | <span class='neutral'></span>
 12111 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {</span>
 12112 |     | <span class='neutral'>        bytes32 m0;</span>
 12113 |     | <span class='neutral'>        bytes32 m1;</span>
 12114 |     | <span class='neutral'>        bytes32 m2;</span>
 12115 |     | <span class='neutral'>        bytes32 m3;</span>
 12116 |     | <span class='neutral'>        bytes32 m4;</span>
 12117 |     | <span class='neutral'>        bytes32 m5;</span>
 12118 |     | <span class='neutral'>        bytes32 m6;</span>
 12119 |     | <span class='neutral'>        bytes32 m7;</span>
 12120 |     | <span class='neutral'>        bytes32 m8;</span>
 12121 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12122 |     | <span class='neutral'>        assembly {</span>
 12123 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12124 |     | <span class='neutral'>                let length := 0</span>
 12125 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12126 |     | <span class='neutral'>                mstore(pos, length)</span>
 12127 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12128 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12129 |     | <span class='neutral'>            }</span>
 12130 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12131 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12132 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12133 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12134 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12135 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12136 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12137 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12138 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12139 |     | <span class='neutral'>            // Selector of `log(string,bool,string,bool)`.</span>
 12140 |     | <span class='neutral'>            mstore(0x00, 0x3f8a701d)</span>
 12141 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12142 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12143 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12144 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12145 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12146 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12147 |     | <span class='neutral'>        }</span>
 12148 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12149 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12150 |     | <span class='neutral'>        assembly {</span>
 12151 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12152 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12153 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12154 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12155 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12156 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12157 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12158 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12159 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12160 |     | <span class='neutral'>        }</span>
 12161 |     | <span class='neutral'>    }</span>
 12162 |     | <span class='neutral'></span>
 12163 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {</span>
 12164 |     | <span class='neutral'>        bytes32 m0;</span>
 12165 |     | <span class='neutral'>        bytes32 m1;</span>
 12166 |     | <span class='neutral'>        bytes32 m2;</span>
 12167 |     | <span class='neutral'>        bytes32 m3;</span>
 12168 |     | <span class='neutral'>        bytes32 m4;</span>
 12169 |     | <span class='neutral'>        bytes32 m5;</span>
 12170 |     | <span class='neutral'>        bytes32 m6;</span>
 12171 |     | <span class='neutral'>        bytes32 m7;</span>
 12172 |     | <span class='neutral'>        bytes32 m8;</span>
 12173 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12174 |     | <span class='neutral'>        assembly {</span>
 12175 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12176 |     | <span class='neutral'>                let length := 0</span>
 12177 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12178 |     | <span class='neutral'>                mstore(pos, length)</span>
 12179 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12180 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12181 |     | <span class='neutral'>            }</span>
 12182 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12183 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12184 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12185 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12186 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12187 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12188 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12189 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12190 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12191 |     | <span class='neutral'>            // Selector of `log(string,bool,string,uint256)`.</span>
 12192 |     | <span class='neutral'>            mstore(0x00, 0x24f91465)</span>
 12193 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12194 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12195 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12196 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12197 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12198 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12199 |     | <span class='neutral'>        }</span>
 12200 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12201 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12202 |     | <span class='neutral'>        assembly {</span>
 12203 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12204 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12205 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12206 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12207 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12208 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12209 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12210 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12211 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12212 |     | <span class='neutral'>        }</span>
 12213 |     | <span class='neutral'>    }</span>
 12214 |     | <span class='neutral'></span>
 12215 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {</span>
 12216 |     | <span class='neutral'>        bytes32 m0;</span>
 12217 |     | <span class='neutral'>        bytes32 m1;</span>
 12218 |     | <span class='neutral'>        bytes32 m2;</span>
 12219 |     | <span class='neutral'>        bytes32 m3;</span>
 12220 |     | <span class='neutral'>        bytes32 m4;</span>
 12221 |     | <span class='neutral'>        bytes32 m5;</span>
 12222 |     | <span class='neutral'>        bytes32 m6;</span>
 12223 |     | <span class='neutral'>        bytes32 m7;</span>
 12224 |     | <span class='neutral'>        bytes32 m8;</span>
 12225 |     | <span class='neutral'>        bytes32 m9;</span>
 12226 |     | <span class='neutral'>        bytes32 m10;</span>
 12227 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12228 |     | <span class='neutral'>        assembly {</span>
 12229 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12230 |     | <span class='neutral'>                let length := 0</span>
 12231 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12232 |     | <span class='neutral'>                mstore(pos, length)</span>
 12233 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12234 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12235 |     | <span class='neutral'>            }</span>
 12236 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12237 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12238 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12239 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12240 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12241 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12242 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12243 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12244 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12245 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 12246 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 12247 |     | <span class='neutral'>            // Selector of `log(string,bool,string,string)`.</span>
 12248 |     | <span class='neutral'>            mstore(0x00, 0xa826caeb)</span>
 12249 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12250 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12251 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12252 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 12253 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12254 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12255 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 12256 |     | <span class='neutral'>        }</span>
 12257 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 12258 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12259 |     | <span class='neutral'>        assembly {</span>
 12260 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12261 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12262 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12263 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12264 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12265 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12266 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12267 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12268 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12269 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 12270 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 12271 |     | <span class='neutral'>        }</span>
 12272 |     | <span class='neutral'>    }</span>
 12273 |     | <span class='neutral'></span>
 12274 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {</span>
 12275 |     | <span class='neutral'>        bytes32 m0;</span>
 12276 |     | <span class='neutral'>        bytes32 m1;</span>
 12277 |     | <span class='neutral'>        bytes32 m2;</span>
 12278 |     | <span class='neutral'>        bytes32 m3;</span>
 12279 |     | <span class='neutral'>        bytes32 m4;</span>
 12280 |     | <span class='neutral'>        bytes32 m5;</span>
 12281 |     | <span class='neutral'>        bytes32 m6;</span>
 12282 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12283 |     | <span class='neutral'>        assembly {</span>
 12284 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12285 |     | <span class='neutral'>                let length := 0</span>
 12286 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12287 |     | <span class='neutral'>                mstore(pos, length)</span>
 12288 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12289 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12290 |     | <span class='neutral'>            }</span>
 12291 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12292 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12293 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12294 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12295 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12296 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12297 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12298 |     | <span class='neutral'>            // Selector of `log(string,uint256,address,address)`.</span>
 12299 |     | <span class='neutral'>            mstore(0x00, 0x5ea2b7ae)</span>
 12300 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12301 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12302 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12303 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12304 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12305 |     | <span class='neutral'>        }</span>
 12306 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12307 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12308 |     | <span class='neutral'>        assembly {</span>
 12309 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12310 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12311 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12312 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12313 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12314 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12315 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12316 |     | <span class='neutral'>        }</span>
 12317 |     | <span class='neutral'>    }</span>
 12318 |     | <span class='neutral'></span>
 12319 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {</span>
 12320 |     | <span class='neutral'>        bytes32 m0;</span>
 12321 |     | <span class='neutral'>        bytes32 m1;</span>
 12322 |     | <span class='neutral'>        bytes32 m2;</span>
 12323 |     | <span class='neutral'>        bytes32 m3;</span>
 12324 |     | <span class='neutral'>        bytes32 m4;</span>
 12325 |     | <span class='neutral'>        bytes32 m5;</span>
 12326 |     | <span class='neutral'>        bytes32 m6;</span>
 12327 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12328 |     | <span class='neutral'>        assembly {</span>
 12329 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12330 |     | <span class='neutral'>                let length := 0</span>
 12331 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12332 |     | <span class='neutral'>                mstore(pos, length)</span>
 12333 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12334 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12335 |     | <span class='neutral'>            }</span>
 12336 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12337 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12338 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12339 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12340 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12341 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12342 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12343 |     | <span class='neutral'>            // Selector of `log(string,uint256,address,bool)`.</span>
 12344 |     | <span class='neutral'>            mstore(0x00, 0x82112a42)</span>
 12345 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12346 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12347 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12348 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12349 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12350 |     | <span class='neutral'>        }</span>
 12351 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12352 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12353 |     | <span class='neutral'>        assembly {</span>
 12354 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12355 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12356 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12357 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12358 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12359 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12360 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12361 |     | <span class='neutral'>        }</span>
 12362 |     | <span class='neutral'>    }</span>
 12363 |     | <span class='neutral'></span>
 12364 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
 12365 |     | <span class='neutral'>        bytes32 m0;</span>
 12366 |     | <span class='neutral'>        bytes32 m1;</span>
 12367 |     | <span class='neutral'>        bytes32 m2;</span>
 12368 |     | <span class='neutral'>        bytes32 m3;</span>
 12369 |     | <span class='neutral'>        bytes32 m4;</span>
 12370 |     | <span class='neutral'>        bytes32 m5;</span>
 12371 |     | <span class='neutral'>        bytes32 m6;</span>
 12372 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12373 |     | <span class='neutral'>        assembly {</span>
 12374 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12375 |     | <span class='neutral'>                let length := 0</span>
 12376 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12377 |     | <span class='neutral'>                mstore(pos, length)</span>
 12378 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12379 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12380 |     | <span class='neutral'>            }</span>
 12381 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12382 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12383 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12384 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12385 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12386 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12387 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12388 |     | <span class='neutral'>            // Selector of `log(string,uint256,address,uint256)`.</span>
 12389 |     | <span class='neutral'>            mstore(0x00, 0x4f04fdc6)</span>
 12390 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12391 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12392 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12393 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12394 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12395 |     | <span class='neutral'>        }</span>
 12396 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12397 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12398 |     | <span class='neutral'>        assembly {</span>
 12399 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12400 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12401 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12402 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12403 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12404 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12405 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12406 |     | <span class='neutral'>        }</span>
 12407 |     | <span class='neutral'>    }</span>
 12408 |     | <span class='neutral'></span>
 12409 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {</span>
 12410 |     | <span class='neutral'>        bytes32 m0;</span>
 12411 |     | <span class='neutral'>        bytes32 m1;</span>
 12412 |     | <span class='neutral'>        bytes32 m2;</span>
 12413 |     | <span class='neutral'>        bytes32 m3;</span>
 12414 |     | <span class='neutral'>        bytes32 m4;</span>
 12415 |     | <span class='neutral'>        bytes32 m5;</span>
 12416 |     | <span class='neutral'>        bytes32 m6;</span>
 12417 |     | <span class='neutral'>        bytes32 m7;</span>
 12418 |     | <span class='neutral'>        bytes32 m8;</span>
 12419 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12420 |     | <span class='neutral'>        assembly {</span>
 12421 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12422 |     | <span class='neutral'>                let length := 0</span>
 12423 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12424 |     | <span class='neutral'>                mstore(pos, length)</span>
 12425 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12426 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12427 |     | <span class='neutral'>            }</span>
 12428 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12429 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12430 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12431 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12432 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12433 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12434 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12435 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12436 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12437 |     | <span class='neutral'>            // Selector of `log(string,uint256,address,string)`.</span>
 12438 |     | <span class='neutral'>            mstore(0x00, 0x9ffb2f93)</span>
 12439 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12440 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12441 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12442 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 12443 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12444 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 12445 |     | <span class='neutral'>        }</span>
 12446 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12447 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12448 |     | <span class='neutral'>        assembly {</span>
 12449 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12450 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12451 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12452 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12453 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12454 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12455 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12456 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12457 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12458 |     | <span class='neutral'>        }</span>
 12459 |     | <span class='neutral'>    }</span>
 12460 |     | <span class='neutral'></span>
 12461 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {</span>
 12462 |     | <span class='neutral'>        bytes32 m0;</span>
 12463 |     | <span class='neutral'>        bytes32 m1;</span>
 12464 |     | <span class='neutral'>        bytes32 m2;</span>
 12465 |     | <span class='neutral'>        bytes32 m3;</span>
 12466 |     | <span class='neutral'>        bytes32 m4;</span>
 12467 |     | <span class='neutral'>        bytes32 m5;</span>
 12468 |     | <span class='neutral'>        bytes32 m6;</span>
 12469 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12470 |     | <span class='neutral'>        assembly {</span>
 12471 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12472 |     | <span class='neutral'>                let length := 0</span>
 12473 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12474 |     | <span class='neutral'>                mstore(pos, length)</span>
 12475 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12476 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12477 |     | <span class='neutral'>            }</span>
 12478 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12479 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12480 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12481 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12482 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12483 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12484 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12485 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool,address)`.</span>
 12486 |     | <span class='neutral'>            mstore(0x00, 0xe0e95b98)</span>
 12487 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12488 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12489 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12490 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12491 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12492 |     | <span class='neutral'>        }</span>
 12493 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12494 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12495 |     | <span class='neutral'>        assembly {</span>
 12496 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12497 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12498 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12499 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12500 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12501 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12502 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12503 |     | <span class='neutral'>        }</span>
 12504 |     | <span class='neutral'>    }</span>
 12505 |     | <span class='neutral'></span>
 12506 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {</span>
 12507 |     | <span class='neutral'>        bytes32 m0;</span>
 12508 |     | <span class='neutral'>        bytes32 m1;</span>
 12509 |     | <span class='neutral'>        bytes32 m2;</span>
 12510 |     | <span class='neutral'>        bytes32 m3;</span>
 12511 |     | <span class='neutral'>        bytes32 m4;</span>
 12512 |     | <span class='neutral'>        bytes32 m5;</span>
 12513 |     | <span class='neutral'>        bytes32 m6;</span>
 12514 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12515 |     | <span class='neutral'>        assembly {</span>
 12516 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12517 |     | <span class='neutral'>                let length := 0</span>
 12518 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12519 |     | <span class='neutral'>                mstore(pos, length)</span>
 12520 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12521 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12522 |     | <span class='neutral'>            }</span>
 12523 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12524 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12525 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12526 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12527 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12528 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12529 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12530 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool,bool)`.</span>
 12531 |     | <span class='neutral'>            mstore(0x00, 0x354c36d6)</span>
 12532 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12533 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12534 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12535 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12536 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12537 |     | <span class='neutral'>        }</span>
 12538 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12539 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12540 |     | <span class='neutral'>        assembly {</span>
 12541 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12542 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12543 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12544 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12545 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12546 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12547 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12548 |     | <span class='neutral'>        }</span>
 12549 |     | <span class='neutral'>    }</span>
 12550 |     | <span class='neutral'></span>
 12551 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
 12552 |     | <span class='neutral'>        bytes32 m0;</span>
 12553 |     | <span class='neutral'>        bytes32 m1;</span>
 12554 |     | <span class='neutral'>        bytes32 m2;</span>
 12555 |     | <span class='neutral'>        bytes32 m3;</span>
 12556 |     | <span class='neutral'>        bytes32 m4;</span>
 12557 |     | <span class='neutral'>        bytes32 m5;</span>
 12558 |     | <span class='neutral'>        bytes32 m6;</span>
 12559 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12560 |     | <span class='neutral'>        assembly {</span>
 12561 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12562 |     | <span class='neutral'>                let length := 0</span>
 12563 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12564 |     | <span class='neutral'>                mstore(pos, length)</span>
 12565 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12566 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12567 |     | <span class='neutral'>            }</span>
 12568 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12569 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12570 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12571 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12572 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12573 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12574 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12575 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool,uint256)`.</span>
 12576 |     | <span class='neutral'>            mstore(0x00, 0xe41b6f6f)</span>
 12577 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12578 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12579 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12580 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12581 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12582 |     | <span class='neutral'>        }</span>
 12583 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12584 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12585 |     | <span class='neutral'>        assembly {</span>
 12586 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12587 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12588 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12589 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12590 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12591 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12592 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12593 |     | <span class='neutral'>        }</span>
 12594 |     | <span class='neutral'>    }</span>
 12595 |     | <span class='neutral'></span>
 12596 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {</span>
 12597 |     | <span class='neutral'>        bytes32 m0;</span>
 12598 |     | <span class='neutral'>        bytes32 m1;</span>
 12599 |     | <span class='neutral'>        bytes32 m2;</span>
 12600 |     | <span class='neutral'>        bytes32 m3;</span>
 12601 |     | <span class='neutral'>        bytes32 m4;</span>
 12602 |     | <span class='neutral'>        bytes32 m5;</span>
 12603 |     | <span class='neutral'>        bytes32 m6;</span>
 12604 |     | <span class='neutral'>        bytes32 m7;</span>
 12605 |     | <span class='neutral'>        bytes32 m8;</span>
 12606 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12607 |     | <span class='neutral'>        assembly {</span>
 12608 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12609 |     | <span class='neutral'>                let length := 0</span>
 12610 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12611 |     | <span class='neutral'>                mstore(pos, length)</span>
 12612 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12613 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12614 |     | <span class='neutral'>            }</span>
 12615 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12616 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12617 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12618 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12619 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12620 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12621 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12622 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12623 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12624 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool,string)`.</span>
 12625 |     | <span class='neutral'>            mstore(0x00, 0xabf73a98)</span>
 12626 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12627 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12628 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12629 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 12630 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12631 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 12632 |     | <span class='neutral'>        }</span>
 12633 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12634 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12635 |     | <span class='neutral'>        assembly {</span>
 12636 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12637 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12638 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12639 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12640 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12641 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12642 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12643 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12644 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12645 |     | <span class='neutral'>        }</span>
 12646 |     | <span class='neutral'>    }</span>
 12647 |     | <span class='neutral'></span>
 12648 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
 12649 |     | <span class='neutral'>        bytes32 m0;</span>
 12650 |     | <span class='neutral'>        bytes32 m1;</span>
 12651 |     | <span class='neutral'>        bytes32 m2;</span>
 12652 |     | <span class='neutral'>        bytes32 m3;</span>
 12653 |     | <span class='neutral'>        bytes32 m4;</span>
 12654 |     | <span class='neutral'>        bytes32 m5;</span>
 12655 |     | <span class='neutral'>        bytes32 m6;</span>
 12656 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12657 |     | <span class='neutral'>        assembly {</span>
 12658 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12659 |     | <span class='neutral'>                let length := 0</span>
 12660 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12661 |     | <span class='neutral'>                mstore(pos, length)</span>
 12662 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12663 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12664 |     | <span class='neutral'>            }</span>
 12665 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12666 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12667 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12668 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12669 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12670 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12671 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12672 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256,address)`.</span>
 12673 |     | <span class='neutral'>            mstore(0x00, 0xe21de278)</span>
 12674 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12675 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12676 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12677 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12678 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12679 |     | <span class='neutral'>        }</span>
 12680 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12681 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12682 |     | <span class='neutral'>        assembly {</span>
 12683 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12684 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12685 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12686 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12687 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12688 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12689 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12690 |     | <span class='neutral'>        }</span>
 12691 |     | <span class='neutral'>    }</span>
 12692 |     | <span class='neutral'></span>
 12693 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
 12694 |     | <span class='neutral'>        bytes32 m0;</span>
 12695 |     | <span class='neutral'>        bytes32 m1;</span>
 12696 |     | <span class='neutral'>        bytes32 m2;</span>
 12697 |     | <span class='neutral'>        bytes32 m3;</span>
 12698 |     | <span class='neutral'>        bytes32 m4;</span>
 12699 |     | <span class='neutral'>        bytes32 m5;</span>
 12700 |     | <span class='neutral'>        bytes32 m6;</span>
 12701 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12702 |     | <span class='neutral'>        assembly {</span>
 12703 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12704 |     | <span class='neutral'>                let length := 0</span>
 12705 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12706 |     | <span class='neutral'>                mstore(pos, length)</span>
 12707 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12708 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12709 |     | <span class='neutral'>            }</span>
 12710 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12711 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12712 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12713 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12714 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12715 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12716 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12717 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256,bool)`.</span>
 12718 |     | <span class='neutral'>            mstore(0x00, 0x7626db92)</span>
 12719 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12720 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12721 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12722 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12723 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12724 |     | <span class='neutral'>        }</span>
 12725 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12726 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12727 |     | <span class='neutral'>        assembly {</span>
 12728 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12729 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12730 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12731 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12732 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12733 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12734 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12735 |     | <span class='neutral'>        }</span>
 12736 |     | <span class='neutral'>    }</span>
 12737 |     | <span class='neutral'></span>
 12738 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
 12739 |     | <span class='neutral'>        bytes32 m0;</span>
 12740 |     | <span class='neutral'>        bytes32 m1;</span>
 12741 |     | <span class='neutral'>        bytes32 m2;</span>
 12742 |     | <span class='neutral'>        bytes32 m3;</span>
 12743 |     | <span class='neutral'>        bytes32 m4;</span>
 12744 |     | <span class='neutral'>        bytes32 m5;</span>
 12745 |     | <span class='neutral'>        bytes32 m6;</span>
 12746 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12747 |     | <span class='neutral'>        assembly {</span>
 12748 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12749 |     | <span class='neutral'>                let length := 0</span>
 12750 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12751 |     | <span class='neutral'>                mstore(pos, length)</span>
 12752 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12753 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12754 |     | <span class='neutral'>            }</span>
 12755 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12756 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12757 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12758 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12759 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12760 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12761 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12762 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256,uint256)`.</span>
 12763 |     | <span class='neutral'>            mstore(0x00, 0xa7a87853)</span>
 12764 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12765 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12766 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12767 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12768 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12769 |     | <span class='neutral'>        }</span>
 12770 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12771 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12772 |     | <span class='neutral'>        assembly {</span>
 12773 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12774 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12775 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12776 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12777 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12778 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12779 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12780 |     | <span class='neutral'>        }</span>
 12781 |     | <span class='neutral'>    }</span>
 12782 |     | <span class='neutral'></span>
 12783 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {</span>
 12784 |     | <span class='neutral'>        bytes32 m0;</span>
 12785 |     | <span class='neutral'>        bytes32 m1;</span>
 12786 |     | <span class='neutral'>        bytes32 m2;</span>
 12787 |     | <span class='neutral'>        bytes32 m3;</span>
 12788 |     | <span class='neutral'>        bytes32 m4;</span>
 12789 |     | <span class='neutral'>        bytes32 m5;</span>
 12790 |     | <span class='neutral'>        bytes32 m6;</span>
 12791 |     | <span class='neutral'>        bytes32 m7;</span>
 12792 |     | <span class='neutral'>        bytes32 m8;</span>
 12793 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12794 |     | <span class='neutral'>        assembly {</span>
 12795 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12796 |     | <span class='neutral'>                let length := 0</span>
 12797 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12798 |     | <span class='neutral'>                mstore(pos, length)</span>
 12799 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12800 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12801 |     | <span class='neutral'>            }</span>
 12802 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12803 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12804 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12805 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12806 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12807 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12808 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12809 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12810 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12811 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256,string)`.</span>
 12812 |     | <span class='neutral'>            mstore(0x00, 0x854b3496)</span>
 12813 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12814 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12815 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12816 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 12817 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12818 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 12819 |     | <span class='neutral'>        }</span>
 12820 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12821 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12822 |     | <span class='neutral'>        assembly {</span>
 12823 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12824 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12825 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12826 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12827 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12828 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12829 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12830 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12831 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12832 |     | <span class='neutral'>        }</span>
 12833 |     | <span class='neutral'>    }</span>
 12834 |     | <span class='neutral'></span>
 12835 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {</span>
 12836 |     | <span class='neutral'>        bytes32 m0;</span>
 12837 |     | <span class='neutral'>        bytes32 m1;</span>
 12838 |     | <span class='neutral'>        bytes32 m2;</span>
 12839 |     | <span class='neutral'>        bytes32 m3;</span>
 12840 |     | <span class='neutral'>        bytes32 m4;</span>
 12841 |     | <span class='neutral'>        bytes32 m5;</span>
 12842 |     | <span class='neutral'>        bytes32 m6;</span>
 12843 |     | <span class='neutral'>        bytes32 m7;</span>
 12844 |     | <span class='neutral'>        bytes32 m8;</span>
 12845 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12846 |     | <span class='neutral'>        assembly {</span>
 12847 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12848 |     | <span class='neutral'>                let length := 0</span>
 12849 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12850 |     | <span class='neutral'>                mstore(pos, length)</span>
 12851 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12852 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12853 |     | <span class='neutral'>            }</span>
 12854 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12855 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12856 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12857 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12858 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12859 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12860 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12861 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12862 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12863 |     | <span class='neutral'>            // Selector of `log(string,uint256,string,address)`.</span>
 12864 |     | <span class='neutral'>            mstore(0x00, 0x7c4632a4)</span>
 12865 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12866 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12867 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12868 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12869 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12870 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12871 |     | <span class='neutral'>        }</span>
 12872 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12873 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12874 |     | <span class='neutral'>        assembly {</span>
 12875 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12876 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12877 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12878 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12879 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12880 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12881 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12882 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12883 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12884 |     | <span class='neutral'>        }</span>
 12885 |     | <span class='neutral'>    }</span>
 12886 |     | <span class='neutral'></span>
 12887 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {</span>
 12888 |     | <span class='neutral'>        bytes32 m0;</span>
 12889 |     | <span class='neutral'>        bytes32 m1;</span>
 12890 |     | <span class='neutral'>        bytes32 m2;</span>
 12891 |     | <span class='neutral'>        bytes32 m3;</span>
 12892 |     | <span class='neutral'>        bytes32 m4;</span>
 12893 |     | <span class='neutral'>        bytes32 m5;</span>
 12894 |     | <span class='neutral'>        bytes32 m6;</span>
 12895 |     | <span class='neutral'>        bytes32 m7;</span>
 12896 |     | <span class='neutral'>        bytes32 m8;</span>
 12897 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12898 |     | <span class='neutral'>        assembly {</span>
 12899 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12900 |     | <span class='neutral'>                let length := 0</span>
 12901 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12902 |     | <span class='neutral'>                mstore(pos, length)</span>
 12903 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12904 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12905 |     | <span class='neutral'>            }</span>
 12906 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12907 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12908 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12909 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12910 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12911 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12912 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12913 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12914 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12915 |     | <span class='neutral'>            // Selector of `log(string,uint256,string,bool)`.</span>
 12916 |     | <span class='neutral'>            mstore(0x00, 0x7d24491d)</span>
 12917 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12918 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12919 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12920 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12921 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12922 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12923 |     | <span class='neutral'>        }</span>
 12924 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12925 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12926 |     | <span class='neutral'>        assembly {</span>
 12927 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12928 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12929 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12930 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12931 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12932 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12933 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12934 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12935 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12936 |     | <span class='neutral'>        }</span>
 12937 |     | <span class='neutral'>    }</span>
 12938 |     | <span class='neutral'></span>
 12939 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {</span>
 12940 |     | <span class='neutral'>        bytes32 m0;</span>
 12941 |     | <span class='neutral'>        bytes32 m1;</span>
 12942 |     | <span class='neutral'>        bytes32 m2;</span>
 12943 |     | <span class='neutral'>        bytes32 m3;</span>
 12944 |     | <span class='neutral'>        bytes32 m4;</span>
 12945 |     | <span class='neutral'>        bytes32 m5;</span>
 12946 |     | <span class='neutral'>        bytes32 m6;</span>
 12947 |     | <span class='neutral'>        bytes32 m7;</span>
 12948 |     | <span class='neutral'>        bytes32 m8;</span>
 12949 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12950 |     | <span class='neutral'>        assembly {</span>
 12951 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12952 |     | <span class='neutral'>                let length := 0</span>
 12953 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12954 |     | <span class='neutral'>                mstore(pos, length)</span>
 12955 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12956 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12957 |     | <span class='neutral'>            }</span>
 12958 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12959 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12960 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12961 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12962 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12963 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12964 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12965 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12966 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12967 |     | <span class='neutral'>            // Selector of `log(string,uint256,string,uint256)`.</span>
 12968 |     | <span class='neutral'>            mstore(0x00, 0xc67ea9d1)</span>
 12969 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12970 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12971 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12972 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12973 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12974 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12975 |     | <span class='neutral'>        }</span>
 12976 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12977 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 12978 |     | <span class='neutral'>        assembly {</span>
 12979 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12980 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12981 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12982 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12983 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12984 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12985 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12986 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12987 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12988 |     | <span class='neutral'>        }</span>
 12989 |     | <span class='neutral'>    }</span>
 12990 |     | <span class='neutral'></span>
 12991 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {</span>
 12992 |     | <span class='neutral'>        bytes32 m0;</span>
 12993 |     | <span class='neutral'>        bytes32 m1;</span>
 12994 |     | <span class='neutral'>        bytes32 m2;</span>
 12995 |     | <span class='neutral'>        bytes32 m3;</span>
 12996 |     | <span class='neutral'>        bytes32 m4;</span>
 12997 |     | <span class='neutral'>        bytes32 m5;</span>
 12998 |     | <span class='neutral'>        bytes32 m6;</span>
 12999 |     | <span class='neutral'>        bytes32 m7;</span>
 13000 |     | <span class='neutral'>        bytes32 m8;</span>
 13001 |     | <span class='neutral'>        bytes32 m9;</span>
 13002 |     | <span class='neutral'>        bytes32 m10;</span>
 13003 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13004 |     | <span class='neutral'>        assembly {</span>
 13005 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13006 |     | <span class='neutral'>                let length := 0</span>
 13007 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13008 |     | <span class='neutral'>                mstore(pos, length)</span>
 13009 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13010 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13011 |     | <span class='neutral'>            }</span>
 13012 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13013 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13014 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13015 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13016 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13017 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13018 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13019 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13020 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13021 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13022 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13023 |     | <span class='neutral'>            // Selector of `log(string,uint256,string,string)`.</span>
 13024 |     | <span class='neutral'>            mstore(0x00, 0x5ab84e1f)</span>
 13025 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13026 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 13027 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 13028 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 13029 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13030 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 13031 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 13032 |     | <span class='neutral'>        }</span>
 13033 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13034 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13035 |     | <span class='neutral'>        assembly {</span>
 13036 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13037 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13038 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13039 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13040 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13041 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13042 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13043 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13044 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13045 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13046 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13047 |     | <span class='neutral'>        }</span>
 13048 |     | <span class='neutral'>    }</span>
 13049 |     | <span class='neutral'></span>
 13050 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {</span>
 13051 |     | <span class='neutral'>        bytes32 m0;</span>
 13052 |     | <span class='neutral'>        bytes32 m1;</span>
 13053 |     | <span class='neutral'>        bytes32 m2;</span>
 13054 |     | <span class='neutral'>        bytes32 m3;</span>
 13055 |     | <span class='neutral'>        bytes32 m4;</span>
 13056 |     | <span class='neutral'>        bytes32 m5;</span>
 13057 |     | <span class='neutral'>        bytes32 m6;</span>
 13058 |     | <span class='neutral'>        bytes32 m7;</span>
 13059 |     | <span class='neutral'>        bytes32 m8;</span>
 13060 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13061 |     | <span class='neutral'>        assembly {</span>
 13062 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13063 |     | <span class='neutral'>                let length := 0</span>
 13064 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13065 |     | <span class='neutral'>                mstore(pos, length)</span>
 13066 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13067 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13068 |     | <span class='neutral'>            }</span>
 13069 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13070 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13071 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13072 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13073 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13074 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13075 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13076 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13077 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13078 |     | <span class='neutral'>            // Selector of `log(string,string,address,address)`.</span>
 13079 |     | <span class='neutral'>            mstore(0x00, 0x439c7bef)</span>
 13080 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13081 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13082 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13083 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13084 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13085 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13086 |     | <span class='neutral'>        }</span>
 13087 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13088 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13089 |     | <span class='neutral'>        assembly {</span>
 13090 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13091 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13092 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13093 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13094 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13095 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13096 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13097 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13098 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13099 |     | <span class='neutral'>        }</span>
 13100 |     | <span class='neutral'>    }</span>
 13101 |     | <span class='neutral'></span>
 13102 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {</span>
 13103 |     | <span class='neutral'>        bytes32 m0;</span>
 13104 |     | <span class='neutral'>        bytes32 m1;</span>
 13105 |     | <span class='neutral'>        bytes32 m2;</span>
 13106 |     | <span class='neutral'>        bytes32 m3;</span>
 13107 |     | <span class='neutral'>        bytes32 m4;</span>
 13108 |     | <span class='neutral'>        bytes32 m5;</span>
 13109 |     | <span class='neutral'>        bytes32 m6;</span>
 13110 |     | <span class='neutral'>        bytes32 m7;</span>
 13111 |     | <span class='neutral'>        bytes32 m8;</span>
 13112 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13113 |     | <span class='neutral'>        assembly {</span>
 13114 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13115 |     | <span class='neutral'>                let length := 0</span>
 13116 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13117 |     | <span class='neutral'>                mstore(pos, length)</span>
 13118 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13119 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13120 |     | <span class='neutral'>            }</span>
 13121 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13122 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13123 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13124 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13125 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13126 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13127 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13128 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13129 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13130 |     | <span class='neutral'>            // Selector of `log(string,string,address,bool)`.</span>
 13131 |     | <span class='neutral'>            mstore(0x00, 0x5ccd4e37)</span>
 13132 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13133 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13134 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13135 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13136 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13137 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13138 |     | <span class='neutral'>        }</span>
 13139 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13140 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13141 |     | <span class='neutral'>        assembly {</span>
 13142 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13143 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13144 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13145 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13146 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13147 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13148 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13149 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13150 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13151 |     | <span class='neutral'>        }</span>
 13152 |     | <span class='neutral'>    }</span>
 13153 |     | <span class='neutral'></span>
 13154 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {</span>
 13155 |     | <span class='neutral'>        bytes32 m0;</span>
 13156 |     | <span class='neutral'>        bytes32 m1;</span>
 13157 |     | <span class='neutral'>        bytes32 m2;</span>
 13158 |     | <span class='neutral'>        bytes32 m3;</span>
 13159 |     | <span class='neutral'>        bytes32 m4;</span>
 13160 |     | <span class='neutral'>        bytes32 m5;</span>
 13161 |     | <span class='neutral'>        bytes32 m6;</span>
 13162 |     | <span class='neutral'>        bytes32 m7;</span>
 13163 |     | <span class='neutral'>        bytes32 m8;</span>
 13164 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13165 |     | <span class='neutral'>        assembly {</span>
 13166 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13167 |     | <span class='neutral'>                let length := 0</span>
 13168 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13169 |     | <span class='neutral'>                mstore(pos, length)</span>
 13170 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13171 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13172 |     | <span class='neutral'>            }</span>
 13173 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13174 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13175 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13176 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13177 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13178 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13179 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13180 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13181 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13182 |     | <span class='neutral'>            // Selector of `log(string,string,address,uint256)`.</span>
 13183 |     | <span class='neutral'>            mstore(0x00, 0x7cc3c607)</span>
 13184 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13185 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13186 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13187 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13188 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13189 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13190 |     | <span class='neutral'>        }</span>
 13191 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13192 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13193 |     | <span class='neutral'>        assembly {</span>
 13194 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13195 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13196 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13197 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13198 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13199 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13200 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13201 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13202 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13203 |     | <span class='neutral'>        }</span>
 13204 |     | <span class='neutral'>    }</span>
 13205 |     | <span class='neutral'></span>
 13206 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {</span>
 13207 |     | <span class='neutral'>        bytes32 m0;</span>
 13208 |     | <span class='neutral'>        bytes32 m1;</span>
 13209 |     | <span class='neutral'>        bytes32 m2;</span>
 13210 |     | <span class='neutral'>        bytes32 m3;</span>
 13211 |     | <span class='neutral'>        bytes32 m4;</span>
 13212 |     | <span class='neutral'>        bytes32 m5;</span>
 13213 |     | <span class='neutral'>        bytes32 m6;</span>
 13214 |     | <span class='neutral'>        bytes32 m7;</span>
 13215 |     | <span class='neutral'>        bytes32 m8;</span>
 13216 |     | <span class='neutral'>        bytes32 m9;</span>
 13217 |     | <span class='neutral'>        bytes32 m10;</span>
 13218 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13219 |     | <span class='neutral'>        assembly {</span>
 13220 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13221 |     | <span class='neutral'>                let length := 0</span>
 13222 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13223 |     | <span class='neutral'>                mstore(pos, length)</span>
 13224 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13225 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13226 |     | <span class='neutral'>            }</span>
 13227 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13228 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13229 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13230 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13231 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13232 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13233 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13234 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13235 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13236 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13237 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13238 |     | <span class='neutral'>            // Selector of `log(string,string,address,string)`.</span>
 13239 |     | <span class='neutral'>            mstore(0x00, 0xeb1bff80)</span>
 13240 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13241 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13242 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13243 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 13244 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13245 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13246 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 13247 |     | <span class='neutral'>        }</span>
 13248 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13249 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13250 |     | <span class='neutral'>        assembly {</span>
 13251 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13252 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13253 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13254 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13255 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13256 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13257 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13258 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13259 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13260 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13261 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13262 |     | <span class='neutral'>        }</span>
 13263 |     | <span class='neutral'>    }</span>
 13264 |     | <span class='neutral'></span>
 13265 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {</span>
 13266 |     | <span class='neutral'>        bytes32 m0;</span>
 13267 |     | <span class='neutral'>        bytes32 m1;</span>
 13268 |     | <span class='neutral'>        bytes32 m2;</span>
 13269 |     | <span class='neutral'>        bytes32 m3;</span>
 13270 |     | <span class='neutral'>        bytes32 m4;</span>
 13271 |     | <span class='neutral'>        bytes32 m5;</span>
 13272 |     | <span class='neutral'>        bytes32 m6;</span>
 13273 |     | <span class='neutral'>        bytes32 m7;</span>
 13274 |     | <span class='neutral'>        bytes32 m8;</span>
 13275 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13276 |     | <span class='neutral'>        assembly {</span>
 13277 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13278 |     | <span class='neutral'>                let length := 0</span>
 13279 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13280 |     | <span class='neutral'>                mstore(pos, length)</span>
 13281 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13282 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13283 |     | <span class='neutral'>            }</span>
 13284 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13285 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13286 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13287 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13288 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13289 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13290 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13291 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13292 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13293 |     | <span class='neutral'>            // Selector of `log(string,string,bool,address)`.</span>
 13294 |     | <span class='neutral'>            mstore(0x00, 0xc371c7db)</span>
 13295 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13296 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13297 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13298 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13299 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13300 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13301 |     | <span class='neutral'>        }</span>
 13302 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13303 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13304 |     | <span class='neutral'>        assembly {</span>
 13305 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13306 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13307 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13308 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13309 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13310 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13311 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13312 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13313 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13314 |     | <span class='neutral'>        }</span>
 13315 |     | <span class='neutral'>    }</span>
 13316 |     | <span class='neutral'></span>
 13317 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {</span>
 13318 |     | <span class='neutral'>        bytes32 m0;</span>
 13319 |     | <span class='neutral'>        bytes32 m1;</span>
 13320 |     | <span class='neutral'>        bytes32 m2;</span>
 13321 |     | <span class='neutral'>        bytes32 m3;</span>
 13322 |     | <span class='neutral'>        bytes32 m4;</span>
 13323 |     | <span class='neutral'>        bytes32 m5;</span>
 13324 |     | <span class='neutral'>        bytes32 m6;</span>
 13325 |     | <span class='neutral'>        bytes32 m7;</span>
 13326 |     | <span class='neutral'>        bytes32 m8;</span>
 13327 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13328 |     | <span class='neutral'>        assembly {</span>
 13329 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13330 |     | <span class='neutral'>                let length := 0</span>
 13331 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13332 |     | <span class='neutral'>                mstore(pos, length)</span>
 13333 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13334 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13335 |     | <span class='neutral'>            }</span>
 13336 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13337 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13338 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13339 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13340 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13341 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13342 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13343 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13344 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13345 |     | <span class='neutral'>            // Selector of `log(string,string,bool,bool)`.</span>
 13346 |     | <span class='neutral'>            mstore(0x00, 0x40785869)</span>
 13347 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13348 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13349 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13350 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13351 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13352 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13353 |     | <span class='neutral'>        }</span>
 13354 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13355 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13356 |     | <span class='neutral'>        assembly {</span>
 13357 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13358 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13359 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13360 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13361 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13362 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13363 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13364 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13365 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13366 |     | <span class='neutral'>        }</span>
 13367 |     | <span class='neutral'>    }</span>
 13368 |     | <span class='neutral'></span>
 13369 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {</span>
 13370 |     | <span class='neutral'>        bytes32 m0;</span>
 13371 |     | <span class='neutral'>        bytes32 m1;</span>
 13372 |     | <span class='neutral'>        bytes32 m2;</span>
 13373 |     | <span class='neutral'>        bytes32 m3;</span>
 13374 |     | <span class='neutral'>        bytes32 m4;</span>
 13375 |     | <span class='neutral'>        bytes32 m5;</span>
 13376 |     | <span class='neutral'>        bytes32 m6;</span>
 13377 |     | <span class='neutral'>        bytes32 m7;</span>
 13378 |     | <span class='neutral'>        bytes32 m8;</span>
 13379 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13380 |     | <span class='neutral'>        assembly {</span>
 13381 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13382 |     | <span class='neutral'>                let length := 0</span>
 13383 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13384 |     | <span class='neutral'>                mstore(pos, length)</span>
 13385 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13386 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13387 |     | <span class='neutral'>            }</span>
 13388 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13389 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13390 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13391 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13392 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13393 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13394 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13395 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13396 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13397 |     | <span class='neutral'>            // Selector of `log(string,string,bool,uint256)`.</span>
 13398 |     | <span class='neutral'>            mstore(0x00, 0xd6aefad2)</span>
 13399 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13400 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13401 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13402 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13403 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13404 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13405 |     | <span class='neutral'>        }</span>
 13406 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13407 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13408 |     | <span class='neutral'>        assembly {</span>
 13409 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13410 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13411 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13412 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13413 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13414 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13415 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13416 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13417 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13418 |     | <span class='neutral'>        }</span>
 13419 |     | <span class='neutral'>    }</span>
 13420 |     | <span class='neutral'></span>
 13421 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {</span>
 13422 |     | <span class='neutral'>        bytes32 m0;</span>
 13423 |     | <span class='neutral'>        bytes32 m1;</span>
 13424 |     | <span class='neutral'>        bytes32 m2;</span>
 13425 |     | <span class='neutral'>        bytes32 m3;</span>
 13426 |     | <span class='neutral'>        bytes32 m4;</span>
 13427 |     | <span class='neutral'>        bytes32 m5;</span>
 13428 |     | <span class='neutral'>        bytes32 m6;</span>
 13429 |     | <span class='neutral'>        bytes32 m7;</span>
 13430 |     | <span class='neutral'>        bytes32 m8;</span>
 13431 |     | <span class='neutral'>        bytes32 m9;</span>
 13432 |     | <span class='neutral'>        bytes32 m10;</span>
 13433 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13434 |     | <span class='neutral'>        assembly {</span>
 13435 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13436 |     | <span class='neutral'>                let length := 0</span>
 13437 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13438 |     | <span class='neutral'>                mstore(pos, length)</span>
 13439 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13440 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13441 |     | <span class='neutral'>            }</span>
 13442 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13443 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13444 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13445 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13446 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13447 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13448 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13449 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13450 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13451 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13452 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13453 |     | <span class='neutral'>            // Selector of `log(string,string,bool,string)`.</span>
 13454 |     | <span class='neutral'>            mstore(0x00, 0x5e84b0ea)</span>
 13455 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13456 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13457 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13458 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 13459 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13460 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13461 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 13462 |     | <span class='neutral'>        }</span>
 13463 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13464 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13465 |     | <span class='neutral'>        assembly {</span>
 13466 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13467 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13468 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13469 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13470 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13471 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13472 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13473 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13474 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13475 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13476 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13477 |     | <span class='neutral'>        }</span>
 13478 |     | <span class='neutral'>    }</span>
 13479 |     | <span class='neutral'></span>
 13480 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {</span>
 13481 |     | <span class='neutral'>        bytes32 m0;</span>
 13482 |     | <span class='neutral'>        bytes32 m1;</span>
 13483 |     | <span class='neutral'>        bytes32 m2;</span>
 13484 |     | <span class='neutral'>        bytes32 m3;</span>
 13485 |     | <span class='neutral'>        bytes32 m4;</span>
 13486 |     | <span class='neutral'>        bytes32 m5;</span>
 13487 |     | <span class='neutral'>        bytes32 m6;</span>
 13488 |     | <span class='neutral'>        bytes32 m7;</span>
 13489 |     | <span class='neutral'>        bytes32 m8;</span>
 13490 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13491 |     | <span class='neutral'>        assembly {</span>
 13492 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13493 |     | <span class='neutral'>                let length := 0</span>
 13494 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13495 |     | <span class='neutral'>                mstore(pos, length)</span>
 13496 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13497 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13498 |     | <span class='neutral'>            }</span>
 13499 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13500 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13501 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13502 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13503 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13504 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13505 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13506 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13507 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13508 |     | <span class='neutral'>            // Selector of `log(string,string,uint256,address)`.</span>
 13509 |     | <span class='neutral'>            mstore(0x00, 0x1023f7b2)</span>
 13510 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13511 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13512 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13513 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13514 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13515 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13516 |     | <span class='neutral'>        }</span>
 13517 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13518 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13519 |     | <span class='neutral'>        assembly {</span>
 13520 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13521 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13522 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13523 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13524 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13525 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13526 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13527 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13528 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13529 |     | <span class='neutral'>        }</span>
 13530 |     | <span class='neutral'>    }</span>
 13531 |     | <span class='neutral'></span>
 13532 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {</span>
 13533 |     | <span class='neutral'>        bytes32 m0;</span>
 13534 |     | <span class='neutral'>        bytes32 m1;</span>
 13535 |     | <span class='neutral'>        bytes32 m2;</span>
 13536 |     | <span class='neutral'>        bytes32 m3;</span>
 13537 |     | <span class='neutral'>        bytes32 m4;</span>
 13538 |     | <span class='neutral'>        bytes32 m5;</span>
 13539 |     | <span class='neutral'>        bytes32 m6;</span>
 13540 |     | <span class='neutral'>        bytes32 m7;</span>
 13541 |     | <span class='neutral'>        bytes32 m8;</span>
 13542 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13543 |     | <span class='neutral'>        assembly {</span>
 13544 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13545 |     | <span class='neutral'>                let length := 0</span>
 13546 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13547 |     | <span class='neutral'>                mstore(pos, length)</span>
 13548 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13549 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13550 |     | <span class='neutral'>            }</span>
 13551 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13552 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13553 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13554 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13555 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13556 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13557 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13558 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13559 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13560 |     | <span class='neutral'>            // Selector of `log(string,string,uint256,bool)`.</span>
 13561 |     | <span class='neutral'>            mstore(0x00, 0xc3a8a654)</span>
 13562 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13563 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13564 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13565 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13566 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13567 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13568 |     | <span class='neutral'>        }</span>
 13569 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13570 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13571 |     | <span class='neutral'>        assembly {</span>
 13572 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13573 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13574 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13575 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13576 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13577 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13578 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13579 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13580 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13581 |     | <span class='neutral'>        }</span>
 13582 |     | <span class='neutral'>    }</span>
 13583 |     | <span class='neutral'></span>
 13584 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {</span>
 13585 |     | <span class='neutral'>        bytes32 m0;</span>
 13586 |     | <span class='neutral'>        bytes32 m1;</span>
 13587 |     | <span class='neutral'>        bytes32 m2;</span>
 13588 |     | <span class='neutral'>        bytes32 m3;</span>
 13589 |     | <span class='neutral'>        bytes32 m4;</span>
 13590 |     | <span class='neutral'>        bytes32 m5;</span>
 13591 |     | <span class='neutral'>        bytes32 m6;</span>
 13592 |     | <span class='neutral'>        bytes32 m7;</span>
 13593 |     | <span class='neutral'>        bytes32 m8;</span>
 13594 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13595 |     | <span class='neutral'>        assembly {</span>
 13596 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13597 |     | <span class='neutral'>                let length := 0</span>
 13598 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13599 |     | <span class='neutral'>                mstore(pos, length)</span>
 13600 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13601 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13602 |     | <span class='neutral'>            }</span>
 13603 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13604 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13605 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13606 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13607 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13608 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13609 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13610 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13611 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13612 |     | <span class='neutral'>            // Selector of `log(string,string,uint256,uint256)`.</span>
 13613 |     | <span class='neutral'>            mstore(0x00, 0xf45d7d2c)</span>
 13614 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13615 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13616 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13617 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13618 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13619 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13620 |     | <span class='neutral'>        }</span>
 13621 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 13622 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13623 |     | <span class='neutral'>        assembly {</span>
 13624 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13625 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13626 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13627 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13628 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13629 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13630 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13631 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13632 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13633 |     | <span class='neutral'>        }</span>
 13634 |     | <span class='neutral'>    }</span>
 13635 |     | <span class='neutral'></span>
 13636 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {</span>
 13637 |     | <span class='neutral'>        bytes32 m0;</span>
 13638 |     | <span class='neutral'>        bytes32 m1;</span>
 13639 |     | <span class='neutral'>        bytes32 m2;</span>
 13640 |     | <span class='neutral'>        bytes32 m3;</span>
 13641 |     | <span class='neutral'>        bytes32 m4;</span>
 13642 |     | <span class='neutral'>        bytes32 m5;</span>
 13643 |     | <span class='neutral'>        bytes32 m6;</span>
 13644 |     | <span class='neutral'>        bytes32 m7;</span>
 13645 |     | <span class='neutral'>        bytes32 m8;</span>
 13646 |     | <span class='neutral'>        bytes32 m9;</span>
 13647 |     | <span class='neutral'>        bytes32 m10;</span>
 13648 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13649 |     | <span class='neutral'>        assembly {</span>
 13650 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13651 |     | <span class='neutral'>                let length := 0</span>
 13652 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13653 |     | <span class='neutral'>                mstore(pos, length)</span>
 13654 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13655 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13656 |     | <span class='neutral'>            }</span>
 13657 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13658 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13659 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13660 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13661 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13662 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13663 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13664 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13665 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13666 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13667 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13668 |     | <span class='neutral'>            // Selector of `log(string,string,uint256,string)`.</span>
 13669 |     | <span class='neutral'>            mstore(0x00, 0x5d1a971a)</span>
 13670 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13671 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13672 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 13673 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 13674 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13675 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13676 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 13677 |     | <span class='neutral'>        }</span>
 13678 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13679 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13680 |     | <span class='neutral'>        assembly {</span>
 13681 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13682 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13683 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13684 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13685 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13686 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13687 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13688 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13689 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13690 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13691 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13692 |     | <span class='neutral'>        }</span>
 13693 |     | <span class='neutral'>    }</span>
 13694 |     | <span class='neutral'></span>
 13695 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {</span>
 13696 |     | <span class='neutral'>        bytes32 m0;</span>
 13697 |     | <span class='neutral'>        bytes32 m1;</span>
 13698 |     | <span class='neutral'>        bytes32 m2;</span>
 13699 |     | <span class='neutral'>        bytes32 m3;</span>
 13700 |     | <span class='neutral'>        bytes32 m4;</span>
 13701 |     | <span class='neutral'>        bytes32 m5;</span>
 13702 |     | <span class='neutral'>        bytes32 m6;</span>
 13703 |     | <span class='neutral'>        bytes32 m7;</span>
 13704 |     | <span class='neutral'>        bytes32 m8;</span>
 13705 |     | <span class='neutral'>        bytes32 m9;</span>
 13706 |     | <span class='neutral'>        bytes32 m10;</span>
 13707 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13708 |     | <span class='neutral'>        assembly {</span>
 13709 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13710 |     | <span class='neutral'>                let length := 0</span>
 13711 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13712 |     | <span class='neutral'>                mstore(pos, length)</span>
 13713 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13714 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13715 |     | <span class='neutral'>            }</span>
 13716 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13717 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13718 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13719 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13720 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13721 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13722 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13723 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13724 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13725 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13726 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13727 |     | <span class='neutral'>            // Selector of `log(string,string,string,address)`.</span>
 13728 |     | <span class='neutral'>            mstore(0x00, 0x6d572f44)</span>
 13729 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13730 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13731 |     | <span class='neutral'>            mstore(0x60, 0x100)</span>
 13732 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13733 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13734 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13735 |     | <span class='neutral'>            writeString(0x120, p2)</span>
 13736 |     | <span class='neutral'>        }</span>
 13737 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13738 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13739 |     | <span class='neutral'>        assembly {</span>
 13740 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13741 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13742 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13743 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13744 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13745 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13746 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13747 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13748 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13749 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13750 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13751 |     | <span class='neutral'>        }</span>
 13752 |     | <span class='neutral'>    }</span>
 13753 |     | <span class='neutral'></span>
 13754 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {</span>
 13755 |     | <span class='neutral'>        bytes32 m0;</span>
 13756 |     | <span class='neutral'>        bytes32 m1;</span>
 13757 |     | <span class='neutral'>        bytes32 m2;</span>
 13758 |     | <span class='neutral'>        bytes32 m3;</span>
 13759 |     | <span class='neutral'>        bytes32 m4;</span>
 13760 |     | <span class='neutral'>        bytes32 m5;</span>
 13761 |     | <span class='neutral'>        bytes32 m6;</span>
 13762 |     | <span class='neutral'>        bytes32 m7;</span>
 13763 |     | <span class='neutral'>        bytes32 m8;</span>
 13764 |     | <span class='neutral'>        bytes32 m9;</span>
 13765 |     | <span class='neutral'>        bytes32 m10;</span>
 13766 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13767 |     | <span class='neutral'>        assembly {</span>
 13768 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13769 |     | <span class='neutral'>                let length := 0</span>
 13770 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13771 |     | <span class='neutral'>                mstore(pos, length)</span>
 13772 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13773 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13774 |     | <span class='neutral'>            }</span>
 13775 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13776 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13777 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13778 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13779 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13780 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13781 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13782 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13783 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13784 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13785 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13786 |     | <span class='neutral'>            // Selector of `log(string,string,string,bool)`.</span>
 13787 |     | <span class='neutral'>            mstore(0x00, 0x2c1754ed)</span>
 13788 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13789 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13790 |     | <span class='neutral'>            mstore(0x60, 0x100)</span>
 13791 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13792 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13793 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13794 |     | <span class='neutral'>            writeString(0x120, p2)</span>
 13795 |     | <span class='neutral'>        }</span>
 13796 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13797 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13798 |     | <span class='neutral'>        assembly {</span>
 13799 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13800 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13801 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13802 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13803 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13804 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13805 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13806 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13807 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13808 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13809 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13810 |     | <span class='neutral'>        }</span>
 13811 |     | <span class='neutral'>    }</span>
 13812 |     | <span class='neutral'></span>
 13813 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {</span>
 13814 |     | <span class='neutral'>        bytes32 m0;</span>
 13815 |     | <span class='neutral'>        bytes32 m1;</span>
 13816 |     | <span class='neutral'>        bytes32 m2;</span>
 13817 |     | <span class='neutral'>        bytes32 m3;</span>
 13818 |     | <span class='neutral'>        bytes32 m4;</span>
 13819 |     | <span class='neutral'>        bytes32 m5;</span>
 13820 |     | <span class='neutral'>        bytes32 m6;</span>
 13821 |     | <span class='neutral'>        bytes32 m7;</span>
 13822 |     | <span class='neutral'>        bytes32 m8;</span>
 13823 |     | <span class='neutral'>        bytes32 m9;</span>
 13824 |     | <span class='neutral'>        bytes32 m10;</span>
 13825 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13826 |     | <span class='neutral'>        assembly {</span>
 13827 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13828 |     | <span class='neutral'>                let length := 0</span>
 13829 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13830 |     | <span class='neutral'>                mstore(pos, length)</span>
 13831 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13832 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13833 |     | <span class='neutral'>            }</span>
 13834 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13835 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13836 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13837 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13838 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13839 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13840 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13841 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13842 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13843 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13844 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13845 |     | <span class='neutral'>            // Selector of `log(string,string,string,uint256)`.</span>
 13846 |     | <span class='neutral'>            mstore(0x00, 0x8eafb02b)</span>
 13847 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13848 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13849 |     | <span class='neutral'>            mstore(0x60, 0x100)</span>
 13850 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13851 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13852 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13853 |     | <span class='neutral'>            writeString(0x120, p2)</span>
 13854 |     | <span class='neutral'>        }</span>
 13855 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13856 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13857 |     | <span class='neutral'>        assembly {</span>
 13858 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13859 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13860 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13861 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13862 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13863 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13864 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13865 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13866 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13867 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13868 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13869 |     | <span class='neutral'>        }</span>
 13870 |     | <span class='neutral'>    }</span>
 13871 |     | <span class='neutral'></span>
 13872 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {</span>
 13873 |     | <span class='neutral'>        bytes32 m0;</span>
 13874 |     | <span class='neutral'>        bytes32 m1;</span>
 13875 |     | <span class='neutral'>        bytes32 m2;</span>
 13876 |     | <span class='neutral'>        bytes32 m3;</span>
 13877 |     | <span class='neutral'>        bytes32 m4;</span>
 13878 |     | <span class='neutral'>        bytes32 m5;</span>
 13879 |     | <span class='neutral'>        bytes32 m6;</span>
 13880 |     | <span class='neutral'>        bytes32 m7;</span>
 13881 |     | <span class='neutral'>        bytes32 m8;</span>
 13882 |     | <span class='neutral'>        bytes32 m9;</span>
 13883 |     | <span class='neutral'>        bytes32 m10;</span>
 13884 |     | <span class='neutral'>        bytes32 m11;</span>
 13885 |     | <span class='neutral'>        bytes32 m12;</span>
 13886 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13887 |     | <span class='neutral'>        assembly {</span>
 13888 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13889 |     | <span class='neutral'>                let length := 0</span>
 13890 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13891 |     | <span class='neutral'>                mstore(pos, length)</span>
 13892 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13893 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13894 |     | <span class='neutral'>            }</span>
 13895 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13896 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13897 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13898 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13899 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13900 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13901 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13902 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13903 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13904 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13905 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13906 |     | <span class='neutral'>            m11 := mload(0x160)</span>
 13907 |     | <span class='neutral'>            m12 := mload(0x180)</span>
 13908 |     | <span class='neutral'>            // Selector of `log(string,string,string,string)`.</span>
 13909 |     | <span class='neutral'>            mstore(0x00, 0xde68f20a)</span>
 13910 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13911 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13912 |     | <span class='neutral'>            mstore(0x60, 0x100)</span>
 13913 |     | <span class='neutral'>            mstore(0x80, 0x140)</span>
 13914 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13915 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13916 |     | <span class='neutral'>            writeString(0x120, p2)</span>
 13917 |     | <span class='neutral'>            writeString(0x160, p3)</span>
 13918 |     | <span class='neutral'>        }</span>
 13919 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x184);</span>
 13920 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 13921 |     | <span class='neutral'>        assembly {</span>
 13922 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13923 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13924 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13925 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13926 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13927 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13928 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13929 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13930 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13931 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13932 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13933 |     | <span class='neutral'>            mstore(0x160, m11)</span>
 13934 |     | <span class='neutral'>            mstore(0x180, m12)</span>
 13935 |     | <span class='neutral'>        }</span>
 13936 |     | <span class='neutral'>    }</span>
 13937 |     | <span class='neutral'>}</span>
 13938 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/interfaces/IERC5267.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IERC5267 {</span>
  7 |     | <span class='neutral'>    /**</span>
  8 |     | <span class='neutral'>     * @dev MAY be emitted to signal that the domain could have changed.</span>
  9 |     | <span class='neutral'>     */</span>
 10 |     | <span class='neutral'>    event EIP712DomainChanged();</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712</span>
 14 |     | <span class='neutral'>     * signature.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    function eip712Domain()</span>
 17 |     | <span class='neutral'>        external</span>
 18 |     | <span class='neutral'>        view</span>
 19 |     | <span class='neutral'>        returns (</span>
 20 |     | <span class='neutral'>            bytes1 fields,</span>
 21 |     | <span class='neutral'>            string memory name,</span>
 22 |     | <span class='neutral'>            string memory version,</span>
 23 |     | <span class='neutral'>            uint256 chainId,</span>
 24 |     | <span class='neutral'>            address verifyingContract,</span>
 25 |     | <span class='neutral'>            bytes32 salt,</span>
 26 |     | <span class='neutral'>            uint256[] memory extensions</span>
 27 |     | <span class='neutral'>        );</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  14 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  15 |     | <span class='neutral'> * For a generic mechanism see {ERC20PresetMinterPauser}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  18 |     | <span class='neutral'> * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  19 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * The default value of {decimals} is 18. To change this, you should override</span>
  22 |     | <span class='neutral'> * this function so it returns a different value.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  25 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  26 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC20</span>
  27 |     | <span class='neutral'> * applications.</span>
  28 |     | <span class='neutral'> *</span>
  29 |     | <span class='neutral'> * Additionally, an {Approval} event is emitted on calls to {transferFrom}.</span>
  30 |     | <span class='neutral'> * This allows applications to reconstruct the allowance for all accounts just</span>
  31 |     | <span class='neutral'> * by listening to said events. Other implementations of the EIP may not emit</span>
  32 |     | <span class='neutral'> * these events, as it isn&#39;t required by the specification.</span>
  33 |     | <span class='neutral'> *</span>
  34 |     | <span class='neutral'> * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}</span>
  35 |     | <span class='neutral'> * functions have been added to mitigate the well-known issues around setting</span>
  36 |     | <span class='neutral'> * allowances. See {IERC20-approve}.</span>
  37 |     | <span class='neutral'> */</span>
  38 |     | <span class='unexecuted'>contract ERC20 is Context, IERC20, IERC20Metadata {</span>
  39 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    string private _name;</span>
  46 |     | <span class='neutral'>    string private _symbol;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  50 |     | <span class='neutral'>     *</span>
  51 |     | <span class='neutral'>     * All two of these values are immutable: they can only be set once during</span>
  52 |     | <span class='neutral'>     * construction.</span>
  53 |     | <span class='neutral'>     */</span>
  54 | *   | <span class='executed'>    constructor(string memory name_, string memory symbol_) {</span>
  55 | *   | <span class='executed'>        _name = name_;</span>
  56 | *   | <span class='executed'>        _symbol = symbol_;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  61 |     | <span class='neutral'>     */</span>
  62 | *   | <span class='executed'>    function name() public view virtual override returns (string memory) {</span>
  63 | *   | <span class='executed'>        return _name;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  68 |     | <span class='neutral'>     * name.</span>
  69 |     | <span class='neutral'>     */</span>
  70 | *   | <span class='executed'>    function symbol() public view virtual override returns (string memory) {</span>
  71 | *   | <span class='executed'>        return _symbol;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  76 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  77 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  80 |     | <span class='neutral'>     * Ether and Wei. This is the default value returned by this function, unless</span>
  81 |     | <span class='neutral'>     * it&#39;s overridden.</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  84 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  85 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='unexecuted'>    function decimals() public view virtual override returns (uint8) {</span>
  88 |     | <span class='unexecuted'>        return 18;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
  93 |     | <span class='neutral'>     */</span>
  94 | *   | <span class='executed'>    function totalSupply() public view virtual override returns (uint256) {</span>
  95 | *   | <span class='executed'>        return _totalSupply;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
 100 |     | <span class='neutral'>     */</span>
 101 | *   | <span class='executed'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
 102 | *   | <span class='executed'>        return _balances[account];</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /**</span>
 106 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * Requirements:</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 111 |     | <span class='neutral'>     * - the caller must have a balance of at least `amount`.</span>
 112 |     | <span class='neutral'>     */</span>
 113 | *   | <span class='executed'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
 114 |     | <span class='neutral'>        address owner = _msgSender();</span>
 115 | *   | <span class='executed'>        _transfer(owner, to, amount);</span>
 116 |     | <span class='neutral'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 121 |     | <span class='neutral'>     */</span>
 122 | *   | <span class='executed'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
 123 | *   | <span class='executed'>        return _allowances[owner][spender];</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on</span>
 130 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * Requirements:</span>
 133 |     | <span class='neutral'>     *</span>
 134 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 135 |     | <span class='neutral'>     */</span>
 136 | *   | <span class='executed'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
 137 |     | <span class='neutral'>        address owner = _msgSender();</span>
 138 | *   | <span class='executed'>        _approve(owner, spender, amount);</span>
 139 | *   | <span class='executed'>        return true;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev See {IERC20-transferFrom}.</span>
 144 |     | <span class='neutral'>     *</span>
 145 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 146 |     | <span class='neutral'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 149 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * Requirements:</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 154 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 155 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 156 |     | <span class='neutral'>     * `amount`.</span>
 157 |     | <span class='neutral'>     */</span>
 158 | *   | <span class='executed'>    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {</span>
 159 |     | <span class='neutral'>        address spender = _msgSender();</span>
 160 | *   | <span class='executed'>        _spendAllowance(from, spender, amount);</span>
 161 | *   | <span class='executed'>        _transfer(from, to, amount);</span>
 162 | *   | <span class='executed'>        return true;</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    /**</span>
 166 |     | <span class='neutral'>     * @dev Atomically increases the allowance granted to `spender` by the caller.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 169 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 170 |     | <span class='neutral'>     *</span>
 171 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 172 |     | <span class='neutral'>     *</span>
 173 |     | <span class='neutral'>     * Requirements:</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 176 |     | <span class='neutral'>     */</span>
 177 |     | <span class='unexecuted'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
 178 |     | <span class='neutral'>        address owner = _msgSender();</span>
 179 |     | <span class='unexecuted'>        _approve(owner, spender, allowance(owner, spender) + addedValue);</span>
 180 |     | <span class='neutral'>        return true;</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /**</span>
 184 |     | <span class='neutral'>     * @dev Atomically decreases the allowance granted to `spender` by the caller.</span>
 185 |     | <span class='neutral'>     *</span>
 186 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 187 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 188 |     | <span class='neutral'>     *</span>
 189 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 190 |     | <span class='neutral'>     *</span>
 191 |     | <span class='neutral'>     * Requirements:</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 194 |     | <span class='neutral'>     * - `spender` must have allowance for the caller of at least</span>
 195 |     | <span class='neutral'>     * `subtractedValue`.</span>
 196 |     | <span class='neutral'>     */</span>
 197 |     | <span class='unexecuted'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
 198 |     | <span class='neutral'>        address owner = _msgSender();</span>
 199 |     | <span class='unexecuted'>        uint256 currentAllowance = allowance(owner, spender);</span>
 200 | *   | <span class='executed'>        require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
 201 |     | <span class='neutral'>        unchecked {</span>
 202 |     | <span class='unexecuted'>            _approve(owner, spender, currentAllowance - subtractedValue);</span>
 203 |     | <span class='neutral'>        }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='unexecuted'>        return true;</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    /**</span>
 209 |     | <span class='neutral'>     * @dev Moves `amount` of tokens from `from` to `to`.</span>
 210 |     | <span class='neutral'>     *</span>
 211 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 212 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 213 |     | <span class='neutral'>     *</span>
 214 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 215 |     | <span class='neutral'>     *</span>
 216 |     | <span class='neutral'>     * Requirements:</span>
 217 |     | <span class='neutral'>     *</span>
 218 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 219 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 220 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 221 |     | <span class='neutral'>     */</span>
 222 | *   | <span class='executed'>    function _transfer(address from, address to, uint256 amount) internal virtual {</span>
 223 | *   | <span class='executed'>        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
 224 | *   | <span class='executed'>        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>        _beforeTokenTransfer(from, to, amount);</span>
 227 |     | <span class='neutral'></span>
 228 | *   | <span class='executed'>        uint256 fromBalance = _balances[from];</span>
 229 | *   | <span class='executed'>        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 230 |     | <span class='neutral'>        unchecked {</span>
 231 | *   | <span class='executed'>            _balances[from] = fromBalance - amount;</span>
 232 |     | <span class='neutral'>            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by</span>
 233 |     | <span class='neutral'>            // decrementing then incrementing.</span>
 234 | *   | <span class='executed'>            _balances[to] += amount;</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'></span>
 237 | *   | <span class='executed'>        emit Transfer(from, to, amount);</span>
 238 |     | <span class='neutral'></span>
 239 | *   | <span class='executed'>        _afterTokenTransfer(from, to, amount);</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    /** @dev Creates `amount` tokens and assigns them to `account`, increasing</span>
 243 |     | <span class='neutral'>     * the total supply.</span>
 244 |     | <span class='neutral'>     *</span>
 245 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 246 |     | <span class='neutral'>     *</span>
 247 |     | <span class='neutral'>     * Requirements:</span>
 248 |     | <span class='neutral'>     *</span>
 249 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 250 |     | <span class='neutral'>     */</span>
 251 | *   | <span class='executed'>    function _mint(address account, uint256 amount) internal virtual {</span>
 252 | *   | <span class='executed'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>        _beforeTokenTransfer(address(0), account, amount);</span>
 255 |     | <span class='neutral'></span>
 256 | *   | <span class='executed'>        _totalSupply += amount;</span>
 257 |     | <span class='neutral'>        unchecked {</span>
 258 |     | <span class='neutral'>            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.</span>
 259 | *   | <span class='executed'>            _balances[account] += amount;</span>
 260 |     | <span class='neutral'>        }</span>
 261 | *   | <span class='executed'>        emit Transfer(address(0), account, amount);</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>        _afterTokenTransfer(address(0), account, amount);</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    /**</span>
 267 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, reducing the</span>
 268 |     | <span class='neutral'>     * total supply.</span>
 269 |     | <span class='neutral'>     *</span>
 270 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 271 |     | <span class='neutral'>     *</span>
 272 |     | <span class='neutral'>     * Requirements:</span>
 273 |     | <span class='neutral'>     *</span>
 274 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 275 |     | <span class='neutral'>     * - `account` must have at least `amount` tokens.</span>
 276 |     | <span class='neutral'>     */</span>
 277 | *   | <span class='executed'>    function _burn(address account, uint256 amount) internal virtual {</span>
 278 | *   | <span class='executed'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>        _beforeTokenTransfer(account, address(0), amount);</span>
 281 |     | <span class='neutral'></span>
 282 | *   | <span class='executed'>        uint256 accountBalance = _balances[account];</span>
 283 | *   | <span class='executed'>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 284 |     | <span class='neutral'>        unchecked {</span>
 285 | *   | <span class='executed'>            _balances[account] = accountBalance - amount;</span>
 286 |     | <span class='neutral'>            // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply.</span>
 287 | *   | <span class='executed'>            _totalSupply -= amount;</span>
 288 |     | <span class='neutral'>        }</span>
 289 |     | <span class='neutral'></span>
 290 | *   | <span class='executed'>        emit Transfer(account, address(0), amount);</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>        _afterTokenTransfer(account, address(0), amount);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    /**</span>
 296 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.</span>
 297 |     | <span class='neutral'>     *</span>
 298 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 299 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 300 |     | <span class='neutral'>     *</span>
 301 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 302 |     | <span class='neutral'>     *</span>
 303 |     | <span class='neutral'>     * Requirements:</span>
 304 |     | <span class='neutral'>     *</span>
 305 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 306 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 307 |     | <span class='neutral'>     */</span>
 308 | *   | <span class='executed'>    function _approve(address owner, address spender, uint256 amount) internal virtual {</span>
 309 | *   | <span class='executed'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 310 | *   | <span class='executed'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 311 |     | <span class='neutral'></span>
 312 | *   | <span class='executed'>        _allowances[owner][spender] = amount;</span>
 313 | *   | <span class='executed'>        emit Approval(owner, spender, amount);</span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    /**</span>
 317 |     | <span class='neutral'>     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.</span>
 318 |     | <span class='neutral'>     *</span>
 319 |     | <span class='neutral'>     * Does not update the allowance amount in case of infinite allowance.</span>
 320 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 321 |     | <span class='neutral'>     *</span>
 322 |     | <span class='neutral'>     * Might emit an {Approval} event.</span>
 323 |     | <span class='neutral'>     */</span>
 324 | *   | <span class='executed'>    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {</span>
 325 | *   | <span class='executed'>        uint256 currentAllowance = allowance(owner, spender);</span>
 326 | *   | <span class='executed'>        if (currentAllowance != type(uint256).max) {</span>
 327 | *   | <span class='executed'>            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
 328 |     | <span class='neutral'>            unchecked {</span>
 329 | *   | <span class='executed'>                _approve(owner, spender, currentAllowance - amount);</span>
 330 |     | <span class='neutral'>            }</span>
 331 |     | <span class='neutral'>        }</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>    /**</span>
 335 |     | <span class='neutral'>     * @dev Hook that is called before any transfer of tokens. This includes</span>
 336 |     | <span class='neutral'>     * minting and burning.</span>
 337 |     | <span class='neutral'>     *</span>
 338 |     | <span class='neutral'>     * Calling conditions:</span>
 339 |     | <span class='neutral'>     *</span>
 340 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 341 |     | <span class='neutral'>     * will be transferred to `to`.</span>
 342 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens will be minted for `to`.</span>
 343 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens will be burned.</span>
 344 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 345 |     | <span class='neutral'>     *</span>
 346 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 347 |     | <span class='neutral'>     */</span>
 348 | *   | <span class='executed'>    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>    /**</span>
 351 |     | <span class='neutral'>     * @dev Hook that is called after any transfer of tokens. This includes</span>
 352 |     | <span class='neutral'>     * minting and burning.</span>
 353 |     | <span class='neutral'>     *</span>
 354 |     | <span class='neutral'>     * Calling conditions:</span>
 355 |     | <span class='neutral'>     *</span>
 356 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 357 |     | <span class='neutral'>     * has been transferred to `to`.</span>
 358 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens have been minted for `to`.</span>
 359 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens have been burned.</span>
 360 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 361 |     | <span class='neutral'>     *</span>
 362 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 363 |     | <span class='neutral'>     */</span>
 364 |     | <span class='neutral'>    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 365 |     | <span class='neutral'>}</span>
 366 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 54 |     | <span class='neutral'>     *</span>
 55 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 58 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 59 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 60 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 61 |     | <span class='neutral'>     * desired value afterwards:</span>
 62 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /**</span>
 69 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 70 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 71 |     | <span class='neutral'>     * allowance.</span>
 72 |     | <span class='neutral'>     *</span>
 73 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 74 |     | <span class='neutral'>     *</span>
 75 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Permit.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/ERC20Permit.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./IERC20Permit.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../ERC20.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../../../utils/cryptography/ECDSA.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;../../../utils/cryptography/EIP712.sol&quot;;</span>
 10 |     | <span class='neutral'>import &quot;../../../utils/Counters.sol&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>/**</span>
 13 |     | <span class='neutral'> * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in</span>
 14 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * Adds the {permit} method, which can be used to change an account&#39;s ERC20 allowance (see {IERC20-allowance}) by</span>
 17 |     | <span class='neutral'> * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn&#39;t</span>
 18 |     | <span class='neutral'> * need to send a transaction, and thus is not required to hold Ether at all.</span>
 19 |     | <span class='neutral'> *</span>
 20 |     | <span class='neutral'> * _Available since v3.4._</span>
 21 |     | <span class='neutral'> */</span>
 22 |     | <span class='neutral'>abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {</span>
 23 |     | <span class='neutral'>    using Counters for Counters.Counter;</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    mapping(address =&gt; Counters.Counter) private _nonces;</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    // solhint-disable-next-line var-name-mixedcase</span>
 28 |     | <span class='neutral'>    bytes32 private constant _PERMIT_TYPEHASH =</span>
 29 |     | <span class='unexecuted'>        keccak256(&quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;);</span>
 30 |     | <span class='neutral'>    /**</span>
 31 |     | <span class='neutral'>     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.</span>
 32 |     | <span class='neutral'>     * However, to ensure consistency with the upgradeable transpiler, we will continue</span>
 33 |     | <span class='neutral'>     * to reserve a slot.</span>
 34 |     | <span class='neutral'>     * @custom:oz-renamed-from _PERMIT_TYPEHASH</span>
 35 |     | <span class='neutral'>     */</span>
 36 |     | <span class='neutral'>    // solhint-disable-next-line var-name-mixedcase</span>
 37 |     | <span class='neutral'>    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /**</span>
 40 |     | <span class='neutral'>     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `&quot;1&quot;`.</span>
 41 |     | <span class='neutral'>     *</span>
 42 |     | <span class='neutral'>     * It&#39;s a good idea to use the same `name` that is defined as the ERC20 token name.</span>
 43 |     | <span class='neutral'>     */</span>
 44 |     | <span class='neutral'>    constructor(string memory name) EIP712(name, &quot;1&quot;) {}</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    /**</span>
 47 |     | <span class='neutral'>     * @inheritdoc IERC20Permit</span>
 48 |     | <span class='neutral'>     */</span>
 49 |     | <span class='unexecuted'>    function permit(</span>
 50 |     | <span class='neutral'>        address owner,</span>
 51 |     | <span class='neutral'>        address spender,</span>
 52 |     | <span class='neutral'>        uint256 value,</span>
 53 |     | <span class='neutral'>        uint256 deadline,</span>
 54 |     | <span class='neutral'>        uint8 v,</span>
 55 |     | <span class='neutral'>        bytes32 r,</span>
 56 |     | <span class='neutral'>        bytes32 s</span>
 57 |     | <span class='unexecuted'>    ) public virtual override {</span>
 58 |     | <span class='unexecuted'>        require(block.timestamp &lt;= deadline, &quot;ERC20Permit: expired deadline&quot;);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='unexecuted'>        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='unexecuted'>        bytes32 hash = _hashTypedDataV4(structHash);</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='unexecuted'>        address signer = ECDSA.recover(hash, v, r, s);</span>
 65 |     | <span class='unexecuted'>        require(signer == owner, &quot;ERC20Permit: invalid signature&quot;);</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>        _approve(owner, spender, value);</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>    /**</span>
 71 |     | <span class='neutral'>     * @inheritdoc IERC20Permit</span>
 72 |     | <span class='neutral'>     */</span>
 73 |     | <span class='unexecuted'>    function nonces(address owner) public view virtual override returns (uint256) {</span>
 74 |     | <span class='unexecuted'>        return _nonces[owner].current();</span>
 75 |     | <span class='neutral'>    }</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='neutral'>    /**</span>
 78 |     | <span class='neutral'>     * @inheritdoc IERC20Permit</span>
 79 |     | <span class='neutral'>     */</span>
 80 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 81 |     | <span class='unexecuted'>    function DOMAIN_SEPARATOR() external view override returns (bytes32) {</span>
 82 |     | <span class='unexecuted'>        return _domainSeparatorV4();</span>
 83 |     | <span class='neutral'>    }</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='neutral'>    /**</span>
 86 |     | <span class='neutral'>     * @dev &quot;Consume a nonce&quot;: return the current value and increment.</span>
 87 |     | <span class='neutral'>     *</span>
 88 |     | <span class='neutral'>     * _Available since v4.1._</span>
 89 |     | <span class='neutral'>     */</span>
 90 |     | <span class='unexecuted'>    function _useNonce(address owner) internal virtual returns (uint256 current) {</span>
 91 |     | <span class='unexecuted'>        Counters.Counter storage nonce = _nonces[owner];</span>
 92 |     | <span class='neutral'>        current = nonce.current();</span>
 93 |     | <span class='unexecuted'>        nonce.increment();</span>
 94 |     | <span class='neutral'>    }</span>
 95 |     | <span class='neutral'>}</span>
 96 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Interface for the optional metadata functions from the ERC20 standard.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * _Available since v4.1._</span>
 12 |     | <span class='neutral'> */</span>
 13 |     | <span class='neutral'>interface IERC20Metadata is IERC20 {</span>
 14 |     | <span class='neutral'>    /**</span>
 15 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /**</span>
 20 |     | <span class='neutral'>     * @dev Returns the symbol of the token.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Adds the {permit} method, which can be used to change an account&#39;s ERC20 allowance (see {IERC20-allowance}) by</span>
 11 |     | <span class='neutral'> * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn&#39;t</span>
 12 |     | <span class='neutral'> * need to send a transaction, and thus is not required to hold Ether at all.</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * ==== Security Considerations</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature</span>
 17 |     | <span class='neutral'> * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be</span>
 18 |     | <span class='neutral'> * considered as an intention to spend the allowance in any specific way. The second is that because permits have</span>
 19 |     | <span class='neutral'> * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should</span>
 20 |     | <span class='neutral'> * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be</span>
 21 |     | <span class='neutral'> * generally recommended is:</span>
 22 |     | <span class='neutral'> *</span>
 23 |     | <span class='neutral'> * ```solidity</span>
 24 |     | <span class='neutral'> * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {</span>
 25 |     | <span class='neutral'> *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}</span>
 26 |     | <span class='neutral'> *     doThing(..., value);</span>
 27 |     | <span class='neutral'> * }</span>
 28 |     | <span class='neutral'> *</span>
 29 |     | <span class='neutral'> * function doThing(..., uint256 value) public {</span>
 30 |     | <span class='neutral'> *     token.safeTransferFrom(msg.sender, address(this), value);</span>
 31 |     | <span class='neutral'> *     ...</span>
 32 |     | <span class='neutral'> * }</span>
 33 |     | <span class='neutral'> * ```</span>
 34 |     | <span class='neutral'> *</span>
 35 |     | <span class='neutral'> * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of</span>
 36 |     | <span class='neutral'> * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also</span>
 37 |     | <span class='neutral'> * {SafeERC20-safeTransferFrom}).</span>
 38 |     | <span class='neutral'> *</span>
 39 |     | <span class='neutral'> * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so</span>
 40 |     | <span class='neutral'> * contracts should have entry points that don&#39;t rely on permit.</span>
 41 |     | <span class='neutral'> */</span>
 42 |     | <span class='neutral'>interface IERC20Permit {</span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Sets `value` as the allowance of `spender` over ``owner``&#39;s tokens,</span>
 45 |     | <span class='neutral'>     * given ``owner``&#39;s signed approval.</span>
 46 |     | <span class='neutral'>     *</span>
 47 |     | <span class='neutral'>     * IMPORTANT: The same issues {IERC20-approve} has related to transaction</span>
 48 |     | <span class='neutral'>     * ordering also apply here.</span>
 49 |     | <span class='neutral'>     *</span>
 50 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 51 |     | <span class='neutral'>     *</span>
 52 |     | <span class='neutral'>     * Requirements:</span>
 53 |     | <span class='neutral'>     *</span>
 54 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 55 |     | <span class='neutral'>     * - `deadline` must be a timestamp in the future.</span>
 56 |     | <span class='neutral'>     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`</span>
 57 |     | <span class='neutral'>     * over the EIP712-formatted function arguments.</span>
 58 |     | <span class='neutral'>     * - the signature must use ``owner``&#39;s current nonce (see {nonces}).</span>
 59 |     | <span class='neutral'>     *</span>
 60 |     | <span class='neutral'>     * For more information on the signature format, see the</span>
 61 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP</span>
 62 |     | <span class='neutral'>     * section].</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * CAUTION: See Security Considerations above.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function permit(</span>
 67 |     | <span class='neutral'>        address owner,</span>
 68 |     | <span class='neutral'>        address spender,</span>
 69 |     | <span class='neutral'>        uint256 value,</span>
 70 |     | <span class='neutral'>        uint256 deadline,</span>
 71 |     | <span class='neutral'>        uint8 v,</span>
 72 |     | <span class='neutral'>        bytes32 r,</span>
 73 |     | <span class='neutral'>        bytes32 s</span>
 74 |     | <span class='neutral'>    ) external;</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>    /**</span>
 77 |     | <span class='neutral'>     * @dev Returns the current nonce for `owner`. This value must be</span>
 78 |     | <span class='neutral'>     * included whenever a signature is generated for {permit}.</span>
 79 |     | <span class='neutral'>     *</span>
 80 |     | <span class='neutral'>     * Every successful call to {permit} increases ``owner``&#39;s nonce by one. This</span>
 81 |     | <span class='neutral'>     * prevents a signature from being used multiple times.</span>
 82 |     | <span class='neutral'>     */</span>
 83 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint256);</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='neutral'>    /**</span>
 86 |     | <span class='neutral'>     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.</span>
 87 |     | <span class='neutral'>     */</span>
 88 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 89 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 90 |     | <span class='neutral'>}</span>
 91 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../extensions/IERC20Permit.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../../utils/Address.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @title SafeERC20</span>
  12 |     | <span class='neutral'> * @dev Wrappers around ERC20 operations that throw on failure (when the token</span>
  13 |     | <span class='neutral'> * contract returns false). Tokens that return no value (and instead revert or</span>
  14 |     | <span class='neutral'> * throw on failure) are also supported, non-reverting calls are assumed to be</span>
  15 |     | <span class='neutral'> * successful.</span>
  16 |     | <span class='neutral'> * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,</span>
  17 |     | <span class='neutral'> * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='unexecuted'>library SafeERC20 {</span>
  20 |     | <span class='neutral'>    using Address for address;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,</span>
  24 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  25 |     | <span class='neutral'>     */</span>
  26 | *   | <span class='executed'>    function safeTransfer(IERC20 token, address to, uint256 value) internal {</span>
  27 | *   | <span class='executed'>        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the</span>
  32 |     | <span class='neutral'>     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.</span>
  33 |     | <span class='neutral'>     */</span>
  34 | *   | <span class='executed'>    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {</span>
  35 | *   | <span class='executed'>        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev Deprecated. This function has issues similar to the ones found in</span>
  40 |     | <span class='neutral'>     * {IERC20-approve}, and its usage is discouraged.</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * Whenever possible, use {safeIncreaseAllowance} and</span>
  43 |     | <span class='neutral'>     * {safeDecreaseAllowance} instead.</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='neutral'>    function safeApprove(IERC20 token, address spender, uint256 value) internal {</span>
  46 |     | <span class='neutral'>        // safeApprove should only be called when setting an initial allowance,</span>
  47 |     | <span class='neutral'>        // or when resetting it to zero. To increase and decrease it, use</span>
  48 |     | <span class='neutral'>        // &#39;safeIncreaseAllowance&#39; and &#39;safeDecreaseAllowance&#39;</span>
  49 |     | <span class='neutral'>        require(</span>
  50 |     | <span class='neutral'>            (value == 0) || (token.allowance(address(this), spender) == 0),</span>
  51 |     | <span class='neutral'>            &quot;SafeERC20: approve from non-zero to non-zero allowance&quot;</span>
  52 |     | <span class='neutral'>        );</span>
  53 |     | <span class='neutral'>        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Increase the calling contract&#39;s allowance toward `spender` by `value`. If `token` returns no value,</span>
  58 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='neutral'>    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {</span>
  61 |     | <span class='neutral'>        uint256 oldAllowance = token.allowance(address(this), spender);</span>
  62 |     | <span class='neutral'>        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /**</span>
  66 |     | <span class='neutral'>     * @dev Decrease the calling contract&#39;s allowance toward `spender` by `value`. If `token` returns no value,</span>
  67 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  68 |     | <span class='neutral'>     */</span>
  69 |     | <span class='neutral'>    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {</span>
  70 |     | <span class='neutral'>        unchecked {</span>
  71 |     | <span class='neutral'>            uint256 oldAllowance = token.allowance(address(this), spender);</span>
  72 |     | <span class='neutral'>            require(oldAllowance &gt;= value, &quot;SafeERC20: decreased allowance below zero&quot;);</span>
  73 |     | <span class='neutral'>            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * @dev Set the calling contract&#39;s allowance toward `spender` to `value`. If `token` returns no value,</span>
  79 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval</span>
  80 |     | <span class='neutral'>     * to be set to zero before setting it to a non-zero value, such as USDT.</span>
  81 |     | <span class='neutral'>     */</span>
  82 |     | <span class='neutral'>    function forceApprove(IERC20 token, address spender, uint256 value) internal {</span>
  83 |     | <span class='neutral'>        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>        if (!_callOptionalReturnBool(token, approvalCall)) {</span>
  86 |     | <span class='neutral'>            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));</span>
  87 |     | <span class='neutral'>            _callOptionalReturn(token, approvalCall);</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.</span>
  93 |     | <span class='neutral'>     * Revert on invalid signature.</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='neutral'>    function safePermit(</span>
  96 |     | <span class='neutral'>        IERC20Permit token,</span>
  97 |     | <span class='neutral'>        address owner,</span>
  98 |     | <span class='neutral'>        address spender,</span>
  99 |     | <span class='neutral'>        uint256 value,</span>
 100 |     | <span class='neutral'>        uint256 deadline,</span>
 101 |     | <span class='neutral'>        uint8 v,</span>
 102 |     | <span class='neutral'>        bytes32 r,</span>
 103 |     | <span class='neutral'>        bytes32 s</span>
 104 |     | <span class='neutral'>    ) internal {</span>
 105 |     | <span class='neutral'>        uint256 nonceBefore = token.nonces(owner);</span>
 106 |     | <span class='neutral'>        token.permit(owner, spender, value, deadline, v, r, s);</span>
 107 |     | <span class='neutral'>        uint256 nonceAfter = token.nonces(owner);</span>
 108 |     | <span class='neutral'>        require(nonceAfter == nonceBefore + 1, &quot;SafeERC20: permit did not succeed&quot;);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /**</span>
 112 |     | <span class='neutral'>     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement</span>
 113 |     | <span class='neutral'>     * on the return value: the return value is optional (but if data is returned, it must not be false).</span>
 114 |     | <span class='neutral'>     * @param token The token targeted by the call.</span>
 115 |     | <span class='neutral'>     * @param data The call data (encoded using abi.encode or one of its variants).</span>
 116 |     | <span class='neutral'>     */</span>
 117 | *   | <span class='executed'>    function _callOptionalReturn(IERC20 token, bytes memory data) private {</span>
 118 |     | <span class='neutral'>        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since</span>
 119 |     | <span class='neutral'>        // we&#39;re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that</span>
 120 |     | <span class='neutral'>        // the target address contains contract code and also asserts for success in the low-level call.</span>
 121 |     | <span class='neutral'></span>
 122 | *   | <span class='executed'>        bytes memory returndata = address(token).functionCall(data, &quot;SafeERC20: low-level call failed&quot;);</span>
 123 | *   | <span class='executed'>        require(returndata.length == 0 || abi.decode(returndata, (bool)), &quot;SafeERC20: ERC20 operation did not succeed&quot;);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement</span>
 128 |     | <span class='neutral'>     * on the return value: the return value is optional (but if data is returned, it must not be false).</span>
 129 |     | <span class='neutral'>     * @param token The token targeted by the call.</span>
 130 |     | <span class='neutral'>     * @param data The call data (encoded using abi.encode or one of its variants).</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.</span>
 133 |     | <span class='neutral'>     */</span>
 134 |     | <span class='neutral'>    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {</span>
 135 |     | <span class='neutral'>        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since</span>
 136 |     | <span class='neutral'>        // we&#39;re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false</span>
 137 |     | <span class='neutral'>        // and not revert is the subcall reverts.</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>        (bool success, bytes memory returndata) = address(token).call(data);</span>
 140 |     | <span class='neutral'>        return</span>
 141 |     | <span class='neutral'>            success &amp;&amp; (returndata.length == 0 || abi.decode(returndata, (bool))) &amp;&amp; Address.isContract(address(token));</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'>}</span>
 144 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC721.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./IERC721Receiver.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./extensions/IERC721Metadata.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../../utils/Address.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../../utils/Strings.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;../../utils/introspection/ERC165.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/**</span>
  15 |     | <span class='neutral'> * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including</span>
  16 |     | <span class='neutral'> * the Metadata extension, but not including the Enumerable extension, which is available separately as</span>
  17 |     | <span class='neutral'> * {ERC721Enumerable}.</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='unexecuted'>contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {</span>
  20 |     | <span class='neutral'>    using Address for address;</span>
  21 |     | <span class='neutral'>    using Strings for uint256;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    // Token name</span>
  24 |     | <span class='neutral'>    string private _name;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    // Token symbol</span>
  27 |     | <span class='neutral'>    string private _symbol;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    // Mapping from token ID to owner address</span>
  30 |     | <span class='neutral'>    mapping(uint256 =&gt; address) private _owners;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    // Mapping owner address to token count</span>
  33 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    // Mapping from token ID to approved address</span>
  36 |     | <span class='neutral'>    mapping(uint256 =&gt; address) private _tokenApprovals;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    // Mapping from owner to operator approvals</span>
  39 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /**</span>
  42 |     | <span class='neutral'>     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.</span>
  43 |     | <span class='neutral'>     */</span>
  44 | *   | <span class='executed'>    constructor(string memory name_, string memory symbol_) {</span>
  45 | *   | <span class='executed'>        _name = name_;</span>
  46 | *   | <span class='executed'>        _symbol = symbol_;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /**</span>
  50 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
  51 |     | <span class='neutral'>     */</span>
  52 | *   | <span class='executed'>    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {</span>
  53 | *   | <span class='executed'>        return</span>
  54 |     | <span class='unexecuted'>            interfaceId == type(IERC721).interfaceId ||</span>
  55 |     | <span class='unexecuted'>            interfaceId == type(IERC721Metadata).interfaceId ||</span>
  56 | *   | <span class='executed'>            super.supportsInterface(interfaceId);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev See {IERC721-balanceOf}.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='unexecuted'>    function balanceOf(address owner) public view virtual override returns (uint256) {</span>
  63 |     | <span class='unexecuted'>        require(owner != address(0), &quot;ERC721: address zero is not a valid owner&quot;);</span>
  64 |     | <span class='unexecuted'>        return _balances[owner];</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /**</span>
  68 |     | <span class='neutral'>     * @dev See {IERC721-ownerOf}.</span>
  69 |     | <span class='neutral'>     */</span>
  70 | *   | <span class='executed'>    function ownerOf(uint256 tokenId) public view virtual override returns (address) {</span>
  71 |     | <span class='neutral'>        address owner = _ownerOf(tokenId);</span>
  72 | *   | <span class='executed'>        require(owner != address(0), &quot;ERC721: invalid token ID&quot;);</span>
  73 |     | <span class='neutral'>        return owner;</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    /**</span>
  77 |     | <span class='neutral'>     * @dev See {IERC721Metadata-name}.</span>
  78 |     | <span class='neutral'>     */</span>
  79 |     | <span class='unexecuted'>    function name() public view virtual override returns (string memory) {</span>
  80 |     | <span class='unexecuted'>        return _name;</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @dev See {IERC721Metadata-symbol}.</span>
  85 |     | <span class='neutral'>     */</span>
  86 |     | <span class='unexecuted'>    function symbol() public view virtual override returns (string memory) {</span>
  87 |     | <span class='unexecuted'>        return _symbol;</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /**</span>
  91 |     | <span class='neutral'>     * @dev See {IERC721Metadata-tokenURI}.</span>
  92 |     | <span class='neutral'>     */</span>
  93 |     | <span class='unexecuted'>    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {</span>
  94 |     | <span class='unexecuted'>        _requireMinted(tokenId);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        string memory baseURI = _baseURI();</span>
  97 |     | <span class='unexecuted'>        return bytes(baseURI).length &gt; 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : &quot;&quot;;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each</span>
 102 |     | <span class='neutral'>     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty</span>
 103 |     | <span class='neutral'>     * by default, can be overridden in child contracts.</span>
 104 |     | <span class='neutral'>     */</span>
 105 |     | <span class='unexecuted'>    function _baseURI() internal view virtual returns (string memory) {</span>
 106 |     | <span class='unexecuted'>        return &quot;&quot;;</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /**</span>
 110 |     | <span class='neutral'>     * @dev See {IERC721-approve}.</span>
 111 |     | <span class='neutral'>     */</span>
 112 | *   | <span class='executed'>    function approve(address to, uint256 tokenId) public virtual override {</span>
 113 |     | <span class='unexecuted'>        address owner = ERC721.ownerOf(tokenId);</span>
 114 | *   | <span class='executed'>        require(to != owner, &quot;ERC721: approval to current owner&quot;);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>        require(</span>
 117 |     | <span class='unexecuted'>            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),</span>
 118 |     | <span class='neutral'>            &quot;ERC721: approve caller is not token owner or approved for all&quot;</span>
 119 |     | <span class='neutral'>        );</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>        _approve(to, tokenId);</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    /**</span>
 125 |     | <span class='neutral'>     * @dev See {IERC721-getApproved}.</span>
 126 |     | <span class='neutral'>     */</span>
 127 | *   | <span class='executed'>    function getApproved(uint256 tokenId) public view virtual override returns (address) {</span>
 128 |     | <span class='unexecuted'>        _requireMinted(tokenId);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>        return _tokenApprovals[tokenId];</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /**</span>
 134 |     | <span class='neutral'>     * @dev See {IERC721-setApprovalForAll}.</span>
 135 |     | <span class='neutral'>     */</span>
 136 |     | <span class='unexecuted'>    function setApprovalForAll(address operator, bool approved) public virtual override {</span>
 137 |     | <span class='unexecuted'>        _setApprovalForAll(_msgSender(), operator, approved);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    /**</span>
 141 |     | <span class='neutral'>     * @dev See {IERC721-isApprovedForAll}.</span>
 142 |     | <span class='neutral'>     */</span>
 143 |     | <span class='unexecuted'>    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {</span>
 144 |     | <span class='unexecuted'>        return _operatorApprovals[owner][operator];</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /**</span>
 148 |     | <span class='neutral'>     * @dev See {IERC721-transferFrom}.</span>
 149 |     | <span class='neutral'>     */</span>
 150 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 tokenId) public virtual override {</span>
 151 |     | <span class='neutral'>        //solhint-disable-next-line max-line-length</span>
 152 |     | <span class='unexecuted'>        require(_isApprovedOrOwner(_msgSender(), tokenId), &quot;ERC721: caller is not token owner or approved&quot;);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>        _transfer(from, to, tokenId);</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    /**</span>
 158 |     | <span class='neutral'>     * @dev See {IERC721-safeTransferFrom}.</span>
 159 |     | <span class='neutral'>     */</span>
 160 |     | <span class='unexecuted'>    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {</span>
 161 |     | <span class='unexecuted'>        safeTransferFrom(from, to, tokenId, &quot;&quot;);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /**</span>
 165 |     | <span class='neutral'>     * @dev See {IERC721-safeTransferFrom}.</span>
 166 |     | <span class='neutral'>     */</span>
 167 |     | <span class='unexecuted'>    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {</span>
 168 |     | <span class='unexecuted'>        require(_isApprovedOrOwner(_msgSender(), tokenId), &quot;ERC721: caller is not token owner or approved&quot;);</span>
 169 |     | <span class='unexecuted'>        _safeTransfer(from, to, tokenId, data);</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    /**</span>
 173 |     | <span class='neutral'>     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients</span>
 174 |     | <span class='neutral'>     * are aware of the ERC721 protocol to prevent tokens from being forever locked.</span>
 175 |     | <span class='neutral'>     *</span>
 176 |     | <span class='neutral'>     * `data` is additional data, it has no specified format and it is sent in call to `to`.</span>
 177 |     | <span class='neutral'>     *</span>
 178 |     | <span class='neutral'>     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.</span>
 179 |     | <span class='neutral'>     * implement alternative mechanisms to perform token transfer, such as signature-based.</span>
 180 |     | <span class='neutral'>     *</span>
 181 |     | <span class='neutral'>     * Requirements:</span>
 182 |     | <span class='neutral'>     *</span>
 183 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 184 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 185 |     | <span class='neutral'>     * - `tokenId` token must exist and be owned by `from`.</span>
 186 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
 187 |     | <span class='neutral'>     *</span>
 188 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 189 |     | <span class='neutral'>     */</span>
 190 |     | <span class='unexecuted'>    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {</span>
 191 |     | <span class='unexecuted'>        _transfer(from, to, tokenId);</span>
 192 |     | <span class='unexecuted'>        require(_checkOnERC721Received(from, to, tokenId, data), &quot;ERC721: transfer to non ERC721Receiver implementer&quot;);</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    /**</span>
 196 |     | <span class='neutral'>     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn&#39;t exist</span>
 197 |     | <span class='neutral'>     */</span>
 198 |     | <span class='neutral'>    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {</span>
 199 | *   | <span class='executed'>        return _owners[tokenId];</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    /**</span>
 203 |     | <span class='neutral'>     * @dev Returns whether `tokenId` exists.</span>
 204 |     | <span class='neutral'>     *</span>
 205 |     | <span class='neutral'>     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.</span>
 206 |     | <span class='neutral'>     *</span>
 207 |     | <span class='neutral'>     * Tokens start existing when they are minted (`_mint`),</span>
 208 |     | <span class='neutral'>     * and stop existing when they are burned (`_burn`).</span>
 209 |     | <span class='neutral'>     */</span>
 210 | *   | <span class='executed'>    function _exists(uint256 tokenId) internal view virtual returns (bool) {</span>
 211 | *   | <span class='executed'>        return _ownerOf(tokenId) != address(0);</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    /**</span>
 215 |     | <span class='neutral'>     * @dev Returns whether `spender` is allowed to manage `tokenId`.</span>
 216 |     | <span class='neutral'>     *</span>
 217 |     | <span class='neutral'>     * Requirements:</span>
 218 |     | <span class='neutral'>     *</span>
 219 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 220 |     | <span class='neutral'>     */</span>
 221 |     | <span class='unexecuted'>    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {</span>
 222 |     | <span class='unexecuted'>        address owner = ERC721.ownerOf(tokenId);</span>
 223 |     | <span class='unexecuted'>        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    /**</span>
 227 |     | <span class='neutral'>     * @dev Safely mints `tokenId` and transfers it to `to`.</span>
 228 |     | <span class='neutral'>     *</span>
 229 |     | <span class='neutral'>     * Requirements:</span>
 230 |     | <span class='neutral'>     *</span>
 231 |     | <span class='neutral'>     * - `tokenId` must not exist.</span>
 232 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
 233 |     | <span class='neutral'>     *</span>
 234 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 235 |     | <span class='neutral'>     */</span>
 236 |     | <span class='neutral'>    function _safeMint(address to, uint256 tokenId) internal virtual {</span>
 237 |     | <span class='neutral'>        _safeMint(to, tokenId, &quot;&quot;);</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    /**</span>
 241 |     | <span class='neutral'>     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is</span>
 242 |     | <span class='neutral'>     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.</span>
 243 |     | <span class='neutral'>     */</span>
 244 |     | <span class='neutral'>    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {</span>
 245 |     | <span class='neutral'>        _mint(to, tokenId);</span>
 246 |     | <span class='neutral'>        require(</span>
 247 |     | <span class='neutral'>            _checkOnERC721Received(address(0), to, tokenId, data),</span>
 248 |     | <span class='neutral'>            &quot;ERC721: transfer to non ERC721Receiver implementer&quot;</span>
 249 |     | <span class='neutral'>        );</span>
 250 |     | <span class='neutral'>    }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>    /**</span>
 253 |     | <span class='neutral'>     * @dev Mints `tokenId` and transfers it to `to`.</span>
 254 |     | <span class='neutral'>     *</span>
 255 |     | <span class='neutral'>     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible</span>
 256 |     | <span class='neutral'>     *</span>
 257 |     | <span class='neutral'>     * Requirements:</span>
 258 |     | <span class='neutral'>     *</span>
 259 |     | <span class='neutral'>     * - `tokenId` must not exist.</span>
 260 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 261 |     | <span class='neutral'>     *</span>
 262 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 263 |     | <span class='neutral'>     */</span>
 264 | *   | <span class='executed'>    function _mint(address to, uint256 tokenId) internal virtual {</span>
 265 | *   | <span class='executed'>        require(to != address(0), &quot;ERC721: mint to the zero address&quot;);</span>
 266 | *   | <span class='executed'>        require(!_exists(tokenId), &quot;ERC721: token already minted&quot;);</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>        _beforeTokenTransfer(address(0), to, tokenId, 1);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>        // Check that tokenId was not minted by `_beforeTokenTransfer` hook</span>
 271 | *   | <span class='executed'>        require(!_exists(tokenId), &quot;ERC721: token already minted&quot;);</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='neutral'>        unchecked {</span>
 274 |     | <span class='neutral'>            // Will not overflow unless all 2**256 token ids are minted to the same owner.</span>
 275 |     | <span class='neutral'>            // Given that tokens are minted one by one, it is impossible in practice that</span>
 276 |     | <span class='neutral'>            // this ever happens. Might change if we allow batch minting.</span>
 277 |     | <span class='neutral'>            // The ERC fails to describe this case.</span>
 278 | *   | <span class='executed'>            _balances[to] += 1;</span>
 279 |     | <span class='neutral'>        }</span>
 280 |     | <span class='neutral'></span>
 281 | *   | <span class='executed'>        _owners[tokenId] = to;</span>
 282 |     | <span class='neutral'></span>
 283 | *   | <span class='executed'>        emit Transfer(address(0), to, tokenId);</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>        _afterTokenTransfer(address(0), to, tokenId, 1);</span>
 286 |     | <span class='neutral'>    }</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>    /**</span>
 289 |     | <span class='neutral'>     * @dev Destroys `tokenId`.</span>
 290 |     | <span class='neutral'>     * The approval is cleared when the token is burned.</span>
 291 |     | <span class='neutral'>     * This is an internal function that does not check if the sender is authorized to operate on the token.</span>
 292 |     | <span class='neutral'>     *</span>
 293 |     | <span class='neutral'>     * Requirements:</span>
 294 |     | <span class='neutral'>     *</span>
 295 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 296 |     | <span class='neutral'>     *</span>
 297 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 298 |     | <span class='neutral'>     */</span>
 299 |     | <span class='unexecuted'>    function _burn(uint256 tokenId) internal virtual {</span>
 300 |     | <span class='unexecuted'>        address owner = ERC721.ownerOf(tokenId);</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>        _beforeTokenTransfer(owner, address(0), tokenId, 1);</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook</span>
 305 |     | <span class='unexecuted'>        owner = ERC721.ownerOf(tokenId);</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='neutral'>        // Clear approvals</span>
 308 |     | <span class='unexecuted'>        delete _tokenApprovals[tokenId];</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>        unchecked {</span>
 311 |     | <span class='neutral'>            // Cannot overflow, as that would require more tokens to be burned/transferred</span>
 312 |     | <span class='neutral'>            // out than the owner initially received through minting and transferring in.</span>
 313 |     | <span class='unexecuted'>            _balances[owner] -= 1;</span>
 314 |     | <span class='neutral'>        }</span>
 315 |     | <span class='unexecuted'>        delete _owners[tokenId];</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='unexecuted'>        emit Transfer(owner, address(0), tokenId);</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>        _afterTokenTransfer(owner, address(0), tokenId, 1);</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>    /**</span>
 323 |     | <span class='neutral'>     * @dev Transfers `tokenId` from `from` to `to`.</span>
 324 |     | <span class='neutral'>     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.</span>
 325 |     | <span class='neutral'>     *</span>
 326 |     | <span class='neutral'>     * Requirements:</span>
 327 |     | <span class='neutral'>     *</span>
 328 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 329 |     | <span class='neutral'>     * - `tokenId` token must be owned by `from`.</span>
 330 |     | <span class='neutral'>     *</span>
 331 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 332 |     | <span class='neutral'>     */</span>
 333 |     | <span class='unexecuted'>    function _transfer(address from, address to, uint256 tokenId) internal virtual {</span>
 334 |     | <span class='unexecuted'>        require(ERC721.ownerOf(tokenId) == from, &quot;ERC721: transfer from incorrect owner&quot;);</span>
 335 |     | <span class='unexecuted'>        require(to != address(0), &quot;ERC721: transfer to the zero address&quot;);</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='neutral'>        _beforeTokenTransfer(from, to, tokenId, 1);</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook</span>
 340 |     | <span class='unexecuted'>        require(ERC721.ownerOf(tokenId) == from, &quot;ERC721: transfer from incorrect owner&quot;);</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='neutral'>        // Clear approvals from the previous owner</span>
 343 |     | <span class='unexecuted'>        delete _tokenApprovals[tokenId];</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>        unchecked {</span>
 346 |     | <span class='neutral'>            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:</span>
 347 |     | <span class='neutral'>            // `from`&#39;s balance is the number of token held, which is at least one before the current</span>
 348 |     | <span class='neutral'>            // transfer.</span>
 349 |     | <span class='neutral'>            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require</span>
 350 |     | <span class='neutral'>            // all 2**256 token ids to be minted, which in practice is impossible.</span>
 351 |     | <span class='unexecuted'>            _balances[from] -= 1;</span>
 352 |     | <span class='unexecuted'>            _balances[to] += 1;</span>
 353 |     | <span class='neutral'>        }</span>
 354 |     | <span class='unexecuted'>        _owners[tokenId] = to;</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='unexecuted'>        emit Transfer(from, to, tokenId);</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='neutral'>        _afterTokenTransfer(from, to, tokenId, 1);</span>
 359 |     | <span class='neutral'>    }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='neutral'>    /**</span>
 362 |     | <span class='neutral'>     * @dev Approve `to` to operate on `tokenId`</span>
 363 |     | <span class='neutral'>     *</span>
 364 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 365 |     | <span class='neutral'>     */</span>
 366 |     | <span class='unexecuted'>    function _approve(address to, uint256 tokenId) internal virtual {</span>
 367 |     | <span class='unexecuted'>        _tokenApprovals[tokenId] = to;</span>
 368 |     | <span class='unexecuted'>        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);</span>
 369 |     | <span class='neutral'>    }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>    /**</span>
 372 |     | <span class='neutral'>     * @dev Approve `operator` to operate on all of `owner` tokens</span>
 373 |     | <span class='neutral'>     *</span>
 374 |     | <span class='neutral'>     * Emits an {ApprovalForAll} event.</span>
 375 |     | <span class='neutral'>     */</span>
 376 |     | <span class='unexecuted'>    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {</span>
 377 |     | <span class='unexecuted'>        require(owner != operator, &quot;ERC721: approve to caller&quot;);</span>
 378 |     | <span class='unexecuted'>        _operatorApprovals[owner][operator] = approved;</span>
 379 |     | <span class='unexecuted'>        emit ApprovalForAll(owner, operator, approved);</span>
 380 |     | <span class='neutral'>    }</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>    /**</span>
 383 |     | <span class='neutral'>     * @dev Reverts if the `tokenId` has not been minted yet.</span>
 384 |     | <span class='neutral'>     */</span>
 385 |     | <span class='unexecuted'>    function _requireMinted(uint256 tokenId) internal view virtual {</span>
 386 |     | <span class='unexecuted'>        require(_exists(tokenId), &quot;ERC721: invalid token ID&quot;);</span>
 387 |     | <span class='neutral'>    }</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>    /**</span>
 390 |     | <span class='neutral'>     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.</span>
 391 |     | <span class='neutral'>     * The call is not executed if the target address is not a contract.</span>
 392 |     | <span class='neutral'>     *</span>
 393 |     | <span class='neutral'>     * @param from address representing the previous owner of the given token ID</span>
 394 |     | <span class='neutral'>     * @param to target address that will receive the tokens</span>
 395 |     | <span class='neutral'>     * @param tokenId uint256 ID of the token to be transferred</span>
 396 |     | <span class='neutral'>     * @param data bytes optional data to send along with the call</span>
 397 |     | <span class='neutral'>     * @return bool whether the call correctly returned the expected magic value</span>
 398 |     | <span class='neutral'>     */</span>
 399 |     | <span class='unexecuted'>    function _checkOnERC721Received(</span>
 400 |     | <span class='neutral'>        address from,</span>
 401 |     | <span class='neutral'>        address to,</span>
 402 |     | <span class='neutral'>        uint256 tokenId,</span>
 403 |     | <span class='neutral'>        bytes memory data</span>
 404 |     | <span class='unexecuted'>    ) private returns (bool) {</span>
 405 |     | <span class='unexecuted'>        if (to.isContract()) {</span>
 406 |     | <span class='unexecuted'>            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {</span>
 407 |     | <span class='unexecuted'>                return retval == IERC721Receiver.onERC721Received.selector;</span>
 408 |     | <span class='neutral'>            } catch (bytes memory reason) {</span>
 409 |     | <span class='unexecuted'>                if (reason.length == 0) {</span>
 410 |     | <span class='unexecuted'>                    revert(&quot;ERC721: transfer to non ERC721Receiver implementer&quot;);</span>
 411 |     | <span class='neutral'>                } else {</span>
 412 |     | <span class='neutral'>                    /// @solidity memory-safe-assembly</span>
 413 |     | <span class='neutral'>                    assembly {</span>
 414 |     | <span class='unexecuted'>                        revert(add(32, reason), mload(reason))</span>
 415 |     | <span class='neutral'>                    }</span>
 416 |     | <span class='neutral'>                }</span>
 417 |     | <span class='neutral'>            }</span>
 418 |     | <span class='neutral'>        } else {</span>
 419 |     | <span class='unexecuted'>            return true;</span>
 420 |     | <span class='neutral'>        }</span>
 421 |     | <span class='neutral'>    }</span>
 422 |     | <span class='neutral'></span>
 423 |     | <span class='neutral'>    /**</span>
 424 |     | <span class='neutral'>     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is</span>
 425 |     | <span class='neutral'>     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.</span>
 426 |     | <span class='neutral'>     *</span>
 427 |     | <span class='neutral'>     * Calling conditions:</span>
 428 |     | <span class='neutral'>     *</span>
 429 |     | <span class='neutral'>     * - When `from` and `to` are both non-zero, ``from``&#39;s tokens will be transferred to `to`.</span>
 430 |     | <span class='neutral'>     * - When `from` is zero, the tokens will be minted for `to`.</span>
 431 |     | <span class='neutral'>     * - When `to` is zero, ``from``&#39;s tokens will be burned.</span>
 432 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 433 |     | <span class='neutral'>     * - `batchSize` is non-zero.</span>
 434 |     | <span class='neutral'>     *</span>
 435 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 436 |     | <span class='neutral'>     */</span>
 437 |     | <span class='neutral'>    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='neutral'>    /**</span>
 440 |     | <span class='neutral'>     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is</span>
 441 |     | <span class='neutral'>     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.</span>
 442 |     | <span class='neutral'>     *</span>
 443 |     | <span class='neutral'>     * Calling conditions:</span>
 444 |     | <span class='neutral'>     *</span>
 445 |     | <span class='neutral'>     * - When `from` and `to` are both non-zero, ``from``&#39;s tokens were transferred to `to`.</span>
 446 |     | <span class='neutral'>     * - When `from` is zero, the tokens were minted for `to`.</span>
 447 |     | <span class='neutral'>     * - When `to` is zero, ``from``&#39;s tokens were burned.</span>
 448 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 449 |     | <span class='neutral'>     * - `batchSize` is non-zero.</span>
 450 |     | <span class='neutral'>     *</span>
 451 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 452 |     | <span class='neutral'>     */</span>
 453 |     | <span class='neutral'>    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}</span>
 454 |     | <span class='neutral'></span>
 455 |     | <span class='neutral'>    /**</span>
 456 |     | <span class='neutral'>     * @dev Unsafe write access to the balances, used by extensions that &quot;mint&quot; tokens using an {ownerOf} override.</span>
 457 |     | <span class='neutral'>     *</span>
 458 |     | <span class='neutral'>     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant</span>
 459 |     | <span class='neutral'>     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such</span>
 460 |     | <span class='neutral'>     * that `ownerOf(tokenId)` is `a`.</span>
 461 |     | <span class='neutral'>     */</span>
 462 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 463 |     | <span class='neutral'>    function __unsafe_increaseBalance(address account, uint256 amount) internal {</span>
 464 |     | <span class='neutral'>        _balances[account] += amount;</span>
 465 |     | <span class='neutral'>    }</span>
 466 |     | <span class='neutral'>}</span>
 467 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../../utils/introspection/IERC165.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Required interface of an ERC721 compliant contract.</span>
  10 |     | <span class='neutral'> */</span>
  11 |     | <span class='neutral'>interface IERC721 is IERC165 {</span>
  12 |     | <span class='neutral'>    /**</span>
  13 |     | <span class='neutral'>     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.</span>
  14 |     | <span class='neutral'>     */</span>
  15 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /**</span>
  18 |     | <span class='neutral'>     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.</span>
  19 |     | <span class='neutral'>     */</span>
  20 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.</span>
  24 |     | <span class='neutral'>     */</span>
  25 |     | <span class='neutral'>    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @dev Returns the number of tokens in ``owner``&#39;s account.</span>
  29 |     | <span class='neutral'>     */</span>
  30 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint256 balance);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /**</span>
  33 |     | <span class='neutral'>     * @dev Returns the owner of the `tokenId` token.</span>
  34 |     | <span class='neutral'>     *</span>
  35 |     | <span class='neutral'>     * Requirements:</span>
  36 |     | <span class='neutral'>     *</span>
  37 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
  38 |     | <span class='neutral'>     */</span>
  39 |     | <span class='neutral'>    function ownerOf(uint256 tokenId) external view returns (address owner);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /**</span>
  42 |     | <span class='neutral'>     * @dev Safely transfers `tokenId` token from `from` to `to`.</span>
  43 |     | <span class='neutral'>     *</span>
  44 |     | <span class='neutral'>     * Requirements:</span>
  45 |     | <span class='neutral'>     *</span>
  46 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  47 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  48 |     | <span class='neutral'>     * - `tokenId` token must exist and be owned by `from`.</span>
  49 |     | <span class='neutral'>     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.</span>
  50 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='neutral'>    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients</span>
  58 |     | <span class='neutral'>     * are aware of the ERC721 protocol to prevent tokens from being forever locked.</span>
  59 |     | <span class='neutral'>     *</span>
  60 |     | <span class='neutral'>     * Requirements:</span>
  61 |     | <span class='neutral'>     *</span>
  62 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  63 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  64 |     | <span class='neutral'>     * - `tokenId` token must exist and be owned by `from`.</span>
  65 |     | <span class='neutral'>     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.</span>
  66 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
  67 |     | <span class='neutral'>     *</span>
  68 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='neutral'>    function safeTransferFrom(address from, address to, uint256 tokenId) external;</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /**</span>
  73 |     | <span class='neutral'>     * @dev Transfers `tokenId` token from `from` to `to`.</span>
  74 |     | <span class='neutral'>     *</span>
  75 |     | <span class='neutral'>     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721</span>
  76 |     | <span class='neutral'>     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must</span>
  77 |     | <span class='neutral'>     * understand this adds an external call which potentially creates a reentrancy vulnerability.</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Requirements:</span>
  80 |     | <span class='neutral'>     *</span>
  81 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  82 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  83 |     | <span class='neutral'>     * - `tokenId` token must be owned by `from`.</span>
  84 |     | <span class='neutral'>     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.</span>
  85 |     | <span class='neutral'>     *</span>
  86 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  87 |     | <span class='neutral'>     */</span>
  88 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 tokenId) external;</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /**</span>
  91 |     | <span class='neutral'>     * @dev Gives permission to `to` to transfer `tokenId` token to another account.</span>
  92 |     | <span class='neutral'>     * The approval is cleared when the token is transferred.</span>
  93 |     | <span class='neutral'>     *</span>
  94 |     | <span class='neutral'>     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.</span>
  95 |     | <span class='neutral'>     *</span>
  96 |     | <span class='neutral'>     * Requirements:</span>
  97 |     | <span class='neutral'>     *</span>
  98 |     | <span class='neutral'>     * - The caller must own the token or be an approved operator.</span>
  99 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 100 |     | <span class='neutral'>     *</span>
 101 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 102 |     | <span class='neutral'>     */</span>
 103 |     | <span class='neutral'>    function approve(address to, uint256 tokenId) external;</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /**</span>
 106 |     | <span class='neutral'>     * @dev Approve or remove `operator` as an operator for the caller.</span>
 107 |     | <span class='neutral'>     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.</span>
 108 |     | <span class='neutral'>     *</span>
 109 |     | <span class='neutral'>     * Requirements:</span>
 110 |     | <span class='neutral'>     *</span>
 111 |     | <span class='neutral'>     * - The `operator` cannot be the caller.</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * Emits an {ApprovalForAll} event.</span>
 114 |     | <span class='neutral'>     */</span>
 115 |     | <span class='neutral'>    function setApprovalForAll(address operator, bool approved) external;</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    /**</span>
 118 |     | <span class='neutral'>     * @dev Returns the account approved for `tokenId` token.</span>
 119 |     | <span class='neutral'>     *</span>
 120 |     | <span class='neutral'>     * Requirements:</span>
 121 |     | <span class='neutral'>     *</span>
 122 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 123 |     | <span class='neutral'>     */</span>
 124 |     | <span class='neutral'>    function getApproved(uint256 tokenId) external view returns (address operator);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * See {setApprovalForAll}</span>
 130 |     | <span class='neutral'>     */</span>
 131 |     | <span class='neutral'>    function isApprovedForAll(address owner, address operator) external view returns (bool);</span>
 132 |     | <span class='neutral'>}</span>
 133 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title ERC721 token receiver interface</span>
  8 |     | <span class='neutral'> * @dev Interface for any contract that wants to support safeTransfers</span>
  9 |     | <span class='neutral'> * from ERC721 asset contracts.</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>interface IERC721Receiver {</span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}</span>
 14 |     | <span class='neutral'>     * by `operator` from `from`, this function is called.</span>
 15 |     | <span class='neutral'>     *</span>
 16 |     | <span class='neutral'>     * It must return its Solidity selector to confirm the token transfer.</span>
 17 |     | <span class='neutral'>     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.</span>
 18 |     | <span class='neutral'>     *</span>
 19 |     | <span class='neutral'>     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.</span>
 20 |     | <span class='neutral'>     */</span>
 21 |     | <span class='neutral'>    function onERC721Received(</span>
 22 |     | <span class='neutral'>        address operator,</span>
 23 |     | <span class='neutral'>        address from,</span>
 24 |     | <span class='neutral'>        uint256 tokenId,</span>
 25 |     | <span class='neutral'>        bytes calldata data</span>
 26 |     | <span class='neutral'>    ) external returns (bytes4);</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC721.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @title ERC-721 Non-Fungible Token Standard, optional metadata extension</span>
 10 |     | <span class='neutral'> * @dev See https://eips.ethereum.org/EIPS/eip-721</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='neutral'>interface IERC721Metadata is IERC721 {</span>
 13 |     | <span class='neutral'>    /**</span>
 14 |     | <span class='neutral'>     * @dev Returns the token collection name.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Returns the token collection symbol.</span>
 20 |     | <span class='neutral'>     */</span>
 21 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /**</span>
 24 |     | <span class='neutral'>     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    function tokenURI(uint256 tokenId) external view returns (string memory);</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/utils/Address.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.1;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Collection of functions related to the address type</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='unexecuted'>library Address {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @dev Returns true if `account` is a contract.</span>
  12 |     | <span class='neutral'>     *</span>
  13 |     | <span class='neutral'>     * [IMPORTANT]</span>
  14 |     | <span class='neutral'>     * ====</span>
  15 |     | <span class='neutral'>     * It is unsafe to assume that an address for which this function returns</span>
  16 |     | <span class='neutral'>     * false is an externally-owned account (EOA) and not a contract.</span>
  17 |     | <span class='neutral'>     *</span>
  18 |     | <span class='neutral'>     * Among others, `isContract` will return false for the following</span>
  19 |     | <span class='neutral'>     * types of addresses:</span>
  20 |     | <span class='neutral'>     *</span>
  21 |     | <span class='neutral'>     *  - an externally-owned account</span>
  22 |     | <span class='neutral'>     *  - a contract in construction</span>
  23 |     | <span class='neutral'>     *  - an address where a contract will be created</span>
  24 |     | <span class='neutral'>     *  - an address where a contract lived, but was destroyed</span>
  25 |     | <span class='neutral'>     *</span>
  26 |     | <span class='neutral'>     * Furthermore, `isContract` will also return true if the target contract within</span>
  27 |     | <span class='neutral'>     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,</span>
  28 |     | <span class='neutral'>     * which only has an effect at the end of a transaction.</span>
  29 |     | <span class='neutral'>     * ====</span>
  30 |     | <span class='neutral'>     *</span>
  31 |     | <span class='neutral'>     * [IMPORTANT]</span>
  32 |     | <span class='neutral'>     * ====</span>
  33 |     | <span class='neutral'>     * You shouldn&#39;t rely on `isContract` to protect against flash loan attacks!</span>
  34 |     | <span class='neutral'>     *</span>
  35 |     | <span class='neutral'>     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets</span>
  36 |     | <span class='neutral'>     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract</span>
  37 |     | <span class='neutral'>     * constructor.</span>
  38 |     | <span class='neutral'>     * ====</span>
  39 |     | <span class='neutral'>     */</span>
  40 |     | <span class='neutral'>    function isContract(address account) internal view returns (bool) {</span>
  41 |     | <span class='neutral'>        // This method relies on extcodesize/address.code.length, which returns 0</span>
  42 |     | <span class='neutral'>        // for contracts in construction, since the code is only stored at the end</span>
  43 |     | <span class='neutral'>        // of the constructor execution.</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>        return account.code.length &gt; 0;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Replacement for Solidity&#39;s `transfer`: sends `amount` wei to</span>
  50 |     | <span class='neutral'>     * `recipient`, forwarding all available gas and reverting on errors.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost</span>
  53 |     | <span class='neutral'>     * of certain opcodes, possibly making contracts go over the 2300 gas limit</span>
  54 |     | <span class='neutral'>     * imposed by `transfer`, making them unable to receive funds via</span>
  55 |     | <span class='neutral'>     * `transfer`. {sendValue} removes this limitation.</span>
  56 |     | <span class='neutral'>     *</span>
  57 |     | <span class='neutral'>     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].</span>
  58 |     | <span class='neutral'>     *</span>
  59 |     | <span class='neutral'>     * IMPORTANT: because control is transferred to `recipient`, care must be</span>
  60 |     | <span class='neutral'>     * taken to not create reentrancy vulnerabilities. Consider using</span>
  61 |     | <span class='neutral'>     * {ReentrancyGuard} or the</span>
  62 |     | <span class='neutral'>     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].</span>
  63 |     | <span class='neutral'>     */</span>
  64 |     | <span class='neutral'>    function sendValue(address payable recipient, uint256 amount) internal {</span>
  65 |     | <span class='neutral'>        require(address(this).balance &gt;= amount, &quot;Address: insufficient balance&quot;);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>        (bool success, ) = recipient.call{value: amount}(&quot;&quot;);</span>
  68 |     | <span class='neutral'>        require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /**</span>
  72 |     | <span class='neutral'>     * @dev Performs a Solidity function call using a low level `call`. A</span>
  73 |     | <span class='neutral'>     * plain `call` is an unsafe replacement for a function call: use this</span>
  74 |     | <span class='neutral'>     * function instead.</span>
  75 |     | <span class='neutral'>     *</span>
  76 |     | <span class='neutral'>     * If `target` reverts with a revert reason, it is bubbled up by this</span>
  77 |     | <span class='neutral'>     * function (like regular Solidity function calls).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Returns the raw returned data. To convert to the expected return value,</span>
  80 |     | <span class='neutral'>     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].</span>
  81 |     | <span class='neutral'>     *</span>
  82 |     | <span class='neutral'>     * Requirements:</span>
  83 |     | <span class='neutral'>     *</span>
  84 |     | <span class='neutral'>     * - `target` must be a contract.</span>
  85 |     | <span class='neutral'>     * - calling `target` with `data` must not revert.</span>
  86 |     | <span class='neutral'>     *</span>
  87 |     | <span class='neutral'>     * _Available since v3.1._</span>
  88 |     | <span class='neutral'>     */</span>
  89 |     | <span class='neutral'>    function functionCall(address target, bytes memory data) internal returns (bytes memory) {</span>
  90 |     | <span class='neutral'>        return functionCallWithValue(target, data, 0, &quot;Address: low-level call failed&quot;);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /**</span>
  94 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with</span>
  95 |     | <span class='neutral'>     * `errorMessage` as a fallback revert reason when `target` reverts.</span>
  96 |     | <span class='neutral'>     *</span>
  97 |     | <span class='neutral'>     * _Available since v3.1._</span>
  98 |     | <span class='neutral'>     */</span>
  99 | *   | <span class='executed'>    function functionCall(</span>
 100 |     | <span class='neutral'>        address target,</span>
 101 |     | <span class='neutral'>        bytes memory data,</span>
 102 |     | <span class='neutral'>        string memory errorMessage</span>
 103 | *   | <span class='executed'>    ) internal returns (bytes memory) {</span>
 104 | *   | <span class='executed'>        return functionCallWithValue(target, data, 0, errorMessage);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 109 |     | <span class='neutral'>     * but also transferring `value` wei to `target`.</span>
 110 |     | <span class='neutral'>     *</span>
 111 |     | <span class='neutral'>     * Requirements:</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * - the calling contract must have an ETH balance of at least `value`.</span>
 114 |     | <span class='neutral'>     * - the called Solidity function must be `payable`.</span>
 115 |     | <span class='neutral'>     *</span>
 116 |     | <span class='neutral'>     * _Available since v3.1._</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='neutral'>    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {</span>
 119 |     | <span class='neutral'>        return functionCallWithValue(target, data, value, &quot;Address: low-level call with value failed&quot;);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /**</span>
 123 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but</span>
 124 |     | <span class='neutral'>     * with `errorMessage` as a fallback revert reason when `target` reverts.</span>
 125 |     | <span class='neutral'>     *</span>
 126 |     | <span class='neutral'>     * _Available since v3.1._</span>
 127 |     | <span class='neutral'>     */</span>
 128 | *   | <span class='executed'>    function functionCallWithValue(</span>
 129 |     | <span class='neutral'>        address target,</span>
 130 |     | <span class='neutral'>        bytes memory data,</span>
 131 |     | <span class='neutral'>        uint256 value,</span>
 132 |     | <span class='neutral'>        string memory errorMessage</span>
 133 |     | <span class='unexecuted'>    ) internal returns (bytes memory) {</span>
 134 |     | <span class='unexecuted'>        require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);</span>
 135 | *   | <span class='executed'>        (bool success, bytes memory returndata) = target.call{value: value}(data);</span>
 136 | *   | <span class='executed'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /**</span>
 140 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 141 |     | <span class='neutral'>     * but performing a static call.</span>
 142 |     | <span class='neutral'>     *</span>
 143 |     | <span class='neutral'>     * _Available since v3.3._</span>
 144 |     | <span class='neutral'>     */</span>
 145 |     | <span class='neutral'>    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {</span>
 146 |     | <span class='neutral'>        return functionStaticCall(target, data, &quot;Address: low-level static call failed&quot;);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /**</span>
 150 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],</span>
 151 |     | <span class='neutral'>     * but performing a static call.</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * _Available since v3.3._</span>
 154 |     | <span class='neutral'>     */</span>
 155 |     | <span class='neutral'>    function functionStaticCall(</span>
 156 |     | <span class='neutral'>        address target,</span>
 157 |     | <span class='neutral'>        bytes memory data,</span>
 158 |     | <span class='neutral'>        string memory errorMessage</span>
 159 |     | <span class='neutral'>    ) internal view returns (bytes memory) {</span>
 160 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.staticcall(data);</span>
 161 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /**</span>
 165 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 166 |     | <span class='neutral'>     * but performing a delegate call.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * _Available since v3.4._</span>
 169 |     | <span class='neutral'>     */</span>
 170 |     | <span class='neutral'>    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {</span>
 171 |     | <span class='neutral'>        return functionDelegateCall(target, data, &quot;Address: low-level delegate call failed&quot;);</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    /**</span>
 175 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],</span>
 176 |     | <span class='neutral'>     * but performing a delegate call.</span>
 177 |     | <span class='neutral'>     *</span>
 178 |     | <span class='neutral'>     * _Available since v3.4._</span>
 179 |     | <span class='neutral'>     */</span>
 180 |     | <span class='neutral'>    function functionDelegateCall(</span>
 181 |     | <span class='neutral'>        address target,</span>
 182 |     | <span class='neutral'>        bytes memory data,</span>
 183 |     | <span class='neutral'>        string memory errorMessage</span>
 184 |     | <span class='neutral'>    ) internal returns (bytes memory) {</span>
 185 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.delegatecall(data);</span>
 186 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    /**</span>
 190 |     | <span class='neutral'>     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling</span>
 191 |     | <span class='neutral'>     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * _Available since v4.8._</span>
 194 |     | <span class='neutral'>     */</span>
 195 | *   | <span class='executed'>    function verifyCallResultFromTarget(</span>
 196 |     | <span class='neutral'>        address target,</span>
 197 |     | <span class='neutral'>        bool success,</span>
 198 |     | <span class='neutral'>        bytes memory returndata,</span>
 199 |     | <span class='neutral'>        string memory errorMessage</span>
 200 | *   | <span class='executed'>    ) internal view returns (bytes memory) {</span>
 201 | *   | <span class='executed'>        if (success) {</span>
 202 | *   | <span class='executed'>            if (returndata.length == 0) {</span>
 203 |     | <span class='neutral'>                // only check isContract if the call was successful and the return data is empty</span>
 204 |     | <span class='neutral'>                // otherwise we already know that it was a contract</span>
 205 | *   | <span class='executed'>                require(isContract(target), &quot;Address: call to non-contract&quot;);</span>
 206 |     | <span class='neutral'>            }</span>
 207 | *   | <span class='executed'>            return returndata;</span>
 208 |     | <span class='neutral'>        } else {</span>
 209 | *   | <span class='executed'>            _revert(returndata, errorMessage);</span>
 210 |     | <span class='neutral'>        }</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    /**</span>
 214 |     | <span class='neutral'>     * @dev Tool to verify that a low level call was successful, and revert if it wasn&#39;t, either by bubbling the</span>
 215 |     | <span class='neutral'>     * revert reason or using the provided one.</span>
 216 |     | <span class='neutral'>     *</span>
 217 |     | <span class='neutral'>     * _Available since v4.3._</span>
 218 |     | <span class='neutral'>     */</span>
 219 |     | <span class='neutral'>    function verifyCallResult(</span>
 220 |     | <span class='neutral'>        bool success,</span>
 221 |     | <span class='neutral'>        bytes memory returndata,</span>
 222 |     | <span class='neutral'>        string memory errorMessage</span>
 223 |     | <span class='neutral'>    ) internal pure returns (bytes memory) {</span>
 224 |     | <span class='neutral'>        if (success) {</span>
 225 |     | <span class='neutral'>            return returndata;</span>
 226 |     | <span class='neutral'>        } else {</span>
 227 |     | <span class='neutral'>            _revert(returndata, errorMessage);</span>
 228 |     | <span class='neutral'>        }</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    function _revert(bytes memory returndata, string memory errorMessage) private pure {</span>
 232 |     | <span class='neutral'>        // Look for revert reason and bubble it up if present</span>
 233 | *   | <span class='executed'>        if (returndata.length &gt; 0) {</span>
 234 |     | <span class='neutral'>            // The easiest way to bubble the revert reason is using memory via assembly</span>
 235 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 236 |     | <span class='neutral'>            assembly {</span>
 237 | *   | <span class='executed'>                let returndata_size := mload(returndata)</span>
 238 | *   | <span class='executed'>                revert(add(32, returndata), returndata_size)</span>
 239 |     | <span class='neutral'>            }</span>
 240 |     | <span class='neutral'>        } else {</span>
 241 |     | <span class='unexecuted'>            revert(errorMessage);</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'>}</span>
 245 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 |     | <span class='neutral'>    function _msgSender() internal view virtual returns (address) {</span>
 18 | *   | <span class='executed'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function _contextSuffixLength() internal view virtual returns (uint256) {</span>
 26 |     | <span class='neutral'>        return 0;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/utils/Counters.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title Counters</span>
  8 |     | <span class='neutral'> * @author Matt Condon (@shrugs)</span>
  9 |     | <span class='neutral'> * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number</span>
 10 |     | <span class='neutral'> * of elements in a mapping, issuing ERC721 ids, or counting request ids.</span>
 11 |     | <span class='neutral'> *</span>
 12 |     | <span class='neutral'> * Include with `using Counters for Counters.Counter;`</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='unexecuted'>library Counters {</span>
 15 |     | <span class='neutral'>    struct Counter {</span>
 16 |     | <span class='neutral'>        // This variable should never be directly accessed by users of the library: interactions must be restricted to</span>
 17 |     | <span class='neutral'>        // the library&#39;s function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add</span>
 18 |     | <span class='neutral'>        // this feature: see https://github.com/ethereum/solidity/issues/4637</span>
 19 |     | <span class='neutral'>        uint256 _value; // default: 0</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function current(Counter storage counter) internal view returns (uint256) {</span>
 23 |     | <span class='unexecuted'>        return counter._value;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    function increment(Counter storage counter) internal {</span>
 27 |     | <span class='neutral'>        unchecked {</span>
 28 |     | <span class='unexecuted'>            counter._value += 1;</span>
 29 |     | <span class='neutral'>        }</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    function decrement(Counter storage counter) internal {</span>
 33 |     | <span class='neutral'>        uint256 value = counter._value;</span>
 34 |     | <span class='neutral'>        require(value &gt; 0, &quot;Counter: decrement overflow&quot;);</span>
 35 |     | <span class='neutral'>        unchecked {</span>
 36 |     | <span class='neutral'>            counter._value = value - 1;</span>
 37 |     | <span class='neutral'>        }</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    function reset(Counter storage counter) internal {</span>
 41 |     | <span class='neutral'>        counter._value = 0;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/utils/ShortStrings.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.8;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./StorageSlot.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |</span>
   9 |     | <span class='neutral'>// | length  | 0x                                                              BB |</span>
  10 |     | <span class='neutral'>type ShortString is bytes32;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/**</span>
  13 |     | <span class='neutral'> * @dev This library provides functions to convert short memory strings</span>
  14 |     | <span class='neutral'> * into a `ShortString` type that can be used as an immutable variable.</span>
  15 |     | <span class='neutral'> *</span>
  16 |     | <span class='neutral'> * Strings of arbitrary length can be optimized using this library if</span>
  17 |     | <span class='neutral'> * they are short enough (up to 31 bytes) by packing them with their</span>
  18 |     | <span class='neutral'> * length (1 byte) in a single EVM word (32 bytes). Additionally, a</span>
  19 |     | <span class='neutral'> * fallback mechanism can be used for every other case.</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * Usage example:</span>
  22 |     | <span class='neutral'> *</span>
  23 |     | <span class='neutral'> * ```solidity</span>
  24 |     | <span class='neutral'> * contract Named {</span>
  25 |     | <span class='neutral'> *     using ShortStrings for *;</span>
  26 |     | <span class='neutral'> *</span>
  27 |     | <span class='neutral'> *     ShortString private immutable _name;</span>
  28 |     | <span class='neutral'> *     string private _nameFallback;</span>
  29 |     | <span class='neutral'> *</span>
  30 |     | <span class='neutral'> *     constructor(string memory contractName) {</span>
  31 |     | <span class='neutral'> *         _name = contractName.toShortStringWithFallback(_nameFallback);</span>
  32 |     | <span class='neutral'> *     }</span>
  33 |     | <span class='neutral'> *</span>
  34 |     | <span class='neutral'> *     function name() external view returns (string memory) {</span>
  35 |     | <span class='neutral'> *         return _name.toStringWithFallback(_nameFallback);</span>
  36 |     | <span class='neutral'> *     }</span>
  37 |     | <span class='neutral'> * }</span>
  38 |     | <span class='neutral'> * ```</span>
  39 |     | <span class='neutral'> */</span>
  40 |     | <span class='unexecuted'>library ShortStrings {</span>
  41 |     | <span class='neutral'>    // Used as an identifier for strings longer than 31 bytes.</span>
  42 |     | <span class='unexecuted'>    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    error StringTooLong(string str);</span>
  45 |     | <span class='neutral'>    error InvalidShortString();</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /**</span>
  48 |     | <span class='neutral'>     * @dev Encode a string of at most 31 chars into a `ShortString`.</span>
  49 |     | <span class='neutral'>     *</span>
  50 |     | <span class='neutral'>     * This will trigger a `StringTooLong` error is the input string is too long.</span>
  51 |     | <span class='neutral'>     */</span>
  52 | *   | <span class='executed'>    function toShortString(string memory str) internal pure returns (ShortString) {</span>
  53 | *   | <span class='executed'>        bytes memory bstr = bytes(str);</span>
  54 | *   | <span class='executed'>        if (bstr.length &gt; 31) {</span>
  55 |     | <span class='unexecuted'>            revert StringTooLong(str);</span>
  56 |     | <span class='neutral'>        }</span>
  57 | *   | <span class='executed'>        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /**</span>
  61 |     | <span class='neutral'>     * @dev Decode a `ShortString` back to a &quot;normal&quot; string.</span>
  62 |     | <span class='neutral'>     */</span>
  63 |     | <span class='unexecuted'>    function toString(ShortString sstr) internal pure returns (string memory) {</span>
  64 |     | <span class='unexecuted'>        uint256 len = byteLength(sstr);</span>
  65 |     | <span class='neutral'>        // using `new string(len)` would work locally but is not memory safe.</span>
  66 |     | <span class='unexecuted'>        string memory str = new string(32);</span>
  67 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  68 |     | <span class='neutral'>        assembly {</span>
  69 |     | <span class='unexecuted'>            mstore(str, len)</span>
  70 |     | <span class='unexecuted'>            mstore(add(str, 0x20), sstr)</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'>        return str;</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /**</span>
  76 |     | <span class='neutral'>     * @dev Return the length of a `ShortString`.</span>
  77 |     | <span class='neutral'>     */</span>
  78 |     | <span class='unexecuted'>    function byteLength(ShortString sstr) internal pure returns (uint256) {</span>
  79 |     | <span class='unexecuted'>        uint256 result = uint256(ShortString.unwrap(sstr)) &amp; 0xFF;</span>
  80 |     | <span class='unexecuted'>        if (result &gt; 31) {</span>
  81 |     | <span class='unexecuted'>            revert InvalidShortString();</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'>        return result;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /**</span>
  87 |     | <span class='neutral'>     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.</span>
  88 |     | <span class='neutral'>     */</span>
  89 | *   | <span class='executed'>    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {</span>
  90 | *   | <span class='executed'>        if (bytes(value).length &lt; 32) {</span>
  91 | *   | <span class='executed'>            return toShortString(value);</span>
  92 |     | <span class='neutral'>        } else {</span>
  93 |     | <span class='unexecuted'>            StorageSlot.getStringSlot(store).value = value;</span>
  94 |     | <span class='neutral'>            return ShortString.wrap(_FALLBACK_SENTINEL);</span>
  95 |     | <span class='neutral'>        }</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.</span>
 100 |     | <span class='neutral'>     */</span>
 101 |     | <span class='unexecuted'>    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {</span>
 102 |     | <span class='unexecuted'>        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {</span>
 103 |     | <span class='unexecuted'>            return toString(value);</span>
 104 |     | <span class='neutral'>        } else {</span>
 105 |     | <span class='unexecuted'>            return store;</span>
 106 |     | <span class='neutral'>        }</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /**</span>
 110 |     | <span class='neutral'>     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.</span>
 111 |     | <span class='neutral'>     *</span>
 112 |     | <span class='neutral'>     * WARNING: This will return the &quot;byte length&quot; of the string. This may not reflect the actual length in terms of</span>
 113 |     | <span class='neutral'>     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.</span>
 114 |     | <span class='neutral'>     */</span>
 115 |     | <span class='neutral'>    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {</span>
 116 |     | <span class='neutral'>        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {</span>
 117 |     | <span class='neutral'>            return byteLength(value);</span>
 118 |     | <span class='neutral'>        } else {</span>
 119 |     | <span class='neutral'>            return bytes(store).length;</span>
 120 |     | <span class='neutral'>        }</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'>}</span>
 123 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)</span>
   3 |     | <span class='neutral'>// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @dev Library for reading and writing primitive types to specific storage slots.</span>
   9 |     | <span class='neutral'> *</span>
  10 |     | <span class='neutral'> * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.</span>
  11 |     | <span class='neutral'> * This library helps with reading and writing to such slots without the need for inline assembly.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.</span>
  14 |     | <span class='neutral'> *</span>
  15 |     | <span class='neutral'> * Example usage to set ERC1967 implementation slot:</span>
  16 |     | <span class='neutral'> * ```solidity</span>
  17 |     | <span class='neutral'> * contract ERC1967 {</span>
  18 |     | <span class='neutral'> *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span>
  19 |     | <span class='neutral'> *</span>
  20 |     | <span class='neutral'> *     function _getImplementation() internal view returns (address) {</span>
  21 |     | <span class='neutral'> *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;</span>
  22 |     | <span class='neutral'> *     }</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> *     function _setImplementation(address newImplementation) internal {</span>
  25 |     | <span class='neutral'> *         require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);</span>
  26 |     | <span class='neutral'> *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;</span>
  27 |     | <span class='neutral'> *     }</span>
  28 |     | <span class='neutral'> * }</span>
  29 |     | <span class='neutral'> * ```</span>
  30 |     | <span class='neutral'> *</span>
  31 |     | <span class='neutral'> * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._</span>
  32 |     | <span class='neutral'> * _Available since v4.9 for `string`, `bytes`._</span>
  33 |     | <span class='neutral'> */</span>
  34 |     | <span class='unexecuted'>library StorageSlot {</span>
  35 |     | <span class='neutral'>    struct AddressSlot {</span>
  36 |     | <span class='neutral'>        address value;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    struct BooleanSlot {</span>
  40 |     | <span class='neutral'>        bool value;</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    struct Bytes32Slot {</span>
  44 |     | <span class='neutral'>        bytes32 value;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    struct Uint256Slot {</span>
  48 |     | <span class='neutral'>        uint256 value;</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    struct StringSlot {</span>
  52 |     | <span class='neutral'>        string value;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    struct BytesSlot {</span>
  56 |     | <span class='neutral'>        bytes value;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns an `AddressSlot` with member `value` located at `slot`.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='neutral'>    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {</span>
  63 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  64 |     | <span class='neutral'>        assembly {</span>
  65 |     | <span class='neutral'>            r.slot := slot</span>
  66 |     | <span class='neutral'>        }</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.</span>
  71 |     | <span class='neutral'>     */</span>
  72 |     | <span class='neutral'>    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {</span>
  73 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  74 |     | <span class='neutral'>        assembly {</span>
  75 |     | <span class='neutral'>            r.slot := slot</span>
  76 |     | <span class='neutral'>        }</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /**</span>
  80 |     | <span class='neutral'>     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.</span>
  81 |     | <span class='neutral'>     */</span>
  82 |     | <span class='neutral'>    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {</span>
  83 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  84 |     | <span class='neutral'>        assembly {</span>
  85 |     | <span class='neutral'>            r.slot := slot</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /**</span>
  90 |     | <span class='neutral'>     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.</span>
  91 |     | <span class='neutral'>     */</span>
  92 |     | <span class='neutral'>    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {</span>
  93 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  94 |     | <span class='neutral'>        assembly {</span>
  95 |     | <span class='neutral'>            r.slot := slot</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /**</span>
 100 |     | <span class='neutral'>     * @dev Returns an `StringSlot` with member `value` located at `slot`.</span>
 101 |     | <span class='neutral'>     */</span>
 102 |     | <span class='neutral'>    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {</span>
 103 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 104 |     | <span class='neutral'>        assembly {</span>
 105 |     | <span class='neutral'>            r.slot := slot</span>
 106 |     | <span class='neutral'>        }</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /**</span>
 110 |     | <span class='neutral'>     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.</span>
 111 |     | <span class='neutral'>     */</span>
 112 |     | <span class='neutral'>    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {</span>
 113 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 114 |     | <span class='neutral'>        assembly {</span>
 115 |     | <span class='neutral'>            r.slot := store.slot</span>
 116 |     | <span class='neutral'>        }</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev Returns an `BytesSlot` with member `value` located at `slot`.</span>
 121 |     | <span class='neutral'>     */</span>
 122 |     | <span class='neutral'>    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {</span>
 123 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 124 |     | <span class='neutral'>        assembly {</span>
 125 |     | <span class='neutral'>            r.slot := slot</span>
 126 |     | <span class='neutral'>        }</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /**</span>
 130 |     | <span class='neutral'>     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.</span>
 131 |     | <span class='neutral'>     */</span>
 132 |     | <span class='neutral'>    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {</span>
 133 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 134 |     | <span class='neutral'>        assembly {</span>
 135 |     | <span class='neutral'>            r.slot := store.slot</span>
 136 |     | <span class='neutral'>        }</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'>}</span>
 139 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/utils/Strings.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./math/Math.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./math/SignedMath.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev String operations.</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='unexecuted'>library Strings {</span>
 13 |     | <span class='neutral'>    bytes16 private constant _SYMBOLS = &quot;0123456789abcdef&quot;;</span>
 14 |     | <span class='neutral'>    uint8 private constant _ADDRESS_LENGTH = 20;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` decimal representation.</span>
 18 |     | <span class='neutral'>     */</span>
 19 |     | <span class='unexecuted'>    function toString(uint256 value) internal pure returns (string memory) {</span>
 20 |     | <span class='neutral'>        unchecked {</span>
 21 |     | <span class='unexecuted'>            uint256 length = Math.log10(value) + 1;</span>
 22 |     | <span class='unexecuted'>            string memory buffer = new string(length);</span>
 23 |     | <span class='neutral'>            uint256 ptr;</span>
 24 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 25 |     | <span class='neutral'>            assembly {</span>
 26 |     | <span class='unexecuted'>                ptr := add(buffer, add(32, length))</span>
 27 |     | <span class='neutral'>            }</span>
 28 |     | <span class='unexecuted'>            while (true) {</span>
 29 |     | <span class='unexecuted'>                ptr--;</span>
 30 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 31 |     | <span class='neutral'>                assembly {</span>
 32 |     | <span class='unexecuted'>                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))</span>
 33 |     | <span class='neutral'>                }</span>
 34 |     | <span class='unexecuted'>                value /= 10;</span>
 35 |     | <span class='unexecuted'>                if (value == 0) break;</span>
 36 |     | <span class='neutral'>            }</span>
 37 |     | <span class='unexecuted'>            return buffer;</span>
 38 |     | <span class='neutral'>        }</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /**</span>
 42 |     | <span class='neutral'>     * @dev Converts a `int256` to its ASCII `string` decimal representation.</span>
 43 |     | <span class='neutral'>     */</span>
 44 |     | <span class='neutral'>    function toString(int256 value) internal pure returns (string memory) {</span>
 45 |     | <span class='neutral'>        return string(abi.encodePacked(value &lt; 0 ? &quot;-&quot; : &quot;&quot;, toString(SignedMath.abs(value))));</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    /**</span>
 49 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.</span>
 50 |     | <span class='neutral'>     */</span>
 51 |     | <span class='neutral'>    function toHexString(uint256 value) internal pure returns (string memory) {</span>
 52 |     | <span class='neutral'>        unchecked {</span>
 53 |     | <span class='neutral'>            return toHexString(value, Math.log256(value) + 1);</span>
 54 |     | <span class='neutral'>        }</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    /**</span>
 58 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.</span>
 59 |     | <span class='neutral'>     */</span>
 60 |     | <span class='neutral'>    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {</span>
 61 |     | <span class='neutral'>        bytes memory buffer = new bytes(2 * length + 2);</span>
 62 |     | <span class='neutral'>        buffer[0] = &quot;0&quot;;</span>
 63 |     | <span class='neutral'>        buffer[1] = &quot;x&quot;;</span>
 64 |     | <span class='neutral'>        for (uint256 i = 2 * length + 1; i &gt; 1; --i) {</span>
 65 |     | <span class='neutral'>            buffer[i] = _SYMBOLS[value &amp; 0xf];</span>
 66 |     | <span class='neutral'>            value &gt;&gt;= 4;</span>
 67 |     | <span class='neutral'>        }</span>
 68 |     | <span class='neutral'>        require(value == 0, &quot;Strings: hex length insufficient&quot;);</span>
 69 |     | <span class='neutral'>        return string(buffer);</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>    /**</span>
 73 |     | <span class='neutral'>     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.</span>
 74 |     | <span class='neutral'>     */</span>
 75 |     | <span class='neutral'>    function toHexString(address addr) internal pure returns (string memory) {</span>
 76 |     | <span class='neutral'>        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='neutral'>    /**</span>
 80 |     | <span class='neutral'>     * @dev Returns true if the two strings are equal.</span>
 81 |     | <span class='neutral'>     */</span>
 82 |     | <span class='neutral'>    function equal(string memory a, string memory b) internal pure returns (bool) {</span>
 83 |     | <span class='neutral'>        return keccak256(bytes(a)) == keccak256(bytes(b));</span>
 84 |     | <span class='neutral'>    }</span>
 85 |     | <span class='neutral'>}</span>
 86 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../Strings.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.</span>
  10 |     | <span class='neutral'> *</span>
  11 |     | <span class='neutral'> * These functions can be used to verify that a message was signed by the holder</span>
  12 |     | <span class='neutral'> * of the private keys of a given address.</span>
  13 |     | <span class='neutral'> */</span>
  14 |     | <span class='unexecuted'>library ECDSA {</span>
  15 |     | <span class='neutral'>    enum RecoverError {</span>
  16 |     | <span class='neutral'>        NoError,</span>
  17 |     | <span class='neutral'>        InvalidSignature,</span>
  18 |     | <span class='neutral'>        InvalidSignatureLength,</span>
  19 |     | <span class='neutral'>        InvalidSignatureS,</span>
  20 |     | <span class='neutral'>        InvalidSignatureV // Deprecated in v4.8</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function _throwError(RecoverError error) private pure {</span>
  24 |     | <span class='unexecuted'>        if (error == RecoverError.NoError) {</span>
  25 |     | <span class='neutral'>            return; // no error: do nothing</span>
  26 |     | <span class='unexecuted'>        } else if (error == RecoverError.InvalidSignature) {</span>
  27 |     | <span class='unexecuted'>            revert(&quot;ECDSA: invalid signature&quot;);</span>
  28 |     | <span class='unexecuted'>        } else if (error == RecoverError.InvalidSignatureLength) {</span>
  29 |     | <span class='unexecuted'>            revert(&quot;ECDSA: invalid signature length&quot;);</span>
  30 |     | <span class='unexecuted'>        } else if (error == RecoverError.InvalidSignatureS) {</span>
  31 |     | <span class='unexecuted'>            revert(&quot;ECDSA: invalid signature &#39;s&#39; value&quot;);</span>
  32 |     | <span class='neutral'>        }</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /**</span>
  36 |     | <span class='neutral'>     * @dev Returns the address that signed a hashed message (`hash`) with</span>
  37 |     | <span class='neutral'>     * `signature` or error string. This address can then be used for verification purposes.</span>
  38 |     | <span class='neutral'>     *</span>
  39 |     | <span class='neutral'>     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:</span>
  40 |     | <span class='neutral'>     * this function rejects them by requiring the `s` value to be in the lower</span>
  41 |     | <span class='neutral'>     * half order, and the `v` value to be either 27 or 28.</span>
  42 |     | <span class='neutral'>     *</span>
  43 |     | <span class='neutral'>     * IMPORTANT: `hash` _must_ be the result of a hash operation for the</span>
  44 |     | <span class='neutral'>     * verification to be secure: it is possible to craft signatures that</span>
  45 |     | <span class='neutral'>     * recover to arbitrary addresses for non-hashed data. A safe way to ensure</span>
  46 |     | <span class='neutral'>     * this is by receiving a hash of the original message (which may otherwise</span>
  47 |     | <span class='neutral'>     * be too long), and then calling {toEthSignedMessageHash} on it.</span>
  48 |     | <span class='neutral'>     *</span>
  49 |     | <span class='neutral'>     * Documentation for signature generation:</span>
  50 |     | <span class='neutral'>     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]</span>
  51 |     | <span class='neutral'>     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]</span>
  52 |     | <span class='neutral'>     *</span>
  53 |     | <span class='neutral'>     * _Available since v4.3._</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {</span>
  56 |     | <span class='neutral'>        if (signature.length == 65) {</span>
  57 |     | <span class='neutral'>            bytes32 r;</span>
  58 |     | <span class='neutral'>            bytes32 s;</span>
  59 |     | <span class='neutral'>            uint8 v;</span>
  60 |     | <span class='neutral'>            // ecrecover takes the signature parameters, and the only way to get them</span>
  61 |     | <span class='neutral'>            // currently is to use assembly.</span>
  62 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
  63 |     | <span class='neutral'>            assembly {</span>
  64 |     | <span class='neutral'>                r := mload(add(signature, 0x20))</span>
  65 |     | <span class='neutral'>                s := mload(add(signature, 0x40))</span>
  66 |     | <span class='neutral'>                v := byte(0, mload(add(signature, 0x60)))</span>
  67 |     | <span class='neutral'>            }</span>
  68 |     | <span class='neutral'>            return tryRecover(hash, v, r, s);</span>
  69 |     | <span class='neutral'>        } else {</span>
  70 |     | <span class='neutral'>            return (address(0), RecoverError.InvalidSignatureLength);</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Returns the address that signed a hashed message (`hash`) with</span>
  76 |     | <span class='neutral'>     * `signature`. This address can then be used for verification purposes.</span>
  77 |     | <span class='neutral'>     *</span>
  78 |     | <span class='neutral'>     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:</span>
  79 |     | <span class='neutral'>     * this function rejects them by requiring the `s` value to be in the lower</span>
  80 |     | <span class='neutral'>     * half order, and the `v` value to be either 27 or 28.</span>
  81 |     | <span class='neutral'>     *</span>
  82 |     | <span class='neutral'>     * IMPORTANT: `hash` _must_ be the result of a hash operation for the</span>
  83 |     | <span class='neutral'>     * verification to be secure: it is possible to craft signatures that</span>
  84 |     | <span class='neutral'>     * recover to arbitrary addresses for non-hashed data. A safe way to ensure</span>
  85 |     | <span class='neutral'>     * this is by receiving a hash of the original message (which may otherwise</span>
  86 |     | <span class='neutral'>     * be too long), and then calling {toEthSignedMessageHash} on it.</span>
  87 |     | <span class='neutral'>     */</span>
  88 |     | <span class='neutral'>    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {</span>
  89 |     | <span class='neutral'>        (address recovered, RecoverError error) = tryRecover(hash, signature);</span>
  90 |     | <span class='neutral'>        _throwError(error);</span>
  91 |     | <span class='neutral'>        return recovered;</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /**</span>
  95 |     | <span class='neutral'>     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.</span>
  96 |     | <span class='neutral'>     *</span>
  97 |     | <span class='neutral'>     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]</span>
  98 |     | <span class='neutral'>     *</span>
  99 |     | <span class='neutral'>     * _Available since v4.3._</span>
 100 |     | <span class='neutral'>     */</span>
 101 |     | <span class='neutral'>    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {</span>
 102 |     | <span class='neutral'>        bytes32 s = vs &amp; bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);</span>
 103 |     | <span class='neutral'>        uint8 v = uint8((uint256(vs) &gt;&gt; 255) + 27);</span>
 104 |     | <span class='neutral'>        return tryRecover(hash, v, r, s);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * _Available since v4.2._</span>
 111 |     | <span class='neutral'>     */</span>
 112 |     | <span class='neutral'>    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {</span>
 113 |     | <span class='neutral'>        (address recovered, RecoverError error) = tryRecover(hash, r, vs);</span>
 114 |     | <span class='neutral'>        _throwError(error);</span>
 115 |     | <span class='neutral'>        return recovered;</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    /**</span>
 119 |     | <span class='neutral'>     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,</span>
 120 |     | <span class='neutral'>     * `r` and `s` signature fields separately.</span>
 121 |     | <span class='neutral'>     *</span>
 122 |     | <span class='neutral'>     * _Available since v4.3._</span>
 123 |     | <span class='neutral'>     */</span>
 124 |     | <span class='unexecuted'>    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {</span>
 125 |     | <span class='neutral'>        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature</span>
 126 |     | <span class='neutral'>        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines</span>
 127 |     | <span class='neutral'>        // the valid range for s in (301): 0 &lt; s &lt; secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most</span>
 128 |     | <span class='neutral'>        // signatures from current libraries generate a unique signature with an s-value in the lower half order.</span>
 129 |     | <span class='neutral'>        //</span>
 130 |     | <span class='neutral'>        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value</span>
 131 |     | <span class='neutral'>        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or</span>
 132 |     | <span class='neutral'>        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept</span>
 133 |     | <span class='neutral'>        // these malleable signatures as well.</span>
 134 |     | <span class='unexecuted'>        if (uint256(s) &gt; 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {</span>
 135 |     | <span class='unexecuted'>            return (address(0), RecoverError.InvalidSignatureS);</span>
 136 |     | <span class='neutral'>        }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>        // If the signature is valid (and not malleable), return the signer address</span>
 139 |     | <span class='unexecuted'>        address signer = ecrecover(hash, v, r, s);</span>
 140 |     | <span class='unexecuted'>        if (signer == address(0)) {</span>
 141 |     | <span class='unexecuted'>            return (address(0), RecoverError.InvalidSignature);</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>        return (signer, RecoverError.NoError);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /**</span>
 148 |     | <span class='neutral'>     * @dev Overload of {ECDSA-recover} that receives the `v`,</span>
 149 |     | <span class='neutral'>     * `r` and `s` signature fields separately.</span>
 150 |     | <span class='neutral'>     */</span>
 151 |     | <span class='unexecuted'>    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {</span>
 152 |     | <span class='unexecuted'>        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);</span>
 153 |     | <span class='unexecuted'>        _throwError(error);</span>
 154 |     | <span class='unexecuted'>        return recovered;</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    /**</span>
 158 |     | <span class='neutral'>     * @dev Returns an Ethereum Signed Message, created from a `hash`. This</span>
 159 |     | <span class='neutral'>     * produces hash corresponding to the one signed with the</span>
 160 |     | <span class='neutral'>     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]</span>
 161 |     | <span class='neutral'>     * JSON-RPC method as part of EIP-191.</span>
 162 |     | <span class='neutral'>     *</span>
 163 |     | <span class='neutral'>     * See {recover}.</span>
 164 |     | <span class='neutral'>     */</span>
 165 |     | <span class='neutral'>    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {</span>
 166 |     | <span class='neutral'>        // 32 is the length in bytes of hash,</span>
 167 |     | <span class='neutral'>        // enforced by the type signature above</span>
 168 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 169 |     | <span class='neutral'>        assembly {</span>
 170 |     | <span class='neutral'>            mstore(0x00, &quot;\x19Ethereum Signed Message:\n32&quot;)</span>
 171 |     | <span class='neutral'>            mstore(0x1c, hash)</span>
 172 |     | <span class='neutral'>            message := keccak256(0x00, 0x3c)</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /**</span>
 177 |     | <span class='neutral'>     * @dev Returns an Ethereum Signed Message, created from `s`. This</span>
 178 |     | <span class='neutral'>     * produces hash corresponding to the one signed with the</span>
 179 |     | <span class='neutral'>     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]</span>
 180 |     | <span class='neutral'>     * JSON-RPC method as part of EIP-191.</span>
 181 |     | <span class='neutral'>     *</span>
 182 |     | <span class='neutral'>     * See {recover}.</span>
 183 |     | <span class='neutral'>     */</span>
 184 |     | <span class='neutral'>    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {</span>
 185 |     | <span class='neutral'>        return keccak256(abi.encodePacked(&quot;\x19Ethereum Signed Message:\n&quot;, Strings.toString(s.length), s));</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    /**</span>
 189 |     | <span class='neutral'>     * @dev Returns an Ethereum Signed Typed Data, created from a</span>
 190 |     | <span class='neutral'>     * `domainSeparator` and a `structHash`. This produces hash corresponding</span>
 191 |     | <span class='neutral'>     * to the one signed with the</span>
 192 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]</span>
 193 |     | <span class='neutral'>     * JSON-RPC method as part of EIP-712.</span>
 194 |     | <span class='neutral'>     *</span>
 195 |     | <span class='neutral'>     * See {recover}.</span>
 196 |     | <span class='neutral'>     */</span>
 197 |     | <span class='unexecuted'>    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {</span>
 198 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 199 |     | <span class='neutral'>        assembly {</span>
 200 |     | <span class='unexecuted'>            let ptr := mload(0x40)</span>
 201 |     | <span class='unexecuted'>            mstore(ptr, &quot;\x19\x01&quot;)</span>
 202 |     | <span class='unexecuted'>            mstore(add(ptr, 0x02), domainSeparator)</span>
 203 |     | <span class='unexecuted'>            mstore(add(ptr, 0x22), structHash)</span>
 204 |     | <span class='unexecuted'>            data := keccak256(ptr, 0x42)</span>
 205 |     | <span class='neutral'>        }</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    /**</span>
 209 |     | <span class='neutral'>     * @dev Returns an Ethereum Signed Data with intended validator, created from a</span>
 210 |     | <span class='neutral'>     * `validator` and `data` according to the version 0 of EIP-191.</span>
 211 |     | <span class='neutral'>     *</span>
 212 |     | <span class='neutral'>     * See {recover}.</span>
 213 |     | <span class='neutral'>     */</span>
 214 |     | <span class='neutral'>    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {</span>
 215 |     | <span class='neutral'>        return keccak256(abi.encodePacked(&quot;\x19\x00&quot;, validator, data));</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'>}</span>
 218 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.8;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./ECDSA.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../ShortStrings.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../interfaces/IERC5267.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,</span>
  14 |     | <span class='neutral'> * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding</span>
  15 |     | <span class='neutral'> * they need in their contracts using a combination of `abi.encode` and `keccak256`.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding</span>
  18 |     | <span class='neutral'> * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA</span>
  19 |     | <span class='neutral'> * ({_hashTypedDataV4}).</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * The implementation of the domain separator was designed to be as efficient as possible while still properly updating</span>
  22 |     | <span class='neutral'> * the chain id to protect against replay attacks on an eventual fork of the chain.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * NOTE: This contract implements the version of the encoding known as &quot;v4&quot;, as implemented by the JSON RPC method</span>
  25 |     | <span class='neutral'> * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].</span>
  26 |     | <span class='neutral'> *</span>
  27 |     | <span class='neutral'> * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain</span>
  28 |     | <span class='neutral'> * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the</span>
  29 |     | <span class='neutral'> * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.</span>
  30 |     | <span class='neutral'> *</span>
  31 |     | <span class='neutral'> * _Available since v3.4._</span>
  32 |     | <span class='neutral'> *</span>
  33 |     | <span class='neutral'> * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment</span>
  34 |     | <span class='neutral'> */</span>
  35 |     | <span class='neutral'>abstract contract EIP712 is IERC5267 {</span>
  36 |     | <span class='neutral'>    using ShortStrings for *;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    bytes32 private constant _TYPE_HASH =</span>
  39 | *   | <span class='executed'>        keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to</span>
  42 |     | <span class='neutral'>    // invalidate the cached domain separator if the chain id changes.</span>
  43 |     | <span class='neutral'>    bytes32 private immutable _cachedDomainSeparator;</span>
  44 |     | <span class='neutral'>    uint256 private immutable _cachedChainId;</span>
  45 |     | <span class='neutral'>    address private immutable _cachedThis;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    bytes32 private immutable _hashedName;</span>
  48 |     | <span class='neutral'>    bytes32 private immutable _hashedVersion;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    ShortString private immutable _name;</span>
  51 |     | <span class='neutral'>    ShortString private immutable _version;</span>
  52 |     | <span class='neutral'>    string private _nameFallback;</span>
  53 |     | <span class='neutral'>    string private _versionFallback;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /**</span>
  56 |     | <span class='neutral'>     * @dev Initializes the domain separator and parameter caches.</span>
  57 |     | <span class='neutral'>     *</span>
  58 |     | <span class='neutral'>     * The meaning of `name` and `version` is specified in</span>
  59 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:</span>
  60 |     | <span class='neutral'>     *</span>
  61 |     | <span class='neutral'>     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.</span>
  62 |     | <span class='neutral'>     * - `version`: the current major version of the signing domain.</span>
  63 |     | <span class='neutral'>     *</span>
  64 |     | <span class='neutral'>     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart</span>
  65 |     | <span class='neutral'>     * contract upgrade].</span>
  66 |     | <span class='neutral'>     */</span>
  67 | *   | <span class='executed'>    constructor(string memory name, string memory version) {</span>
  68 | *   | <span class='executed'>        _name = name.toShortStringWithFallback(_nameFallback);</span>
  69 | *   | <span class='executed'>        _version = version.toShortStringWithFallback(_versionFallback);</span>
  70 | *   | <span class='executed'>        _hashedName = keccak256(bytes(name));</span>
  71 | *   | <span class='executed'>        _hashedVersion = keccak256(bytes(version));</span>
  72 |     | <span class='neutral'></span>
  73 | *   | <span class='executed'>        _cachedChainId = block.chainid;</span>
  74 | *   | <span class='executed'>        _cachedDomainSeparator = _buildDomainSeparator();</span>
  75 | *   | <span class='executed'>        _cachedThis = address(this);</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /**</span>
  79 |     | <span class='neutral'>     * @dev Returns the domain separator for the current chain.</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='unexecuted'>    function _domainSeparatorV4() internal view returns (bytes32) {</span>
  82 |     | <span class='unexecuted'>        if (address(this) == _cachedThis &amp;&amp; block.chainid == _cachedChainId) {</span>
  83 |     | <span class='unexecuted'>            return _cachedDomainSeparator;</span>
  84 |     | <span class='neutral'>        } else {</span>
  85 |     | <span class='unexecuted'>            return _buildDomainSeparator();</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 | *   | <span class='executed'>    function _buildDomainSeparator() private view returns (bytes32) {</span>
  90 | *   | <span class='executed'>        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /**</span>
  94 |     | <span class='neutral'>     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this</span>
  95 |     | <span class='neutral'>     * function returns the hash of the fully encoded EIP712 message for this domain.</span>
  96 |     | <span class='neutral'>     *</span>
  97 |     | <span class='neutral'>     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:</span>
  98 |     | <span class='neutral'>     *</span>
  99 |     | <span class='neutral'>     * ```solidity</span>
 100 |     | <span class='neutral'>     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(</span>
 101 |     | <span class='neutral'>     *     keccak256(&quot;Mail(address to,string contents)&quot;),</span>
 102 |     | <span class='neutral'>     *     mailTo,</span>
 103 |     | <span class='neutral'>     *     keccak256(bytes(mailContents))</span>
 104 |     | <span class='neutral'>     * )));</span>
 105 |     | <span class='neutral'>     * address signer = ECDSA.recover(digest, signature);</span>
 106 |     | <span class='neutral'>     * ```</span>
 107 |     | <span class='neutral'>     */</span>
 108 |     | <span class='unexecuted'>    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {</span>
 109 |     | <span class='unexecuted'>        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /**</span>
 113 |     | <span class='neutral'>     * @dev See {EIP-5267}.</span>
 114 |     | <span class='neutral'>     *</span>
 115 |     | <span class='neutral'>     * _Available since v4.9._</span>
 116 |     | <span class='neutral'>     */</span>
 117 |     | <span class='unexecuted'>    function eip712Domain()</span>
 118 |     | <span class='neutral'>        public</span>
 119 |     | <span class='neutral'>        view</span>
 120 |     | <span class='neutral'>        virtual</span>
 121 |     | <span class='neutral'>        override</span>
 122 |     | <span class='neutral'>        returns (</span>
 123 |     | <span class='unexecuted'>            bytes1 fields,</span>
 124 |     | <span class='unexecuted'>            string memory name,</span>
 125 |     | <span class='neutral'>            string memory version,</span>
 126 |     | <span class='neutral'>            uint256 chainId,</span>
 127 |     | <span class='neutral'>            address verifyingContract,</span>
 128 |     | <span class='neutral'>            bytes32 salt,</span>
 129 |     | <span class='neutral'>            uint256[] memory extensions</span>
 130 |     | <span class='neutral'>        )</span>
 131 |     | <span class='neutral'>    {</span>
 132 |     | <span class='unexecuted'>        return (</span>
 133 |     | <span class='neutral'>            hex&quot;0f&quot;, // 01111</span>
 134 |     | <span class='unexecuted'>            _name.toStringWithFallback(_nameFallback),</span>
 135 |     | <span class='unexecuted'>            _version.toStringWithFallback(_versionFallback),</span>
 136 |     | <span class='unexecuted'>            block.chainid,</span>
 137 |     | <span class='unexecuted'>            address(this),</span>
 138 |     | <span class='unexecuted'>            bytes32(0),</span>
 139 |     | <span class='unexecuted'>            new uint256[](0)</span>
 140 |     | <span class='neutral'>        );</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'>}</span>
 143 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./IERC165.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Implementation of the {IERC165} interface.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check</span>
 12 |     | <span class='neutral'> * for the additional interface id that will be supported. For example:</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * ```solidity</span>
 15 |     | <span class='neutral'> * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 16 |     | <span class='neutral'> *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);</span>
 17 |     | <span class='neutral'> * }</span>
 18 |     | <span class='neutral'> * ```</span>
 19 |     | <span class='neutral'> *</span>
 20 |     | <span class='neutral'> * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.</span>
 21 |     | <span class='neutral'> */</span>
 22 |     | <span class='neutral'>abstract contract ERC165 is IERC165 {</span>
 23 |     | <span class='neutral'>    /**</span>
 24 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 27 |     | <span class='unexecuted'>        return interfaceId == type(IERC165).interfaceId;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC165 standard, as defined in the</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-165[EIP].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Implementers can declare support of contract interfaces, which can then be</span>
 11 |     | <span class='neutral'> * queried by others ({ERC165Checker}).</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * For an implementation, see {ERC165}.</span>
 14 |     | <span class='neutral'> */</span>
 15 |     | <span class='neutral'>interface IERC165 {</span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns true if this contract implements the interface defined by</span>
 18 |     | <span class='neutral'>     * `interfaceId`. See the corresponding</span>
 19 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]</span>
 20 |     | <span class='neutral'>     * to learn more about how these ids are created.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * This function call must use less than 30 000 gas.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/utils/math/Math.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Standard math utilities missing in the Solidity language.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='unexecuted'>library Math {</span>
  10 |     | <span class='neutral'>    enum Rounding {</span>
  11 |     | <span class='neutral'>        Down, // Toward negative infinity</span>
  12 |     | <span class='neutral'>        Up, // Toward infinity</span>
  13 |     | <span class='neutral'>        Zero // Toward zero</span>
  14 |     | <span class='neutral'>    }</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /**</span>
  17 |     | <span class='neutral'>     * @dev Returns the largest of two numbers.</span>
  18 |     | <span class='neutral'>     */</span>
  19 |     | <span class='neutral'>    function max(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  20 |     | <span class='neutral'>        return a &gt; b ? a : b;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @dev Returns the smallest of two numbers.</span>
  25 |     | <span class='neutral'>     */</span>
  26 | *   | <span class='executed'>    function min(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  27 | *   | <span class='executed'>        return a &lt; b ? a : b;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Returns the average of two numbers. The result is rounded towards</span>
  32 |     | <span class='neutral'>     * zero.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='neutral'>    function average(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  35 |     | <span class='neutral'>        // (a + b) / 2 can overflow.</span>
  36 |     | <span class='neutral'>        return (a &amp; b) + (a ^ b) / 2;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /**</span>
  40 |     | <span class='neutral'>     * @dev Returns the ceiling of the division of two numbers.</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * This differs from standard division with `/` in that it rounds up instead</span>
  43 |     | <span class='neutral'>     * of rounding down.</span>
  44 |     | <span class='neutral'>     */</span>
  45 | *   | <span class='executed'>    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  46 |     | <span class='neutral'>        // (a + b - 1) / b can overflow on addition, so we distribute.</span>
  47 | *   | <span class='executed'>        return a == 0 ? 0 : (a - 1) / b + 1;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='neutral'>     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
  52 |     | <span class='neutral'>     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)</span>
  53 |     | <span class='neutral'>     * with further edits by Uniswap Labs also under MIT license.</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {</span>
  56 |     | <span class='neutral'>        unchecked {</span>
  57 |     | <span class='neutral'>            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use</span>
  58 |     | <span class='neutral'>            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256</span>
  59 |     | <span class='neutral'>            // variables such that product = prod1 * 2^256 + prod0.</span>
  60 |     | <span class='neutral'>            uint256 prod0; // Least significant 256 bits of the product</span>
  61 |     | <span class='neutral'>            uint256 prod1; // Most significant 256 bits of the product</span>
  62 |     | <span class='neutral'>            assembly {</span>
  63 |     | <span class='neutral'>                let mm := mulmod(x, y, not(0))</span>
  64 |     | <span class='neutral'>                prod0 := mul(x, y)</span>
  65 |     | <span class='neutral'>                prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  66 |     | <span class='neutral'>            }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>            // Handle non-overflow cases, 256 by 256 division.</span>
  69 |     | <span class='neutral'>            if (prod1 == 0) {</span>
  70 |     | <span class='neutral'>                // Solidity will revert if denominator == 0, unlike the div opcode on its own.</span>
  71 |     | <span class='neutral'>                // The surrounding unchecked block does not change this fact.</span>
  72 |     | <span class='neutral'>                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.</span>
  73 |     | <span class='neutral'>                return prod0 / denominator;</span>
  74 |     | <span class='neutral'>            }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>            // Make sure the result is less than 2^256. Also prevents denominator == 0.</span>
  77 |     | <span class='neutral'>            require(denominator &gt; prod1, &quot;Math: mulDiv overflow&quot;);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  80 |     | <span class='neutral'>            // 512 by 256 division.</span>
  81 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>            // Make division exact by subtracting the remainder from [prod1 prod0].</span>
  84 |     | <span class='neutral'>            uint256 remainder;</span>
  85 |     | <span class='neutral'>            assembly {</span>
  86 |     | <span class='neutral'>                // Compute remainder using mulmod.</span>
  87 |     | <span class='neutral'>                remainder := mulmod(x, y, denominator)</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>                // Subtract 256 bit number from 512 bit number.</span>
  90 |     | <span class='neutral'>                prod1 := sub(prod1, gt(remainder, prod0))</span>
  91 |     | <span class='neutral'>                prod0 := sub(prod0, remainder)</span>
  92 |     | <span class='neutral'>            }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always &gt;= 1.</span>
  95 |     | <span class='neutral'>            // See https://cs.stackexchange.com/q/138556/92363.</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>            // Does not overflow because the denominator cannot be zero at this stage in the function.</span>
  98 |     | <span class='neutral'>            uint256 twos = denominator &amp; (~denominator + 1);</span>
  99 |     | <span class='neutral'>            assembly {</span>
 100 |     | <span class='neutral'>                // Divide denominator by twos.</span>
 101 |     | <span class='neutral'>                denominator := div(denominator, twos)</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>                // Divide [prod1 prod0] by twos.</span>
 104 |     | <span class='neutral'>                prod0 := div(prod0, twos)</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.</span>
 107 |     | <span class='neutral'>                twos := add(div(sub(0, twos), twos), 1)</span>
 108 |     | <span class='neutral'>            }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>            // Shift in bits from prod1 into prod0.</span>
 111 |     | <span class='neutral'>            prod0 |= prod1 * twos;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such</span>
 114 |     | <span class='neutral'>            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for</span>
 115 |     | <span class='neutral'>            // four bits. That is, denominator * inv = 1 mod 2^4.</span>
 116 |     | <span class='neutral'>            uint256 inverse = (3 * denominator) ^ 2;</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel&#39;s lifting lemma, this also works</span>
 119 |     | <span class='neutral'>            // in modular arithmetic, doubling the correct bits in each step.</span>
 120 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^8</span>
 121 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^16</span>
 122 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^32</span>
 123 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^64</span>
 124 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^128</span>
 125 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^256</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.</span>
 128 |     | <span class='neutral'>            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is</span>
 129 |     | <span class='neutral'>            // less than 2^256, this is the final result. We don&#39;t need to compute the high bits of the result and prod1</span>
 130 |     | <span class='neutral'>            // is no longer required.</span>
 131 |     | <span class='neutral'>            result = prod0 * inverse;</span>
 132 |     | <span class='neutral'>            return result;</span>
 133 |     | <span class='neutral'>        }</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    /**</span>
 137 |     | <span class='neutral'>     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.</span>
 138 |     | <span class='neutral'>     */</span>
 139 |     | <span class='neutral'>    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {</span>
 140 |     | <span class='neutral'>        uint256 result = mulDiv(x, y, denominator);</span>
 141 |     | <span class='neutral'>        if (rounding == Rounding.Up &amp;&amp; mulmod(x, y, denominator) &gt; 0) {</span>
 142 |     | <span class='neutral'>            result += 1;</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'>        return result;</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /**</span>
 148 |     | <span class='neutral'>     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.</span>
 149 |     | <span class='neutral'>     *</span>
 150 |     | <span class='neutral'>     * Inspired by Henry S. Warren, Jr.&#39;s &quot;Hacker&#39;s Delight&quot; (Chapter 11).</span>
 151 |     | <span class='neutral'>     */</span>
 152 |     | <span class='unexecuted'>    function sqrt(uint256 a) internal pure returns (uint256) {</span>
 153 |     | <span class='unexecuted'>        if (a == 0) {</span>
 154 |     | <span class='unexecuted'>            return 0;</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.</span>
 158 |     | <span class='neutral'>        //</span>
 159 |     | <span class='neutral'>        // We know that the &quot;msb&quot; (most significant bit) of our target number `a` is a power of 2 such that we have</span>
 160 |     | <span class='neutral'>        // `msb(a) &lt;= a &lt; 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.</span>
 161 |     | <span class='neutral'>        //</span>
 162 |     | <span class='neutral'>        // This can be rewritten `2**log2(a) &lt;= a &lt; 2**(log2(a) + 1)`</span>
 163 |     | <span class='neutral'>        // → `sqrt(2**k) &lt;= sqrt(a) &lt; sqrt(2**(k+1))`</span>
 164 |     | <span class='neutral'>        // → `2**(k/2) &lt;= sqrt(a) &lt; 2**((k+1)/2) &lt;= 2**(k/2 + 1)`</span>
 165 |     | <span class='neutral'>        //</span>
 166 |     | <span class='neutral'>        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.</span>
 167 |     | <span class='unexecuted'>        uint256 result = 1 &lt;&lt; (log2(a) &gt;&gt; 1);</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,</span>
 170 |     | <span class='neutral'>        // since it is the square root of a uint256. Newton&#39;s method converges quadratically (precision doubles at</span>
 171 |     | <span class='neutral'>        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision</span>
 172 |     | <span class='neutral'>        // into the expected uint128 result.</span>
 173 |     | <span class='neutral'>        unchecked {</span>
 174 |     | <span class='unexecuted'>            result = (result + a / result) &gt;&gt; 1;</span>
 175 |     | <span class='unexecuted'>            result = (result + a / result) &gt;&gt; 1;</span>
 176 |     | <span class='unexecuted'>            result = (result + a / result) &gt;&gt; 1;</span>
 177 |     | <span class='unexecuted'>            result = (result + a / result) &gt;&gt; 1;</span>
 178 |     | <span class='unexecuted'>            result = (result + a / result) &gt;&gt; 1;</span>
 179 |     | <span class='unexecuted'>            result = (result + a / result) &gt;&gt; 1;</span>
 180 |     | <span class='unexecuted'>            result = (result + a / result) &gt;&gt; 1;</span>
 181 |     | <span class='unexecuted'>            return min(result, a / result);</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /**</span>
 186 |     | <span class='neutral'>     * @notice Calculates sqrt(a), following the selected rounding direction.</span>
 187 |     | <span class='neutral'>     */</span>
 188 |     | <span class='neutral'>    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {</span>
 189 |     | <span class='neutral'>        unchecked {</span>
 190 |     | <span class='neutral'>            uint256 result = sqrt(a);</span>
 191 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; result * result &lt; a ? 1 : 0);</span>
 192 |     | <span class='neutral'>        }</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    /**</span>
 196 |     | <span class='neutral'>     * @dev Return the log in base 2, rounded down, of a positive value.</span>
 197 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 198 |     | <span class='neutral'>     */</span>
 199 |     | <span class='unexecuted'>    function log2(uint256 value) internal pure returns (uint256) {</span>
 200 |     | <span class='neutral'>        uint256 result = 0;</span>
 201 |     | <span class='neutral'>        unchecked {</span>
 202 |     | <span class='unexecuted'>            if (value &gt;&gt; 128 &gt; 0) {</span>
 203 |     | <span class='unexecuted'>                value &gt;&gt;= 128;</span>
 204 |     | <span class='unexecuted'>                result += 128;</span>
 205 |     | <span class='neutral'>            }</span>
 206 |     | <span class='unexecuted'>            if (value &gt;&gt; 64 &gt; 0) {</span>
 207 |     | <span class='unexecuted'>                value &gt;&gt;= 64;</span>
 208 |     | <span class='unexecuted'>                result += 64;</span>
 209 |     | <span class='neutral'>            }</span>
 210 |     | <span class='unexecuted'>            if (value &gt;&gt; 32 &gt; 0) {</span>
 211 |     | <span class='unexecuted'>                value &gt;&gt;= 32;</span>
 212 |     | <span class='unexecuted'>                result += 32;</span>
 213 |     | <span class='neutral'>            }</span>
 214 |     | <span class='unexecuted'>            if (value &gt;&gt; 16 &gt; 0) {</span>
 215 |     | <span class='unexecuted'>                value &gt;&gt;= 16;</span>
 216 |     | <span class='unexecuted'>                result += 16;</span>
 217 |     | <span class='neutral'>            }</span>
 218 |     | <span class='unexecuted'>            if (value &gt;&gt; 8 &gt; 0) {</span>
 219 |     | <span class='unexecuted'>                value &gt;&gt;= 8;</span>
 220 |     | <span class='unexecuted'>                result += 8;</span>
 221 |     | <span class='neutral'>            }</span>
 222 |     | <span class='unexecuted'>            if (value &gt;&gt; 4 &gt; 0) {</span>
 223 |     | <span class='unexecuted'>                value &gt;&gt;= 4;</span>
 224 |     | <span class='unexecuted'>                result += 4;</span>
 225 |     | <span class='neutral'>            }</span>
 226 |     | <span class='unexecuted'>            if (value &gt;&gt; 2 &gt; 0) {</span>
 227 |     | <span class='unexecuted'>                value &gt;&gt;= 2;</span>
 228 |     | <span class='unexecuted'>                result += 2;</span>
 229 |     | <span class='neutral'>            }</span>
 230 |     | <span class='unexecuted'>            if (value &gt;&gt; 1 &gt; 0) {</span>
 231 |     | <span class='unexecuted'>                result += 1;</span>
 232 |     | <span class='neutral'>            }</span>
 233 |     | <span class='neutral'>        }</span>
 234 |     | <span class='unexecuted'>        return result;</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    /**</span>
 238 |     | <span class='neutral'>     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.</span>
 239 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 240 |     | <span class='neutral'>     */</span>
 241 |     | <span class='neutral'>    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 242 |     | <span class='neutral'>        unchecked {</span>
 243 |     | <span class='neutral'>            uint256 result = log2(value);</span>
 244 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 1 &lt;&lt; result &lt; value ? 1 : 0);</span>
 245 |     | <span class='neutral'>        }</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /**</span>
 249 |     | <span class='neutral'>     * @dev Return the log in base 10, rounded down, of a positive value.</span>
 250 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 251 |     | <span class='neutral'>     */</span>
 252 |     | <span class='unexecuted'>    function log10(uint256 value) internal pure returns (uint256) {</span>
 253 |     | <span class='neutral'>        uint256 result = 0;</span>
 254 |     | <span class='neutral'>        unchecked {</span>
 255 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 64) {</span>
 256 |     | <span class='unexecuted'>                value /= 10 ** 64;</span>
 257 |     | <span class='unexecuted'>                result += 64;</span>
 258 |     | <span class='neutral'>            }</span>
 259 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 32) {</span>
 260 |     | <span class='unexecuted'>                value /= 10 ** 32;</span>
 261 |     | <span class='unexecuted'>                result += 32;</span>
 262 |     | <span class='neutral'>            }</span>
 263 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 16) {</span>
 264 |     | <span class='unexecuted'>                value /= 10 ** 16;</span>
 265 |     | <span class='unexecuted'>                result += 16;</span>
 266 |     | <span class='neutral'>            }</span>
 267 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 8) {</span>
 268 |     | <span class='unexecuted'>                value /= 10 ** 8;</span>
 269 |     | <span class='unexecuted'>                result += 8;</span>
 270 |     | <span class='neutral'>            }</span>
 271 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 4) {</span>
 272 |     | <span class='unexecuted'>                value /= 10 ** 4;</span>
 273 |     | <span class='unexecuted'>                result += 4;</span>
 274 |     | <span class='neutral'>            }</span>
 275 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 2) {</span>
 276 |     | <span class='unexecuted'>                value /= 10 ** 2;</span>
 277 |     | <span class='unexecuted'>                result += 2;</span>
 278 |     | <span class='neutral'>            }</span>
 279 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 1) {</span>
 280 |     | <span class='unexecuted'>                result += 1;</span>
 281 |     | <span class='neutral'>            }</span>
 282 |     | <span class='neutral'>        }</span>
 283 |     | <span class='unexecuted'>        return result;</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    /**</span>
 287 |     | <span class='neutral'>     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.</span>
 288 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 289 |     | <span class='neutral'>     */</span>
 290 |     | <span class='neutral'>    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 291 |     | <span class='neutral'>        unchecked {</span>
 292 |     | <span class='neutral'>            uint256 result = log10(value);</span>
 293 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 10 ** result &lt; value ? 1 : 0);</span>
 294 |     | <span class='neutral'>        }</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    /**</span>
 298 |     | <span class='neutral'>     * @dev Return the log in base 256, rounded down, of a positive value.</span>
 299 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 300 |     | <span class='neutral'>     *</span>
 301 |     | <span class='neutral'>     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.</span>
 302 |     | <span class='neutral'>     */</span>
 303 |     | <span class='neutral'>    function log256(uint256 value) internal pure returns (uint256) {</span>
 304 |     | <span class='neutral'>        uint256 result = 0;</span>
 305 |     | <span class='neutral'>        unchecked {</span>
 306 |     | <span class='neutral'>            if (value &gt;&gt; 128 &gt; 0) {</span>
 307 |     | <span class='neutral'>                value &gt;&gt;= 128;</span>
 308 |     | <span class='neutral'>                result += 16;</span>
 309 |     | <span class='neutral'>            }</span>
 310 |     | <span class='neutral'>            if (value &gt;&gt; 64 &gt; 0) {</span>
 311 |     | <span class='neutral'>                value &gt;&gt;= 64;</span>
 312 |     | <span class='neutral'>                result += 8;</span>
 313 |     | <span class='neutral'>            }</span>
 314 |     | <span class='neutral'>            if (value &gt;&gt; 32 &gt; 0) {</span>
 315 |     | <span class='neutral'>                value &gt;&gt;= 32;</span>
 316 |     | <span class='neutral'>                result += 4;</span>
 317 |     | <span class='neutral'>            }</span>
 318 |     | <span class='neutral'>            if (value &gt;&gt; 16 &gt; 0) {</span>
 319 |     | <span class='neutral'>                value &gt;&gt;= 16;</span>
 320 |     | <span class='neutral'>                result += 2;</span>
 321 |     | <span class='neutral'>            }</span>
 322 |     | <span class='neutral'>            if (value &gt;&gt; 8 &gt; 0) {</span>
 323 |     | <span class='neutral'>                result += 1;</span>
 324 |     | <span class='neutral'>            }</span>
 325 |     | <span class='neutral'>        }</span>
 326 |     | <span class='neutral'>        return result;</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>    /**</span>
 330 |     | <span class='neutral'>     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.</span>
 331 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 332 |     | <span class='neutral'>     */</span>
 333 |     | <span class='neutral'>    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 334 |     | <span class='neutral'>        unchecked {</span>
 335 |     | <span class='neutral'>            uint256 result = log256(value);</span>
 336 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 1 &lt;&lt; (result &lt;&lt; 3) &lt; value ? 1 : 0);</span>
 337 |     | <span class='neutral'>        }</span>
 338 |     | <span class='neutral'>    }</span>
 339 |     | <span class='neutral'>}</span>
 340 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Standard signed math utilities missing in the Solidity language.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='unexecuted'>library SignedMath {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Returns the largest of two signed numbers.</span>
 12 |     | <span class='neutral'>     */</span>
 13 |     | <span class='neutral'>    function max(int256 a, int256 b) internal pure returns (int256) {</span>
 14 |     | <span class='neutral'>        return a &gt; b ? a : b;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Returns the smallest of two signed numbers.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='neutral'>    function min(int256 a, int256 b) internal pure returns (int256) {</span>
 21 |     | <span class='neutral'>        return a &lt; b ? a : b;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the average of two signed numbers without overflow.</span>
 26 |     | <span class='neutral'>     * The result is rounded towards zero.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    function average(int256 a, int256 b) internal pure returns (int256) {</span>
 29 |     | <span class='neutral'>        // Formula from the book &quot;Hacker&#39;s Delight&quot;</span>
 30 |     | <span class='neutral'>        int256 x = (a &amp; b) + ((a ^ b) &gt;&gt; 1);</span>
 31 |     | <span class='neutral'>        return x + (int256(uint256(x) &gt;&gt; 255) &amp; (a ^ b));</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Returns the absolute unsigned value of a signed value.</span>
 36 |     | <span class='neutral'>     */</span>
 37 |     | <span class='neutral'>    function abs(int256 n) internal pure returns (uint256) {</span>
 38 |     | <span class='neutral'>        unchecked {</span>
 39 |     | <span class='neutral'>            // must be unchecked in order to support `n = type(int256).min`</span>
 40 |     | <span class='neutral'>            return uint256(n &gt;= 0 ? n : -n);</span>
 41 |     | <span class='neutral'>        }</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/ActivePool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/utils/math/Math.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>import &quot;./Dependencies/Constants.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./Interfaces/IActivePool.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;./Interfaces/IAddressesRegistry.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;./Interfaces/IBoldToken.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;./Interfaces/IInterestRouter.sol&quot;;</span>
  13 |     | <span class='neutral'>import &quot;./Interfaces/IDefaultPool.sol&quot;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>/*</span>
  16 |     | <span class='neutral'> * The Active Pool holds the collateral and Bold debt (but not Bold tokens) for all active troves.</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> * When a trove is liquidated, it&#39;s Coll and Bold debt are transferred from the Active Pool, to either the</span>
  19 |     | <span class='neutral'> * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> */</span>
  22 | *   | <span class='executed'>contract ActivePool is IActivePool {</span>
  23 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    string public constant NAME = &quot;ActivePool&quot;;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>    IERC20 public immutable collToken;</span>
  28 |     | <span class='unexecuted'>    address public immutable borrowerOperationsAddress;</span>
  29 |     | <span class='unexecuted'>    address public immutable troveManagerAddress;</span>
  30 |     | <span class='unexecuted'>    address public immutable defaultPoolAddress;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>    IBoldToken public immutable boldToken;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    IInterestRouter public immutable interestRouter;</span>
  35 |     | <span class='unexecuted'>    IBoldRewardsReceiver public immutable stabilityPool;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    uint256 internal collBalance; // deposited coll tracker</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    // Aggregate recorded debt tracker. Updated whenever a Trove&#39;s debt is touched AND whenever the aggregate pending interest is minted.</span>
  40 |     | <span class='neutral'>    // &quot;D&quot; in the spec.</span>
  41 |     | <span class='unexecuted'>    uint256 public aggRecordedDebt;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /* Sum of individual recorded Trove debts weighted by their respective chosen interest rates.</span>
  44 |     | <span class='neutral'>    * Updated at individual Trove operations.</span>
  45 |     | <span class='neutral'>    * &quot;S&quot; in the spec.</span>
  46 |     | <span class='neutral'>    */</span>
  47 |     | <span class='unexecuted'>    uint256 public aggWeightedDebtSum;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    // Last time at which the aggregate recorded debt and weighted sum were updated</span>
  50 |     | <span class='unexecuted'>    uint256 public lastAggUpdateTime;</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    // Timestamp at which branch was shut down. 0 if not shut down.</span>
  53 |     | <span class='unexecuted'>    uint256 public shutdownTime;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    // Aggregate batch fees tracker</span>
  56 |     | <span class='unexecuted'>    uint256 public aggBatchManagementFees;</span>
  57 |     | <span class='neutral'>    /* Sum of individual recorded Trove debts weighted by their respective batch management fees</span>
  58 |     | <span class='neutral'>     * Updated at individual batched Trove operations.</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='unexecuted'>    uint256 public aggWeightedBatchManagementFeeSum;</span>
  61 |     | <span class='neutral'>    // Last time at which the aggregate batch fees and weighted sum were updated</span>
  62 |     | <span class='unexecuted'>    uint256 public lastAggBatchManagementFeesUpdateTime;</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    // --- Events ---</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    event CollTokenAddressChanged(address _newCollTokenAddress);</span>
  67 |     | <span class='neutral'>    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);</span>
  68 |     | <span class='neutral'>    event TroveManagerAddressChanged(address _newTroveManagerAddress);</span>
  69 |     | <span class='neutral'>    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);</span>
  70 |     | <span class='neutral'>    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);</span>
  71 |     | <span class='neutral'>    event ActivePoolBoldDebtUpdated(uint256 _recordedDebtSum);</span>
  72 |     | <span class='neutral'>    event ActivePoolCollBalanceUpdated(uint256 _collBalance);</span>
  73 |     | <span class='neutral'></span>
  74 | *   | <span class='executed'>    constructor(IAddressesRegistry _addressesRegistry) {</span>
  75 | *   | <span class='executed'>        collToken = _addressesRegistry.collToken();</span>
  76 | *   | <span class='executed'>        borrowerOperationsAddress = address(_addressesRegistry.borrowerOperations());</span>
  77 | *   | <span class='executed'>        troveManagerAddress = address(_addressesRegistry.troveManager());</span>
  78 | *   | <span class='executed'>        stabilityPool = IBoldRewardsReceiver(_addressesRegistry.stabilityPool());</span>
  79 | *   | <span class='executed'>        defaultPoolAddress = address(_addressesRegistry.defaultPool());</span>
  80 | *   | <span class='executed'>        interestRouter = _addressesRegistry.interestRouter();</span>
  81 | *   | <span class='executed'>        boldToken = _addressesRegistry.boldToken();</span>
  82 |     | <span class='neutral'></span>
  83 | *   | <span class='executed'>        emit CollTokenAddressChanged(address(collToken));</span>
  84 | *   | <span class='executed'>        emit BorrowerOperationsAddressChanged(borrowerOperationsAddress);</span>
  85 | *   | <span class='executed'>        emit TroveManagerAddressChanged(troveManagerAddress);</span>
  86 | *   | <span class='executed'>        emit StabilityPoolAddressChanged(address(stabilityPool));</span>
  87 | *   | <span class='executed'>        emit DefaultPoolAddressChanged(defaultPoolAddress);</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        // Allow funds movements between Liquity contracts</span>
  90 | *   | <span class='executed'>        collToken.approve(defaultPoolAddress, type(uint256).max);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    // --- Getters for public variables. Required by IPool interface ---</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /*</span>
  96 |     | <span class='neutral'>    * Returns the Coll state variable.</span>
  97 |     | <span class='neutral'>    *</span>
  98 |     | <span class='neutral'>    *Not necessarily equal to the the contract&#39;s raw Coll balance - ether can be forcibly sent to contracts.</span>
  99 |     | <span class='neutral'>    */</span>
 100 | *   | <span class='executed'>    function getCollBalance() external view override returns (uint256) {</span>
 101 | *   | <span class='executed'>        return collBalance;</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 | *   | <span class='executed'>    function calcPendingAggInterest() public view returns (uint256) {</span>
 105 | *   | <span class='executed'>        if (shutdownTime != 0) return 0;</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>        // We use the ceiling of the division here to ensure positive error, while we use regular floor division</span>
 108 |     | <span class='neutral'>        // when calculating the interest accrued by individual Troves.</span>
 109 |     | <span class='neutral'>        // This ensures that `system debt &gt;= sum(trove debt)` always holds, and thus system debt won&#39;t turn negative</span>
 110 |     | <span class='neutral'>        // even if all Trove debt is repaid. The difference should be small and it should scale with the number of</span>
 111 |     | <span class='neutral'>        // interest minting events.</span>
 112 | *   | <span class='executed'>        return Math.ceilDiv(aggWeightedDebtSum * (block.timestamp - lastAggUpdateTime), ONE_YEAR * DECIMAL_PRECISION);</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>    function calcPendingSPYield() external view returns (uint256) {</span>
 116 |     | <span class='unexecuted'>        return calcPendingAggInterest() * SP_YIELD_SPLIT / DECIMAL_PRECISION;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 | *   | <span class='executed'>    function calcPendingAggBatchManagementFee() public view returns (uint256) {</span>
 120 | *   | <span class='executed'>        uint256 periodEnd = shutdownTime != 0 ? shutdownTime : block.timestamp;</span>
 121 | *   | <span class='executed'>        uint256 periodStart = Math.min(lastAggBatchManagementFeesUpdateTime, periodEnd);</span>
 122 |     | <span class='neutral'></span>
 123 | *   | <span class='executed'>        return Math.ceilDiv(aggWeightedBatchManagementFeeSum * (periodEnd - periodStart), ONE_YEAR * DECIMAL_PRECISION);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 | *   | <span class='executed'>    function getNewApproxAvgInterestRateFromTroveChange(TroveChange calldata _troveChange)</span>
 127 |     | <span class='neutral'>        external</span>
 128 |     | <span class='neutral'>        view</span>
 129 | *   | <span class='executed'>        returns (uint256)</span>
 130 |     | <span class='neutral'>    {</span>
 131 |     | <span class='neutral'>        // We are ignoring the upfront fee when calculating the approx. avg. interest rate.</span>
 132 |     | <span class='neutral'>        // This is a simple way to resolve the circularity in:</span>
 133 |     | <span class='neutral'>        //   fee depends on avg. interest rate -&gt; avg. interest rate is weighted by debt -&gt; debt includes fee -&gt; ...</span>
 134 | *   | <span class='executed'>        assert(_troveChange.upfrontFee == 0);</span>
 135 |     | <span class='neutral'></span>
 136 | *   | <span class='executed'>        if (shutdownTime != 0) return 0;</span>
 137 |     | <span class='neutral'></span>
 138 | *   | <span class='executed'>        uint256 newAggRecordedDebt = aggRecordedDebt;</span>
 139 | *   | <span class='executed'>        newAggRecordedDebt += calcPendingAggInterest();</span>
 140 | *   | <span class='executed'>        newAggRecordedDebt += _troveChange.appliedRedistBoldDebtGain;</span>
 141 | *   | <span class='executed'>        newAggRecordedDebt += _troveChange.debtIncrease;</span>
 142 | *   | <span class='executed'>        newAggRecordedDebt += _troveChange.batchAccruedManagementFee;</span>
 143 | *   | <span class='executed'>        newAggRecordedDebt -= _troveChange.debtDecrease;</span>
 144 |     | <span class='neutral'></span>
 145 | *   | <span class='executed'>        uint256 newAggWeightedDebtSum = aggWeightedDebtSum;</span>
 146 | *   | <span class='executed'>        newAggWeightedDebtSum += _troveChange.newWeightedRecordedDebt;</span>
 147 | *   | <span class='executed'>        newAggWeightedDebtSum -= _troveChange.oldWeightedRecordedDebt;</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>        // Avoid division by 0 if the first ever borrower tries to borrow 0 BOLD</span>
 150 |     | <span class='neutral'>        // Borrowing 0 BOLD is not allowed, but our check of debt &gt;= MIN_DEBT happens _after_ calculating the upfront</span>
 151 |     | <span class='neutral'>        // fee, which involves getting the new approx. avg. interest rate</span>
 152 | *   | <span class='executed'>        return newAggRecordedDebt &gt; 0 ? newAggWeightedDebtSum / newAggRecordedDebt : 0;</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    // Returns sum of agg.recorded debt plus agg. pending interest. Excludes pending redist. gains.</span>
 156 | *   | <span class='executed'>    function getBoldDebt() external view returns (uint256) {</span>
 157 | *   | <span class='executed'>        return aggRecordedDebt + calcPendingAggInterest() + aggBatchManagementFees + calcPendingAggBatchManagementFee();</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    // --- Pool functionality ---</span>
 161 |     | <span class='neutral'></span>
 162 | *   | <span class='executed'>    function sendColl(address _account, uint256 _amount) external override {</span>
 163 | *   | <span class='executed'>        _requireCallerIsBOorTroveMorSP();</span>
 164 |     | <span class='neutral'></span>
 165 | *   | <span class='executed'>        _accountForSendColl(_amount);</span>
 166 |     | <span class='neutral'></span>
 167 | *   | <span class='executed'>        collToken.safeTransfer(_account, _amount);</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>    function sendCollToDefaultPool(uint256 _amount) external override {</span>
 171 |     | <span class='unexecuted'>        _requireCallerIsTroveManager();</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='unexecuted'>        _accountForSendColl(_amount);</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>        IDefaultPool(defaultPoolAddress).receiveColl(_amount);</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 | *   | <span class='executed'>    function _accountForSendColl(uint256 _amount) internal {</span>
 179 | *   | <span class='executed'>        uint256 newCollBalance = collBalance - _amount;</span>
 180 |     | <span class='neutral'>        collBalance = newCollBalance;</span>
 181 |     | <span class='neutral'>        emit ActivePoolCollBalanceUpdated(newCollBalance);</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='unexecuted'>    function receiveColl(uint256 _amount) external {</span>
 185 |     | <span class='unexecuted'>        _requireCallerIsBorrowerOperationsOrDefaultPool();</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='unexecuted'>        _accountForReceivedColl(_amount);</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>        // Pull Coll tokens from sender</span>
 190 |     | <span class='unexecuted'>        collToken.safeTransferFrom(msg.sender, address(this), _amount);</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'></span>
 193 | *   | <span class='executed'>    function accountForReceivedColl(uint256 _amount) public {</span>
 194 | *   | <span class='executed'>        _requireCallerIsBorrowerOperationsOrDefaultPool();</span>
 195 |     | <span class='neutral'></span>
 196 | *   | <span class='executed'>        _accountForReceivedColl(_amount);</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 | *   | <span class='executed'>    function _accountForReceivedColl(uint256 _amount) internal {</span>
 200 | *   | <span class='executed'>        uint256 newCollBalance = collBalance + _amount;</span>
 201 | *   | <span class='executed'>        collBalance = newCollBalance;</span>
 202 |     | <span class='neutral'></span>
 203 | *   | <span class='executed'>        emit ActivePoolCollBalanceUpdated(newCollBalance);</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    // --- Aggregate interest operations ---</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    // This function is called inside all state-changing user ops: borrower ops, liquidations, redemptions and SP deposits/withdrawals.</span>
 209 |     | <span class='neutral'>    // Some user ops trigger debt changes to Trove(s), in which case _troveDebtChange will be non-zero.</span>
 210 |     | <span class='neutral'>    // The aggregate recorded debt is incremented by the aggregate pending interest, plus the net Trove debt change.</span>
 211 |     | <span class='neutral'>    // The net Trove debt change consists of the sum of a) any debt issued/repaid and b) any redistribution debt gain applied in the encapsulating operation.</span>
 212 |     | <span class='neutral'>    // It does *not* include the Trove&#39;s individual accrued interest - this gets accounted for in the aggregate accrued interest.</span>
 213 |     | <span class='neutral'>    // The net Trove debt change could be positive or negative in a repayment (depending on whether its redistribution gain or repayment amount is larger),</span>
 214 |     | <span class='neutral'>    // so this function accepts both the increase and the decrease to avoid using (and converting to/from) signed ints.</span>
 215 | *   | <span class='executed'>    function mintAggInterestAndAccountForTroveChange(TroveChange calldata _troveChange, address _batchAddress)</span>
 216 |     | <span class='neutral'>        external</span>
 217 |     | <span class='neutral'>    {</span>
 218 | *   | <span class='executed'>        _requireCallerIsBOorTroveM();</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>        // Batch management fees</span>
 221 | *   | <span class='executed'>        if (_batchAddress != address(0)) {</span>
 222 | *   | <span class='executed'>            _mintBatchManagementFeeAndAccountForChange(_troveChange, _batchAddress);</span>
 223 |     | <span class='neutral'>        }</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>        // Do the arithmetic in 2 steps here to avoid underflow from the decrease</span>
 226 | *   | <span class='executed'>        uint256 newAggRecordedDebt = aggRecordedDebt; // 1 SLOAD</span>
 227 | *   | <span class='executed'>        newAggRecordedDebt += _mintAggInterest(_troveChange.upfrontFee); // adds minted agg. interest + upfront fee</span>
 228 | *   | <span class='executed'>        newAggRecordedDebt += _troveChange.appliedRedistBoldDebtGain;</span>
 229 | *   | <span class='executed'>        newAggRecordedDebt += _troveChange.debtIncrease;</span>
 230 | *   | <span class='executed'>        newAggRecordedDebt -= _troveChange.debtDecrease;</span>
 231 | *   | <span class='executed'>        aggRecordedDebt = newAggRecordedDebt; // 1 SSTORE</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>        // assert(aggRecordedDebt &gt;= 0) // This should never be negative. If all redistribution gians and all aggregate interest was applied</span>
 234 |     | <span class='neutral'>        // and all Trove debts were repaid, it should become 0.</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>        // Do the arithmetic in 2 steps here to avoid underflow from the decrease</span>
 237 | *   | <span class='executed'>        uint256 newAggWeightedDebtSum = aggWeightedDebtSum; // 1 SLOAD</span>
 238 | *   | <span class='executed'>        newAggWeightedDebtSum += _troveChange.newWeightedRecordedDebt;</span>
 239 | *   | <span class='executed'>        newAggWeightedDebtSum -= _troveChange.oldWeightedRecordedDebt;</span>
 240 | *   | <span class='executed'>        aggWeightedDebtSum = newAggWeightedDebtSum; // 1 SSTORE</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 | *   | <span class='executed'>    function mintAggInterest() external override {</span>
 244 | *   | <span class='executed'>        _requireCallerIsBOorSP();</span>
 245 | *   | <span class='executed'>        aggRecordedDebt += _mintAggInterest(0);</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 | *   | <span class='executed'>    function _mintAggInterest(uint256 _upfrontFee) internal returns (uint256 mintedAmount) {</span>
 249 | *   | <span class='executed'>        mintedAmount = calcPendingAggInterest() + _upfrontFee;</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>        // Mint part of the BOLD interest to the SP and part to the router for LPs.</span>
 252 | *   | <span class='executed'>        if (mintedAmount &gt; 0) {</span>
 253 | *   | <span class='executed'>            uint256 spYield = SP_YIELD_SPLIT * mintedAmount / DECIMAL_PRECISION;</span>
 254 | *   | <span class='executed'>            uint256 remainderToLPs = mintedAmount - spYield;</span>
 255 |     | <span class='neutral'></span>
 256 | *   | <span class='executed'>            boldToken.mint(address(interestRouter), remainderToLPs);</span>
 257 |     | <span class='neutral'></span>
 258 | *   | <span class='executed'>            if (spYield &gt; 0) {</span>
 259 | *   | <span class='executed'>                boldToken.mint(address(stabilityPool), spYield);</span>
 260 | *   | <span class='executed'>                stabilityPool.triggerBoldRewards(spYield);</span>
 261 |     | <span class='neutral'>            }</span>
 262 |     | <span class='neutral'>        }</span>
 263 |     | <span class='neutral'></span>
 264 | *   | <span class='executed'>        lastAggUpdateTime = block.timestamp;</span>
 265 |     | <span class='neutral'>    }</span>
 266 |     | <span class='neutral'></span>
 267 | *   | <span class='executed'>    function mintBatchManagementFeeAndAccountForChange(TroveChange calldata _troveChange, address _batchAddress)</span>
 268 |     | <span class='neutral'>        external</span>
 269 |     | <span class='neutral'>        override</span>
 270 |     | <span class='neutral'>    {</span>
 271 | *   | <span class='executed'>        _requireCallerIsTroveManager();</span>
 272 | *   | <span class='executed'>        _mintBatchManagementFeeAndAccountForChange(_troveChange, _batchAddress);</span>
 273 |     | <span class='neutral'>    }</span>
 274 |     | <span class='neutral'></span>
 275 | *   | <span class='executed'>    function _mintBatchManagementFeeAndAccountForChange(TroveChange memory _troveChange, address _batchAddress)</span>
 276 |     | <span class='neutral'>        internal</span>
 277 |     | <span class='neutral'>    {</span>
 278 | *   | <span class='executed'>        aggRecordedDebt += _troveChange.batchAccruedManagementFee;</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>        // Do the arithmetic in 2 steps here to avoid underflow from the decrease</span>
 281 | *   | <span class='executed'>        uint256 newAggBatchManagementFees = aggBatchManagementFees; // 1 SLOAD</span>
 282 | *   | <span class='executed'>        newAggBatchManagementFees += calcPendingAggBatchManagementFee();</span>
 283 | *   | <span class='executed'>        newAggBatchManagementFees -= _troveChange.batchAccruedManagementFee;</span>
 284 | *   | <span class='executed'>        aggBatchManagementFees = newAggBatchManagementFees; // 1 SSTORE</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>        // Do the arithmetic in 2 steps here to avoid underflow from the decrease</span>
 287 | *   | <span class='executed'>        uint256 newAggWeightedBatchManagementFeeSum = aggWeightedBatchManagementFeeSum; // 1 SLOAD</span>
 288 | *   | <span class='executed'>        newAggWeightedBatchManagementFeeSum += _troveChange.newWeightedRecordedBatchManagementFee;</span>
 289 | *   | <span class='executed'>        newAggWeightedBatchManagementFeeSum -= _troveChange.oldWeightedRecordedBatchManagementFee;</span>
 290 | *   | <span class='executed'>        aggWeightedBatchManagementFeeSum = newAggWeightedBatchManagementFeeSum; // 1 SSTORE</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>        // mint fee to batch address</span>
 293 | *   | <span class='executed'>        if (_troveChange.batchAccruedManagementFee &gt; 0) {</span>
 294 |     | <span class='unexecuted'>            boldToken.mint(_batchAddress, _troveChange.batchAccruedManagementFee);</span>
 295 |     | <span class='neutral'>        }</span>
 296 |     | <span class='neutral'></span>
 297 | *   | <span class='executed'>        lastAggBatchManagementFeesUpdateTime = block.timestamp;</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'>    // --- Shutdown ---</span>
 301 |     | <span class='neutral'></span>
 302 | *   | <span class='executed'>    function setShutdownFlag() external {</span>
 303 | *   | <span class='executed'>        _requireCallerIsTroveManager();</span>
 304 | *   | <span class='executed'>        shutdownTime = block.timestamp;</span>
 305 |     | <span class='neutral'>    }</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='unexecuted'>    function hasBeenShutDown() external view returns (bool) {</span>
 308 |     | <span class='unexecuted'>        return shutdownTime != 0;</span>
 309 |     | <span class='neutral'>    }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    // --- &#39;require&#39; functions ---</span>
 312 |     | <span class='neutral'></span>
 313 | *   | <span class='executed'>    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {</span>
 314 | *   | <span class='executed'>        require(</span>
 315 | *   | <span class='executed'>            msg.sender == borrowerOperationsAddress || msg.sender == defaultPoolAddress,</span>
 316 |     | <span class='neutral'>            &quot;ActivePool: Caller is neither BO nor Default Pool&quot;</span>
 317 |     | <span class='neutral'>        );</span>
 318 |     | <span class='neutral'>    }</span>
 319 |     | <span class='neutral'></span>
 320 | *   | <span class='executed'>    function _requireCallerIsBOorTroveMorSP() internal view {</span>
 321 | *   | <span class='executed'>        require(</span>
 322 | *   | <span class='executed'>            msg.sender == borrowerOperationsAddress || msg.sender == troveManagerAddress</span>
 323 |     | <span class='unexecuted'>                || msg.sender == address(stabilityPool),</span>
 324 |     | <span class='neutral'>            &quot;ActivePool: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool&quot;</span>
 325 |     | <span class='neutral'>        );</span>
 326 |     | <span class='neutral'>    }</span>
 327 |     | <span class='neutral'></span>
 328 | *   | <span class='executed'>    function _requireCallerIsBOorSP() internal view {</span>
 329 | *   | <span class='executed'>        require(</span>
 330 | *   | <span class='executed'>            msg.sender == borrowerOperationsAddress || msg.sender == address(stabilityPool),</span>
 331 |     | <span class='neutral'>            &quot;ActivePool: Caller is not BorrowerOperations nor StabilityPool&quot;</span>
 332 |     | <span class='neutral'>        );</span>
 333 |     | <span class='neutral'>    }</span>
 334 |     | <span class='neutral'></span>
 335 | *   | <span class='executed'>    function _requireCallerIsBOorTroveM() internal view {</span>
 336 | *   | <span class='executed'>        require(</span>
 337 | *   | <span class='executed'>            msg.sender == borrowerOperationsAddress || msg.sender == troveManagerAddress,</span>
 338 |     | <span class='neutral'>            &quot;ActivePool: Caller is neither BorrowerOperations nor TroveManager&quot;</span>
 339 |     | <span class='neutral'>        );</span>
 340 |     | <span class='neutral'>    }</span>
 341 |     | <span class='neutral'></span>
 342 | *   | <span class='executed'>    function _requireCallerIsTroveManager() internal view {</span>
 343 | *   | <span class='executed'>        require(msg.sender == troveManagerAddress, &quot;ActivePool: Caller is not TroveManager&quot;);</span>
 344 |     | <span class='neutral'>    }</span>
 345 |     | <span class='neutral'>}</span>
 346 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/AddressesRegistry.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./Dependencies/Ownable.sol&quot;;</span>
   6 |     | <span class='neutral'>import {MIN_LIQUIDATION_PENALTY_SP, MAX_LIQUIDATION_PENALTY_REDISTRIBUTION} from &quot;./Dependencies/Constants.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Interfaces/IAddressesRegistry.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 | *   | <span class='executed'>contract AddressesRegistry is Ownable, IAddressesRegistry {</span>
  10 | *   | <span class='executed'>    IERC20Metadata public collToken;</span>
  11 | *   | <span class='executed'>    IBorrowerOperations public borrowerOperations;</span>
  12 | *   | <span class='executed'>    ITroveManager public troveManager;</span>
  13 | *   | <span class='executed'>    ITroveNFT public troveNFT;</span>
  14 | *   | <span class='executed'>    IMetadataNFT public metadataNFT;</span>
  15 | *   | <span class='executed'>    IStabilityPool public stabilityPool;</span>
  16 | *   | <span class='executed'>    IPriceFeed public priceFeed;</span>
  17 | *   | <span class='executed'>    IActivePool public activePool;</span>
  18 | *   | <span class='executed'>    IDefaultPool public defaultPool;</span>
  19 | *   | <span class='executed'>    address public gasPoolAddress;</span>
  20 | *   | <span class='executed'>    ICollSurplusPool public collSurplusPool;</span>
  21 | *   | <span class='executed'>    ISortedTroves public sortedTroves;</span>
  22 | *   | <span class='executed'>    IInterestRouter public interestRouter;</span>
  23 |     | <span class='unexecuted'>    IHintHelpers public hintHelpers;</span>
  24 |     | <span class='unexecuted'>    IMultiTroveGetter public multiTroveGetter;</span>
  25 | *   | <span class='executed'>    ICollateralRegistry public collateralRegistry;</span>
  26 | *   | <span class='executed'>    IBoldToken public boldToken;</span>
  27 | *   | <span class='executed'>    IWETH public WETH;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    // Critical system collateral ratio. If the system&#39;s total collateral ratio (TCR) falls below the CCR, some borrowing operation restrictions are applied</span>
  30 | *   | <span class='executed'>    uint256 public immutable CCR;</span>
  31 |     | <span class='neutral'>    // Shutdown system collateral ratio. If the system&#39;s total collateral ratio (TCR) for a given collateral falls below the SCR,</span>
  32 |     | <span class='neutral'>    // the protocol triggers the shutdown of the borrow market and permanently disables all borrowing operations except for closing Troves.</span>
  33 | *   | <span class='executed'>    uint256 public immutable SCR;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    // Minimum collateral ratio for individual troves</span>
  36 | *   | <span class='executed'>    uint256 public immutable MCR;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    // Liquidation penalty for troves offset to the SP</span>
  39 | *   | <span class='executed'>    uint256 public immutable LIQUIDATION_PENALTY_SP;</span>
  40 |     | <span class='neutral'>    // Liquidation penalty for troves redistributed</span>
  41 | *   | <span class='executed'>    uint256 public immutable LIQUIDATION_PENALTY_REDISTRIBUTION;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    error InvalidCCR();</span>
  44 |     | <span class='neutral'>    error InvalidMCR();</span>
  45 |     | <span class='neutral'>    error InvalidSCR();</span>
  46 |     | <span class='neutral'>    error SPPenaltyTooLow();</span>
  47 |     | <span class='neutral'>    error SPPenaltyGtRedist();</span>
  48 |     | <span class='neutral'>    error RedistPenaltyTooHigh();</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    event CollTokenAddressChanged(address _collTokenAddress);</span>
  51 |     | <span class='neutral'>    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);</span>
  52 |     | <span class='neutral'>    event TroveManagerAddressChanged(address _troveManagerAddress);</span>
  53 |     | <span class='neutral'>    event TroveNFTAddressChanged(address _troveNFTAddress);</span>
  54 |     | <span class='neutral'>    event MetadataNFTAddressChanged(address _metadataNFTAddress);</span>
  55 |     | <span class='neutral'>    event StabilityPoolAddressChanged(address _stabilityPoolAddress);</span>
  56 |     | <span class='neutral'>    event PriceFeedAddressChanged(address _priceFeedAddress);</span>
  57 |     | <span class='neutral'>    event ActivePoolAddressChanged(address _activePoolAddress);</span>
  58 |     | <span class='neutral'>    event DefaultPoolAddressChanged(address _defaultPoolAddress);</span>
  59 |     | <span class='neutral'>    event GasPoolAddressChanged(address _gasPoolAddress);</span>
  60 |     | <span class='neutral'>    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);</span>
  61 |     | <span class='neutral'>    event SortedTrovesAddressChanged(address _sortedTrovesAddress);</span>
  62 |     | <span class='neutral'>    event InterestRouterAddressChanged(address _interestRouterAddress);</span>
  63 |     | <span class='neutral'>    event HintHelpersAddressChanged(address _hintHelpersAddress);</span>
  64 |     | <span class='neutral'>    event MultiTroveGetterAddressChanged(address _multiTroveGetterAddress);</span>
  65 |     | <span class='neutral'>    event CollateralRegistryAddressChanged(address _collateralRegistryAddress);</span>
  66 |     | <span class='neutral'>    event BoldTokenAddressChanged(address _boldTokenAddress);</span>
  67 |     | <span class='neutral'>    event WETHAddressChanged(address _wethAddress);</span>
  68 |     | <span class='neutral'></span>
  69 | *   | <span class='executed'>    constructor(</span>
  70 |     | <span class='neutral'>        address _owner,</span>
  71 |     | <span class='neutral'>        uint256 _ccr,</span>
  72 |     | <span class='neutral'>        uint256 _mcr,</span>
  73 |     | <span class='neutral'>        uint256 _scr,</span>
  74 |     | <span class='neutral'>        uint256 _liquidationPenaltySP,</span>
  75 |     | <span class='neutral'>        uint256 _liquidationPenaltyRedistribution</span>
  76 |     | <span class='neutral'>    ) Ownable(_owner) {</span>
  77 | *   | <span class='executed'>        if (_ccr &lt;= 1e18 || _ccr &gt;= 2e18) revert InvalidCCR();</span>
  78 | *   | <span class='executed'>        if (_mcr &lt;= 1e18 || _mcr &gt;= 2e18) revert InvalidMCR();</span>
  79 | *   | <span class='executed'>        if (_scr &lt;= 1e18 || _scr &gt;= 2e18) revert InvalidSCR();</span>
  80 | *   | <span class='executed'>        if (_liquidationPenaltySP &lt; MIN_LIQUIDATION_PENALTY_SP) revert SPPenaltyTooLow();</span>
  81 | *   | <span class='executed'>        if (_liquidationPenaltySP &gt; _liquidationPenaltyRedistribution) revert SPPenaltyGtRedist();</span>
  82 | *   | <span class='executed'>        if (_liquidationPenaltyRedistribution &gt; MAX_LIQUIDATION_PENALTY_REDISTRIBUTION) revert RedistPenaltyTooHigh();</span>
  83 |     | <span class='neutral'></span>
  84 | *   | <span class='executed'>        CCR = _ccr;</span>
  85 | *   | <span class='executed'>        SCR = _scr;</span>
  86 | *   | <span class='executed'>        MCR = _mcr;</span>
  87 | *   | <span class='executed'>        LIQUIDATION_PENALTY_SP = _liquidationPenaltySP;</span>
  88 | *   | <span class='executed'>        LIQUIDATION_PENALTY_REDISTRIBUTION = _liquidationPenaltyRedistribution;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 | *   | <span class='executed'>    function setAddresses(AddressVars memory _vars) external onlyOwner {</span>
  92 | *   | <span class='executed'>        collToken = _vars.collToken;</span>
  93 | *   | <span class='executed'>        borrowerOperations = _vars.borrowerOperations;</span>
  94 | *   | <span class='executed'>        troveManager = _vars.troveManager;</span>
  95 | *   | <span class='executed'>        troveNFT = _vars.troveNFT;</span>
  96 | *   | <span class='executed'>        metadataNFT = _vars.metadataNFT;</span>
  97 | *   | <span class='executed'>        stabilityPool = _vars.stabilityPool;</span>
  98 | *   | <span class='executed'>        priceFeed = _vars.priceFeed;</span>
  99 | *   | <span class='executed'>        activePool = _vars.activePool;</span>
 100 | *   | <span class='executed'>        defaultPool = _vars.defaultPool;</span>
 101 | *   | <span class='executed'>        gasPoolAddress = _vars.gasPoolAddress;</span>
 102 | *   | <span class='executed'>        collSurplusPool = _vars.collSurplusPool;</span>
 103 | *   | <span class='executed'>        sortedTroves = _vars.sortedTroves;</span>
 104 | *   | <span class='executed'>        interestRouter = _vars.interestRouter;</span>
 105 | *   | <span class='executed'>        hintHelpers = _vars.hintHelpers;</span>
 106 | *   | <span class='executed'>        multiTroveGetter = _vars.multiTroveGetter;</span>
 107 | *   | <span class='executed'>        collateralRegistry = _vars.collateralRegistry;</span>
 108 | *   | <span class='executed'>        boldToken = _vars.boldToken;</span>
 109 | *   | <span class='executed'>        WETH = _vars.WETH;</span>
 110 |     | <span class='neutral'></span>
 111 | *   | <span class='executed'>        emit CollTokenAddressChanged(address(_vars.collToken));</span>
 112 | *   | <span class='executed'>        emit BorrowerOperationsAddressChanged(address(_vars.borrowerOperations));</span>
 113 | *   | <span class='executed'>        emit TroveManagerAddressChanged(address(_vars.troveManager));</span>
 114 | *   | <span class='executed'>        emit TroveNFTAddressChanged(address(_vars.troveNFT));</span>
 115 | *   | <span class='executed'>        emit MetadataNFTAddressChanged(address(_vars.metadataNFT));</span>
 116 | *   | <span class='executed'>        emit StabilityPoolAddressChanged(address(_vars.stabilityPool));</span>
 117 | *   | <span class='executed'>        emit PriceFeedAddressChanged(address(_vars.priceFeed));</span>
 118 | *   | <span class='executed'>        emit ActivePoolAddressChanged(address(_vars.activePool));</span>
 119 | *   | <span class='executed'>        emit DefaultPoolAddressChanged(address(_vars.defaultPool));</span>
 120 | *   | <span class='executed'>        emit GasPoolAddressChanged(_vars.gasPoolAddress);</span>
 121 | *   | <span class='executed'>        emit CollSurplusPoolAddressChanged(address(_vars.collSurplusPool));</span>
 122 | *   | <span class='executed'>        emit SortedTrovesAddressChanged(address(_vars.sortedTroves));</span>
 123 | *   | <span class='executed'>        emit InterestRouterAddressChanged(address(_vars.interestRouter));</span>
 124 | *   | <span class='executed'>        emit HintHelpersAddressChanged(address(_vars.hintHelpers));</span>
 125 | *   | <span class='executed'>        emit MultiTroveGetterAddressChanged(address(_vars.multiTroveGetter));</span>
 126 | *   | <span class='executed'>        emit CollateralRegistryAddressChanged(address(_vars.collateralRegistry));</span>
 127 | *   | <span class='executed'>        emit BoldTokenAddressChanged(address(_vars.boldToken));</span>
 128 | *   | <span class='executed'>        emit WETHAddressChanged(address(_vars.WETH));</span>
 129 |     | <span class='neutral'></span>
 130 | *   | <span class='executed'>        _renounceOwnership();</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'>}</span>
 133 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/BoldToken.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Permit.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Dependencies/Ownable.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Interfaces/IBoldToken.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/*</span>
  10 |     | <span class='neutral'> * --- Functionality added specific to the BoldToken ---</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> * 1) Transfer protection: blacklist of addresses that are invalid recipients (i.e. core Liquity contracts) in external</span>
  13 |     | <span class='neutral'> * transfer() and transferFrom() calls. The purpose is to protect users from losing tokens by mistakenly sending Bold directly to a Liquity</span>
  14 |     | <span class='neutral'> * core contract, when they should rather call the right function.</span>
  15 |     | <span class='neutral'> *</span>
  16 |     | <span class='neutral'> * 2) sendToPool() and returnFromPool(): functions callable only Liquity core contracts, which move Bold tokens between Liquity &lt;-&gt; user.</span>
  17 |     | <span class='neutral'> */</span>
  18 |     | <span class='neutral'></span>
  19 | *   | <span class='executed'>contract BoldToken is Ownable, IBoldToken, ERC20Permit {</span>
  20 |     | <span class='neutral'>    string internal constant _NAME = &quot;Bold Stablecoin&quot;;</span>
  21 |     | <span class='neutral'>    string internal constant _SYMBOL = &quot;Bold&quot;;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    // --- Addresses ---</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    address public collateralRegistryAddress;</span>
  26 |     | <span class='neutral'>    mapping(address =&gt; bool) troveManagerAddresses;</span>
  27 |     | <span class='neutral'>    mapping(address =&gt; bool) stabilityPoolAddresses;</span>
  28 |     | <span class='neutral'>    mapping(address =&gt; bool) borrowerOperationsAddresses;</span>
  29 |     | <span class='neutral'>    mapping(address =&gt; bool) activePoolAddresses;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    // --- Events ---</span>
  32 |     | <span class='neutral'>    event CollateralRegistryAddressChanged(address _newCollateralRegistryAddress);</span>
  33 |     | <span class='neutral'>    event TroveManagerAddressAdded(address _newTroveManagerAddress);</span>
  34 |     | <span class='neutral'>    event StabilityPoolAddressAdded(address _newStabilityPoolAddress);</span>
  35 |     | <span class='neutral'>    event BorrowerOperationsAddressAdded(address _newBorrowerOperationsAddress);</span>
  36 |     | <span class='neutral'>    event ActivePoolAddressAdded(address _newActivePoolAddress);</span>
  37 |     | <span class='neutral'></span>
  38 | *   | <span class='executed'>    constructor(address _owner) Ownable(_owner) ERC20(_NAME, _SYMBOL) ERC20Permit(_NAME) {}</span>
  39 |     | <span class='neutral'></span>
  40 | *   | <span class='executed'>    function setBranchAddresses(</span>
  41 |     | <span class='neutral'>        address _troveManagerAddress,</span>
  42 |     | <span class='neutral'>        address _stabilityPoolAddress,</span>
  43 |     | <span class='neutral'>        address _borrowerOperationsAddress,</span>
  44 |     | <span class='neutral'>        address _activePoolAddress</span>
  45 |     | <span class='neutral'>    ) external override onlyOwner {</span>
  46 | *   | <span class='executed'>        troveManagerAddresses[_troveManagerAddress] = true;</span>
  47 | *   | <span class='executed'>        emit TroveManagerAddressAdded(_troveManagerAddress);</span>
  48 |     | <span class='neutral'></span>
  49 | *   | <span class='executed'>        stabilityPoolAddresses[_stabilityPoolAddress] = true;</span>
  50 | *   | <span class='executed'>        emit StabilityPoolAddressAdded(_stabilityPoolAddress);</span>
  51 |     | <span class='neutral'></span>
  52 | *   | <span class='executed'>        borrowerOperationsAddresses[_borrowerOperationsAddress] = true;</span>
  53 | *   | <span class='executed'>        emit BorrowerOperationsAddressAdded(_borrowerOperationsAddress);</span>
  54 |     | <span class='neutral'></span>
  55 | *   | <span class='executed'>        activePoolAddresses[_activePoolAddress] = true;</span>
  56 | *   | <span class='executed'>        emit ActivePoolAddressAdded(_activePoolAddress);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 | *   | <span class='executed'>    function setCollateralRegistry(address _collateralRegistryAddress) external override onlyOwner {</span>
  60 | *   | <span class='executed'>        collateralRegistryAddress = _collateralRegistryAddress;</span>
  61 | *   | <span class='executed'>        emit CollateralRegistryAddressChanged(_collateralRegistryAddress);</span>
  62 |     | <span class='neutral'></span>
  63 | *   | <span class='executed'>        _renounceOwnership();</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    // --- Functions for intra-Liquity calls ---</span>
  67 |     | <span class='neutral'></span>
  68 | *   | <span class='executed'>    function mint(address _account, uint256 _amount) external override {</span>
  69 | *   | <span class='executed'>        _requireCallerIsBOorAP();</span>
  70 | *   | <span class='executed'>        _mint(_account, _amount);</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 | *   | <span class='executed'>    function burn(address _account, uint256 _amount) external override {</span>
  74 | *   | <span class='executed'>        _requireCallerIsCRorBOorTMorSP();</span>
  75 | *   | <span class='executed'>        _burn(_account, _amount);</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function sendToPool(address _sender, address _poolAddress, uint256 _amount) external override {</span>
  79 |     | <span class='neutral'>        _requireCallerIsStabilityPool();</span>
  80 |     | <span class='neutral'>        _transfer(_sender, _poolAddress, _amount);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 | *   | <span class='executed'>    function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external override {</span>
  84 | *   | <span class='executed'>        _requireCallerIsStabilityPool();</span>
  85 | *   | <span class='executed'>        _transfer(_poolAddress, _receiver, _amount);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    // --- External functions ---</span>
  89 |     | <span class='neutral'></span>
  90 | *   | <span class='executed'>    function transfer(address recipient, uint256 amount) public override(ERC20, IERC20) returns (bool) {</span>
  91 |     | <span class='unexecuted'>        _requireValidRecipient(recipient);</span>
  92 | *   | <span class='executed'>        return super.transfer(recipient, amount);</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>    function transferFrom(address sender, address recipient, uint256 amount)</span>
  96 |     | <span class='neutral'>        public</span>
  97 |     | <span class='neutral'>        override(ERC20, IERC20)</span>
  98 |     | <span class='unexecuted'>        returns (bool)</span>
  99 |     | <span class='neutral'>    {</span>
 100 |     | <span class='unexecuted'>        _requireValidRecipient(recipient);</span>
 101 |     | <span class='unexecuted'>        return super.transferFrom(sender, recipient, amount);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    // --- &#39;require&#39; functions ---</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>    function _requireValidRecipient(address _recipient) internal view {</span>
 107 |     | <span class='unexecuted'>        require(</span>
 108 |     | <span class='unexecuted'>            _recipient != address(0) &amp;&amp; _recipient != address(this),</span>
 109 |     | <span class='neutral'>            &quot;Bold: Cannot transfer tokens directly to the Bold token contract or the zero address&quot;</span>
 110 |     | <span class='neutral'>        );</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 | *   | <span class='executed'>    function _requireCallerIsBOorAP() internal view {</span>
 114 | *   | <span class='executed'>        require(</span>
 115 | *   | <span class='executed'>            borrowerOperationsAddresses[msg.sender] || activePoolAddresses[msg.sender],</span>
 116 |     | <span class='neutral'>            &quot;BoldToken: Caller is not BO or AP&quot;</span>
 117 |     | <span class='neutral'>        );</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 | *   | <span class='executed'>    function _requireCallerIsCRorBOorTMorSP() internal view {</span>
 121 | *   | <span class='executed'>        require(</span>
 122 | *   | <span class='executed'>            msg.sender == collateralRegistryAddress || borrowerOperationsAddresses[msg.sender]</span>
 123 | *   | <span class='executed'>                || troveManagerAddresses[msg.sender] || stabilityPoolAddresses[msg.sender],</span>
 124 |     | <span class='neutral'>            &quot;Bold: Caller is neither CR nor BorrowerOperations nor TroveManager nor StabilityPool&quot;</span>
 125 |     | <span class='neutral'>        );</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 | *   | <span class='executed'>    function _requireCallerIsStabilityPool() internal view {</span>
 129 | *   | <span class='executed'>        require(stabilityPoolAddresses[msg.sender], &quot;Bold: Caller is not the StabilityPool&quot;);</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'>}</span>
 132 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/BorrowerOperations.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
    2 |     | <span class='neutral'></span>
    3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
    4 |     | <span class='neutral'></span>
    5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='neutral'>import &quot;./Interfaces/IBorrowerOperations.sol&quot;;</span>
    8 |     | <span class='neutral'>import &quot;./Interfaces/IAddressesRegistry.sol&quot;;</span>
    9 |     | <span class='neutral'>import &quot;./Interfaces/ITroveManager.sol&quot;;</span>
   10 |     | <span class='neutral'>import &quot;./Interfaces/IBoldToken.sol&quot;;</span>
   11 |     | <span class='neutral'>import &quot;./Interfaces/ICollSurplusPool.sol&quot;;</span>
   12 |     | <span class='neutral'>import &quot;./Interfaces/ISortedTroves.sol&quot;;</span>
   13 |     | <span class='neutral'>import &quot;./Dependencies/LiquityBase.sol&quot;;</span>
   14 |     | <span class='neutral'>import &quot;./Dependencies/AddRemoveManagers.sol&quot;;</span>
   15 |     | <span class='neutral'>import &quot;./Types/LatestTroveData.sol&quot;;</span>
   16 |     | <span class='neutral'>import &quot;./Types/LatestBatchData.sol&quot;;</span>
   17 |     | <span class='neutral'></span>
   18 | *   | <span class='executed'>contract BorrowerOperations is LiquityBase, AddRemoveManagers, IBorrowerOperations {</span>
   19 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
   20 |     | <span class='neutral'></span>
   21 |     | <span class='neutral'>    // --- Connected contract declarations ---</span>
   22 |     | <span class='neutral'></span>
   23 |     | <span class='neutral'>    IERC20 internal immutable collToken;</span>
   24 | *   | <span class='executed'>    ITroveManager public troveManager;</span>
   25 |     | <span class='neutral'>    address internal gasPoolAddress;</span>
   26 |     | <span class='neutral'>    ICollSurplusPool internal collSurplusPool;</span>
   27 | *   | <span class='executed'>    IBoldToken public boldToken;</span>
   28 |     | <span class='neutral'>    // A doubly linked list of Troves, sorted by their collateral ratios</span>
   29 |     | <span class='neutral'>    ISortedTroves internal sortedTroves;</span>
   30 |     | <span class='neutral'>    // Wrapped ETH for liquidation reserve (gas compensation)</span>
   31 |     | <span class='neutral'>    IWETH internal immutable WETH;</span>
   32 |     | <span class='neutral'></span>
   33 |     | <span class='neutral'>    // Critical system collateral ratio. If the system&#39;s total collateral ratio (TCR) falls below the CCR, some borrowing operation restrictions are applied</span>
   34 | *   | <span class='executed'>    uint256 public immutable CCR;</span>
   35 |     | <span class='neutral'></span>
   36 |     | <span class='neutral'>    // Shutdown system collateral ratio. If the system&#39;s total collateral ratio (TCR) for a given collateral falls below the SCR,</span>
   37 |     | <span class='neutral'>    // the protocol triggers the shutdown of the borrow market and permanently disables all borrowing operations except for closing Troves.</span>
   38 |     | <span class='unexecuted'>    uint256 public immutable SCR;</span>
   39 | *   | <span class='executed'>    bool public hasBeenShutDown;</span>
   40 |     | <span class='neutral'></span>
   41 |     | <span class='neutral'>    // Minimum collateral ratio for individual troves</span>
   42 |     | <span class='unexecuted'>    uint256 public immutable MCR;</span>
   43 |     | <span class='neutral'></span>
   44 |     | <span class='neutral'>    /*</span>
   45 |     | <span class='neutral'>    * Mapping from TroveId to individual delegate for interest rate setting.</span>
   46 |     | <span class='neutral'>    *</span>
   47 |     | <span class='neutral'>    * This address then has the ability to update the borrower’s interest rate, but not change its debt or collateral.</span>
   48 |     | <span class='neutral'>    * Useful for instance for cold/hot wallet setups.</span>
   49 |     | <span class='neutral'>    */</span>
   50 |     | <span class='neutral'>    mapping(uint256 =&gt; InterestIndividualDelegate) private interestIndividualDelegateOf;</span>
   51 |     | <span class='neutral'></span>
   52 |     | <span class='neutral'>    /*</span>
   53 |     | <span class='neutral'>     * Mapping from TroveId to granted address for interest rate setting (batch manager).</span>
   54 |     | <span class='neutral'>     *</span>
   55 |     | <span class='neutral'>     * Batch managers set the interest rate for every Trove in the batch. The interest rate is the same for all Troves in the batch.</span>
   56 |     | <span class='neutral'>     */</span>
   57 |     | <span class='unexecuted'>    mapping(uint256 =&gt; address) public interestBatchManagerOf;</span>
   58 |     | <span class='neutral'></span>
   59 |     | <span class='neutral'>    // List of registered Interest Batch Managers</span>
   60 |     | <span class='neutral'>    mapping(address =&gt; InterestBatchManager) private interestBatchManagers;</span>
   61 |     | <span class='neutral'></span>
   62 |     | <span class='neutral'>    /* --- Variable container structs  ---</span>
   63 |     | <span class='neutral'></span>
   64 |     | <span class='neutral'>    Used to hold, return and assign variables inside a function, in order to avoid the error:</span>
   65 |     | <span class='neutral'>    &quot;CompilerError: Stack too deep&quot;. */</span>
   66 |     | <span class='neutral'></span>
   67 |     | <span class='neutral'>    struct OpenTroveVars {</span>
   68 |     | <span class='neutral'>        ITroveManager troveManager;</span>
   69 |     | <span class='neutral'>        uint256 troveId;</span>
   70 |     | <span class='neutral'>        TroveChange change;</span>
   71 |     | <span class='neutral'>        LatestBatchData batch;</span>
   72 |     | <span class='neutral'>    }</span>
   73 |     | <span class='neutral'></span>
   74 |     | <span class='neutral'>    struct LocalVariables_openTrove {</span>
   75 |     | <span class='neutral'>        ITroveManager troveManager;</span>
   76 |     | <span class='neutral'>        IActivePool activePool;</span>
   77 |     | <span class='neutral'>        IBoldToken boldToken;</span>
   78 |     | <span class='neutral'>        uint256 troveId;</span>
   79 |     | <span class='neutral'>        uint256 price;</span>
   80 |     | <span class='neutral'>        uint256 avgInterestRate;</span>
   81 |     | <span class='neutral'>        uint256 entireDebt;</span>
   82 |     | <span class='neutral'>        uint256 ICR;</span>
   83 |     | <span class='neutral'>        uint256 newTCR;</span>
   84 |     | <span class='neutral'>        bool newOracleFailureDetected;</span>
   85 |     | <span class='neutral'>    }</span>
   86 |     | <span class='neutral'></span>
   87 |     | <span class='neutral'>    struct LocalVariables_adjustTrove {</span>
   88 |     | <span class='neutral'>        IActivePool activePool;</span>
   89 |     | <span class='neutral'>        IBoldToken boldToken;</span>
   90 |     | <span class='neutral'>        LatestTroveData trove;</span>
   91 |     | <span class='neutral'>        uint256 price;</span>
   92 |     | <span class='neutral'>        bool isBelowCriticalThreshold;</span>
   93 |     | <span class='neutral'>        uint256 newICR;</span>
   94 |     | <span class='neutral'>        uint256 newDebt;</span>
   95 |     | <span class='neutral'>        uint256 newColl;</span>
   96 |     | <span class='neutral'>        bool newOracleFailureDetected;</span>
   97 |     | <span class='neutral'>    }</span>
   98 |     | <span class='neutral'></span>
   99 |     | <span class='neutral'>    struct LocalVariables_setInterestBatchManager {</span>
  100 |     | <span class='neutral'>        ITroveManager troveManager;</span>
  101 |     | <span class='neutral'>        IActivePool activePool;</span>
  102 |     | <span class='neutral'>        ISortedTroves sortedTroves;</span>
  103 |     | <span class='neutral'>        address oldBatchManager;</span>
  104 |     | <span class='neutral'>        LatestTroveData trove;</span>
  105 |     | <span class='neutral'>        LatestBatchData oldBatch;</span>
  106 |     | <span class='neutral'>        LatestBatchData newBatch;</span>
  107 |     | <span class='neutral'>    }</span>
  108 |     | <span class='neutral'></span>
  109 |     | <span class='neutral'>    struct LocalVariables_removeFromBatch {</span>
  110 |     | <span class='neutral'>        ITroveManager troveManager;</span>
  111 |     | <span class='neutral'>        ISortedTroves sortedTroves;</span>
  112 |     | <span class='neutral'>        address batchManager;</span>
  113 |     | <span class='neutral'>        LatestTroveData trove;</span>
  114 |     | <span class='neutral'>        LatestBatchData batch;</span>
  115 |     | <span class='neutral'>        uint256 newBatchDebt;</span>
  116 |     | <span class='neutral'>    }</span>
  117 |     | <span class='neutral'></span>
  118 |     | <span class='neutral'>    error IsShutDown();</span>
  119 |     | <span class='neutral'>    error TCRNotBelowSCR();</span>
  120 |     | <span class='neutral'>    error ZeroAdjustment();</span>
  121 |     | <span class='neutral'>    error NotOwnerNorInterestManager();</span>
  122 |     | <span class='neutral'>    error TroveInBatch();</span>
  123 |     | <span class='neutral'>    error TroveNotInBatch();</span>
  124 |     | <span class='neutral'>    error InterestNotInRange();</span>
  125 |     | <span class='neutral'>    error BatchInterestRateChangePeriodNotPassed();</span>
  126 |     | <span class='neutral'>    error DelegateInterestRateChangePeriodNotPassed();</span>
  127 |     | <span class='neutral'>    error TroveExists();</span>
  128 |     | <span class='neutral'>    error TroveNotOpen();</span>
  129 |     | <span class='neutral'>    error TroveNotActive();</span>
  130 |     | <span class='neutral'>    error TroveNotZombie();</span>
  131 |     | <span class='neutral'>    error TroveWithZeroDebt();</span>
  132 |     | <span class='neutral'>    error UpfrontFeeTooHigh();</span>
  133 |     | <span class='neutral'>    error ICRBelowMCR();</span>
  134 |     | <span class='neutral'>    error RepaymentNotMatchingCollWithdrawal();</span>
  135 |     | <span class='neutral'>    error TCRBelowCCR();</span>
  136 |     | <span class='neutral'>    error DebtBelowMin();</span>
  137 |     | <span class='neutral'>    error CollWithdrawalTooHigh();</span>
  138 |     | <span class='neutral'>    error NotEnoughBoldBalance();</span>
  139 |     | <span class='neutral'>    error InterestRateTooLow();</span>
  140 |     | <span class='neutral'>    error InterestRateTooHigh();</span>
  141 |     | <span class='neutral'>    error InterestRateNotNew();</span>
  142 |     | <span class='neutral'>    error InvalidInterestBatchManager();</span>
  143 |     | <span class='neutral'>    error BatchManagerExists();</span>
  144 |     | <span class='neutral'>    error BatchManagerNotNew();</span>
  145 |     | <span class='neutral'>    error NewFeeNotLower();</span>
  146 |     | <span class='neutral'>    error CallerNotTroveManager();</span>
  147 |     | <span class='neutral'>    error CallerNotPriceFeed();</span>
  148 |     | <span class='neutral'>    error MinGeMax();</span>
  149 |     | <span class='neutral'>    error AnnualManagementFeeTooHigh();</span>
  150 |     | <span class='neutral'>    error MinInterestRateChangePeriodTooLow();</span>
  151 |     | <span class='neutral'>    error NewOracleFailureDetected();</span>
  152 |     | <span class='neutral'></span>
  153 |     | <span class='neutral'>    event TroveManagerAddressChanged(address _newTroveManagerAddress);</span>
  154 |     | <span class='neutral'>    event GasPoolAddressChanged(address _gasPoolAddress);</span>
  155 |     | <span class='neutral'>    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);</span>
  156 |     | <span class='neutral'>    event SortedTrovesAddressChanged(address _sortedTrovesAddress);</span>
  157 |     | <span class='neutral'>    event BoldTokenAddressChanged(address _boldTokenAddress);</span>
  158 |     | <span class='neutral'></span>
  159 |     | <span class='neutral'>    event ShutDown(uint256 _tcr);</span>
  160 |     | <span class='neutral'></span>
  161 | *   | <span class='executed'>    constructor(IAddressesRegistry _addressesRegistry)</span>
  162 | *   | <span class='executed'>        AddRemoveManagers(_addressesRegistry)</span>
  163 | *   | <span class='executed'>        LiquityBase(_addressesRegistry)</span>
  164 |     | <span class='neutral'>    {</span>
  165 |     | <span class='neutral'>        // This makes impossible to open a trove with zero withdrawn Bold</span>
  166 |     | <span class='neutral'>        assert(MIN_DEBT &gt; 0);</span>
  167 |     | <span class='neutral'></span>
  168 | *   | <span class='executed'>        collToken = _addressesRegistry.collToken();</span>
  169 |     | <span class='neutral'></span>
  170 | *   | <span class='executed'>        WETH = _addressesRegistry.WETH();</span>
  171 |     | <span class='neutral'></span>
  172 | *   | <span class='executed'>        CCR = _addressesRegistry.CCR();</span>
  173 | *   | <span class='executed'>        SCR = _addressesRegistry.SCR();</span>
  174 | *   | <span class='executed'>        MCR = _addressesRegistry.MCR();</span>
  175 |     | <span class='neutral'></span>
  176 | *   | <span class='executed'>        troveManager = _addressesRegistry.troveManager();</span>
  177 | *   | <span class='executed'>        gasPoolAddress = _addressesRegistry.gasPoolAddress();</span>
  178 | *   | <span class='executed'>        collSurplusPool = _addressesRegistry.collSurplusPool();</span>
  179 | *   | <span class='executed'>        sortedTroves = _addressesRegistry.sortedTroves();</span>
  180 | *   | <span class='executed'>        boldToken = _addressesRegistry.boldToken();</span>
  181 |     | <span class='neutral'></span>
  182 | *   | <span class='executed'>        emit TroveManagerAddressChanged(address(troveManager));</span>
  183 | *   | <span class='executed'>        emit GasPoolAddressChanged(gasPoolAddress);</span>
  184 | *   | <span class='executed'>        emit CollSurplusPoolAddressChanged(address(collSurplusPool));</span>
  185 | *   | <span class='executed'>        emit SortedTrovesAddressChanged(address(sortedTroves));</span>
  186 | *   | <span class='executed'>        emit BoldTokenAddressChanged(address(boldToken));</span>
  187 |     | <span class='neutral'></span>
  188 |     | <span class='neutral'>        // Allow funds movements between Liquity contracts</span>
  189 | *   | <span class='executed'>        collToken.approve(address(activePool), type(uint256).max);</span>
  190 |     | <span class='neutral'>    }</span>
  191 |     | <span class='neutral'></span>
  192 |     | <span class='neutral'>    // --- Borrower Trove Operations ---</span>
  193 |     | <span class='neutral'></span>
  194 | *   | <span class='executed'>    function openTrove(</span>
  195 |     | <span class='neutral'>        address _owner,</span>
  196 |     | <span class='neutral'>        uint256 _ownerIndex,</span>
  197 |     | <span class='neutral'>        uint256 _collAmount,</span>
  198 |     | <span class='neutral'>        uint256 _boldAmount,</span>
  199 |     | <span class='neutral'>        uint256 _upperHint,</span>
  200 |     | <span class='neutral'>        uint256 _lowerHint,</span>
  201 |     | <span class='neutral'>        uint256 _annualInterestRate,</span>
  202 |     | <span class='neutral'>        uint256 _maxUpfrontFee,</span>
  203 |     | <span class='neutral'>        address _addManager,</span>
  204 |     | <span class='neutral'>        address _removeManager,</span>
  205 |     | <span class='neutral'>        address _receiver</span>
  206 | *   | <span class='executed'>    ) external override returns (uint256) {</span>
  207 | *   | <span class='executed'>        _requireValidAnnualInterestRate(_annualInterestRate);</span>
  208 |     | <span class='neutral'></span>
  209 | *   | <span class='executed'>        OpenTroveVars memory vars;</span>
  210 |     | <span class='neutral'></span>
  211 | *   | <span class='executed'>        vars.troveId = _openTrove(</span>
  212 | *   | <span class='executed'>            _owner,</span>
  213 | *   | <span class='executed'>            _ownerIndex,</span>
  214 | *   | <span class='executed'>            _collAmount,</span>
  215 | *   | <span class='executed'>            _boldAmount,</span>
  216 | *   | <span class='executed'>            _annualInterestRate,</span>
  217 | *   | <span class='executed'>            address(0), //@note interestBa</span>
  218 | *   | <span class='executed'>            0,</span>
  219 | *   | <span class='executed'>            0,</span>
  220 | *   | <span class='executed'>            _maxUpfrontFee,</span>
  221 | *   | <span class='executed'>            _addManager,</span>
  222 | *   | <span class='executed'>            _removeManager,</span>
  223 | *   | <span class='executed'>            _receiver,</span>
  224 | *   | <span class='executed'>            vars.change</span>
  225 |     | <span class='neutral'>        );</span>
  226 |     | <span class='neutral'></span>
  227 |     | <span class='neutral'>        // Set the stored Trove properties and mint the NFT</span>
  228 | *   | <span class='executed'>        troveManager.onOpenTrove(_owner, vars.troveId, vars.change, _annualInterestRate);</span>
  229 |     | <span class='neutral'></span>
  230 | *   | <span class='executed'>        sortedTroves.insert(vars.troveId, _annualInterestRate, _upperHint, _lowerHint);</span>
  231 |     | <span class='neutral'></span>
  232 | *   | <span class='executed'>        return vars.troveId;</span>
  233 |     | <span class='neutral'>    }</span>
  234 |     | <span class='neutral'></span>
  235 | *   | <span class='executed'>    function openTroveAndJoinInterestBatchManager(OpenTroveAndJoinInterestBatchManagerParams calldata _params)</span>
  236 |     | <span class='neutral'>        external</span>
  237 |     | <span class='neutral'>        override</span>
  238 | *   | <span class='executed'>        returns (uint256)</span>
  239 |     | <span class='neutral'>    {</span>
  240 | *   | <span class='executed'>        _requireValidInterestBatchManager(_params.interestBatchManager);</span>
  241 |     | <span class='neutral'></span>
  242 | *   | <span class='executed'>        OpenTroveVars memory vars;</span>
  243 | *   | <span class='executed'>        vars.troveManager = troveManager;</span>
  244 |     | <span class='neutral'></span>
  245 | *   | <span class='executed'>        vars.batch = vars.troveManager.getLatestBatchData(_params.interestBatchManager);</span>
  246 |     | <span class='neutral'></span>
  247 |     | <span class='neutral'>        // We set old weighted values here, as it’s only necessary for batches, so we don’t need to pass them to _openTrove func</span>
  248 | *   | <span class='executed'>        vars.change.batchAccruedManagementFee = vars.batch.accruedManagementFee;</span>
  249 | *   | <span class='executed'>        vars.change.oldWeightedRecordedDebt = vars.batch.weightedRecordedDebt;</span>
  250 | *   | <span class='executed'>        vars.change.oldWeightedRecordedBatchManagementFee = vars.batch.weightedRecordedBatchManagementFee;</span>
  251 | *   | <span class='executed'>        vars.troveId = _openTrove(</span>
  252 | *   | <span class='executed'>            _params.owner,</span>
  253 | *   | <span class='executed'>            _params.ownerIndex,</span>
  254 | *   | <span class='executed'>            _params.collAmount,</span>
  255 | *   | <span class='executed'>            _params.boldAmount,</span>
  256 | *   | <span class='executed'>            vars.batch.annualInterestRate,</span>
  257 | *   | <span class='executed'>            _params.interestBatchManager,</span>
  258 | *   | <span class='executed'>            vars.batch.entireDebtWithoutRedistribution,</span>
  259 | *   | <span class='executed'>            vars.batch.annualManagementFee,</span>
  260 | *   | <span class='executed'>            _params.maxUpfrontFee,</span>
  261 | *   | <span class='executed'>            _params.addManager,</span>
  262 | *   | <span class='executed'>            _params.removeManager,</span>
  263 | *   | <span class='executed'>            _params.receiver,</span>
  264 | *   | <span class='executed'>            vars.change</span>
  265 |     | <span class='neutral'>        );</span>
  266 |     | <span class='neutral'></span>
  267 | *   | <span class='executed'>        interestBatchManagerOf[vars.troveId] = _params.interestBatchManager;</span>
  268 |     | <span class='neutral'></span>
  269 |     | <span class='neutral'>        // Set the stored Trove properties and mint the NFT</span>
  270 | *   | <span class='executed'>        vars.troveManager.onOpenTroveAndJoinBatch(</span>
  271 | *   | <span class='executed'>            _params.owner,</span>
  272 | *   | <span class='executed'>            vars.troveId,</span>
  273 | *   | <span class='executed'>            vars.change,</span>
  274 | *   | <span class='executed'>            _params.interestBatchManager,</span>
  275 | *   | <span class='executed'>            vars.batch.entireCollWithoutRedistribution,</span>
  276 | *   | <span class='executed'>            vars.batch.entireDebtWithoutRedistribution</span>
  277 |     | <span class='neutral'>        );</span>
  278 |     | <span class='neutral'></span>
  279 | *   | <span class='executed'>        sortedTroves.insertIntoBatch(</span>
  280 | *   | <span class='executed'>            vars.troveId,</span>
  281 | *   | <span class='executed'>            BatchId.wrap(_params.interestBatchManager),</span>
  282 | *   | <span class='executed'>            vars.batch.annualInterestRate,</span>
  283 | *   | <span class='executed'>            _params.upperHint,</span>
  284 | *   | <span class='executed'>            _params.lowerHint</span>
  285 |     | <span class='neutral'>        );</span>
  286 |     | <span class='neutral'></span>
  287 | *   | <span class='executed'>        return vars.troveId;</span>
  288 |     | <span class='neutral'>    }</span>
  289 |     | <span class='neutral'></span>
  290 | *   | <span class='executed'>    function _openTrove(</span>
  291 |     | <span class='neutral'>        address _owner,</span>
  292 |     | <span class='neutral'>        uint256 _ownerIndex,</span>
  293 |     | <span class='neutral'>        uint256 _collAmount,</span>
  294 |     | <span class='neutral'>        uint256 _boldAmount,</span>
  295 |     | <span class='neutral'>        uint256 _annualInterestRate,</span>
  296 |     | <span class='neutral'>        address _interestBatchManager,</span>
  297 |     | <span class='neutral'>        uint256 _batchEntireDebt,</span>
  298 |     | <span class='neutral'>        uint256 _batchManagementAnnualFee,</span>
  299 |     | <span class='neutral'>        uint256 _maxUpfrontFee,</span>
  300 |     | <span class='neutral'>        address _addManager,</span>
  301 |     | <span class='neutral'>        address _removeManager,</span>
  302 |     | <span class='neutral'>        address _receiver,</span>
  303 |     | <span class='neutral'>        TroveChange memory _change</span>
  304 | *   | <span class='executed'>    ) internal returns (uint256) {</span>
  305 | *   | <span class='executed'>        _requireIsNotShutDown();</span>
  306 |     | <span class='neutral'></span>
  307 | *   | <span class='executed'>        LocalVariables_openTrove memory vars;</span>
  308 |     | <span class='neutral'></span>
  309 |     | <span class='neutral'>        // stack too deep not allowing to reuse troveManager from outer functions</span>
  310 | *   | <span class='executed'>        vars.troveManager = troveManager;</span>
  311 | *   | <span class='executed'>        vars.activePool = activePool;</span>
  312 | *   | <span class='executed'>        vars.boldToken = boldToken;</span>
  313 |     | <span class='neutral'></span>
  314 | *   | <span class='executed'>        vars.price = _requireOraclesLive();</span>
  315 |     | <span class='neutral'></span>
  316 |     | <span class='neutral'>        // --- Checks ---</span>
  317 |     | <span class='neutral'></span>
  318 | *   | <span class='executed'>        vars.troveId = uint256(keccak256(abi.encode(_owner, _ownerIndex)));</span>
  319 | *   | <span class='executed'>        _requireTroveDoesNotExists(vars.troveManager, vars.troveId);</span>
  320 |     | <span class='neutral'></span>
  321 | *   | <span class='executed'>        _change.collIncrease = _collAmount;</span>
  322 | *   | <span class='executed'>        _change.debtIncrease = _boldAmount;</span>
  323 |     | <span class='neutral'></span>
  324 |     | <span class='neutral'>        // For simplicity, we ignore the fee when calculating the approx. interest rate</span>
  325 | *   | <span class='executed'>        _change.newWeightedRecordedDebt = (_batchEntireDebt + _change.debtIncrease) * _annualInterestRate;</span>
  326 |     | <span class='neutral'></span>
  327 | *   | <span class='executed'>        vars.avgInterestRate = vars.activePool.getNewApproxAvgInterestRateFromTroveChange(_change);</span>
  328 | *   | <span class='executed'>        _change.upfrontFee = _calcUpfrontFee(_change.debtIncrease, vars.avgInterestRate);</span>
  329 | *   | <span class='executed'>        _requireUserAcceptsUpfrontFee(_change.upfrontFee, _maxUpfrontFee);</span>
  330 |     | <span class='neutral'></span>
  331 | *   | <span class='executed'>        vars.entireDebt = _change.debtIncrease + _change.upfrontFee;</span>
  332 | *   | <span class='executed'>        _requireAtLeastMinDebt(vars.entireDebt);</span>
  333 |     | <span class='neutral'></span>
  334 |     | <span class='neutral'>        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee, and the batch fee if needed</span>
  335 | *   | <span class='executed'>        if (_interestBatchManager == address(0)) {</span>
  336 | *   | <span class='executed'>            _change.newWeightedRecordedDebt = vars.entireDebt * _annualInterestRate;</span>
  337 |     | <span class='neutral'>        } else {</span>
  338 |     | <span class='neutral'>            // old values have been set outside, before calling this function</span>
  339 | *   | <span class='executed'>            _change.newWeightedRecordedDebt = (_batchEntireDebt + vars.entireDebt) * _annualInterestRate;</span>
  340 | *   | <span class='executed'>            _change.newWeightedRecordedBatchManagementFee =</span>
  341 | *   | <span class='executed'>                (_batchEntireDebt + vars.entireDebt) * _batchManagementAnnualFee;</span>
  342 |     | <span class='neutral'>        }</span>
  343 |     | <span class='neutral'></span>
  344 |     | <span class='neutral'>        // ICR is based on the requested Bold amount + upfront fee.</span>
  345 | *   | <span class='executed'>        vars.ICR = LiquityMath._computeCR(_collAmount, vars.entireDebt, vars.price);</span>
  346 | *   | <span class='executed'>        _requireICRisAboveMCR(vars.ICR);</span>
  347 |     | <span class='neutral'></span>
  348 | *   | <span class='executed'>        vars.newTCR = _getNewTCRFromTroveChange(_change, vars.price);</span>
  349 | *   | <span class='executed'>        _requireNewTCRisAboveCCR(vars.newTCR);</span>
  350 |     | <span class='neutral'></span>
  351 |     | <span class='neutral'>        // --- Effects &amp; interactions ---</span>
  352 |     | <span class='neutral'></span>
  353 |     | <span class='neutral'>        // Set add/remove managers</span>
  354 | *   | <span class='executed'>        _setAddManager(vars.troveId, _addManager);</span>
  355 | *   | <span class='executed'>        _setRemoveManagerAndReceiver(vars.troveId, _removeManager, _receiver);</span>
  356 |     | <span class='neutral'></span>
  357 | *   | <span class='executed'>        vars.activePool.mintAggInterestAndAccountForTroveChange(_change, _interestBatchManager);</span>
  358 |     | <span class='neutral'></span>
  359 |     | <span class='neutral'>        // Pull coll tokens from sender and move them to the Active Pool</span>
  360 | *   | <span class='executed'>        _pullCollAndSendToActivePool(vars.activePool, _collAmount);</span>
  361 |     | <span class='neutral'></span>
  362 |     | <span class='neutral'>        // Mint the requested _boldAmount to the borrower and mint the gas comp to the GasPool</span>
  363 | *   | <span class='executed'>        vars.boldToken.mint(msg.sender, _boldAmount);</span>
  364 | *   | <span class='executed'>        WETH.transferFrom(msg.sender, gasPoolAddress, ETH_GAS_COMPENSATION);</span>
  365 |     | <span class='neutral'></span>
  366 | *   | <span class='executed'>        return vars.troveId;</span>
  367 |     | <span class='neutral'>    }</span>
  368 |     | <span class='neutral'></span>
  369 |     | <span class='neutral'>    // Send collateral to a trove</span>
  370 | *   | <span class='executed'>    function addColl(uint256 _troveId, uint256 _collAmount) external override {</span>
  371 | *   | <span class='executed'>        ITroveManager troveManagerCached = troveManager;</span>
  372 | *   | <span class='executed'>        _requireTroveIsActive(troveManagerCached, _troveId);</span>
  373 |     | <span class='neutral'></span>
  374 | *   | <span class='executed'>        TroveChange memory troveChange;</span>
  375 | *   | <span class='executed'>        troveChange.collIncrease = _collAmount;</span>
  376 |     | <span class='neutral'></span>
  377 | *   | <span class='executed'>        _adjustTrove(</span>
  378 | *   | <span class='executed'>            troveManagerCached,</span>
  379 | *   | <span class='executed'>            _troveId,</span>
  380 |     | <span class='neutral'>            troveChange,</span>
  381 | *   | <span class='executed'>            0 // _maxUpfrontFee</span>
  382 |     | <span class='neutral'>        );</span>
  383 |     | <span class='neutral'>    }</span>
  384 |     | <span class='neutral'></span>
  385 |     | <span class='neutral'>    // Withdraw collateral from a trove</span>
  386 | *   | <span class='executed'>    function withdrawColl(uint256 _troveId, uint256 _collWithdrawal) external override {</span>
  387 | *   | <span class='executed'>        ITroveManager troveManagerCached = troveManager;</span>
  388 | *   | <span class='executed'>        _requireTroveIsActive(troveManagerCached, _troveId);</span>
  389 |     | <span class='neutral'></span>
  390 | *   | <span class='executed'>        TroveChange memory troveChange;</span>
  391 | *   | <span class='executed'>        troveChange.collDecrease = _collWithdrawal;</span>
  392 |     | <span class='neutral'></span>
  393 | *   | <span class='executed'>        _adjustTrove(</span>
  394 | *   | <span class='executed'>            troveManagerCached,</span>
  395 | *   | <span class='executed'>            _troveId,</span>
  396 |     | <span class='neutral'>            troveChange,</span>
  397 | *   | <span class='executed'>            0 // _maxUpfrontFee</span>
  398 |     | <span class='neutral'>        );</span>
  399 |     | <span class='neutral'>    }</span>
  400 |     | <span class='neutral'></span>
  401 |     | <span class='neutral'>    // Withdraw Bold tokens from a trove: mint new Bold tokens to the owner, and increase the trove&#39;s debt accordingly</span>
  402 | *   | <span class='executed'>    function withdrawBold(uint256 _troveId, uint256 _boldAmount, uint256 _maxUpfrontFee) external override {</span>
  403 | *   | <span class='executed'>        ITroveManager troveManagerCached = troveManager;</span>
  404 | *   | <span class='executed'>        _requireTroveIsActive(troveManagerCached, _troveId);</span>
  405 |     | <span class='neutral'></span>
  406 | *   | <span class='executed'>        TroveChange memory troveChange;</span>
  407 | *   | <span class='executed'>        troveChange.debtIncrease = _boldAmount;</span>
  408 | *   | <span class='executed'>        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);</span>
  409 |     | <span class='neutral'>    }</span>
  410 |     | <span class='neutral'></span>
  411 |     | <span class='neutral'>    // Repay Bold tokens to a Trove: Burn the repaid Bold tokens, and reduce the trove&#39;s debt accordingly</span>
  412 | *   | <span class='executed'>    function repayBold(uint256 _troveId, uint256 _boldAmount) external override {</span>
  413 | *   | <span class='executed'>        ITroveManager troveManagerCached = troveManager;</span>
  414 | *   | <span class='executed'>        _requireTroveIsActive(troveManagerCached, _troveId);</span>
  415 |     | <span class='neutral'></span>
  416 | *   | <span class='executed'>        TroveChange memory troveChange;</span>
  417 | *   | <span class='executed'>        troveChange.debtDecrease = _boldAmount;</span>
  418 |     | <span class='neutral'></span>
  419 | *   | <span class='executed'>        _adjustTrove(</span>
  420 | *   | <span class='executed'>            troveManagerCached,</span>
  421 | *   | <span class='executed'>            _troveId,</span>
  422 |     | <span class='neutral'>            troveChange,</span>
  423 | *   | <span class='executed'>            0 // _maxUpfrontFee</span>
  424 |     | <span class='neutral'>        );</span>
  425 |     | <span class='neutral'>    }</span>
  426 |     | <span class='neutral'></span>
  427 | *   | <span class='executed'>    function _initTroveChange(</span>
  428 |     | <span class='neutral'>        TroveChange memory _troveChange,</span>
  429 |     | <span class='neutral'>        uint256 _collChange,</span>
  430 |     | <span class='neutral'>        bool _isCollIncrease,</span>
  431 |     | <span class='neutral'>        uint256 _boldChange,</span>
  432 |     | <span class='neutral'>        bool _isDebtIncrease</span>
  433 |     | <span class='neutral'>    ) internal pure {</span>
  434 | *   | <span class='executed'>        if (_isCollIncrease) {</span>
  435 | *   | <span class='executed'>            _troveChange.collIncrease = _collChange;</span>
  436 |     | <span class='neutral'>        } else {</span>
  437 | *   | <span class='executed'>            _troveChange.collDecrease = _collChange;</span>
  438 |     | <span class='neutral'>        }</span>
  439 |     | <span class='neutral'></span>
  440 | *   | <span class='executed'>        if (_isDebtIncrease) {</span>
  441 | *   | <span class='executed'>            _troveChange.debtIncrease = _boldChange;</span>
  442 |     | <span class='neutral'>        } else {</span>
  443 | *   | <span class='executed'>            _troveChange.debtDecrease = _boldChange;</span>
  444 |     | <span class='neutral'>        }</span>
  445 |     | <span class='neutral'>    }</span>
  446 |     | <span class='neutral'></span>
  447 | *   | <span class='executed'>    function adjustTrove(</span>
  448 |     | <span class='neutral'>        uint256 _troveId,</span>
  449 |     | <span class='neutral'>        uint256 _collChange,</span>
  450 |     | <span class='neutral'>        bool _isCollIncrease,</span>
  451 |     | <span class='neutral'>        uint256 _boldChange,</span>
  452 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
  453 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
  454 | *   | <span class='executed'>    ) external override {</span>
  455 | *   | <span class='executed'>        ITroveManager troveManagerCached = troveManager;</span>
  456 | *   | <span class='executed'>        _requireTroveIsActive(troveManagerCached, _troveId);</span>
  457 |     | <span class='neutral'></span>
  458 | *   | <span class='executed'>        TroveChange memory troveChange;</span>
  459 | *   | <span class='executed'>        _initTroveChange(troveChange, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease);</span>
  460 | *   | <span class='executed'>        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);</span>
  461 |     | <span class='neutral'>    }</span>
  462 |     | <span class='neutral'></span>
  463 | *   | <span class='executed'>    function adjustZombieTrove(</span>
  464 |     | <span class='neutral'>        uint256 _troveId,</span>
  465 |     | <span class='neutral'>        uint256 _collChange,</span>
  466 |     | <span class='neutral'>        bool _isCollIncrease,</span>
  467 |     | <span class='neutral'>        uint256 _boldChange,</span>
  468 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
  469 |     | <span class='neutral'>        uint256 _upperHint,</span>
  470 |     | <span class='neutral'>        uint256 _lowerHint,</span>
  471 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
  472 |     | <span class='neutral'>    ) external override {</span>
  473 | *   | <span class='executed'>        ITroveManager troveManagerCached = troveManager;</span>
  474 | *   | <span class='executed'>        _requireTroveIsZombie(troveManagerCached, _troveId);</span>
  475 |     | <span class='neutral'></span>
  476 | *   | <span class='executed'>        TroveChange memory troveChange;</span>
  477 | *   | <span class='executed'>        _initTroveChange(troveChange, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease);</span>
  478 | *   | <span class='executed'>        _adjustTrove(troveManagerCached, _troveId, troveChange, _maxUpfrontFee);</span>
  479 |     | <span class='neutral'></span>
  480 | *   | <span class='executed'>        troveManagerCached.setTroveStatusToActive(_troveId);</span>
  481 |     | <span class='neutral'></span>
  482 | *   | <span class='executed'>        address batchManager = interestBatchManagerOf[_troveId];</span>
  483 |     | <span class='neutral'>        uint256 batchAnnualInterestRate;</span>
  484 | *   | <span class='executed'>        if (batchManager != address(0)) {</span>
  485 | *   | <span class='executed'>            LatestBatchData memory batch = troveManagerCached.getLatestBatchData(batchManager);</span>
  486 | *   | <span class='executed'>            batchAnnualInterestRate = batch.annualInterestRate;</span>
  487 |     | <span class='neutral'>        }</span>
  488 | *   | <span class='executed'>        _reInsertIntoSortedTroves(</span>
  489 | *   | <span class='executed'>            _troveId,</span>
  490 | *   | <span class='executed'>            troveManagerCached.getTroveAnnualInterestRate(_troveId),</span>
  491 | *   | <span class='executed'>            _upperHint,</span>
  492 | *   | <span class='executed'>            _lowerHint,</span>
  493 | *   | <span class='executed'>            batchManager,</span>
  494 | *   | <span class='executed'>            batchAnnualInterestRate</span>
  495 |     | <span class='neutral'>        );</span>
  496 |     | <span class='neutral'>    }</span>
  497 |     | <span class='neutral'></span>
  498 | *   | <span class='executed'>    function adjustTroveInterestRate(</span>
  499 |     | <span class='neutral'>        uint256 _troveId,</span>
  500 |     | <span class='neutral'>        uint256 _newAnnualInterestRate,</span>
  501 |     | <span class='neutral'>        uint256 _upperHint,</span>
  502 |     | <span class='neutral'>        uint256 _lowerHint,</span>
  503 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
  504 | *   | <span class='executed'>    ) external {</span>
  505 | *   | <span class='executed'>        _requireIsNotShutDown();</span>
  506 |     | <span class='neutral'></span>
  507 | *   | <span class='executed'>        ITroveManager troveManagerCached = troveManager;</span>
  508 |     | <span class='neutral'></span>
  509 | *   | <span class='executed'>        _requireValidAnnualInterestRate(_newAnnualInterestRate);</span>
  510 | *   | <span class='executed'>        _requireIsNotInBatch(_troveId);</span>
  511 | *   | <span class='executed'>        _requireSenderIsOwnerOrInterestManager(_troveId);</span>
  512 | *   | <span class='executed'>        _requireTroveIsActive(troveManagerCached, _troveId);</span>
  513 |     | <span class='neutral'></span>
  514 | *   | <span class='executed'>        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);</span>
  515 | *   | <span class='executed'>        _requireValidDelegateAdustment(_troveId, trove.lastInterestRateAdjTime, _newAnnualInterestRate);</span>
  516 | *   | <span class='executed'>        _requireAnnualInterestRateIsNew(trove.annualInterestRate, _newAnnualInterestRate);</span>
  517 |     | <span class='neutral'></span>
  518 | *   | <span class='executed'>        uint256 newDebt = trove.entireDebt;</span>
  519 |     | <span class='neutral'></span>
  520 | *   | <span class='executed'>        TroveChange memory troveChange;</span>
  521 | *   | <span class='executed'>        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;</span>
  522 | *   | <span class='executed'>        troveChange.appliedRedistCollGain = trove.redistCollGain;</span>
  523 | *   | <span class='executed'>        troveChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;</span>
  524 | *   | <span class='executed'>        troveChange.oldWeightedRecordedDebt = trove.weightedRecordedDebt;</span>
  525 |     | <span class='neutral'></span>
  526 |     | <span class='neutral'>        // Apply upfront fee on premature adjustments</span>
  527 | *   | <span class='executed'>        if (</span>
  528 | *   | <span class='executed'>            trove.annualInterestRate != _newAnnualInterestRate</span>
  529 | *   | <span class='executed'>                &amp;&amp; block.timestamp &lt; trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN</span>
  530 |     | <span class='neutral'>        ) {</span>
  531 |     | <span class='unexecuted'>            newDebt = _applyUpfrontFee(trove.entireColl, newDebt, troveChange, _maxUpfrontFee);</span>
  532 |     | <span class='neutral'>        }</span>
  533 |     | <span class='neutral'></span>
  534 |     | <span class='neutral'>        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee</span>
  535 | *   | <span class='executed'>        troveChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;</span>
  536 |     | <span class='neutral'></span>
  537 | *   | <span class='executed'>        activePool.mintAggInterestAndAccountForTroveChange(troveChange, address(0));</span>
  538 |     | <span class='neutral'></span>
  539 | *   | <span class='executed'>        sortedTroves.reInsert(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint);</span>
  540 | *   | <span class='executed'>        troveManagerCached.onAdjustTroveInterestRate(</span>
  541 | *   | <span class='executed'>            _troveId, trove.entireColl, newDebt, _newAnnualInterestRate, troveChange</span>
  542 |     | <span class='neutral'>        );</span>
  543 |     | <span class='neutral'>    }</span>
  544 |     | <span class='neutral'></span>
  545 |     | <span class='neutral'>    /*</span>
  546 |     | <span class='neutral'>    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.</span>
  547 |     | <span class='neutral'>    */</span>
  548 | *   | <span class='executed'>    function _adjustTrove(</span>
  549 |     | <span class='neutral'>        ITroveManager _troveManager,</span>
  550 |     | <span class='neutral'>        uint256 _troveId,</span>
  551 |     | <span class='neutral'>        TroveChange memory _troveChange,</span>
  552 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
  553 |     | <span class='neutral'>    ) internal {</span>
  554 | *   | <span class='executed'>        _requireIsNotShutDown();</span>
  555 |     | <span class='neutral'></span>
  556 | *   | <span class='executed'>        LocalVariables_adjustTrove memory vars;</span>
  557 | *   | <span class='executed'>        vars.activePool = activePool;</span>
  558 | *   | <span class='executed'>        vars.boldToken = boldToken;</span>
  559 |     | <span class='neutral'></span>
  560 | *   | <span class='executed'>        vars.price = _requireOraclesLive();</span>
  561 | *   | <span class='executed'>        vars.isBelowCriticalThreshold = _checkBelowCriticalThreshold(vars.price, CCR);</span>
  562 |     | <span class='neutral'></span>
  563 |     | <span class='neutral'>        // --- Checks ---</span>
  564 |     | <span class='neutral'></span>
  565 | *   | <span class='executed'>        _requireTroveIsOpen(_troveManager, _troveId);</span>
  566 |     | <span class='neutral'></span>
  567 | *   | <span class='executed'>        address owner = troveNFT.ownerOf(_troveId);</span>
  568 |     | <span class='neutral'>        address receiver = owner; // If it’s a withdrawal, and manager has receive privilege, manager would be the receiver</span>
  569 |     | <span class='neutral'></span>
  570 | *   | <span class='executed'>        if (_troveChange.collDecrease &gt; 0 || _troveChange.debtIncrease &gt; 0) {</span>
  571 | *   | <span class='executed'>            receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);</span>
  572 |     | <span class='neutral'>        }</span>
  573 |     | <span class='neutral'></span>
  574 | *   | <span class='executed'>        if (_troveChange.collIncrease &gt; 0 || _troveChange.debtDecrease &gt; 0) {</span>
  575 | *   | <span class='executed'>            _requireSenderIsOwnerOrAddManager(_troveId, owner);</span>
  576 |     | <span class='neutral'>        }</span>
  577 |     | <span class='neutral'></span>
  578 | *   | <span class='executed'>        vars.trove = _troveManager.getLatestTroveData(_troveId);</span>
  579 |     | <span class='neutral'></span>
  580 |     | <span class='neutral'>        // When the adjustment is a debt repayment, check it&#39;s a valid amount and that the caller has enough Bold</span>
  581 | *   | <span class='executed'>        if (_troveChange.debtDecrease &gt; 0) {</span>
  582 | *   | <span class='executed'>            uint256 maxRepayment = vars.trove.entireDebt &gt; MIN_DEBT ? vars.trove.entireDebt - MIN_DEBT : 0;</span>
  583 | *   | <span class='executed'>            if (_troveChange.debtDecrease &gt; maxRepayment) {</span>
  584 | *   | <span class='executed'>                _troveChange.debtDecrease = maxRepayment;</span>
  585 |     | <span class='neutral'>            }</span>
  586 | *   | <span class='executed'>            _requireSufficientBoldBalance(vars.boldToken, msg.sender, _troveChange.debtDecrease);</span>
  587 |     | <span class='neutral'>        }</span>
  588 |     | <span class='neutral'></span>
  589 | *   | <span class='executed'>        _requireNonZeroAdjustment(_troveChange);</span>
  590 |     | <span class='neutral'></span>
  591 |     | <span class='neutral'>        // When the adjustment is a collateral withdrawal, check that it&#39;s no more than the Trove&#39;s entire collateral</span>
  592 | *   | <span class='executed'>        if (_troveChange.collDecrease &gt; 0) {</span>
  593 | *   | <span class='executed'>            _requireValidCollWithdrawal(vars.trove.entireColl, _troveChange.collDecrease);</span>
  594 |     | <span class='neutral'>        }</span>
  595 |     | <span class='neutral'></span>
  596 | *   | <span class='executed'>        vars.newColl = vars.trove.entireColl + _troveChange.collIncrease - _troveChange.collDecrease;</span>
  597 | *   | <span class='executed'>        vars.newDebt = vars.trove.entireDebt + _troveChange.debtIncrease - _troveChange.debtDecrease;</span>
  598 |     | <span class='neutral'></span>
  599 | *   | <span class='executed'>        address batchManager = interestBatchManagerOf[_troveId];</span>
  600 | *   | <span class='executed'>        bool isTroveInBatch = batchManager != address(0);</span>
  601 | *   | <span class='executed'>        LatestBatchData memory batch;</span>
  602 | *   | <span class='executed'>        uint256 batchFutureDebt;</span>
  603 | *   | <span class='executed'>        if (isTroveInBatch) {</span>
  604 | *   | <span class='executed'>            batch = _troveManager.getLatestBatchData(batchManager);</span>
  605 |     | <span class='neutral'></span>
  606 | *   | <span class='executed'>            batchFutureDebt = batch.entireDebtWithoutRedistribution + vars.trove.redistBoldDebtGain</span>
  607 | *   | <span class='executed'>                + _troveChange.debtIncrease - _troveChange.debtDecrease;</span>
  608 |     | <span class='neutral'></span>
  609 | *   | <span class='executed'>            _troveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;</span>
  610 | *   | <span class='executed'>            _troveChange.appliedRedistCollGain = vars.trove.redistCollGain;</span>
  611 | *   | <span class='executed'>            _troveChange.batchAccruedManagementFee = batch.accruedManagementFee;</span>
  612 | *   | <span class='executed'>            _troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;</span>
  613 | *   | <span class='executed'>            _troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;</span>
  614 | *   | <span class='executed'>            _troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;</span>
  615 | *   | <span class='executed'>            _troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;</span>
  616 |     | <span class='neutral'>        } else {</span>
  617 | *   | <span class='executed'>            _troveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;</span>
  618 | *   | <span class='executed'>            _troveChange.appliedRedistCollGain = vars.trove.redistCollGain;</span>
  619 | *   | <span class='executed'>            _troveChange.oldWeightedRecordedDebt = vars.trove.weightedRecordedDebt;</span>
  620 | *   | <span class='executed'>            _troveChange.newWeightedRecordedDebt = vars.newDebt * vars.trove.annualInterestRate;</span>
  621 |     | <span class='neutral'>        }</span>
  622 |     | <span class='neutral'></span>
  623 |     | <span class='neutral'>        // Pay an upfront fee on debt increases</span>
  624 | *   | <span class='executed'>        if (_troveChange.debtIncrease &gt; 0) {</span>
  625 | *   | <span class='executed'>            uint256 avgInterestRate = vars.activePool.getNewApproxAvgInterestRateFromTroveChange(_troveChange);</span>
  626 | *   | <span class='executed'>            _troveChange.upfrontFee = _calcUpfrontFee(_troveChange.debtIncrease, avgInterestRate);</span>
  627 | *   | <span class='executed'>            _requireUserAcceptsUpfrontFee(_troveChange.upfrontFee, _maxUpfrontFee);</span>
  628 |     | <span class='neutral'></span>
  629 | *   | <span class='executed'>            vars.newDebt += _troveChange.upfrontFee;</span>
  630 | *   | <span class='executed'>            if (isTroveInBatch) {</span>
  631 | *   | <span class='executed'>                batchFutureDebt += _troveChange.upfrontFee;</span>
  632 |     | <span class='neutral'>                // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee</span>
  633 | *   | <span class='executed'>                _troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;</span>
  634 | *   | <span class='executed'>                _troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;</span>
  635 |     | <span class='neutral'>            } else {</span>
  636 |     | <span class='neutral'>                // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee</span>
  637 | *   | <span class='executed'>                _troveChange.newWeightedRecordedDebt = vars.newDebt * vars.trove.annualInterestRate;</span>
  638 |     | <span class='neutral'>            }</span>
  639 |     | <span class='neutral'>        }</span>
  640 |     | <span class='neutral'></span>
  641 |     | <span class='neutral'>        // Make sure the Trove doesn&#39;t end up zombie</span>
  642 |     | <span class='neutral'>        // Now the max repayment is capped to stay above MIN_DEBT, so this only applies to adjustZombieTrove</span>
  643 | *   | <span class='executed'>        _requireAtLeastMinDebt(vars.newDebt);</span>
  644 |     | <span class='neutral'></span>
  645 | *   | <span class='executed'>        vars.newICR = LiquityMath._computeCR(vars.newColl, vars.newDebt, vars.price);</span>
  646 |     | <span class='neutral'></span>
  647 |     | <span class='neutral'>        // Check the adjustment satisfies all conditions for the current system mode</span>
  648 | *   | <span class='executed'>        _requireValidAdjustmentInCurrentMode(_troveChange, vars);</span>
  649 |     | <span class='neutral'></span>
  650 |     | <span class='neutral'>        // --- Effects and interactions ---</span>
  651 |     | <span class='neutral'></span>
  652 | *   | <span class='executed'>        if (isTroveInBatch) {</span>
  653 | *   | <span class='executed'>            _troveManager.onAdjustTroveInsideBatch(</span>
  654 | *   | <span class='executed'>                _troveId,</span>
  655 | *   | <span class='executed'>                vars.newColl,</span>
  656 | *   | <span class='executed'>                vars.newDebt,</span>
  657 | *   | <span class='executed'>                _troveChange,</span>
  658 | *   | <span class='executed'>                batchManager,</span>
  659 | *   | <span class='executed'>                batch.entireCollWithoutRedistribution,</span>
  660 | *   | <span class='executed'>                batch.entireDebtWithoutRedistribution</span>
  661 |     | <span class='neutral'>            );</span>
  662 |     | <span class='neutral'>        } else {</span>
  663 | *   | <span class='executed'>            _troveManager.onAdjustTrove(_troveId, vars.newColl, vars.newDebt, _troveChange);</span>
  664 |     | <span class='neutral'>        }</span>
  665 |     | <span class='neutral'></span>
  666 | *   | <span class='executed'>        vars.activePool.mintAggInterestAndAccountForTroveChange(_troveChange, batchManager);</span>
  667 | *   | <span class='executed'>        _moveTokensFromAdjustment(receiver, _troveChange, vars.boldToken, vars.activePool);</span>
  668 |     | <span class='neutral'>    }</span>
  669 |     | <span class='neutral'></span>
  670 | *   | <span class='executed'>    function closeTrove(uint256 _troveId) external override {</span>
  671 | *   | <span class='executed'>        ITroveManager troveManagerCached = troveManager;</span>
  672 | *   | <span class='executed'>        IActivePool activePoolCached = activePool;</span>
  673 | *   | <span class='executed'>        IBoldToken boldTokenCached = boldToken;</span>
  674 |     | <span class='neutral'></span>
  675 |     | <span class='neutral'>        // --- Checks ---</span>
  676 |     | <span class='neutral'></span>
  677 | *   | <span class='executed'>        address owner = troveNFT.ownerOf(_troveId);</span>
  678 | *   | <span class='executed'>        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);</span>
  679 | *   | <span class='executed'>        _requireTroveIsOpen(troveManagerCached, _troveId);</span>
  680 |     | <span class='neutral'></span>
  681 | *   | <span class='executed'>        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);</span>
  682 |     | <span class='neutral'></span>
  683 |     | <span class='neutral'>        // The borrower must repay their entire debt including accrued interest, batch fee and redist. gains</span>
  684 | *   | <span class='executed'>        _requireSufficientBoldBalance(boldTokenCached, msg.sender, trove.entireDebt);</span>
  685 |     | <span class='neutral'></span>
  686 |     | <span class='unexecuted'>        TroveChange memory troveChange;</span>
  687 |     | <span class='unexecuted'>        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;</span>
  688 |     | <span class='unexecuted'>        troveChange.appliedRedistCollGain = trove.redistCollGain;</span>
  689 |     | <span class='unexecuted'>        troveChange.collDecrease = trove.entireColl;</span>
  690 |     | <span class='unexecuted'>        troveChange.debtDecrease = trove.entireDebt;</span>
  691 |     | <span class='neutral'></span>
  692 |     | <span class='unexecuted'>        address batchManager = interestBatchManagerOf[_troveId];</span>
  693 |     | <span class='unexecuted'>        LatestBatchData memory batch;</span>
  694 |     | <span class='unexecuted'>        if (batchManager != address(0)) {</span>
  695 |     | <span class='unexecuted'>            batch = troveManagerCached.getLatestBatchData(batchManager);</span>
  696 |     | <span class='unexecuted'>            uint256 batchFutureDebt =</span>
  697 |     | <span class='unexecuted'>                batch.entireDebtWithoutRedistribution - (trove.entireDebt - trove.redistBoldDebtGain);</span>
  698 |     | <span class='unexecuted'>            troveChange.batchAccruedManagementFee = batch.accruedManagementFee;</span>
  699 |     | <span class='unexecuted'>            troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;</span>
  700 |     | <span class='unexecuted'>            troveChange.newWeightedRecordedDebt = batchFutureDebt * batch.annualInterestRate;</span>
  701 |     | <span class='unexecuted'>            troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;</span>
  702 |     | <span class='unexecuted'>            troveChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * batch.annualManagementFee;</span>
  703 |     | <span class='neutral'>        } else {</span>
  704 |     | <span class='unexecuted'>            troveChange.oldWeightedRecordedDebt = trove.weightedRecordedDebt;</span>
  705 |     | <span class='neutral'>            // troveChange.newWeightedRecordedDebt = 0;</span>
  706 |     | <span class='neutral'>        }</span>
  707 |     | <span class='neutral'></span>
  708 |     | <span class='unexecuted'>        (uint256 price,) = priceFeed.fetchPrice();</span>
  709 |     | <span class='unexecuted'>        uint256 newTCR = _getNewTCRFromTroveChange(troveChange, price);</span>
  710 |     | <span class='unexecuted'>        if (!hasBeenShutDown) _requireNewTCRisAboveCCR(newTCR);</span>
  711 |     | <span class='neutral'></span>
  712 |     | <span class='unexecuted'>        troveManagerCached.onCloseTrove(</span>
  713 |     | <span class='unexecuted'>            _troveId,</span>
  714 |     | <span class='unexecuted'>            troveChange,</span>
  715 |     | <span class='unexecuted'>            batchManager,</span>
  716 |     | <span class='unexecuted'>            batch.entireCollWithoutRedistribution,</span>
  717 |     | <span class='unexecuted'>            batch.entireDebtWithoutRedistribution</span>
  718 |     | <span class='neutral'>        );</span>
  719 |     | <span class='neutral'></span>
  720 |     | <span class='neutral'>        // If trove is in batch</span>
  721 |     | <span class='unexecuted'>        if (batchManager != address(0)) {</span>
  722 |     | <span class='neutral'>            // Unlink here in BorrowerOperations</span>
  723 |     | <span class='unexecuted'>            interestBatchManagerOf[_troveId] = address(0);</span>
  724 |     | <span class='neutral'>        }</span>
  725 |     | <span class='neutral'></span>
  726 |     | <span class='unexecuted'>        activePoolCached.mintAggInterestAndAccountForTroveChange(troveChange, batchManager);</span>
  727 |     | <span class='neutral'></span>
  728 |     | <span class='neutral'>        // Return ETH gas compensation</span>
  729 |     | <span class='unexecuted'>        WETH.transferFrom(gasPoolAddress, receiver, ETH_GAS_COMPENSATION);</span>
  730 |     | <span class='neutral'>        // Burn the remainder of the Trove&#39;s entire debt from the user</span>
  731 |     | <span class='unexecuted'>        boldTokenCached.burn(msg.sender, trove.entireDebt);</span>
  732 |     | <span class='neutral'></span>
  733 |     | <span class='neutral'>        // Send the collateral back to the user</span>
  734 |     | <span class='unexecuted'>        activePoolCached.sendColl(receiver, trove.entireColl);</span>
  735 |     | <span class='neutral'></span>
  736 | *   | <span class='executed'>        _wipeTroveMappings(_troveId);</span>
  737 |     | <span class='neutral'>    }</span>
  738 |     | <span class='neutral'></span>
  739 | *   | <span class='executed'>    function applyPendingDebt(uint256 _troveId, uint256 _lowerHint, uint256 _upperHint) public {</span>
  740 | *   | <span class='executed'>        _requireIsNotShutDown();</span>
  741 |     | <span class='neutral'></span>
  742 | *   | <span class='executed'>        ITroveManager troveManagerCached = troveManager;</span>
  743 |     | <span class='neutral'></span>
  744 | *   | <span class='executed'>        _requireTroveIsOpen(troveManagerCached, _troveId);</span>
  745 |     | <span class='neutral'></span>
  746 | *   | <span class='executed'>        LatestTroveData memory trove = troveManagerCached.getLatestTroveData(_troveId);</span>
  747 | *   | <span class='executed'>        _requireNonZeroDebt(trove.entireDebt);</span>
  748 |     | <span class='neutral'></span>
  749 | *   | <span class='executed'>        TroveChange memory change;</span>
  750 | *   | <span class='executed'>        change.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;</span>
  751 | *   | <span class='executed'>        change.appliedRedistCollGain = trove.redistCollGain;</span>
  752 |     | <span class='neutral'></span>
  753 | *   | <span class='executed'>        address batchManager = interestBatchManagerOf[_troveId];</span>
  754 | *   | <span class='executed'>        LatestBatchData memory batch;</span>
  755 |     | <span class='neutral'></span>
  756 | *   | <span class='executed'>        if (batchManager == address(0)) {</span>
  757 | *   | <span class='executed'>            change.oldWeightedRecordedDebt = trove.weightedRecordedDebt;</span>
  758 | *   | <span class='executed'>            change.newWeightedRecordedDebt = trove.entireDebt * trove.annualInterestRate;</span>
  759 |     | <span class='neutral'>        } else {</span>
  760 | *   | <span class='executed'>            batch = troveManagerCached.getLatestBatchData(batchManager);</span>
  761 | *   | <span class='executed'>            change.batchAccruedManagementFee = batch.accruedManagementFee;</span>
  762 | *   | <span class='executed'>            change.oldWeightedRecordedDebt = batch.weightedRecordedDebt;</span>
  763 | *   | <span class='executed'>            change.newWeightedRecordedDebt =</span>
  764 | *   | <span class='executed'>                (batch.entireDebtWithoutRedistribution + trove.redistBoldDebtGain) * batch.annualInterestRate;</span>
  765 | *   | <span class='executed'>            change.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;</span>
  766 | *   | <span class='executed'>            change.newWeightedRecordedBatchManagementFee =</span>
  767 | *   | <span class='executed'>                (batch.entireDebtWithoutRedistribution + trove.redistBoldDebtGain) * batch.annualManagementFee;</span>
  768 |     | <span class='neutral'>        }</span>
  769 |     | <span class='neutral'></span>
  770 | *   | <span class='executed'>        troveManagerCached.onApplyTroveInterest(</span>
  771 | *   | <span class='executed'>            _troveId,</span>
  772 | *   | <span class='executed'>            trove.entireColl,</span>
  773 | *   | <span class='executed'>            trove.entireDebt,</span>
  774 | *   | <span class='executed'>            batchManager,</span>
  775 | *   | <span class='executed'>            batch.entireCollWithoutRedistribution,</span>
  776 | *   | <span class='executed'>            batch.entireDebtWithoutRedistribution,</span>
  777 | *   | <span class='executed'>            change</span>
  778 |     | <span class='neutral'>        );</span>
  779 | *   | <span class='executed'>        activePool.mintAggInterestAndAccountForTroveChange(change, batchManager);</span>
  780 |     | <span class='neutral'></span>
  781 |     | <span class='neutral'>        // If the trove was zombie, and now it’s not anymore, put it back in the list</span>
  782 | *   | <span class='executed'>        if (_checkTroveIsZombie(troveManagerCached, _troveId) &amp;&amp; trove.entireDebt &gt;= MIN_DEBT) {</span>
  783 |     | <span class='unexecuted'>            troveManagerCached.setTroveStatusToActive(_troveId);</span>
  784 |     | <span class='unexecuted'>            _reInsertIntoSortedTroves(</span>
  785 |     | <span class='unexecuted'>                _troveId, trove.annualInterestRate, _upperHint, _lowerHint, batchManager, batch.annualInterestRate</span>
  786 |     | <span class='neutral'>            );</span>
  787 |     | <span class='neutral'>        }</span>
  788 |     | <span class='neutral'>    }</span>
  789 |     | <span class='neutral'></span>
  790 |     | <span class='unexecuted'>    function getInterestIndividualDelegateOf(uint256 _troveId)</span>
  791 |     | <span class='neutral'>        external</span>
  792 |     | <span class='neutral'>        view</span>
  793 |     | <span class='neutral'>        returns (InterestIndividualDelegate memory)</span>
  794 |     | <span class='neutral'>    {</span>
  795 |     | <span class='unexecuted'>        return interestIndividualDelegateOf[_troveId];</span>
  796 |     | <span class='neutral'>    }</span>
  797 |     | <span class='neutral'></span>
  798 | *   | <span class='executed'>    function setInterestIndividualDelegate(</span>
  799 |     | <span class='neutral'>        uint256 _troveId,</span>
  800 |     | <span class='neutral'>        address _delegate,</span>
  801 |     | <span class='neutral'>        uint128 _minInterestRate,</span>
  802 |     | <span class='neutral'>        uint128 _maxInterestRate,</span>
  803 |     | <span class='neutral'>        // only needed if trove was previously in a batch:</span>
  804 |     | <span class='neutral'>        uint256 _newAnnualInterestRate,</span>
  805 |     | <span class='neutral'>        uint256 _upperHint,</span>
  806 |     | <span class='neutral'>        uint256 _lowerHint,</span>
  807 |     | <span class='neutral'>        uint256 _maxUpfrontFee,</span>
  808 |     | <span class='neutral'>        uint256 _minInterestRateChangePeriod</span>
  809 |     | <span class='neutral'>    ) external {</span>
  810 | *   | <span class='executed'>        _requireIsNotShutDown();</span>
  811 | *   | <span class='executed'>        _requireTroveIsActive(troveManager, _troveId);</span>
  812 | *   | <span class='executed'>        _requireCallerIsBorrower(_troveId);</span>
  813 | *   | <span class='executed'>        _requireValidAnnualInterestRate(_minInterestRate);</span>
  814 | *   | <span class='executed'>        _requireValidAnnualInterestRate(_maxInterestRate);</span>
  815 |     | <span class='neutral'>        // With the check below, it could only be ==</span>
  816 | *   | <span class='executed'>        _requireOrderedRange(_minInterestRate, _maxInterestRate);</span>
  817 |     | <span class='neutral'></span>
  818 | *   | <span class='executed'>        interestIndividualDelegateOf[_troveId] =</span>
  819 | *   | <span class='executed'>            InterestIndividualDelegate(_delegate, _minInterestRate, _maxInterestRate, _minInterestRateChangePeriod);</span>
  820 |     | <span class='neutral'>        // Can’t have both individual delegation and batch manager</span>
  821 | *   | <span class='executed'>        if (interestBatchManagerOf[_troveId] != address(0)) {</span>
  822 |     | <span class='neutral'>            // Not needed, implicitly checked in removeFromBatch</span>
  823 |     | <span class='neutral'>            //_requireValidAnnualInterestRate(_newAnnualInterestRate);</span>
  824 | *   | <span class='executed'>            removeFromBatch(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint, _maxUpfrontFee);</span>
  825 |     | <span class='neutral'>        }</span>
  826 |     | <span class='neutral'>    }</span>
  827 |     | <span class='neutral'></span>
  828 | *   | <span class='executed'>    function removeInterestIndividualDelegate(uint256 _troveId) external {</span>
  829 | *   | <span class='executed'>        _requireCallerIsBorrower(_troveId);</span>
  830 | *   | <span class='executed'>        delete interestIndividualDelegateOf[_troveId];</span>
  831 |     | <span class='neutral'>    }</span>
  832 |     | <span class='neutral'></span>
  833 | *   | <span class='executed'>    function getInterestBatchManager(address _account) external view returns (InterestBatchManager memory) {</span>
  834 | *   | <span class='executed'>        return interestBatchManagers[_account];</span>
  835 |     | <span class='neutral'>    }</span>
  836 |     | <span class='neutral'></span>
  837 | *   | <span class='executed'>    function registerBatchManager( //wait no access contol ?</span>
  838 |     | <span class='neutral'>        uint128 _minInterestRate,</span>
  839 |     | <span class='neutral'>        uint128 _maxInterestRate,</span>
  840 |     | <span class='neutral'>        uint128 _currentInterestRate,</span>
  841 |     | <span class='neutral'>        uint128 _annualManagementFee,</span>
  842 |     | <span class='neutral'>        uint128 _minInterestRateChangePeriod</span>
  843 |     | <span class='neutral'>    ) external {</span>
  844 | *   | <span class='executed'>        _requireIsNotShutDown();</span>
  845 | *   | <span class='executed'>        _requireNonExistentInterestBatchManager(msg.sender);</span>
  846 | *   | <span class='executed'>        _requireValidAnnualInterestRate(_minInterestRate);</span>
  847 | *   | <span class='executed'>        _requireValidAnnualInterestRate(_maxInterestRate);</span>
  848 |     | <span class='neutral'>        // With the check below, it could only be ==</span>
  849 | *   | <span class='executed'>        _requireOrderedRange(_minInterestRate, _maxInterestRate);</span>
  850 | *   | <span class='executed'>        _requireInterestRateInRange(_currentInterestRate, _minInterestRate, _maxInterestRate);</span>
  851 |     | <span class='neutral'>        // Not needed, implicitly checked in the condition above:</span>
  852 |     | <span class='neutral'>        //_requireValidAnnualInterestRate(_currentInterestRate);</span>
  853 | *   | <span class='executed'>        if (_annualManagementFee &gt; MAX_ANNUAL_BATCH_MANAGEMENT_FEE) revert AnnualManagementFeeTooHigh();</span>
  854 | *   | <span class='executed'>        if (_minInterestRateChangePeriod &lt; MIN_INTEREST_RATE_CHANGE_PERIOD) revert MinInterestRateChangePeriodTooLow();</span>
  855 |     | <span class='neutral'></span>
  856 | *   | <span class='executed'>        interestBatchManagers[msg.sender] =</span>
  857 | *   | <span class='executed'>            InterestBatchManager(_minInterestRate, _maxInterestRate, _minInterestRateChangePeriod);</span>
  858 |     | <span class='neutral'></span>
  859 | *   | <span class='executed'>        troveManager.onRegisterBatchManager(msg.sender, _currentInterestRate, _annualManagementFee);</span>
  860 |     | <span class='neutral'>    }</span>
  861 |     | <span class='neutral'></span>
  862 | *   | <span class='executed'>    function lowerBatchManagementFee(uint256 _newAnnualManagementFee) external {</span>
  863 | *   | <span class='executed'>        _requireIsNotShutDown();</span>
  864 | *   | <span class='executed'>        _requireValidInterestBatchManager(msg.sender);</span>
  865 |     | <span class='neutral'></span>
  866 | *   | <span class='executed'>        ITroveManager troveManagerCached = troveManager;</span>
  867 |     | <span class='neutral'></span>
  868 | *   | <span class='executed'>        LatestBatchData memory batch = troveManagerCached.getLatestBatchData(msg.sender);</span>
  869 | *   | <span class='executed'>        if (_newAnnualManagementFee &gt;= batch.annualManagementFee) {</span>
  870 | *   | <span class='executed'>            revert NewFeeNotLower();</span>
  871 |     | <span class='neutral'>        }</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>        // Lower batch fee on TM</span>
  874 | *   | <span class='executed'>        troveManagerCached.onLowerBatchManagerAnnualFee(</span>
  875 | *   | <span class='executed'>            msg.sender,</span>
  876 | *   | <span class='executed'>            batch.entireCollWithoutRedistribution,</span>
  877 | *   | <span class='executed'>            batch.entireDebtWithoutRedistribution,</span>
  878 |     | <span class='neutral'>            _newAnnualManagementFee</span>
  879 |     | <span class='neutral'>        );</span>
  880 |     | <span class='neutral'></span>
  881 |     | <span class='neutral'>        // active pool mint</span>
  882 | *   | <span class='executed'>        TroveChange memory batchChange;</span>
  883 | *   | <span class='executed'>        batchChange.batchAccruedManagementFee = batch.accruedManagementFee;</span>
  884 | *   | <span class='executed'>        batchChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;</span>
  885 | *   | <span class='executed'>        batchChange.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;</span>
  886 | *   | <span class='executed'>        batchChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;</span>
  887 | *   | <span class='executed'>        batchChange.newWeightedRecordedBatchManagementFee =</span>
  888 | *   | <span class='executed'>            batch.entireDebtWithoutRedistribution * _newAnnualManagementFee;</span>
  889 |     | <span class='neutral'></span>
  890 | *   | <span class='executed'>        activePool.mintAggInterestAndAccountForTroveChange(batchChange, msg.sender);</span>
  891 |     | <span class='neutral'>    }</span>
  892 |     | <span class='neutral'></span>
  893 | *   | <span class='executed'>    function setBatchManagerAnnualInterestRate(</span>
  894 |     | <span class='neutral'>        uint128 _newAnnualInterestRate,</span>
  895 |     | <span class='neutral'>        uint256 _upperHint,</span>
  896 |     | <span class='neutral'>        uint256 _lowerHint,</span>
  897 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
  898 |     | <span class='neutral'>    ) external {</span>
  899 | *   | <span class='executed'>        _requireIsNotShutDown();</span>
  900 | *   | <span class='executed'>        _requireValidInterestBatchManager(msg.sender);</span>
  901 | *   | <span class='executed'>        _requireInterestRateInBatchManagerRange(msg.sender, _newAnnualInterestRate);</span>
  902 |     | <span class='neutral'>        // Not needed, implicitly checked in the condition above:</span>
  903 |     | <span class='neutral'>        //_requireValidAnnualInterestRate(_newAnnualInterestRate);</span>
  904 |     | <span class='neutral'></span>
  905 | *   | <span class='executed'>        ITroveManager troveManagerCached = troveManager;</span>
  906 | *   | <span class='executed'>        IActivePool activePoolCached = activePool;</span>
  907 |     | <span class='neutral'></span>
  908 | *   | <span class='executed'>        LatestBatchData memory batch = troveManagerCached.getLatestBatchData(msg.sender);</span>
  909 | *   | <span class='executed'>        _requireBatchInterestRateChangePeriodPassed(msg.sender, uint256(batch.lastInterestRateAdjTime));</span>
  910 |     | <span class='neutral'></span>
  911 |     | <span class='unexecuted'>        uint256 newDebt = batch.entireDebtWithoutRedistribution;</span>
  912 |     | <span class='neutral'></span>
  913 |     | <span class='unexecuted'>        TroveChange memory batchChange;</span>
  914 |     | <span class='unexecuted'>        batchChange.batchAccruedManagementFee = batch.accruedManagementFee;</span>
  915 |     | <span class='unexecuted'>        batchChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;</span>
  916 |     | <span class='unexecuted'>        batchChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;</span>
  917 |     | <span class='unexecuted'>        batchChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;</span>
  918 |     | <span class='unexecuted'>        batchChange.newWeightedRecordedBatchManagementFee = newDebt * batch.annualManagementFee;</span>
  919 |     | <span class='neutral'></span>
  920 |     | <span class='neutral'>        // Apply upfront fee on premature adjustments</span>
  921 |     | <span class='unexecuted'>        if (</span>
  922 |     | <span class='unexecuted'>            batch.annualInterestRate != _newAnnualInterestRate</span>
  923 |     | <span class='unexecuted'>                &amp;&amp; block.timestamp &lt; batch.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN</span>
  924 |     | <span class='unexecuted'>        ) {</span>
  925 |     | <span class='unexecuted'>            uint256 price = _requireOraclesLive();</span>
  926 |     | <span class='neutral'></span>
  927 |     | <span class='unexecuted'>            uint256 avgInterestRate = activePoolCached.getNewApproxAvgInterestRateFromTroveChange(batchChange);</span>
  928 |     | <span class='unexecuted'>            batchChange.upfrontFee = _calcUpfrontFee(newDebt, avgInterestRate);</span>
  929 |     | <span class='unexecuted'>            _requireUserAcceptsUpfrontFee(batchChange.upfrontFee, _maxUpfrontFee);</span>
  930 |     | <span class='neutral'></span>
  931 |     | <span class='unexecuted'>            newDebt += batchChange.upfrontFee;</span>
  932 |     | <span class='neutral'></span>
  933 |     | <span class='neutral'>            // Recalculate the batch&#39;s weighted terms, now taking into account the upfront fee</span>
  934 |     | <span class='unexecuted'>            batchChange.newWeightedRecordedDebt = newDebt * _newAnnualInterestRate;</span>
  935 |     | <span class='unexecuted'>            batchChange.newWeightedRecordedBatchManagementFee = newDebt * batch.annualManagementFee;</span>
  936 |     | <span class='neutral'></span>
  937 |     | <span class='neutral'>            // Disallow a premature adjustment if it would result in TCR &lt; CCR</span>
  938 |     | <span class='neutral'>            // (which includes the case when TCR is already below CCR before the adjustment).</span>
  939 |     | <span class='unexecuted'>            uint256 newTCR = _getNewTCRFromTroveChange(batchChange, price);</span>
  940 |     | <span class='unexecuted'>            _requireNewTCRisAboveCCR(newTCR);</span>
  941 |     | <span class='neutral'>        }</span>
  942 |     | <span class='neutral'></span>
  943 |     | <span class='unexecuted'>        activePoolCached.mintAggInterestAndAccountForTroveChange(batchChange, msg.sender);</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='neutral'>        // Check batch is not empty, and then reinsert in sorted list</span>
  946 |     | <span class='unexecuted'>        if (!sortedTroves.isEmptyBatch(BatchId.wrap(msg.sender))) {</span>
  947 |     | <span class='unexecuted'>            sortedTroves.reInsertBatch(BatchId.wrap(msg.sender), _newAnnualInterestRate, _upperHint, _lowerHint);</span>
  948 |     | <span class='neutral'>        }</span>
  949 |     | <span class='neutral'></span>
  950 |     | <span class='unexecuted'>        troveManagerCached.onSetBatchManagerAnnualInterestRate(</span>
  951 |     | <span class='unexecuted'>            msg.sender, batch.entireCollWithoutRedistribution, newDebt, _newAnnualInterestRate, batchChange.upfrontFee</span>
  952 |     | <span class='neutral'>        );</span>
  953 |     | <span class='neutral'>    }</span>
  954 |     | <span class='neutral'></span>
  955 | *   | <span class='executed'>    function setInterestBatchManager(</span>
  956 |     | <span class='neutral'>        uint256 _troveId,</span>
  957 |     | <span class='neutral'>        address _newBatchManager,</span>
  958 |     | <span class='neutral'>        uint256 _upperHint,</span>
  959 |     | <span class='neutral'>        uint256 _lowerHint,</span>
  960 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
  961 | *   | <span class='executed'>    ) public override {</span>
  962 | *   | <span class='executed'>        _requireIsNotShutDown();</span>
  963 | *   | <span class='executed'>        LocalVariables_setInterestBatchManager memory vars;</span>
  964 | *   | <span class='executed'>        vars.troveManager = troveManager;</span>
  965 | *   | <span class='executed'>        vars.activePool = activePool;</span>
  966 | *   | <span class='executed'>        vars.sortedTroves = sortedTroves;</span>
  967 |     | <span class='neutral'></span>
  968 | *   | <span class='executed'>        _requireTroveIsActive(vars.troveManager, _troveId);</span>
  969 | *   | <span class='executed'>        _requireCallerIsBorrower(_troveId);</span>
  970 | *   | <span class='executed'>        _requireValidInterestBatchManager(_newBatchManager);</span>
  971 |     | <span class='unexecuted'>        _requireIsNotInBatch(_troveId);</span>
  972 |     | <span class='neutral'></span>
  973 |     | <span class='unexecuted'>        interestBatchManagerOf[_troveId] = _newBatchManager;</span>
  974 |     | <span class='neutral'>        // Can’t have both individual delegation and batch manager</span>
  975 |     | <span class='unexecuted'>        if (interestIndividualDelegateOf[_troveId].account != address(0)) delete interestIndividualDelegateOf[_troveId];</span>
  976 |     | <span class='neutral'></span>
  977 |     | <span class='unexecuted'>        vars.trove = vars.troveManager.getLatestTroveData(_troveId);</span>
  978 |     | <span class='unexecuted'>        vars.newBatch = vars.troveManager.getLatestBatchData(_newBatchManager);</span>
  979 |     | <span class='neutral'></span>
  980 |     | <span class='unexecuted'>        TroveChange memory newBatchTroveChange;</span>
  981 |     | <span class='unexecuted'>        newBatchTroveChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;</span>
  982 |     | <span class='unexecuted'>        newBatchTroveChange.appliedRedistCollGain = vars.trove.redistCollGain;</span>
  983 |     | <span class='unexecuted'>        newBatchTroveChange.batchAccruedManagementFee = vars.newBatch.accruedManagementFee;</span>
  984 |     | <span class='unexecuted'>        newBatchTroveChange.oldWeightedRecordedDebt =</span>
  985 |     | <span class='unexecuted'>            vars.newBatch.weightedRecordedDebt + vars.trove.weightedRecordedDebt;</span>
  986 |     | <span class='unexecuted'>        newBatchTroveChange.newWeightedRecordedDebt =</span>
  987 |     | <span class='unexecuted'>            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualInterestRate;</span>
  988 |     | <span class='neutral'></span>
  989 |     | <span class='neutral'>        // An upfront fee is always charged upon joining a batch to ensure that borrowers can not game the fee logic</span>
  990 |     | <span class='neutral'>        // and gain free interest rate updates (e.g. if they also manage the batch they joined)</span>
  991 |     | <span class='unexecuted'>        vars.trove.entireDebt =</span>
  992 |     | <span class='unexecuted'>            _applyUpfrontFee(vars.trove.entireColl, vars.trove.entireDebt, newBatchTroveChange, _maxUpfrontFee);</span>
  993 |     | <span class='neutral'></span>
  994 |     | <span class='neutral'>        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee</span>
  995 |     | <span class='unexecuted'>        newBatchTroveChange.newWeightedRecordedDebt =</span>
  996 |     | <span class='unexecuted'>            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualInterestRate;</span>
  997 |     | <span class='neutral'></span>
  998 |     | <span class='neutral'>        // Add batch fees</span>
  999 |     | <span class='unexecuted'>        newBatchTroveChange.oldWeightedRecordedBatchManagementFee = vars.newBatch.weightedRecordedBatchManagementFee;</span>
 1000 |     | <span class='unexecuted'>        newBatchTroveChange.newWeightedRecordedBatchManagementFee =</span>
 1001 |     | <span class='unexecuted'>            (vars.newBatch.entireDebtWithoutRedistribution + vars.trove.entireDebt) * vars.newBatch.annualManagementFee;</span>
 1002 |     | <span class='unexecuted'>        vars.activePool.mintAggInterestAndAccountForTroveChange(newBatchTroveChange, _newBatchManager);</span>
 1003 |     | <span class='neutral'></span>
 1004 |     | <span class='unexecuted'>        vars.troveManager.onSetInterestBatchManager(</span>
 1005 |     | <span class='unexecuted'>            ITroveManager.OnSetInterestBatchManagerParams({</span>
 1006 |     | <span class='unexecuted'>                troveId: _troveId,</span>
 1007 |     | <span class='unexecuted'>                troveColl: vars.trove.entireColl,</span>
 1008 |     | <span class='unexecuted'>                troveDebt: vars.trove.entireDebt,</span>
 1009 |     | <span class='unexecuted'>                troveChange: newBatchTroveChange,</span>
 1010 |     | <span class='unexecuted'>                newBatchAddress: _newBatchManager,</span>
 1011 |     | <span class='unexecuted'>                newBatchColl: vars.newBatch.entireCollWithoutRedistribution,</span>
 1012 |     | <span class='unexecuted'>                newBatchDebt: vars.newBatch.entireDebtWithoutRedistribution</span>
 1013 |     | <span class='neutral'>            })</span>
 1014 |     | <span class='neutral'>        );</span>
 1015 |     | <span class='neutral'></span>
 1016 |     | <span class='unexecuted'>        vars.sortedTroves.remove(_troveId);</span>
 1017 | *   | <span class='executed'>        vars.sortedTroves.insertIntoBatch(</span>
 1018 |     | <span class='unexecuted'>            _troveId, BatchId.wrap(_newBatchManager), vars.newBatch.annualInterestRate, _upperHint, _lowerHint</span>
 1019 |     | <span class='neutral'>        );</span>
 1020 |     | <span class='neutral'>    }</span>
 1021 |     | <span class='neutral'></span>
 1022 | *   | <span class='executed'>    function removeFromBatch(</span>
 1023 |     | <span class='neutral'>        uint256 _troveId,</span>
 1024 |     | <span class='neutral'>        uint256 _newAnnualInterestRate,</span>
 1025 |     | <span class='neutral'>        uint256 _upperHint,</span>
 1026 |     | <span class='neutral'>        uint256 _lowerHint,</span>
 1027 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
 1028 |     | <span class='neutral'>    ) public override {</span>
 1029 | *   | <span class='executed'>        _requireIsNotShutDown();</span>
 1030 |     | <span class='neutral'></span>
 1031 | *   | <span class='executed'>        LocalVariables_removeFromBatch memory vars;</span>
 1032 | *   | <span class='executed'>        vars.troveManager = troveManager;</span>
 1033 | *   | <span class='executed'>        vars.sortedTroves = sortedTroves;</span>
 1034 |     | <span class='neutral'></span>
 1035 | *   | <span class='executed'>        _requireTroveIsActive(vars.troveManager, _troveId);</span>
 1036 | *   | <span class='executed'>        _requireCallerIsBorrower(_troveId);</span>
 1037 | *   | <span class='executed'>        _requireValidAnnualInterestRate(_newAnnualInterestRate);</span>
 1038 |     | <span class='neutral'></span>
 1039 | *   | <span class='executed'>        vars.batchManager = _requireIsInBatch(_troveId);</span>
 1040 | *   | <span class='executed'>        delete interestBatchManagerOf[_troveId];</span>
 1041 |     | <span class='neutral'></span>
 1042 |     | <span class='neutral'>        // Remove trove from Batch in SortedTroves</span>
 1043 | *   | <span class='executed'>        vars.sortedTroves.removeFromBatch(_troveId);</span>
 1044 |     | <span class='neutral'>        // Reinsert as single trove</span>
 1045 | *   | <span class='executed'>        vars.sortedTroves.insert(_troveId, _newAnnualInterestRate, _upperHint, _lowerHint);</span>
 1046 |     | <span class='neutral'></span>
 1047 | *   | <span class='executed'>        vars.trove = vars.troveManager.getLatestTroveData(_troveId);</span>
 1048 | *   | <span class='executed'>        vars.batch = vars.troveManager.getLatestBatchData(vars.batchManager);</span>
 1049 |     | <span class='neutral'></span>
 1050 | *   | <span class='executed'>        uint256 batchFutureDebt =</span>
 1051 | *   | <span class='executed'>            vars.batch.entireDebtWithoutRedistribution - (vars.trove.entireDebt - vars.trove.redistBoldDebtGain);</span>
 1052 |     | <span class='neutral'></span>
 1053 | *   | <span class='executed'>        TroveChange memory batchChange;</span>
 1054 | *   | <span class='executed'>        batchChange.appliedRedistBoldDebtGain = vars.trove.redistBoldDebtGain;</span>
 1055 | *   | <span class='executed'>        batchChange.appliedRedistCollGain = vars.trove.redistCollGain;</span>
 1056 | *   | <span class='executed'>        batchChange.batchAccruedManagementFee = vars.batch.accruedManagementFee;</span>
 1057 | *   | <span class='executed'>        batchChange.oldWeightedRecordedDebt = vars.batch.weightedRecordedDebt;</span>
 1058 | *   | <span class='executed'>        batchChange.newWeightedRecordedDebt =</span>
 1059 | *   | <span class='executed'>            batchFutureDebt * vars.batch.annualInterestRate + vars.trove.entireDebt * _newAnnualInterestRate;</span>
 1060 |     | <span class='neutral'></span>
 1061 |     | <span class='neutral'>        // Apply upfront fee on premature adjustments</span>
 1062 | *   | <span class='executed'>        if (</span>
 1063 | *   | <span class='executed'>            vars.batch.annualInterestRate != _newAnnualInterestRate</span>
 1064 | *   | <span class='executed'>                &amp;&amp; block.timestamp &lt; vars.trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN</span>
 1065 |     | <span class='neutral'>        ) {</span>
 1066 | *   | <span class='executed'>            vars.trove.entireDebt =</span>
 1067 | *   | <span class='executed'>                _applyUpfrontFee(vars.trove.entireColl, vars.trove.entireDebt, batchChange, _maxUpfrontFee);</span>
 1068 |     | <span class='neutral'>        }</span>
 1069 |     | <span class='neutral'></span>
 1070 |     | <span class='neutral'>        // Recalculate newWeightedRecordedDebt, now taking into account the upfront fee</span>
 1071 | *   | <span class='executed'>        batchChange.newWeightedRecordedDebt =</span>
 1072 | *   | <span class='executed'>            batchFutureDebt * vars.batch.annualInterestRate + vars.trove.entireDebt * _newAnnualInterestRate;</span>
 1073 |     | <span class='neutral'>        // Add batch fees</span>
 1074 | *   | <span class='executed'>        batchChange.oldWeightedRecordedBatchManagementFee = vars.batch.weightedRecordedBatchManagementFee;</span>
 1075 | *   | <span class='executed'>        batchChange.newWeightedRecordedBatchManagementFee = batchFutureDebt * vars.batch.annualManagementFee;</span>
 1076 |     | <span class='neutral'></span>
 1077 | *   | <span class='executed'>        activePool.mintAggInterestAndAccountForTroveChange(batchChange, vars.batchManager);</span>
 1078 |     | <span class='neutral'></span>
 1079 | *   | <span class='executed'>        vars.troveManager.onRemoveFromBatch(</span>
 1080 | *   | <span class='executed'>            _troveId,</span>
 1081 | *   | <span class='executed'>            vars.trove.entireColl,</span>
 1082 | *   | <span class='executed'>            vars.trove.entireDebt,</span>
 1083 | *   | <span class='executed'>            batchChange,</span>
 1084 | *   | <span class='executed'>            vars.batchManager,</span>
 1085 | *   | <span class='executed'>            vars.batch.entireCollWithoutRedistribution,</span>
 1086 | *   | <span class='executed'>            vars.batch.entireDebtWithoutRedistribution,</span>
 1087 | *   | <span class='executed'>            _newAnnualInterestRate</span>
 1088 |     | <span class='neutral'>        );</span>
 1089 |     | <span class='neutral'>    }</span>
 1090 |     | <span class='neutral'></span>
 1091 | *   | <span class='executed'>    function switchBatchManager(</span>
 1092 |     | <span class='neutral'>        uint256 _troveId,</span>
 1093 |     | <span class='neutral'>        uint256 _removeUpperHint,</span>
 1094 |     | <span class='neutral'>        uint256 _removeLowerHint,</span>
 1095 |     | <span class='neutral'>        address _newBatchManager,</span>
 1096 |     | <span class='neutral'>        uint256 _addUpperHint,</span>
 1097 |     | <span class='neutral'>        uint256 _addLowerHint,</span>
 1098 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
 1099 |     | <span class='neutral'>    ) external override {</span>
 1100 | *   | <span class='executed'>        address oldBatchManager = _requireIsInBatch(_troveId);</span>
 1101 | *   | <span class='executed'>        _requireNewInterestBatchManager(oldBatchManager, _newBatchManager);</span>
 1102 |     | <span class='neutral'></span>
 1103 | *   | <span class='executed'>        LatestBatchData memory oldBatch = troveManager.getLatestBatchData(oldBatchManager);</span>
 1104 |     | <span class='neutral'></span>
 1105 | *   | <span class='executed'>        removeFromBatch(_troveId, oldBatch.annualInterestRate, _removeUpperHint, _removeLowerHint, 0);</span>
 1106 | *   | <span class='executed'>        setInterestBatchManager(_troveId, _newBatchManager, _addUpperHint, _addLowerHint, _maxUpfrontFee);</span>
 1107 |     | <span class='neutral'>    }</span>
 1108 |     | <span class='neutral'></span>
 1109 | *   | <span class='executed'>    function _applyUpfrontFee(</span>
 1110 |     | <span class='neutral'>        uint256 _troveEntireColl,</span>
 1111 |     | <span class='neutral'>        uint256 _troveEntireDebt,</span>
 1112 |     | <span class='neutral'>        TroveChange memory _troveChange,</span>
 1113 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
 1114 | *   | <span class='executed'>    ) internal returns (uint256) {</span>
 1115 | *   | <span class='executed'>        uint256 price = _requireOraclesLive();</span>
 1116 |     | <span class='neutral'></span>
 1117 | *   | <span class='executed'>        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(_troveChange);</span>
 1118 | *   | <span class='executed'>        _troveChange.upfrontFee = _calcUpfrontFee(_troveEntireDebt, avgInterestRate);</span>
 1119 | *   | <span class='executed'>        _requireUserAcceptsUpfrontFee(_troveChange.upfrontFee, _maxUpfrontFee);</span>
 1120 |     | <span class='neutral'></span>
 1121 | *   | <span class='executed'>        _troveEntireDebt += _troveChange.upfrontFee;</span>
 1122 |     | <span class='neutral'></span>
 1123 |     | <span class='neutral'>        // ICR is based on the requested Bold amount + upfront fee.</span>
 1124 | *   | <span class='executed'>        uint256 newICR = LiquityMath._computeCR(_troveEntireColl, _troveEntireDebt, price);</span>
 1125 | *   | <span class='executed'>        _requireICRisAboveMCR(newICR);</span>
 1126 |     | <span class='neutral'></span>
 1127 |     | <span class='neutral'>        // Disallow a premature adjustment if it would result in TCR &lt; CCR</span>
 1128 |     | <span class='neutral'>        // (which includes the case when TCR is already below CCR before the adjustment).</span>
 1129 | *   | <span class='executed'>        uint256 newTCR = _getNewTCRFromTroveChange(_troveChange, price);</span>
 1130 | *   | <span class='executed'>        _requireNewTCRisAboveCCR(newTCR);</span>
 1131 |     | <span class='neutral'></span>
 1132 | *   | <span class='executed'>        return _troveEntireDebt;</span>
 1133 |     | <span class='neutral'>    }</span>
 1134 |     | <span class='neutral'></span>
 1135 | *   | <span class='executed'>    function _calcUpfrontFee(uint256 _debt, uint256 _avgInterestRate) internal pure returns (uint256) {</span>
 1136 | *   | <span class='executed'>        return _calcInterest(_debt * _avgInterestRate, UPFRONT_INTEREST_PERIOD);</span>
 1137 |     | <span class='neutral'>    }</span>
 1138 |     | <span class='neutral'></span>
 1139 |     | <span class='neutral'>    // Call from TM to clean state here</span>
 1140 | *   | <span class='executed'>    function onLiquidateTrove(uint256 _troveId) external {</span>
 1141 | *   | <span class='executed'>        _requireCallerIsTroveManager();</span>
 1142 |     | <span class='neutral'></span>
 1143 | *   | <span class='executed'>        _wipeTroveMappings(_troveId);</span>
 1144 |     | <span class='neutral'>    }</span>
 1145 |     | <span class='neutral'></span>
 1146 |     | <span class='unexecuted'>    function _wipeTroveMappings(uint256 _troveId) internal {</span>
 1147 |     | <span class='unexecuted'>        delete interestIndividualDelegateOf[_troveId];</span>
 1148 |     | <span class='unexecuted'>        delete interestBatchManagerOf[_troveId];</span>
 1149 |     | <span class='unexecuted'>        _wipeAddRemoveManagers(_troveId);</span>
 1150 |     | <span class='neutral'>    }</span>
 1151 |     | <span class='neutral'></span>
 1152 |     | <span class='neutral'>    /**</span>
 1153 |     | <span class='neutral'>     * Claim remaining collateral from a liquidation with ICR exceeding the liquidation penalty</span>
 1154 |     | <span class='neutral'>     */</span>
 1155 | *   | <span class='executed'>    function claimCollateral() external override {</span>
 1156 |     | <span class='neutral'>        // send coll from CollSurplus Pool to owner</span>
 1157 | *   | <span class='executed'>        collSurplusPool.claimColl(msg.sender);</span>
 1158 |     | <span class='neutral'>    }</span>
 1159 |     | <span class='neutral'></span>
 1160 | *   | <span class='executed'>    function shutdown() external {</span>
 1161 | *   | <span class='executed'>        if (hasBeenShutDown) revert IsShutDown();</span>
 1162 |     | <span class='neutral'></span>
 1163 | *   | <span class='executed'>        uint256 totalColl = getEntireSystemColl();</span>
 1164 | *   | <span class='executed'>        uint256 totalDebt = getEntireSystemDebt();</span>
 1165 | *   | <span class='executed'>        (uint256 price, bool newOracleFailureDetected) = priceFeed.fetchPrice();</span>
 1166 |     | <span class='neutral'>        // If the oracle failed, the above call to PriceFeed will have shut this branch down</span>
 1167 | *   | <span class='executed'>        if (newOracleFailureDetected) return;</span>
 1168 |     | <span class='neutral'></span>
 1169 |     | <span class='neutral'>        // Otherwise, proceed with the TCR check:</span>
 1170 | *   | <span class='executed'>        uint256 TCR = LiquityMath._computeCR(totalColl, totalDebt, price);</span>
 1171 | *   | <span class='executed'>        if (TCR &gt;= SCR) revert TCRNotBelowSCR();</span>
 1172 |     | <span class='neutral'></span>
 1173 | *   | <span class='executed'>        _applyShutdown();</span>
 1174 |     | <span class='neutral'></span>
 1175 | *   | <span class='executed'>        emit ShutDown(TCR);</span>
 1176 |     | <span class='neutral'>    }</span>
 1177 |     | <span class='neutral'></span>
 1178 |     | <span class='neutral'>    // Not technically a &quot;Borrower op&quot;, but seems best placed here given current shutdown logic.</span>
 1179 | *   | <span class='executed'>    function shutdownFromOracleFailure() external {</span>
 1180 | *   | <span class='executed'>        _requireCallerIsPriceFeed();</span>
 1181 |     | <span class='neutral'></span>
 1182 |     | <span class='neutral'>        // No-op rather than revert here, so that the outer function call which fetches the price does not revert</span>
 1183 |     | <span class='neutral'>        // if the system is already shut down.</span>
 1184 |     | <span class='unexecuted'>        if (hasBeenShutDown) return;</span>
 1185 |     | <span class='neutral'></span>
 1186 | *   | <span class='executed'>        _applyShutdown();</span>
 1187 |     | <span class='neutral'>    }</span>
 1188 |     | <span class='neutral'></span>
 1189 | *   | <span class='executed'>    function _applyShutdown() internal {</span>
 1190 | *   | <span class='executed'>        activePool.mintAggInterest();</span>
 1191 | *   | <span class='executed'>        hasBeenShutDown = true;</span>
 1192 | *   | <span class='executed'>        troveManager.shutdown();</span>
 1193 |     | <span class='neutral'>    }</span>
 1194 |     | <span class='neutral'></span>
 1195 |     | <span class='neutral'>    // --- Helper functions ---</span>
 1196 |     | <span class='neutral'></span>
 1197 | *   | <span class='executed'>    function _reInsertIntoSortedTroves(</span>
 1198 |     | <span class='neutral'>        uint256 _troveId,</span>
 1199 |     | <span class='neutral'>        uint256 _troveAnnualInterestRate,</span>
 1200 |     | <span class='neutral'>        uint256 _upperHint,</span>
 1201 |     | <span class='neutral'>        uint256 _lowerHint,</span>
 1202 |     | <span class='neutral'>        address _batchManager,</span>
 1203 |     | <span class='neutral'>        uint256 _batchAnnualInterestRate</span>
 1204 |     | <span class='neutral'>    ) internal {</span>
 1205 |     | <span class='neutral'>        // If it was in a batch, we need to put it back, otherwise we insert it normally</span>
 1206 | *   | <span class='executed'>        if (_batchManager == address(0)) {</span>
 1207 |     | <span class='unexecuted'>            sortedTroves.insert(_troveId, _troveAnnualInterestRate, _upperHint, _lowerHint);</span>
 1208 |     | <span class='neutral'>        } else {</span>
 1209 | *   | <span class='executed'>            sortedTroves.insertIntoBatch(</span>
 1210 | *   | <span class='executed'>                _troveId, BatchId.wrap(_batchManager), _batchAnnualInterestRate, _upperHint, _lowerHint</span>
 1211 |     | <span class='neutral'>            );</span>
 1212 |     | <span class='neutral'>        }</span>
 1213 |     | <span class='neutral'>    }</span>
 1214 |     | <span class='neutral'></span>
 1215 |     | <span class='neutral'>    // This function mints the BOLD corresponding to the borrower&#39;s chosen debt increase</span>
 1216 |     | <span class='neutral'>    // (it does not mint the accrued interest).</span>
 1217 | *   | <span class='executed'>    function _moveTokensFromAdjustment(</span>
 1218 |     | <span class='neutral'>        address withdrawalReceiver,</span>
 1219 |     | <span class='neutral'>        TroveChange memory _troveChange,</span>
 1220 |     | <span class='neutral'>        IBoldToken _boldToken,</span>
 1221 |     | <span class='neutral'>        IActivePool _activePool</span>
 1222 |     | <span class='neutral'>    ) internal {</span>
 1223 | *   | <span class='executed'>        if (_troveChange.debtIncrease &gt; 0) {</span>
 1224 | *   | <span class='executed'>            _boldToken.mint(withdrawalReceiver, _troveChange.debtIncrease);</span>
 1225 | *   | <span class='executed'>        } else if (_troveChange.debtDecrease &gt; 0) {</span>
 1226 | *   | <span class='executed'>            _boldToken.burn(msg.sender, _troveChange.debtDecrease);</span>
 1227 |     | <span class='neutral'>        }</span>
 1228 |     | <span class='neutral'></span>
 1229 | *   | <span class='executed'>        if (_troveChange.collIncrease &gt; 0) {</span>
 1230 |     | <span class='neutral'>            // Pull coll tokens from sender and move them to the Active Pool</span>
 1231 | *   | <span class='executed'>            _pullCollAndSendToActivePool(_activePool, _troveChange.collIncrease);</span>
 1232 | *   | <span class='executed'>        } else if (_troveChange.collDecrease &gt; 0) {</span>
 1233 |     | <span class='neutral'>            // Pull Coll from Active Pool and decrease its recorded Coll balance</span>
 1234 | *   | <span class='executed'>            _activePool.sendColl(withdrawalReceiver, _troveChange.collDecrease);</span>
 1235 |     | <span class='neutral'>        }</span>
 1236 |     | <span class='neutral'>    }</span>
 1237 |     | <span class='neutral'></span>
 1238 | *   | <span class='executed'>    function _pullCollAndSendToActivePool(IActivePool _activePool, uint256 _amount) internal {</span>
 1239 |     | <span class='neutral'>        // Send Coll tokens from sender to active pool</span>
 1240 | *   | <span class='executed'>        collToken.safeTransferFrom(msg.sender, address(_activePool), _amount);</span>
 1241 |     | <span class='neutral'>        // Make sure Active Pool accountancy is right</span>
 1242 | *   | <span class='executed'>        _activePool.accountForReceivedColl(_amount);</span>
 1243 |     | <span class='neutral'>    }</span>
 1244 |     | <span class='neutral'></span>
 1245 |     | <span class='unexecuted'>    function checkBatchManagerExists(address _batchManager) external view returns (bool) {</span>
 1246 |     | <span class='unexecuted'>        return interestBatchManagers[_batchManager].maxInterestRate &gt; 0;</span>
 1247 |     | <span class='neutral'>    }</span>
 1248 |     | <span class='neutral'></span>
 1249 |     | <span class='neutral'>    // --- &#39;Require&#39; wrapper functions ---</span>
 1250 |     | <span class='neutral'></span>
 1251 | *   | <span class='executed'>    function _requireIsNotShutDown() internal view {</span>
 1252 | *   | <span class='executed'>        if (hasBeenShutDown) {</span>
 1253 | *   | <span class='executed'>            revert IsShutDown();</span>
 1254 |     | <span class='neutral'>        }</span>
 1255 |     | <span class='neutral'>    }</span>
 1256 |     | <span class='neutral'></span>
 1257 | *   | <span class='executed'>    function _requireNonZeroAdjustment(TroveChange memory _troveChange) internal pure {</span>
 1258 | *   | <span class='executed'>        if (</span>
 1259 | *   | <span class='executed'>            _troveChange.collIncrease == 0 &amp;&amp; _troveChange.collDecrease == 0 &amp;&amp; _troveChange.debtIncrease == 0</span>
 1260 | *   | <span class='executed'>                &amp;&amp; _troveChange.debtDecrease == 0</span>
 1261 |     | <span class='neutral'>        ) {</span>
 1262 | *   | <span class='executed'>            revert ZeroAdjustment();</span>
 1263 |     | <span class='neutral'>        }</span>
 1264 |     | <span class='neutral'>    }</span>
 1265 |     | <span class='neutral'></span>
 1266 | *   | <span class='executed'>    function _requireSenderIsOwnerOrInterestManager(uint256 _troveId) internal view {</span>
 1267 | *   | <span class='executed'>        address owner = troveNFT.ownerOf(_troveId);</span>
 1268 | *   | <span class='executed'>        if (msg.sender != owner &amp;&amp; msg.sender != interestIndividualDelegateOf[_troveId].account) {</span>
 1269 |     | <span class='unexecuted'>            revert NotOwnerNorInterestManager();</span>
 1270 |     | <span class='neutral'>        }</span>
 1271 |     | <span class='neutral'>    }</span>
 1272 |     | <span class='neutral'></span>
 1273 | *   | <span class='executed'>    function _requireValidDelegateAdustment(</span>
 1274 |     | <span class='neutral'>        uint256 _troveId,</span>
 1275 |     | <span class='neutral'>        uint256 _lastInterestRateAdjTime,</span>
 1276 |     | <span class='neutral'>        uint256 _annualInterestRate</span>
 1277 |     | <span class='neutral'>    ) internal view {</span>
 1278 | *   | <span class='executed'>        InterestIndividualDelegate memory individualDelegate = interestIndividualDelegateOf[_troveId];</span>
 1279 |     | <span class='neutral'>        // We have previously checked that sender is either owner or delegate</span>
 1280 |     | <span class='neutral'>        // If it’s owner, this restriction doesn’t apply</span>
 1281 | *   | <span class='executed'>        if (individualDelegate.account == msg.sender) {</span>
 1282 | *   | <span class='executed'>            _requireInterestRateInRange(</span>
 1283 | *   | <span class='executed'>                _annualInterestRate, individualDelegate.minInterestRate, individualDelegate.maxInterestRate</span>
 1284 |     | <span class='neutral'>            );</span>
 1285 | *   | <span class='executed'>            _requireDelegateInterestRateChangePeriodPassed(</span>
 1286 | *   | <span class='executed'>                _lastInterestRateAdjTime, individualDelegate.minInterestRateChangePeriod</span>
 1287 |     | <span class='neutral'>            );</span>
 1288 |     | <span class='neutral'>        }</span>
 1289 |     | <span class='neutral'>    }</span>
 1290 |     | <span class='neutral'></span>
 1291 | *   | <span class='executed'>    function _requireIsNotInBatch(uint256 _troveId) internal view {</span>
 1292 | *   | <span class='executed'>        if (interestBatchManagerOf[_troveId] != address(0)) {</span>
 1293 | *   | <span class='executed'>            revert TroveInBatch();</span>
 1294 |     | <span class='neutral'>        }</span>
 1295 |     | <span class='neutral'>    }</span>
 1296 |     | <span class='neutral'></span>
 1297 | *   | <span class='executed'>    function _requireIsInBatch(uint256 _troveId) internal view returns (address) {</span>
 1298 | *   | <span class='executed'>        address batchManager = interestBatchManagerOf[_troveId];</span>
 1299 | *   | <span class='executed'>        if (batchManager == address(0)) {</span>
 1300 | *   | <span class='executed'>            revert TroveNotInBatch();</span>
 1301 |     | <span class='neutral'>        }</span>
 1302 |     | <span class='neutral'></span>
 1303 |     | <span class='neutral'>        return batchManager;</span>
 1304 |     | <span class='neutral'>    }</span>
 1305 |     | <span class='neutral'></span>
 1306 | *   | <span class='executed'>    function _requireTroveDoesNotExists(ITroveManager _troveManager, uint256 _troveId) internal view {</span>
 1307 | *   | <span class='executed'>        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);</span>
 1308 | *   | <span class='executed'>        if (status != ITroveManager.Status.nonExistent) {</span>
 1309 | *   | <span class='executed'>            revert TroveExists();</span>
 1310 |     | <span class='neutral'>        }</span>
 1311 |     | <span class='neutral'>    }</span>
 1312 |     | <span class='neutral'></span>
 1313 | *   | <span class='executed'>    function _requireTroveIsOpen(ITroveManager _troveManager, uint256 _troveId) internal view {</span>
 1314 | *   | <span class='executed'>        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);</span>
 1315 | *   | <span class='executed'>        if (status != ITroveManager.Status.active &amp;&amp; status != ITroveManager.Status.zombie) {</span>
 1316 | *   | <span class='executed'>            revert TroveNotOpen();</span>
 1317 |     | <span class='neutral'>        }</span>
 1318 |     | <span class='neutral'>    }</span>
 1319 |     | <span class='neutral'></span>
 1320 | *   | <span class='executed'>    function _requireTroveIsActive(ITroveManager _troveManager, uint256 _troveId) internal view {</span>
 1321 | *   | <span class='executed'>        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);</span>
 1322 | *   | <span class='executed'>        if (status != ITroveManager.Status.active) {</span>
 1323 | *   | <span class='executed'>            revert TroveNotActive();</span>
 1324 |     | <span class='neutral'>        }</span>
 1325 |     | <span class='neutral'>    }</span>
 1326 |     | <span class='neutral'></span>
 1327 | *   | <span class='executed'>    function _requireTroveIsZombie(ITroveManager _troveManager, uint256 _troveId) internal view {</span>
 1328 | *   | <span class='executed'>        if (!_checkTroveIsZombie(_troveManager, _troveId)) {</span>
 1329 | *   | <span class='executed'>            revert TroveNotZombie();</span>
 1330 |     | <span class='neutral'>        }</span>
 1331 |     | <span class='neutral'>    }</span>
 1332 |     | <span class='neutral'></span>
 1333 | *   | <span class='executed'>    function _checkTroveIsZombie(ITroveManager _troveManager, uint256 _troveId) public view returns (bool) {</span>
 1334 | *   | <span class='executed'>        ITroveManager.Status status = _troveManager.getTroveStatus(_troveId);</span>
 1335 | *   | <span class='executed'>        return status == ITroveManager.Status.zombie;</span>
 1336 |     | <span class='neutral'>    }</span>
 1337 |     | <span class='neutral'></span>
 1338 | *   | <span class='executed'>    function _requireNonZeroDebt(uint256 _troveDebt) internal pure {</span>
 1339 | *   | <span class='executed'>        if (_troveDebt == 0) {</span>
 1340 |     | <span class='unexecuted'>            revert TroveWithZeroDebt();</span>
 1341 |     | <span class='neutral'>        }</span>
 1342 |     | <span class='neutral'>    }</span>
 1343 |     | <span class='neutral'></span>
 1344 | *   | <span class='executed'>    function _requireUserAcceptsUpfrontFee(uint256 _fee, uint256 _maxFee) internal pure {</span>
 1345 | *   | <span class='executed'>        if (_fee &gt; _maxFee) {</span>
 1346 | *   | <span class='executed'>            revert UpfrontFeeTooHigh();</span>
 1347 |     | <span class='neutral'>        }</span>
 1348 |     | <span class='neutral'>    }</span>
 1349 |     | <span class='neutral'></span>
 1350 | *   | <span class='executed'>    function _requireValidAdjustmentInCurrentMode(</span>
 1351 |     | <span class='neutral'>        TroveChange memory _troveChange,</span>
 1352 |     | <span class='neutral'>        LocalVariables_adjustTrove memory _vars</span>
 1353 |     | <span class='neutral'>    ) internal view {</span>
 1354 |     | <span class='neutral'>        /*</span>
 1355 |     | <span class='neutral'>        * Below Critical Threshold, it is not permitted:</span>
 1356 |     | <span class='neutral'>        *</span>
 1357 |     | <span class='neutral'>        * - Borrowing, unless it brings TCR up to CCR again</span>
 1358 |     | <span class='neutral'>        * - Collateral withdrawal except accompanied by a debt repayment of at least the same value</span>
 1359 |     | <span class='neutral'>        *</span>
 1360 |     | <span class='neutral'>        * In Normal Mode, ensure:</span>
 1361 |     | <span class='neutral'>        *</span>
 1362 |     | <span class='neutral'>        * - The adjustment won&#39;t pull the TCR below CCR</span>
 1363 |     | <span class='neutral'>        *</span>
 1364 |     | <span class='neutral'>        * In Both cases:</span>
 1365 |     | <span class='neutral'>        * - The new ICR is above MCR</span>
 1366 |     | <span class='neutral'>        */</span>
 1367 | *   | <span class='executed'>        _requireICRisAboveMCR(_vars.newICR);</span>
 1368 |     | <span class='neutral'></span>
 1369 | *   | <span class='executed'>        uint256 newTCR = _getNewTCRFromTroveChange(_troveChange, _vars.price);</span>
 1370 | *   | <span class='executed'>        if (_vars.isBelowCriticalThreshold) {</span>
 1371 | *   | <span class='executed'>            _requireNoBorrowingUnlessNewTCRisAboveCCR(_troveChange.debtIncrease, newTCR);</span>
 1372 | *   | <span class='executed'>            _requireDebtRepaymentGeCollWithdrawal(_troveChange, _vars.price);</span>
 1373 |     | <span class='neutral'>        } else {</span>
 1374 |     | <span class='neutral'>            // if Normal Mode</span>
 1375 | *   | <span class='executed'>            _requireNewTCRisAboveCCR(newTCR);</span>
 1376 |     | <span class='neutral'>        }</span>
 1377 |     | <span class='neutral'>    }</span>
 1378 |     | <span class='neutral'></span>
 1379 | *   | <span class='executed'>    function _requireICRisAboveMCR(uint256 _newICR) internal view {</span>
 1380 | *   | <span class='executed'>        if (_newICR &lt; MCR) {</span>
 1381 | *   | <span class='executed'>            revert ICRBelowMCR();</span>
 1382 |     | <span class='neutral'>        }</span>
 1383 |     | <span class='neutral'>    }</span>
 1384 |     | <span class='neutral'></span>
 1385 | *   | <span class='executed'>    function _requireNoBorrowingUnlessNewTCRisAboveCCR(uint256 _debtIncrease, uint256 _newTCR) internal view {</span>
 1386 | *   | <span class='executed'>        if (_debtIncrease &gt; 0 &amp;&amp; _newTCR &lt; CCR) {</span>
 1387 |     | <span class='unexecuted'>            revert TCRBelowCCR();</span>
 1388 |     | <span class='neutral'>        }</span>
 1389 |     | <span class='neutral'>    }</span>
 1390 |     | <span class='neutral'></span>
 1391 | *   | <span class='executed'>    function _requireDebtRepaymentGeCollWithdrawal(TroveChange memory _troveChange, uint256 _price) internal pure {</span>
 1392 | *   | <span class='executed'>        if ((_troveChange.debtDecrease * DECIMAL_PRECISION &lt; _troveChange.collDecrease * _price)) {</span>
 1393 |     | <span class='unexecuted'>            revert RepaymentNotMatchingCollWithdrawal();</span>
 1394 |     | <span class='neutral'>        }</span>
 1395 |     | <span class='neutral'>    }</span>
 1396 |     | <span class='neutral'></span>
 1397 | *   | <span class='executed'>    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal view {</span>
 1398 | *   | <span class='executed'>        if (_newTCR &lt; CCR) {</span>
 1399 | *   | <span class='executed'>            revert TCRBelowCCR();</span>
 1400 |     | <span class='neutral'>        }</span>
 1401 |     | <span class='neutral'>    }</span>
 1402 |     | <span class='neutral'></span>
 1403 | *   | <span class='executed'>    function _requireAtLeastMinDebt(uint256 _debt) internal pure {</span>
 1404 | *   | <span class='executed'>        if (_debt &lt; MIN_DEBT) {</span>
 1405 | *   | <span class='executed'>            revert DebtBelowMin();</span>
 1406 |     | <span class='neutral'>        }</span>
 1407 |     | <span class='neutral'>    }</span>
 1408 |     | <span class='neutral'></span>
 1409 | *   | <span class='executed'>    function _requireValidCollWithdrawal(uint256 _currentColl, uint256 _collWithdrawal) internal pure {</span>
 1410 | *   | <span class='executed'>        if (_collWithdrawal &gt; _currentColl) {</span>
 1411 | *   | <span class='executed'>            revert CollWithdrawalTooHigh();</span>
 1412 |     | <span class='neutral'>        }</span>
 1413 |     | <span class='neutral'>    }</span>
 1414 |     | <span class='neutral'></span>
 1415 | *   | <span class='executed'>    function _requireSufficientBoldBalance(IBoldToken _boldToken, address _borrower, uint256 _debtRepayment)</span>
 1416 |     | <span class='neutral'>        internal</span>
 1417 |     | <span class='neutral'>        view</span>
 1418 |     | <span class='neutral'>    {</span>
 1419 | *   | <span class='executed'>        if (_boldToken.balanceOf(_borrower) &lt; _debtRepayment) {</span>
 1420 | *   | <span class='executed'>            revert NotEnoughBoldBalance();</span>
 1421 |     | <span class='neutral'>        }</span>
 1422 |     | <span class='neutral'>    }</span>
 1423 |     | <span class='neutral'></span>
 1424 | *   | <span class='executed'>    function _requireValidAnnualInterestRate(uint256 _annualInterestRate) internal pure {</span>
 1425 | *   | <span class='executed'>        if (_annualInterestRate &lt; MIN_ANNUAL_INTEREST_RATE) {</span>
 1426 | *   | <span class='executed'>            revert InterestRateTooLow();</span>
 1427 |     | <span class='neutral'>        }</span>
 1428 | *   | <span class='executed'>        if (_annualInterestRate &gt; MAX_ANNUAL_INTEREST_RATE) {</span>
 1429 | *   | <span class='executed'>            revert InterestRateTooHigh();</span>
 1430 |     | <span class='neutral'>        }</span>
 1431 |     | <span class='neutral'>    }</span>
 1432 |     | <span class='neutral'></span>
 1433 | *   | <span class='executed'>    function _requireAnnualInterestRateIsNew(uint256 _oldAnnualInterestRate, uint256 _newAnnualInterestRate)</span>
 1434 |     | <span class='neutral'>        internal</span>
 1435 |     | <span class='neutral'>        pure</span>
 1436 |     | <span class='neutral'>    {</span>
 1437 | *   | <span class='executed'>        if (_oldAnnualInterestRate == _newAnnualInterestRate) {</span>
 1438 |     | <span class='unexecuted'>            revert InterestRateNotNew();</span>
 1439 |     | <span class='neutral'>        }</span>
 1440 |     | <span class='neutral'>    }</span>
 1441 |     | <span class='neutral'></span>
 1442 | *   | <span class='executed'>    function _requireOrderedRange(uint256 _minInterestRate, uint256 _maxInterestRate) internal pure {</span>
 1443 | *   | <span class='executed'>        if (_minInterestRate &gt;= _maxInterestRate) revert MinGeMax();</span>
 1444 |     | <span class='neutral'>    }</span>
 1445 |     | <span class='neutral'></span>
 1446 | *   | <span class='executed'>    function _requireInterestRateInBatchManagerRange(address _interestBatchManagerAddress, uint256 _annualInterestRate)</span>
 1447 |     | <span class='neutral'>        internal</span>
 1448 |     | <span class='neutral'>        view</span>
 1449 |     | <span class='neutral'>    {</span>
 1450 | *   | <span class='executed'>        InterestBatchManager memory interestBatchManager = interestBatchManagers[_interestBatchManagerAddress];</span>
 1451 | *   | <span class='executed'>        _requireInterestRateInRange(</span>
 1452 | *   | <span class='executed'>            _annualInterestRate, interestBatchManager.minInterestRate, interestBatchManager.maxInterestRate</span>
 1453 |     | <span class='neutral'>        );</span>
 1454 |     | <span class='neutral'>    }</span>
 1455 |     | <span class='neutral'></span>
 1456 | *   | <span class='executed'>    function _requireInterestRateInRange(</span>
 1457 |     | <span class='neutral'>        uint256 _annualInterestRate,</span>
 1458 |     | <span class='neutral'>        uint256 _minInterestRate,</span>
 1459 |     | <span class='neutral'>        uint256 _maxInterestRate</span>
 1460 |     | <span class='neutral'>    ) internal pure {</span>
 1461 | *   | <span class='executed'>        if (_minInterestRate &gt; _annualInterestRate || _annualInterestRate &gt; _maxInterestRate) {</span>
 1462 | *   | <span class='executed'>            revert InterestNotInRange();</span>
 1463 |     | <span class='neutral'>        }</span>
 1464 |     | <span class='neutral'>    }</span>
 1465 |     | <span class='neutral'></span>
 1466 | *   | <span class='executed'>    function _requireBatchInterestRateChangePeriodPassed(</span>
 1467 |     | <span class='neutral'>        address _interestBatchManagerAddress,</span>
 1468 |     | <span class='neutral'>        uint256 _lastInterestRateAdjTime</span>
 1469 |     | <span class='neutral'>    ) internal view {</span>
 1470 | *   | <span class='executed'>        InterestBatchManager memory interestBatchManager = interestBatchManagers[_interestBatchManagerAddress];</span>
 1471 | *   | <span class='executed'>        if (block.timestamp &lt; _lastInterestRateAdjTime + uint256(interestBatchManager.minInterestRateChangePeriod)) {</span>
 1472 | *   | <span class='executed'>            revert BatchInterestRateChangePeriodNotPassed();</span>
 1473 |     | <span class='neutral'>        }</span>
 1474 |     | <span class='neutral'>    }</span>
 1475 |     | <span class='neutral'></span>
 1476 | *   | <span class='executed'>    function _requireDelegateInterestRateChangePeriodPassed(</span>
 1477 |     | <span class='neutral'>        uint256 _lastInterestRateAdjTime,</span>
 1478 |     | <span class='neutral'>        uint256 _minInterestRateChangePeriod</span>
 1479 |     | <span class='neutral'>    ) internal view {</span>
 1480 | *   | <span class='executed'>        if (block.timestamp &lt; _lastInterestRateAdjTime + _minInterestRateChangePeriod) {</span>
 1481 | *   | <span class='executed'>            revert DelegateInterestRateChangePeriodNotPassed();</span>
 1482 |     | <span class='neutral'>        }</span>
 1483 |     | <span class='neutral'>    }</span>
 1484 |     | <span class='neutral'></span>
 1485 | *   | <span class='executed'>    function _requireValidInterestBatchManager(address _interestBatchManagerAddress) internal view {</span>
 1486 | *   | <span class='executed'>        if (interestBatchManagers[_interestBatchManagerAddress].maxInterestRate == 0) {</span>
 1487 | *   | <span class='executed'>            revert InvalidInterestBatchManager();</span>
 1488 |     | <span class='neutral'>        }</span>
 1489 |     | <span class='neutral'>    }</span>
 1490 |     | <span class='neutral'></span>
 1491 | *   | <span class='executed'>    function _requireNonExistentInterestBatchManager(address _interestBatchManagerAddress) internal view {</span>
 1492 | *   | <span class='executed'>        if (interestBatchManagers[_interestBatchManagerAddress].maxInterestRate &gt; 0) {</span>
 1493 | *   | <span class='executed'>            revert BatchManagerExists();</span>
 1494 |     | <span class='neutral'>        }</span>
 1495 |     | <span class='neutral'>    }</span>
 1496 |     | <span class='neutral'></span>
 1497 | *   | <span class='executed'>    function _requireNewInterestBatchManager(address _oldBatchManagerAddress, address _newBatchManagerAddress)</span>
 1498 |     | <span class='neutral'>        internal</span>
 1499 |     | <span class='neutral'>        pure</span>
 1500 |     | <span class='neutral'>    {</span>
 1501 | *   | <span class='executed'>        if (_oldBatchManagerAddress == _newBatchManagerAddress) {</span>
 1502 | *   | <span class='executed'>            revert BatchManagerNotNew();</span>
 1503 |     | <span class='neutral'>        }</span>
 1504 |     | <span class='neutral'>    }</span>
 1505 |     | <span class='neutral'></span>
 1506 | *   | <span class='executed'>    function _requireCallerIsTroveManager() internal view {</span>
 1507 | *   | <span class='executed'>        if (msg.sender != address(troveManager)) {</span>
 1508 | *   | <span class='executed'>            revert CallerNotTroveManager();</span>
 1509 |     | <span class='neutral'>        }</span>
 1510 |     | <span class='neutral'>    }</span>
 1511 |     | <span class='neutral'></span>
 1512 | *   | <span class='executed'>    function _requireCallerIsPriceFeed() internal view {</span>
 1513 | *   | <span class='executed'>        if (msg.sender != address(priceFeed)) {</span>
 1514 | *   | <span class='executed'>            revert CallerNotPriceFeed();</span>
 1515 |     | <span class='neutral'>        }</span>
 1516 |     | <span class='neutral'>    }</span>
 1517 |     | <span class='neutral'></span>
 1518 | *   | <span class='executed'>    function _requireOraclesLive() internal returns (uint256) {</span>
 1519 | *   | <span class='executed'>        (uint256 price, bool newOracleFailureDetected) = priceFeed.fetchPrice();</span>
 1520 | *   | <span class='executed'>        if (newOracleFailureDetected) {</span>
 1521 |     | <span class='unexecuted'>            revert NewOracleFailureDetected();</span>
 1522 |     | <span class='neutral'>        }</span>
 1523 |     | <span class='neutral'></span>
 1524 | *   | <span class='executed'>        return price;</span>
 1525 |     | <span class='neutral'>    }</span>
 1526 |     | <span class='neutral'></span>
 1527 |     | <span class='neutral'>    // --- ICR and TCR getters ---</span>
 1528 |     | <span class='neutral'></span>
 1529 | *   | <span class='executed'>    function _getNewTCRFromTroveChange(TroveChange memory _troveChange, uint256 _price)</span>
 1530 |     | <span class='neutral'>        internal</span>
 1531 |     | <span class='neutral'>        view</span>
 1532 | *   | <span class='executed'>        returns (uint256 newTCR)</span>
 1533 |     | <span class='neutral'>    {</span>
 1534 | *   | <span class='executed'>        uint256 totalColl = getEntireSystemColl();</span>
 1535 | *   | <span class='executed'>        totalColl += _troveChange.collIncrease;</span>
 1536 | *   | <span class='executed'>        totalColl -= _troveChange.collDecrease;</span>
 1537 |     | <span class='neutral'></span>
 1538 | *   | <span class='executed'>        uint256 totalDebt = getEntireSystemDebt();</span>
 1539 | *   | <span class='executed'>        totalDebt += _troveChange.debtIncrease;</span>
 1540 | *   | <span class='executed'>        totalDebt += _troveChange.upfrontFee;</span>
 1541 | *   | <span class='executed'>        totalDebt -= _troveChange.debtDecrease;</span>
 1542 |     | <span class='neutral'></span>
 1543 | *   | <span class='executed'>        newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);</span>
 1544 |     | <span class='neutral'>    }</span>
 1545 |     | <span class='neutral'>}</span>
 1546 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/CollSurplusPool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>import &quot;./Interfaces/ICollSurplusPool.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;./Interfaces/IAddressesRegistry.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 | *   | <span class='executed'>contract CollSurplusPool is ICollSurplusPool {</span>
 11 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    string public constant NAME = &quot;CollSurplusPool&quot;;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    IERC20 public immutable collToken;</span>
 16 |     | <span class='unexecuted'>    address public immutable borrowerOperationsAddress;</span>
 17 |     | <span class='unexecuted'>    address public immutable troveManagerAddress;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    // deposited ether tracker</span>
 20 |     | <span class='neutral'>    uint256 internal collBalance;</span>
 21 |     | <span class='neutral'>    // Collateral surplus claimable by trove owners</span>
 22 |     | <span class='neutral'>    mapping(address =&gt; uint256) internal balances;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    // --- Events ---</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);</span>
 27 |     | <span class='neutral'>    event TroveManagerAddressChanged(address _newTroveManagerAddress);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    event CollBalanceUpdated(address indexed _account, uint256 _newBalance);</span>
 30 |     | <span class='neutral'>    event CollSent(address indexed _to, uint256 _amount);</span>
 31 |     | <span class='neutral'></span>
 32 | *   | <span class='executed'>    constructor(IAddressesRegistry _addressesRegistry) {</span>
 33 | *   | <span class='executed'>        collToken = _addressesRegistry.collToken();</span>
 34 | *   | <span class='executed'>        borrowerOperationsAddress = address(_addressesRegistry.borrowerOperations());</span>
 35 | *   | <span class='executed'>        troveManagerAddress = address(_addressesRegistry.troveManager());</span>
 36 |     | <span class='neutral'></span>
 37 | *   | <span class='executed'>        emit BorrowerOperationsAddressChanged(borrowerOperationsAddress);</span>
 38 | *   | <span class='executed'>        emit TroveManagerAddressChanged(troveManagerAddress);</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /* Returns the collBalance state variable</span>
 42 |     | <span class='neutral'>       Not necessarily equal to the raw coll balance - coll can be forcibly sent to contracts. */</span>
 43 |     | <span class='unexecuted'>    function getCollBalance() external view override returns (uint256) {</span>
 44 |     | <span class='unexecuted'>        return collBalance;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    function getCollateral(address _account) external view override returns (uint256) {</span>
 48 |     | <span class='unexecuted'>        return balances[_account];</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    // --- Pool functionality ---</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='unexecuted'>    function accountSurplus(address _account, uint256 _amount) external override {</span>
 54 |     | <span class='unexecuted'>        _requireCallerIsTroveManager();</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='unexecuted'>        uint256 newAmount = balances[_account] + _amount;</span>
 57 |     | <span class='unexecuted'>        balances[_account] = newAmount;</span>
 58 |     | <span class='unexecuted'>        collBalance = collBalance + _amount;</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='unexecuted'>        emit CollBalanceUpdated(_account, newAmount);</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 | *   | <span class='executed'>    function claimColl(address _account) external override {</span>
 64 | *   | <span class='executed'>        _requireCallerIsBorrowerOperations();</span>
 65 | *   | <span class='executed'>        uint256 claimableColl = balances[_account];</span>
 66 | *   | <span class='executed'>        require(claimableColl &gt; 0, &quot;CollSurplusPool: No collateral available to claim&quot;);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='unexecuted'>        balances[_account] = 0;</span>
 69 |     | <span class='unexecuted'>        emit CollBalanceUpdated(_account, 0);</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='unexecuted'>        collBalance = collBalance - claimableColl;</span>
 72 |     | <span class='unexecuted'>        emit CollSent(_account, claimableColl);</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='unexecuted'>        collToken.safeTransfer(_account, claimableColl);</span>
 75 |     | <span class='neutral'>    }</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='neutral'>    // --- &#39;require&#39; functions ---</span>
 78 |     | <span class='neutral'></span>
 79 | *   | <span class='executed'>    function _requireCallerIsBorrowerOperations() internal view {</span>
 80 | *   | <span class='executed'>        require(msg.sender == borrowerOperationsAddress, &quot;CollSurplusPool: Caller is not Borrower Operations&quot;);</span>
 81 |     | <span class='neutral'>    }</span>
 82 |     | <span class='neutral'></span>
 83 | *   | <span class='executed'>    function _requireCallerIsTroveManager() internal view {</span>
 84 | *   | <span class='executed'>        require(msg.sender == troveManagerAddress, &quot;CollSurplusPool: Caller is not TroveManager&quot;);</span>
 85 |     | <span class='neutral'>    }</span>
 86 |     | <span class='neutral'>}</span>
 87 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/CollateralRegistry.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;./Interfaces/ITroveManager.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./Interfaces/IBoldToken.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./Dependencies/Constants.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;./Dependencies/LiquityMath.sol&quot;;</span>
  11 |     | <span class='neutral'>import {console} from &quot;forge-std/console.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;./Interfaces/ICollateralRegistry.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 | *   | <span class='executed'>contract CollateralRegistry is ICollateralRegistry {</span>
  15 |     | <span class='neutral'>    // See: https://github.com/ethereum/solidity/issues/12587</span>
  16 |     | <span class='unexecuted'>    uint256 public immutable totalCollaterals;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    IERC20Metadata internal immutable token0;</span>
  19 |     | <span class='neutral'>    IERC20Metadata internal immutable token1;</span>
  20 |     | <span class='neutral'>    IERC20Metadata internal immutable token2;</span>
  21 |     | <span class='neutral'>    IERC20Metadata internal immutable token3;</span>
  22 |     | <span class='neutral'>    IERC20Metadata internal immutable token4;</span>
  23 |     | <span class='neutral'>    IERC20Metadata internal immutable token5;</span>
  24 |     | <span class='neutral'>    IERC20Metadata internal immutable token6;</span>
  25 |     | <span class='neutral'>    IERC20Metadata internal immutable token7;</span>
  26 |     | <span class='neutral'>    IERC20Metadata internal immutable token8;</span>
  27 |     | <span class='neutral'>    IERC20Metadata internal immutable token9;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    ITroveManager internal immutable troveManager0;</span>
  30 |     | <span class='neutral'>    ITroveManager internal immutable troveManager1;</span>
  31 |     | <span class='neutral'>    ITroveManager internal immutable troveManager2;</span>
  32 |     | <span class='neutral'>    ITroveManager internal immutable troveManager3;</span>
  33 |     | <span class='neutral'>    ITroveManager internal immutable troveManager4;</span>
  34 |     | <span class='neutral'>    ITroveManager internal immutable troveManager5;</span>
  35 |     | <span class='neutral'>    ITroveManager internal immutable troveManager6;</span>
  36 |     | <span class='neutral'>    ITroveManager internal immutable troveManager7;</span>
  37 |     | <span class='neutral'>    ITroveManager internal immutable troveManager8;</span>
  38 |     | <span class='neutral'>    ITroveManager internal immutable troveManager9;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>    IBoldToken public immutable boldToken;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>    uint256 public baseRate;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    // The timestamp of the latest fee operation (redemption or new Bold issuance)</span>
  45 | *   | <span class='executed'>    uint256 public lastFeeOperationTime = block.timestamp;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    event BaseRateUpdated(uint256 _baseRate);</span>
  48 |     | <span class='neutral'>    event LastFeeOpTimeUpdated(uint256 _lastFeeOpTime);</span>
  49 |     | <span class='neutral'></span>
  50 | *   | <span class='executed'>    constructor(IBoldToken _boldToken, IERC20Metadata[] memory _tokens, ITroveManager[] memory _troveManagers) {</span>
  51 | *   | <span class='executed'>        uint256 numTokens = _tokens.length;</span>
  52 | *   | <span class='executed'>        require(numTokens &gt; 0, &quot;Collateral list cannot be empty&quot;);</span>
  53 | *   | <span class='executed'>        require(numTokens &lt;= 10, &quot;Collateral list too long&quot;);</span>
  54 | *   | <span class='executed'>        totalCollaterals = numTokens;</span>
  55 |     | <span class='neutral'></span>
  56 | *   | <span class='executed'>        boldToken = _boldToken;</span>
  57 |     | <span class='neutral'></span>
  58 | *   | <span class='executed'>        token0 = _tokens[0];</span>
  59 | *   | <span class='executed'>        token1 = numTokens &gt; 1 ? _tokens[1] : IERC20Metadata(address(0));</span>
  60 | *   | <span class='executed'>        token2 = numTokens &gt; 2 ? _tokens[2] : IERC20Metadata(address(0));</span>
  61 | *   | <span class='executed'>        token3 = numTokens &gt; 3 ? _tokens[3] : IERC20Metadata(address(0));</span>
  62 | *   | <span class='executed'>        token4 = numTokens &gt; 4 ? _tokens[4] : IERC20Metadata(address(0));</span>
  63 | *   | <span class='executed'>        token5 = numTokens &gt; 5 ? _tokens[5] : IERC20Metadata(address(0));</span>
  64 | *   | <span class='executed'>        token6 = numTokens &gt; 6 ? _tokens[6] : IERC20Metadata(address(0));</span>
  65 | *   | <span class='executed'>        token7 = numTokens &gt; 7 ? _tokens[7] : IERC20Metadata(address(0));</span>
  66 | *   | <span class='executed'>        token8 = numTokens &gt; 8 ? _tokens[8] : IERC20Metadata(address(0));</span>
  67 | *   | <span class='executed'>        token9 = numTokens &gt; 9 ? _tokens[9] : IERC20Metadata(address(0));</span>
  68 |     | <span class='neutral'></span>
  69 | *   | <span class='executed'>        troveManager0 = _troveManagers[0];</span>
  70 | *   | <span class='executed'>        troveManager1 = numTokens &gt; 1 ? _troveManagers[1] : ITroveManager(address(0));</span>
  71 | *   | <span class='executed'>        troveManager2 = numTokens &gt; 2 ? _troveManagers[2] : ITroveManager(address(0));</span>
  72 | *   | <span class='executed'>        troveManager3 = numTokens &gt; 3 ? _troveManagers[3] : ITroveManager(address(0));</span>
  73 | *   | <span class='executed'>        troveManager4 = numTokens &gt; 4 ? _troveManagers[4] : ITroveManager(address(0));</span>
  74 | *   | <span class='executed'>        troveManager5 = numTokens &gt; 5 ? _troveManagers[5] : ITroveManager(address(0));</span>
  75 | *   | <span class='executed'>        troveManager6 = numTokens &gt; 6 ? _troveManagers[6] : ITroveManager(address(0));</span>
  76 | *   | <span class='executed'>        troveManager7 = numTokens &gt; 7 ? _troveManagers[7] : ITroveManager(address(0));</span>
  77 | *   | <span class='executed'>        troveManager8 = numTokens &gt; 8 ? _troveManagers[8] : ITroveManager(address(0));</span>
  78 | *   | <span class='executed'>        troveManager9 = numTokens &gt; 9 ? _troveManagers[9] : ITroveManager(address(0));</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>        // Initialize the baseRate state variable</span>
  81 | *   | <span class='executed'>        baseRate = INITIAL_BASE_RATE;</span>
  82 | *   | <span class='executed'>        emit BaseRateUpdated(INITIAL_BASE_RATE);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    struct RedemptionTotals {</span>
  86 |     | <span class='neutral'>        uint256 numCollaterals;</span>
  87 |     | <span class='neutral'>        uint256 boldSupplyAtStart;</span>
  88 |     | <span class='neutral'>        uint256 unbacked;</span>
  89 |     | <span class='neutral'>        uint256 redeemedAmount;</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 | *   | <span class='executed'>    function redeemCollateral(uint256 _boldAmount, uint256 _maxIterationsPerCollateral, uint256 _maxFeePercentage)</span>
  93 |     | <span class='neutral'>        external</span>
  94 | *   | <span class='executed'>    {</span>
  95 | *   | <span class='executed'>        _requireValidMaxFeePercentage(_maxFeePercentage);</span>
  96 | *   | <span class='executed'>        _requireAmountGreaterThanZero(_boldAmount);</span>
  97 |     | <span class='neutral'></span>
  98 | *   | <span class='executed'>        RedemptionTotals memory totals;</span>
  99 |     | <span class='neutral'></span>
 100 | *   | <span class='executed'>        totals.numCollaterals = totalCollaterals;</span>
 101 | *   | <span class='executed'>        uint256[] memory unbackedPortions = new uint256[](totals.numCollaterals);</span>
 102 | *   | <span class='executed'>        uint256[] memory prices = new uint256[](totals.numCollaterals);</span>
 103 |     | <span class='neutral'></span>
 104 | *   | <span class='executed'>        totals.boldSupplyAtStart = boldToken.totalSupply();</span>
 105 |     | <span class='neutral'>        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.</span>
 106 |     | <span class='neutral'>        // Use the saved total Bold supply value, from before it was reduced by the redemption.</span>
 107 |     | <span class='neutral'>        // We only compute it here, and update it at the end,</span>
 108 |     | <span class='neutral'>        // because the final redeemed amount may be less than the requested amount</span>
 109 |     | <span class='neutral'>        // Redeemers should take this into account in order to request the optimal amount to not overpay</span>
 110 | *   | <span class='executed'>        uint256 redemptionRate =</span>
 111 | *   | <span class='executed'>            _calcRedemptionRate(_getUpdatedBaseRateFromRedemption(_boldAmount, totals.boldSupplyAtStart));</span>
 112 | *   | <span class='executed'>        require(redemptionRate &lt;= _maxFeePercentage, &quot;CR: Fee exceeded provided maximum&quot;);</span>
 113 |     | <span class='neutral'>        // Implicit by the above and the _requireValidMaxFeePercentage checks</span>
 114 |     | <span class='neutral'>        //require(newBaseRate &lt; DECIMAL_PRECISION, &quot;CR: Fee would eat up all collateral&quot;);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>        // Gather and accumulate unbacked portions</span>
 117 | *   | <span class='executed'>        for (uint256 index = 0; index &lt; totals.numCollaterals; index++) {</span>
 118 | *   | <span class='executed'>            ITroveManager troveManager = getTroveManager(index);</span>
 119 | *   | <span class='executed'>            (uint256 unbackedPortion, uint256 price, bool redeemable) =</span>
 120 | *   | <span class='executed'>                troveManager.getUnbackedPortionPriceAndRedeemability();</span>
 121 | *   | <span class='executed'>            prices[index] = price;</span>
 122 | *   | <span class='executed'>            if (redeemable) {</span>
 123 | *   | <span class='executed'>                totals.unbacked += unbackedPortion;</span>
 124 | *   | <span class='executed'>                unbackedPortions[index] = unbackedPortion;</span>
 125 |     | <span class='neutral'>            }</span>
 126 |     | <span class='neutral'>        }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>        // There’s an unlikely scenario where all the normally redeemable branches (i.e. having TCR &gt; SCR) have 0 unbacked</span>
 129 |     | <span class='neutral'>        // In that case, we redeem proportinally to branch size</span>
 130 | *   | <span class='executed'>        if (totals.unbacked == 0) {</span>
 131 | *   | <span class='executed'>            unbackedPortions = new uint256[](totals.numCollaterals);</span>
 132 | *   | <span class='executed'>            for (uint256 index = 0; index &lt; totals.numCollaterals; index++) {</span>
 133 | *   | <span class='executed'>                ITroveManager troveManager = getTroveManager(index);</span>
 134 | *   | <span class='executed'>                (,, bool redeemable) = troveManager.getUnbackedPortionPriceAndRedeemability();</span>
 135 | *   | <span class='executed'>                if (redeemable) {</span>
 136 |     | <span class='unexecuted'>                    uint256 unbackedPortion = troveManager.getEntireSystemDebt();</span>
 137 |     | <span class='unexecuted'>                    totals.unbacked += unbackedPortion;</span>
 138 |     | <span class='unexecuted'>                    unbackedPortions[index] = unbackedPortion;</span>
 139 |     | <span class='neutral'>                }</span>
 140 |     | <span class='neutral'>            }</span>
 141 |     | <span class='neutral'>        }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>        // Compute redemption amount for each collateral and redeem against the corresponding TroveManager</span>
 144 | *   | <span class='executed'>        for (uint256 index = 0; index &lt; totals.numCollaterals; index++) {</span>
 145 |     | <span class='neutral'>            //uint256 unbackedPortion = unbackedPortions[index];</span>
 146 | *   | <span class='executed'>            if (unbackedPortions[index] &gt; 0) {</span>
 147 | *   | <span class='executed'>                uint256 redeemAmount = _boldAmount * unbackedPortions[index] / totals.unbacked;</span>
 148 | *   | <span class='executed'>                if (redeemAmount &gt; 0) {</span>
 149 | *   | <span class='executed'>                    ITroveManager troveManager = getTroveManager(index);</span>
 150 |     | <span class='neutral'></span>
 151 | *   | <span class='executed'>                    uint256 redeemedAmount = troveManager.redeemCollateral(</span>
 152 | *   | <span class='executed'>                        msg.sender, redeemAmount, prices[index], redemptionRate, _maxIterationsPerCollateral</span>
 153 |     | <span class='neutral'>                    );</span>
 154 |     | <span class='neutral'></span>
 155 | *   | <span class='executed'>                    totals.redeemedAmount += redeemedAmount;</span>
 156 |     | <span class='neutral'>                }</span>
 157 |     | <span class='neutral'>            }</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'></span>
 160 | *   | <span class='executed'>        _updateBaseRateAndGetRedemptionRate(totals.redeemedAmount, totals.boldSupplyAtStart);</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>        // Burn the total Bold that is cancelled with debt</span>
 163 | *   | <span class='executed'>        if (totals.redeemedAmount &gt; 0) {</span>
 164 | *   | <span class='executed'>            boldToken.burn(msg.sender, totals.redeemedAmount);</span>
 165 |     | <span class='neutral'>        }</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    // --- Internal fee functions ---</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing.</span>
 171 | *   | <span class='executed'>    function _updateLastFeeOpTime() internal {</span>
 172 | *   | <span class='executed'>        uint256 timePassed = block.timestamp - lastFeeOperationTime;</span>
 173 |     | <span class='neutral'></span>
 174 | *   | <span class='executed'>        if (timePassed &gt;= ONE_MINUTE) {</span>
 175 | *   | <span class='executed'>            lastFeeOperationTime = block.timestamp;</span>
 176 | *   | <span class='executed'>            emit LastFeeOpTimeUpdated(block.timestamp);</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 | *   | <span class='executed'>    function _minutesPassedSinceLastFeeOp() internal view returns (uint256) {</span>
 181 | *   | <span class='executed'>        return (block.timestamp - lastFeeOperationTime) / ONE_MINUTE;</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    // Updates the `baseRate` state with math from `_getUpdatedBaseRateFromRedemption`</span>
 185 | *   | <span class='executed'>    function _updateBaseRateAndGetRedemptionRate(uint256 _boldAmount, uint256 _totalBoldSupplyAtStart) internal {</span>
 186 | *   | <span class='executed'>        uint256 newBaseRate = _getUpdatedBaseRateFromRedemption(_boldAmount, _totalBoldSupplyAtStart);</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>        //assert(newBaseRate &lt;= DECIMAL_PRECISION); // This is already enforced in `_getUpdatedBaseRateFromRedemption`</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>        // Update the baseRate state variable</span>
 191 | *   | <span class='executed'>        baseRate = newBaseRate;</span>
 192 | *   | <span class='executed'>        emit BaseRateUpdated(newBaseRate);</span>
 193 |     | <span class='neutral'></span>
 194 | *   | <span class='executed'>        _updateLastFeeOpTime();</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>    /*</span>
 198 |     | <span class='neutral'>     * This function calculates the new baseRate in the following way:</span>
 199 |     | <span class='neutral'>     * 1) decays the baseRate based on time passed since last redemption or Bold borrowing operation.</span>
 200 |     | <span class='neutral'>     * then,</span>
 201 |     | <span class='neutral'>     * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply</span>
 202 |     | <span class='neutral'>     */</span>
 203 | *   | <span class='executed'>    function _getUpdatedBaseRateFromRedemption(uint256 _redeemAmount, uint256 _totalBoldSupply)</span>
 204 |     | <span class='neutral'>        internal</span>
 205 |     | <span class='neutral'>        view</span>
 206 | *   | <span class='executed'>        returns (uint256)</span>
 207 |     | <span class='neutral'>    {</span>
 208 |     | <span class='neutral'>        // decay the base rate</span>
 209 | *   | <span class='executed'>        uint256 decayedBaseRate = _calcDecayedBaseRate();</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>        // get the fraction of total supply that was redeemed</span>
 212 | *   | <span class='executed'>        uint256 redeemedBoldFraction = _redeemAmount * DECIMAL_PRECISION / _totalBoldSupply;</span>
 213 |     | <span class='neutral'></span>
 214 | *   | <span class='executed'>        uint256 newBaseRate = decayedBaseRate + redeemedBoldFraction / REDEMPTION_BETA;</span>
 215 | *   | <span class='executed'>        newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>        return newBaseRate;</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 | *   | <span class='executed'>    function _calcDecayedBaseRate() internal view returns (uint256) {</span>
 221 | *   | <span class='executed'>        uint256 minutesPassed = _minutesPassedSinceLastFeeOp();</span>
 222 | *   | <span class='executed'>        uint256 decayFactor = LiquityMath._decPow(REDEMPTION_MINUTE_DECAY_FACTOR, minutesPassed);</span>
 223 |     | <span class='neutral'></span>
 224 | *   | <span class='executed'>        return baseRate * decayFactor / DECIMAL_PRECISION;</span>
 225 |     | <span class='neutral'>    }</span>
 226 |     | <span class='neutral'></span>
 227 | *   | <span class='executed'>    function _calcRedemptionRate(uint256 _baseRate) internal pure returns (uint256) {</span>
 228 | *   | <span class='executed'>        return LiquityMath._min(</span>
 229 | *   | <span class='executed'>            REDEMPTION_FEE_FLOOR + _baseRate,</span>
 230 |     | <span class='neutral'>            DECIMAL_PRECISION // cap at a maximum of 100%</span>
 231 |     | <span class='neutral'>        );</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='unexecuted'>    function _calcRedemptionFee(uint256 _redemptionRate, uint256 _amount) internal pure returns (uint256) {</span>
 235 | *   | <span class='executed'>        uint256 redemptionFee = _redemptionRate * _amount / DECIMAL_PRECISION;</span>
 236 |     | <span class='neutral'>        return redemptionFee;</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    // external redemption rate/fee getters</span>
 240 |     | <span class='neutral'></span>
 241 | *   | <span class='executed'>    function getRedemptionRate() external view override returns (uint256) {</span>
 242 | *   | <span class='executed'>        return _calcRedemptionRate(baseRate);</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='unexecuted'>    function getRedemptionRateWithDecay() public view override returns (uint256) {</span>
 246 |     | <span class='unexecuted'>        return _calcRedemptionRate(_calcDecayedBaseRate());</span>
 247 |     | <span class='neutral'>    }</span>
 248 |     | <span class='neutral'></span>
 249 | *   | <span class='executed'>    function getRedemptionRateForRedeemedAmount(uint256 _redeemAmount) external view returns (uint256) {</span>
 250 |     | <span class='unexecuted'>        uint256 totalBoldSupply = boldToken.totalSupply();</span>
 251 |     | <span class='unexecuted'>        uint256 newBaseRate = _getUpdatedBaseRateFromRedemption(_redeemAmount, totalBoldSupply);</span>
 252 | *   | <span class='executed'>        return _calcRedemptionRate(newBaseRate);</span>
 253 |     | <span class='neutral'>    }</span>
 254 |     | <span class='neutral'></span>
 255 | *   | <span class='executed'>    function getRedemptionFeeWithDecay(uint256 _ETHDrawn) external view override returns (uint256) {</span>
 256 | *   | <span class='executed'>        return _calcRedemptionFee(getRedemptionRateWithDecay(), _ETHDrawn);</span>
 257 |     | <span class='neutral'>    }</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='unexecuted'>    function getEffectiveRedemptionFeeInBold(uint256 _redeemAmount) external view override returns (uint256) {</span>
 260 |     | <span class='unexecuted'>        uint256 totalBoldSupply = boldToken.totalSupply();</span>
 261 |     | <span class='unexecuted'>        uint256 newBaseRate = _getUpdatedBaseRateFromRedemption(_redeemAmount, totalBoldSupply);</span>
 262 |     | <span class='unexecuted'>        return _calcRedemptionFee(_calcRedemptionRate(newBaseRate), _redeemAmount);</span>
 263 |     | <span class='neutral'>    }</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>    // getters</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='unexecuted'>    function getToken(uint256 _index) external view returns (IERC20Metadata) {</span>
 268 |     | <span class='unexecuted'>        if (_index == 0) return token0;</span>
 269 |     | <span class='unexecuted'>        else if (_index == 1) return token1;</span>
 270 |     | <span class='unexecuted'>        else if (_index == 2) return token2;</span>
 271 |     | <span class='unexecuted'>        else if (_index == 3) return token3;</span>
 272 |     | <span class='unexecuted'>        else if (_index == 4) return token4;</span>
 273 |     | <span class='unexecuted'>        else if (_index == 5) return token5;</span>
 274 |     | <span class='unexecuted'>        else if (_index == 6) return token6;</span>
 275 |     | <span class='unexecuted'>        else if (_index == 7) return token7;</span>
 276 |     | <span class='unexecuted'>        else if (_index == 8) return token8;</span>
 277 |     | <span class='unexecuted'>        else if (_index == 9) return token9;</span>
 278 |     | <span class='neutral'>        else revert(&quot;Invalid index&quot;);</span>
 279 |     | <span class='neutral'>    }</span>
 280 |     | <span class='neutral'></span>
 281 | *   | <span class='executed'>    function getTroveManager(uint256 _index) public view returns (ITroveManager) {</span>
 282 | *   | <span class='executed'>        if (_index == 0) return troveManager0;</span>
 283 |     | <span class='unexecuted'>        else if (_index == 1) return troveManager1;</span>
 284 |     | <span class='unexecuted'>        else if (_index == 2) return troveManager2;</span>
 285 |     | <span class='unexecuted'>        else if (_index == 3) return troveManager3;</span>
 286 |     | <span class='unexecuted'>        else if (_index == 4) return troveManager4;</span>
 287 |     | <span class='unexecuted'>        else if (_index == 5) return troveManager5;</span>
 288 |     | <span class='unexecuted'>        else if (_index == 6) return troveManager6;</span>
 289 |     | <span class='unexecuted'>        else if (_index == 7) return troveManager7;</span>
 290 |     | <span class='unexecuted'>        else if (_index == 8) return troveManager8;</span>
 291 |     | <span class='unexecuted'>        else if (_index == 9) return troveManager9;</span>
 292 | *   | <span class='executed'>        else revert(&quot;Invalid index&quot;);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    // require functions</span>
 296 |     | <span class='neutral'></span>
 297 | *   | <span class='executed'>    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage) internal pure {</span>
 298 | *   | <span class='executed'>        require(</span>
 299 | *   | <span class='executed'>            _maxFeePercentage &gt;= REDEMPTION_FEE_FLOOR &amp;&amp; _maxFeePercentage &lt;= DECIMAL_PRECISION,</span>
 300 |     | <span class='neutral'>            &quot;Max fee percentage must be between 0.5% and 100%&quot;</span>
 301 |     | <span class='neutral'>        );</span>
 302 |     | <span class='neutral'>    }</span>
 303 |     | <span class='neutral'></span>
 304 | *   | <span class='executed'>    function _requireAmountGreaterThanZero(uint256 _amount) internal pure {</span>
 305 | *   | <span class='executed'>        require(_amount &gt; 0, &quot;CollateralRegistry: Amount must be greater than zero&quot;);</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'>}</span>
 308 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/DefaultPool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;./Interfaces/IDefaultPool.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./Interfaces/IAddressesRegistry.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./Interfaces/IActivePool.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/*</span>
  12 |     | <span class='neutral'> * The Default Pool holds the Coll and Bold debt (but not Bold tokens) from liquidations that have been redistributed</span>
  13 |     | <span class='neutral'> * to active troves but not yet &quot;applied&quot;, i.e. not yet recorded on a recipient active trove&#39;s struct.</span>
  14 |     | <span class='neutral'> *</span>
  15 |     | <span class='neutral'> * When a trove makes an operation that applies its pending Coll and Bold debt, its pending Coll and Bold debt is moved</span>
  16 |     | <span class='neutral'> * from the Default Pool to the Active Pool.</span>
  17 |     | <span class='neutral'> */</span>
  18 | *   | <span class='executed'>contract DefaultPool is IDefaultPool {</span>
  19 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    string public constant NAME = &quot;DefaultPool&quot;;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    IERC20 public immutable collToken;</span>
  24 |     | <span class='unexecuted'>    address public immutable troveManagerAddress;</span>
  25 |     | <span class='unexecuted'>    address public immutable activePoolAddress;</span>
  26 |     | <span class='neutral'>    uint256 internal collBalance; // deposited Coll tracker</span>
  27 |     | <span class='neutral'>    uint256 internal BoldDebt; // debt</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    event CollTokenAddressChanged(address _newCollTokenAddress);</span>
  30 |     | <span class='neutral'>    event ActivePoolAddressChanged(address _newActivePoolAddress);</span>
  31 |     | <span class='neutral'>    event TroveManagerAddressChanged(address _newTroveManagerAddress);</span>
  32 |     | <span class='neutral'>    event DefaultPoolBoldDebtUpdated(uint256 _boldDebt);</span>
  33 |     | <span class='neutral'>    event DefaultPoolCollBalanceUpdated(uint256 _collBalance);</span>
  34 |     | <span class='neutral'></span>
  35 | *   | <span class='executed'>    constructor(IAddressesRegistry _addressesRegistry) {</span>
  36 | *   | <span class='executed'>        collToken = _addressesRegistry.collToken();</span>
  37 | *   | <span class='executed'>        troveManagerAddress = address(_addressesRegistry.troveManager());</span>
  38 | *   | <span class='executed'>        activePoolAddress = address(_addressesRegistry.activePool());</span>
  39 |     | <span class='neutral'></span>
  40 | *   | <span class='executed'>        emit CollTokenAddressChanged(address(collToken));</span>
  41 | *   | <span class='executed'>        emit TroveManagerAddressChanged(troveManagerAddress);</span>
  42 | *   | <span class='executed'>        emit ActivePoolAddressChanged(activePoolAddress);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>        // Allow funds movements between Liquity contracts</span>
  45 | *   | <span class='executed'>        collToken.approve(activePoolAddress, type(uint256).max);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    // --- Getters for public variables. Required by IPool interface ---</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /*</span>
  51 |     | <span class='neutral'>    * Returns the collBalance state variable.</span>
  52 |     | <span class='neutral'>    *</span>
  53 |     | <span class='neutral'>    * Not necessarily equal to the the contract&#39;s raw Coll balance - ether can be forcibly sent to contracts.</span>
  54 |     | <span class='neutral'>    */</span>
  55 | *   | <span class='executed'>    function getCollBalance() external view override returns (uint256) {</span>
  56 | *   | <span class='executed'>        return collBalance;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 | *   | <span class='executed'>    function getBoldDebt() external view override returns (uint256) {</span>
  60 | *   | <span class='executed'>        return BoldDebt;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    // --- Pool functionality ---</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function sendCollToActivePool(uint256 _amount) external override {</span>
  66 |     | <span class='unexecuted'>        _requireCallerIsTroveManager();</span>
  67 |     | <span class='unexecuted'>        uint256 newCollBalance = collBalance - _amount;</span>
  68 |     | <span class='unexecuted'>        collBalance = newCollBalance;</span>
  69 |     | <span class='unexecuted'>        emit DefaultPoolCollBalanceUpdated(newCollBalance);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        // Send Coll to Active Pool and increase its recorded Coll balance</span>
  72 |     | <span class='unexecuted'>        IActivePool(activePoolAddress).receiveColl(_amount);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>    function receiveColl(uint256 _amount) external {</span>
  76 |     | <span class='unexecuted'>        _requireCallerIsActivePool();</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>        uint256 newCollBalance = collBalance + _amount;</span>
  79 |     | <span class='unexecuted'>        collBalance = newCollBalance;</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>        // Pull Coll tokens from ActivePool</span>
  82 |     | <span class='unexecuted'>        collToken.safeTransferFrom(msg.sender, address(this), _amount);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        emit DefaultPoolCollBalanceUpdated(newCollBalance);</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>    function increaseBoldDebt(uint256 _amount) external override {</span>
  88 |     | <span class='unexecuted'>        _requireCallerIsTroveManager();</span>
  89 |     | <span class='unexecuted'>        BoldDebt = BoldDebt + _amount;</span>
  90 |     | <span class='unexecuted'>        emit DefaultPoolBoldDebtUpdated(BoldDebt);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    function decreaseBoldDebt(uint256 _amount) external override {</span>
  94 |     | <span class='unexecuted'>        _requireCallerIsTroveManager();</span>
  95 |     | <span class='unexecuted'>        BoldDebt = BoldDebt - _amount;</span>
  96 |     | <span class='neutral'>        emit DefaultPoolBoldDebtUpdated(BoldDebt);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    // --- &#39;require&#39; functions ---</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>    function _requireCallerIsActivePool() internal view {</span>
 102 |     | <span class='unexecuted'>        require(msg.sender == activePoolAddress, &quot;DefaultPool: Caller is not the ActivePool&quot;);</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>    function _requireCallerIsTroveManager() internal view {</span>
 106 |     | <span class='unexecuted'>        require(msg.sender == troveManagerAddress, &quot;DefaultPool: Caller is not the TroveManager&quot;);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'>}</span>
 109 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Dependencies/AddRemoveManagers.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;../Interfaces/IAddRemoveManagers.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../Interfaces/IAddressesRegistry.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../Interfaces/ITroveNFT.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='unexecuted'>contract AddRemoveManagers is IAddRemoveManagers {</span>
  10 |     | <span class='neutral'>    ITroveNFT internal immutable troveNFT;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    struct RemoveManagerReceiver {</span>
  13 |     | <span class='neutral'>        address manager;</span>
  14 |     | <span class='neutral'>        address receiver;</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /*</span>
  18 |     | <span class='neutral'>     * Mapping from TroveId to granted address for operations that &quot;give&quot; money to the trove (add collateral, pay debt).</span>
  19 |     | <span class='neutral'>     * Useful for instance for cold/hot wallet setups.</span>
  20 |     | <span class='neutral'>     * If its value is zero address, any address is allowed to do those operations on behalf of trove owner.</span>
  21 |     | <span class='neutral'>     * Otherwise, only the address in this mapping (and the trove owner) will be allowed.</span>
  22 |     | <span class='neutral'>     * To restrict this permission to no one, trove owner should be set in this mapping.</span>
  23 |     | <span class='neutral'>     */</span>
  24 |     | <span class='unexecuted'>    mapping(uint256 =&gt; address) public addManagerOf;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /*</span>
  27 |     | <span class='neutral'>     * Mapping from TroveId to granted addresses for operations that &quot;withdraw&quot; money from the trove (withdraw collateral, borrow),</span>
  28 |     | <span class='neutral'>     * and for each of those addresses another address for the receiver of those withdrawn funds.</span>
  29 |     | <span class='neutral'>     * Useful for instance for cold/hot wallet setups or for automations.</span>
  30 |     | <span class='neutral'>     * Only the address in this mapping, if any, and the trove owner, will be allowed.</span>
  31 |     | <span class='neutral'>     * Therefore, by default this permission is restricted to no one.</span>
  32 |     | <span class='neutral'>     * If the receiver is zero, the owner is assumed as the receiver.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='unexecuted'>    mapping(uint256 =&gt; RemoveManagerReceiver) public removeManagerReceiverOf;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    error EmptyManager();</span>
  37 |     | <span class='neutral'>    error NotBorrower();</span>
  38 |     | <span class='neutral'>    error NotOwnerNorAddManager();</span>
  39 |     | <span class='neutral'>    error NotOwnerNorRemoveManager();</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    event TroveNFTAddressChanged(address _newTroveNFTAddress);</span>
  42 |     | <span class='neutral'>    event AddManagerUpdated(uint256 indexed _troveId, address _newAddManager);</span>
  43 |     | <span class='neutral'>    event RemoveManagerAndReceiverUpdated(uint256 indexed _troveId, address _newRemoveManager, address _newReceiver);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>    constructor(IAddressesRegistry _addressesRegistry) {</span>
  46 | *   | <span class='executed'>        troveNFT = _addressesRegistry.troveNFT();</span>
  47 | *   | <span class='executed'>        emit TroveNFTAddressChanged(address(troveNFT));</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 | *   | <span class='executed'>    function setAddManager(uint256 _troveId, address _manager) external {</span>
  51 | *   | <span class='executed'>        _requireCallerIsBorrower(_troveId);</span>
  52 | *   | <span class='executed'>        _setAddManager(_troveId, _manager);</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 | *   | <span class='executed'>    function _setAddManager(uint256 _troveId, address _manager) internal {</span>
  56 | *   | <span class='executed'>        addManagerOf[_troveId] = _manager;</span>
  57 | *   | <span class='executed'>        emit AddManagerUpdated(_troveId, _manager);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 | *   | <span class='executed'>    function setRemoveManager(uint256 _troveId, address _manager) external {</span>
  61 | *   | <span class='executed'>        setRemoveManagerWithReceiver(_troveId, _manager, troveNFT.ownerOf(_troveId));</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 | *   | <span class='executed'>    function setRemoveManagerWithReceiver(uint256 _troveId, address _manager, address _receiver) public {</span>
  65 | *   | <span class='executed'>        _requireCallerIsBorrower(_troveId);</span>
  66 | *   | <span class='executed'>        _setRemoveManagerAndReceiver(_troveId, _manager, _receiver);</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 | *   | <span class='executed'>    function _setRemoveManagerAndReceiver(uint256 _troveId, address _manager, address _receiver) internal {</span>
  70 | *   | <span class='executed'>        _requireNonZeroManagerUnlessWiping(_manager, _receiver);</span>
  71 | *   | <span class='executed'>        removeManagerReceiverOf[_troveId].manager = _manager;</span>
  72 | *   | <span class='executed'>        removeManagerReceiverOf[_troveId].receiver = _receiver;</span>
  73 | *   | <span class='executed'>        emit RemoveManagerAndReceiverUpdated(_troveId, _manager, _receiver);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>    function _wipeAddRemoveManagers(uint256 _troveId) internal {</span>
  77 |     | <span class='unexecuted'>        delete addManagerOf[_troveId];</span>
  78 |     | <span class='unexecuted'>        delete removeManagerReceiverOf[_troveId];</span>
  79 |     | <span class='unexecuted'>        emit AddManagerUpdated(_troveId, address(0));</span>
  80 |     | <span class='unexecuted'>        emit RemoveManagerAndReceiverUpdated(_troveId, address(0), address(0));</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 | *   | <span class='executed'>    function _requireNonZeroManagerUnlessWiping(address _manager, address _receiver) internal pure {</span>
  84 | *   | <span class='executed'>        if (_manager == address(0) &amp;&amp; _receiver != address(0)) {</span>
  85 |     | <span class='unexecuted'>            revert EmptyManager();</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 | *   | <span class='executed'>    function _requireCallerIsBorrower(uint256 _troveId) internal view {</span>
  90 | *   | <span class='executed'>        if (msg.sender != troveNFT.ownerOf(_troveId)) {</span>
  91 | *   | <span class='executed'>            revert NotBorrower();</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 | *   | <span class='executed'>    function _requireSenderIsOwnerOrAddManager(uint256 _troveId, address _owner) internal view {</span>
  96 | *   | <span class='executed'>        address addManager = addManagerOf[_troveId];</span>
  97 | *   | <span class='executed'>        if (msg.sender != _owner &amp;&amp; addManager != address(0) &amp;&amp; msg.sender != addManager) {</span>
  98 |     | <span class='unexecuted'>            revert NotOwnerNorAddManager();</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 | *   | <span class='executed'>    function _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(uint256 _troveId, address _owner)</span>
 103 |     | <span class='neutral'>        internal</span>
 104 |     | <span class='neutral'>        view</span>
 105 | *   | <span class='executed'>        returns (address)</span>
 106 |     | <span class='neutral'>    {</span>
 107 | *   | <span class='executed'>        address manager = removeManagerReceiverOf[_troveId].manager;</span>
 108 | *   | <span class='executed'>        address receiver = removeManagerReceiverOf[_troveId].receiver;</span>
 109 | *   | <span class='executed'>        if (msg.sender != _owner &amp;&amp; msg.sender != manager) {</span>
 110 | *   | <span class='executed'>            revert NotOwnerNorRemoveManager();</span>
 111 |     | <span class='neutral'>        }</span>
 112 | *   | <span class='executed'>        if (receiver == address(0) || msg.sender != manager) {</span>
 113 | *   | <span class='executed'>            return _owner;</span>
 114 |     | <span class='neutral'>        }</span>
 115 |     | <span class='unexecuted'>        return receiver;</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'>}</span>
 118 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Dependencies/AggregatorV3Interface.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// Code from https://github.com/smartcontractkit/chainlink/blob/master/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface AggregatorV3Interface {</span>
  7 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
  8 |     | <span class='neutral'>    function latestRoundData()</span>
  9 |     | <span class='neutral'>        external</span>
 10 |     | <span class='neutral'>        view</span>
 11 |     | <span class='neutral'>        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Dependencies/Constants.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>address constant ZERO_ADDRESS = address(0);</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>uint256 constant MAX_UINT256 = type(uint256).max;</span>
  7 |     | <span class='neutral'></span>
  8 | *   | <span class='executed'>uint256 constant DECIMAL_PRECISION = 1e18;</span>
  9 |     | <span class='neutral'>uint256 constant _100pct = DECIMAL_PRECISION;</span>
 10 | *   | <span class='executed'>uint256 constant _1pct = DECIMAL_PRECISION / 100;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>// Amount of ETH to be locked in gas pool on opening troves</span>
 13 | *   | <span class='executed'>uint256 constant ETH_GAS_COMPENSATION = 0.0375 ether;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>// Liquidation</span>
 16 | *   | <span class='executed'>uint256 constant MIN_LIQUIDATION_PENALTY_SP = 5e16; // 5%</span>
 17 | *   | <span class='executed'>uint256 constant MAX_LIQUIDATION_PENALTY_REDISTRIBUTION = 20e16; // 20%</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>// Fraction of collateral awarded to liquidator</span>
 20 |     | <span class='unexecuted'>uint256 constant COLL_GAS_COMPENSATION_DIVISOR = 200; // dividing by 200 yields 0.5%</span>
 21 |     | <span class='unexecuted'>uint256 constant COLL_GAS_COMPENSATION_CAP = 2 ether; // Max coll gas compensation capped at 2 ETH</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>// Minimum amount of net Bold debt a trove must have</span>
 24 | *   | <span class='executed'>uint256 constant MIN_DEBT = 2000e18;</span>
 25 |     | <span class='neutral'></span>
 26 | *   | <span class='executed'>uint256 constant MIN_ANNUAL_INTEREST_RATE = _1pct / 2; // 0.5%</span>
 27 | *   | <span class='executed'>uint256 constant MAX_ANNUAL_INTEREST_RATE = 250 * _1pct;</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>// Batch management params</span>
 30 | *   | <span class='executed'>uint128 constant MAX_ANNUAL_BATCH_MANAGEMENT_FEE = uint128(_100pct / 10); // 10%</span>
 31 | *   | <span class='executed'>uint128 constant MIN_INTEREST_RATE_CHANGE_PERIOD = 1 hours; // only applies to batch managers / batched Troves</span>
 32 |     | <span class='neutral'></span>
 33 | *   | <span class='executed'>uint256 constant REDEMPTION_FEE_FLOOR = _1pct / 2; // 0.5%</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>// For the debt / shares ratio to increase by a factor 1e9</span>
 36 |     | <span class='neutral'>// at a average annual debt increase (compounded interest + fees) of 10%, it would take more than 217 years (log(1e9)/log(1.1))</span>
 37 |     | <span class='neutral'>// at a average annual debt increase (compounded interest + fees) of 50%, it would take more than 51 years (log(1e9)/log(1.5))</span>
 38 |     | <span class='neutral'>// The increase pace could be forced to be higher through an inflation attack,</span>
 39 |     | <span class='neutral'>// but precisely the fact that we have this max value now prevents the attack</span>
 40 | *   | <span class='executed'>uint256 constant MAX_BATCH_SHARES_RATIO = 1e9;</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>// Half-life of 6h. 6h = 360 min</span>
 43 |     | <span class='neutral'>// (1/2) = d^360 =&gt; d = (1/2)^(1/360)</span>
 44 | *   | <span class='executed'>uint256 constant REDEMPTION_MINUTE_DECAY_FACTOR = 998076443575628800;</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>// BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.</span>
 47 |     | <span class='neutral'>// Corresponds to (1 / ALPHA) in the white paper.</span>
 48 | *   | <span class='executed'>uint256 constant REDEMPTION_BETA = 1;</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>// To prevent redemptions unless Bold depegs below 0.95 and allow the system to take off</span>
 51 |     | <span class='neutral'>uint256 constant INITIAL_BASE_RATE = _100pct; // 100% initial redemption rate</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>// Discount to be used once the shutdown thas been triggered</span>
 54 |     | <span class='unexecuted'>uint256 constant URGENT_REDEMPTION_BONUS = 2e16; // 2%</span>
 55 |     | <span class='neutral'></span>
 56 | *   | <span class='executed'>uint256 constant ONE_MINUTE = 1 minutes;</span>
 57 | *   | <span class='executed'>uint256 constant ONE_YEAR = 365 days;</span>
 58 | *   | <span class='executed'>uint256 constant UPFRONT_INTEREST_PERIOD = 7 days;</span>
 59 | *   | <span class='executed'>uint256 constant INTEREST_RATE_ADJ_COOLDOWN = 7 days;</span>
 60 |     | <span class='neutral'></span>
 61 | *   | <span class='executed'>uint256 constant SP_YIELD_SPLIT = 75 * _1pct; // 75%</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>// Dummy contract that lets legacy Hardhat tests query some of the constants</span>
 64 |     | <span class='unexecuted'>contract Constants {</span>
 65 |     | <span class='unexecuted'>    uint256 public constant _ETH_GAS_COMPENSATION = ETH_GAS_COMPENSATION;</span>
 66 |     | <span class='unexecuted'>    uint256 public constant _MIN_DEBT = MIN_DEBT;</span>
 67 |     | <span class='neutral'>}</span>
 68 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Dependencies/IOsTokenVaultController.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'></span>
 3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
 4 |     | <span class='neutral'></span>
 5 |     | <span class='neutral'>interface IOsTokenVaultController {</span>
 6 |     | <span class='neutral'>    function convertToAssets(uint256 shares) external view returns (uint256);</span>
 7 |     | <span class='neutral'>}</span>
 8 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Dependencies/IStaderOracle.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'></span>
 3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
 4 |     | <span class='neutral'></span>
 5 |     | <span class='neutral'>interface IStaderOracle {</span>
 6 |     | <span class='neutral'>    function exchangeRate() external view returns (uint256, uint256, uint256);</span>
 7 |     | <span class='neutral'>}</span>
 8 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Dependencies/LiquityBase.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./Constants.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./LiquityMath.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../Interfaces/IAddressesRegistry.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../Interfaces/IActivePool.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;../Interfaces/IDefaultPool.sol&quot;;</span>
 10 |     | <span class='neutral'>import &quot;../Interfaces/IPriceFeed.sol&quot;;</span>
 11 |     | <span class='neutral'>import &quot;../Interfaces/ILiquityBase.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>/*</span>
 14 |     | <span class='neutral'>* Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and</span>
 15 |     | <span class='neutral'>* common functions.</span>
 16 |     | <span class='neutral'>*/</span>
 17 |     | <span class='unexecuted'>contract LiquityBase is ILiquityBase {</span>
 18 | *   | <span class='executed'>    IActivePool public activePool;</span>
 19 |     | <span class='neutral'>    IDefaultPool internal defaultPool;</span>
 20 |     | <span class='unexecuted'>    IPriceFeed public priceFeed;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    event ActivePoolAddressChanged(address _newActivePoolAddress);</span>
 23 |     | <span class='neutral'>    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);</span>
 24 |     | <span class='neutral'>    event PriceFeedAddressChanged(address _newPriceFeedAddress);</span>
 25 |     | <span class='neutral'></span>
 26 | *   | <span class='executed'>    constructor(IAddressesRegistry _addressesRegistry) {</span>
 27 | *   | <span class='executed'>        activePool = _addressesRegistry.activePool();</span>
 28 | *   | <span class='executed'>        defaultPool = _addressesRegistry.defaultPool();</span>
 29 | *   | <span class='executed'>        priceFeed = _addressesRegistry.priceFeed();</span>
 30 |     | <span class='neutral'></span>
 31 | *   | <span class='executed'>        emit ActivePoolAddressChanged(address(activePool));</span>
 32 | *   | <span class='executed'>        emit DefaultPoolAddressChanged(address(defaultPool));</span>
 33 | *   | <span class='executed'>        emit PriceFeedAddressChanged(address(priceFeed));</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'>    // --- Gas compensation functions ---</span>
 36 |     | <span class='neutral'></span>
 37 | *   | <span class='executed'>    function getEntireSystemColl() public view returns (uint256 entireSystemColl) {</span>
 38 | *   | <span class='executed'>        uint256 activeColl = activePool.getCollBalance();</span>
 39 | *   | <span class='executed'>        uint256 liquidatedColl = defaultPool.getCollBalance();</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>        return activeColl + liquidatedColl;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 | *   | <span class='executed'>    function getEntireSystemDebt() public view returns (uint256 entireSystemDebt) {</span>
 45 | *   | <span class='executed'>        uint256 activeDebt = activePool.getBoldDebt();</span>
 46 | *   | <span class='executed'>        uint256 closedDebt = defaultPool.getBoldDebt();</span>
 47 |     | <span class='neutral'></span>
 48 | *   | <span class='executed'>        return activeDebt + closedDebt;</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 | *   | <span class='executed'>    function _getTCR(uint256 _price) internal view returns (uint256 TCR) {</span>
 52 | *   | <span class='executed'>        uint256 entireSystemColl = getEntireSystemColl();</span>
 53 | *   | <span class='executed'>        uint256 entireSystemDebt = getEntireSystemDebt();</span>
 54 |     | <span class='neutral'></span>
 55 | *   | <span class='executed'>        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, _price);</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>        return TCR;</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'></span>
 60 | *   | <span class='executed'>    function _checkBelowCriticalThreshold(uint256 _price, uint256 _CCR) internal view returns (bool) {</span>
 61 | *   | <span class='executed'>        uint256 TCR = _getTCR(_price);</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>        return TCR &lt; _CCR;</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'></span>
 66 | *   | <span class='executed'>    function _calcInterest(uint256 _weightedDebt, uint256 _period) internal pure returns (uint256) {</span>
 67 | *   | <span class='executed'>        return _weightedDebt * _period / ONE_YEAR / DECIMAL_PRECISION;</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'>}</span>
 70 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Dependencies/LiquityMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {DECIMAL_PRECISION} from &quot;./Constants.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library LiquityMath {</span>
  8 | *   | <span class='executed'>    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {</span>
  9 | *   | <span class='executed'>        return (_a &lt; _b) ? _a : _b;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 | *   | <span class='executed'>    function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {</span>
 13 | *   | <span class='executed'>        return (_a &gt;= _b) ? _a : _b;</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function _sub_min_0(uint256 _a, uint256 _b) internal pure returns (uint256) {</span>
 17 |     | <span class='neutral'>        return (_a &gt; _b) ? _a - _b : 0;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /* </span>
 21 |     | <span class='neutral'>    * Multiply two decimal numbers and use normal rounding rules:</span>
 22 |     | <span class='neutral'>    * -round product up if 19&#39;th mantissa digit &gt;= 5</span>
 23 |     | <span class='neutral'>    * -round product down if 19&#39;th mantissa digit &lt; 5</span>
 24 |     | <span class='neutral'>    *</span>
 25 |     | <span class='neutral'>    * Used only inside the exponentiation, _decPow().</span>
 26 |     | <span class='neutral'>    */</span>
 27 | *   | <span class='executed'>    function decMul(uint256 x, uint256 y) internal pure returns (uint256 decProd) {</span>
 28 | *   | <span class='executed'>        uint256 prod_xy = x * y;</span>
 29 |     | <span class='neutral'></span>
 30 | *   | <span class='executed'>        decProd = (prod_xy + DECIMAL_PRECISION / 2) / DECIMAL_PRECISION;</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    /* </span>
 34 |     | <span class='neutral'>    * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.</span>
 35 |     | <span class='neutral'>    * </span>
 36 |     | <span class='neutral'>    * Uses the efficient &quot;exponentiation by squaring&quot; algorithm. O(log(n)) complexity. </span>
 37 |     | <span class='neutral'>    * </span>
 38 |     | <span class='neutral'>    * Called by function CollateralRegistry._calcDecayedBaseRate, that represent time in units of minutes</span>
 39 |     | <span class='neutral'>    *</span>
 40 |     | <span class='neutral'>    * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals</span>
 41 |     | <span class='neutral'>    * &quot;minutes in 1000 years&quot;: 60 * 24 * 365 * 1000</span>
 42 |     | <span class='neutral'>    * </span>
 43 |     | <span class='neutral'>    * If a period of &gt; 1000 years is ever used as an exponent in either of the above functions, the result will be</span>
 44 |     | <span class='neutral'>    * negligibly different from just passing the cap, since: </span>
 45 |     | <span class='neutral'>    *</span>
 46 |     | <span class='neutral'>    * In function 1), the decayed base rate will be 0 for 1000 years or &gt; 1000 years</span>
 47 |     | <span class='neutral'>    * In function 2), the difference in tokens issued at 1000 years and any time &gt; 1000 years, will be negligible</span>
 48 |     | <span class='neutral'>    */</span>
 49 | *   | <span class='executed'>    function _decPow(uint256 _base, uint256 _minutes) internal pure returns (uint256) {</span>
 50 | *   | <span class='executed'>        if (_minutes &gt; 525600000) _minutes = 525600000; // cap to avoid overflow</span>
 51 |     | <span class='neutral'></span>
 52 | *   | <span class='executed'>        if (_minutes == 0) return DECIMAL_PRECISION;</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>        uint256 y = DECIMAL_PRECISION;</span>
 55 | *   | <span class='executed'>        uint256 x = _base;</span>
 56 | *   | <span class='executed'>        uint256 n = _minutes;</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>        // Exponentiation-by-squaring</span>
 59 | *   | <span class='executed'>        while (n &gt; 1) {</span>
 60 | *   | <span class='executed'>            if (n % 2 == 0) {</span>
 61 | *   | <span class='executed'>                x = decMul(x, x);</span>
 62 | *   | <span class='executed'>                n = n / 2;</span>
 63 |     | <span class='neutral'>            } else {</span>
 64 |     | <span class='neutral'>                // if (n % 2 != 0)</span>
 65 | *   | <span class='executed'>                y = decMul(x, y);</span>
 66 | *   | <span class='executed'>                x = decMul(x, x);</span>
 67 | *   | <span class='executed'>                n = (n - 1) / 2;</span>
 68 |     | <span class='neutral'>            }</span>
 69 |     | <span class='neutral'>        }</span>
 70 |     | <span class='neutral'></span>
 71 | *   | <span class='executed'>        return decMul(x, y);</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'></span>
 74 | *   | <span class='executed'>    function _getAbsoluteDifference(uint256 _a, uint256 _b) internal pure returns (uint256) {</span>
 75 | *   | <span class='executed'>        return (_a &gt;= _b) ? _a - _b : _b - _a;</span>
 76 |     | <span class='neutral'>    }</span>
 77 |     | <span class='neutral'></span>
 78 | *   | <span class='executed'>    function _computeCR(uint256 _coll, uint256 _debt, uint256 _price) internal pure returns (uint256) {</span>
 79 | *   | <span class='executed'>        if (_debt &gt; 0) {</span>
 80 | *   | <span class='executed'>            uint256 newCollRatio = _coll * _price / _debt;</span>
 81 |     | <span class='neutral'></span>
 82 | *   | <span class='executed'>            return newCollRatio;</span>
 83 |     | <span class='neutral'>        }</span>
 84 |     | <span class='neutral'>        // Return the maximal value for uint256 if the debt is 0. Represents &quot;infinite&quot; CR.</span>
 85 |     | <span class='neutral'>        else {</span>
 86 |     | <span class='neutral'>            // if (_debt == 0)</span>
 87 |     | <span class='neutral'>            return 2 ** 256 - 1;</span>
 88 |     | <span class='neutral'>        }</span>
 89 |     | <span class='neutral'>    }</span>
 90 |     | <span class='neutral'>}</span>
 91 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Dependencies/Ownable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>/**</span>
  6 |     | <span class='neutral'> * Based on OpenZeppelin&#39;s Ownable contract:</span>
  7 |     | <span class='neutral'> * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol</span>
  8 |     | <span class='neutral'> *</span>
  9 |     | <span class='neutral'> * @dev Contract module which provides a basic access control mechanism, where</span>
 10 |     | <span class='neutral'> * there is an account (an owner) that can be granted exclusive access to</span>
 11 |     | <span class='neutral'> * specific functions.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * This module is used through inheritance. It will make available the modifier</span>
 14 |     | <span class='neutral'> * `onlyOwner`, which can be applied to your functions to restrict their use to</span>
 15 |     | <span class='neutral'> * the owner.</span>
 16 |     | <span class='neutral'> */</span>
 17 |     | <span class='unexecuted'>contract Ownable {</span>
 18 |     | <span class='neutral'>    address private _owner;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    /**</span>
 23 |     | <span class='neutral'>     * @dev Initializes the contract setting `initialOwner` as the initial owner.</span>
 24 |     | <span class='neutral'>     */</span>
 25 | *   | <span class='executed'>    constructor(address initialOwner) {</span>
 26 | *   | <span class='executed'>        _owner = initialOwner;</span>
 27 | *   | <span class='executed'>        emit OwnershipTransferred(address(0), initialOwner);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    /**</span>
 31 |     | <span class='neutral'>     * @dev Returns the address of the current owner.</span>
 32 |     | <span class='neutral'>     */</span>
 33 |     | <span class='unexecuted'>    function owner() public view returns (address) {</span>
 34 |     | <span class='unexecuted'>        return _owner;</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    /**</span>
 38 |     | <span class='neutral'>     * @dev Throws if called by any account other than the owner.</span>
 39 |     | <span class='neutral'>     */</span>
 40 |     | <span class='neutral'>    modifier onlyOwner() {</span>
 41 | *   | <span class='executed'>        require(isOwner(), &quot;Ownable: caller is not the owner&quot;);</span>
 42 |     | <span class='neutral'>        _;</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    /**</span>
 46 |     | <span class='neutral'>     * @dev Returns true if the caller is the current owner.</span>
 47 |     | <span class='neutral'>     */</span>
 48 | *   | <span class='executed'>    function isOwner() public view returns (bool) {</span>
 49 | *   | <span class='executed'>        return msg.sender == _owner;</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Leaves the contract without owner. It will not be possible to call</span>
 54 |     | <span class='neutral'>     * `onlyOwner` functions anymore.</span>
 55 |     | <span class='neutral'>     *</span>
 56 |     | <span class='neutral'>     * NOTE: Renouncing ownership will leave the contract without an owner,</span>
 57 |     | <span class='neutral'>     * thereby removing any functionality that is only available to the owner.</span>
 58 |     | <span class='neutral'>     *</span>
 59 |     | <span class='neutral'>     * NOTE: This function is not safe, as it doesn’t check owner is calling it.</span>
 60 |     | <span class='neutral'>     * Make sure you check it before calling it.</span>
 61 |     | <span class='neutral'>     */</span>
 62 | *   | <span class='executed'>    function _renounceOwnership() internal {</span>
 63 | *   | <span class='executed'>        emit OwnershipTransferred(_owner, address(0));</span>
 64 | *   | <span class='executed'>        _owner = address(0);</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'>}</span>
 67 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/GasPool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./Interfaces/IAddressesRegistry.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./Interfaces/IBorrowerOperations.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;./Interfaces/ITroveManager.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>/**</span>
 11 |     | <span class='neutral'> * The purpose of this contract is to hold WETH tokens for gas compensation:</span>
 12 |     | <span class='neutral'> * https://github.com/liquity/bold/?tab=readme-ov-file#liquidation-gas-compensation</span>
 13 |     | <span class='neutral'> * When a borrower opens a trove, an additional amount of WETH is pulled,</span>
 14 |     | <span class='neutral'> * and sent to this contract.</span>
 15 |     | <span class='neutral'> * When a borrower closes their active trove, this gas compensation is refunded</span>
 16 |     | <span class='neutral'> * When a trove is liquidated, this gas compensation is paid to liquidator</span>
 17 |     | <span class='neutral'> */</span>
 18 | *   | <span class='executed'>contract GasPool {</span>
 19 | *   | <span class='executed'>    constructor(IAddressesRegistry _addressesRegistry) {</span>
 20 | *   | <span class='executed'>        IWETH WETH = _addressesRegistry.WETH();</span>
 21 | *   | <span class='executed'>        IBorrowerOperations borrowerOperations = _addressesRegistry.borrowerOperations();</span>
 22 | *   | <span class='executed'>        ITroveManager troveManager = _addressesRegistry.troveManager();</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>        // Allow BorrowerOperations to refund gas compensation</span>
 25 | *   | <span class='executed'>        WETH.approve(address(borrowerOperations), type(uint256).max);</span>
 26 |     | <span class='neutral'>        // Allow TroveManager to pay gas compensation to liquidator</span>
 27 | *   | <span class='executed'>        WETH.approve(address(troveManager), type(uint256).max);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/HintHelpers.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./Interfaces/ICollateralRegistry.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Dependencies/LiquityMath.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Dependencies/Constants.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./Interfaces/IHintHelpers.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 | *   | <span class='executed'>contract HintHelpers is IHintHelpers {</span>
  11 |     | <span class='unexecuted'>    string public constant NAME = &quot;HintHelpers&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>    ICollateralRegistry public immutable collateralRegistry;</span>
  14 |     | <span class='neutral'></span>
  15 | *   | <span class='executed'>    constructor(ICollateralRegistry _collateralRegistry) {</span>
  16 | *   | <span class='executed'>        collateralRegistry = _collateralRegistry;</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    /* getApproxHint() - return id of a Trove that is, on average, (length / numTrials) positions away in the</span>
  20 |     | <span class='neutral'>    sortedTroves list from the correct insert position of the Trove to be inserted. </span>
  21 |     | <span class='neutral'>    </span>
  22 |     | <span class='neutral'>    Note: The output id is worst-case O(n) positions away from the correct insert position, however, the function</span>
  23 |     | <span class='neutral'>    is probabilistic. Input can be tuned to guarantee results to a high degree of confidence, e.g:</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    Submitting numTrials = k * sqrt(length), with k = 15 makes it very, very likely that the ouput id will</span>
  26 |     | <span class='neutral'>    be &lt;= sqrt(length) positions away from the correct insert position.</span>
  27 |     | <span class='neutral'>    */</span>
  28 | *   | <span class='executed'>    function getApproxHint(uint256 _collIndex, uint256 _interestRate, uint256 _numTrials, uint256 _inputRandomSeed)</span>
  29 |     | <span class='neutral'>        external</span>
  30 |     | <span class='neutral'>        view</span>
  31 |     | <span class='unexecuted'>        returns (uint256 hintId, uint256 diff, uint256 latestRandomSeed)</span>
  32 |     | <span class='unexecuted'>    {</span>
  33 |     | <span class='unexecuted'>        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);</span>
  34 |     | <span class='unexecuted'>        ISortedTroves sortedTroves = troveManager.sortedTroves();</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>        uint256 arrayLength = troveManager.getTroveIdsCount();</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>        if (arrayLength == 0) {</span>
  39 |     | <span class='unexecuted'>            return (0, 0, _inputRandomSeed);</span>
  40 |     | <span class='neutral'>        }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>        hintId = sortedTroves.getLast();</span>
  43 |     | <span class='unexecuted'>        diff = LiquityMath._getAbsoluteDifference(_interestRate, troveManager.getTroveAnnualInterestRate(hintId));</span>
  44 |     | <span class='unexecuted'>        latestRandomSeed = _inputRandomSeed;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>        for (uint256 i = 1; i &lt; _numTrials; ++i) {</span>
  47 |     | <span class='unexecuted'>            latestRandomSeed = uint256(keccak256(abi.encodePacked(latestRandomSeed)));</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>            uint256 arrayIndex = latestRandomSeed % arrayLength;</span>
  50 |     | <span class='unexecuted'>            uint256 currentId = troveManager.getTroveFromTroveIdsArray(arrayIndex);</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>            // Skip this Trove if it&#39;s zombie and not in the sorted list</span>
  53 |     | <span class='unexecuted'>            if (!sortedTroves.contains(currentId)) continue;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>            uint256 currentInterestRate = troveManager.getTroveAnnualInterestRate(currentId);</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>            // check if abs(current - IR) &gt; abs(closest - IR), and update closest if current is closer</span>
  58 |     | <span class='unexecuted'>            uint256 currentDiff = LiquityMath._getAbsoluteDifference(currentInterestRate, _interestRate);</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>            if (currentDiff &lt; diff) {</span>
  61 |     | <span class='unexecuted'>                diff = currentDiff;</span>
  62 |     | <span class='unexecuted'>                hintId = currentId;</span>
  63 |     | <span class='neutral'>            }</span>
  64 |     | <span class='neutral'>        }</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 | *   | <span class='executed'>    function _calcUpfrontFee(uint256 _debt, uint256 _avgInterestRate) internal pure returns (uint256) {</span>
  68 | *   | <span class='executed'>        return _debt * _avgInterestRate * UPFRONT_INTEREST_PERIOD / ONE_YEAR / DECIMAL_PRECISION;</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 | *   | <span class='executed'>    function predictOpenTroveUpfrontFee(uint256 _collIndex, uint256 _borrowedAmount, uint256 _interestRate)</span>
  72 |     | <span class='neutral'>        external</span>
  73 |     | <span class='neutral'>        view</span>
  74 | *   | <span class='executed'>        returns (uint256)</span>
  75 |     | <span class='neutral'>    {</span>
  76 | *   | <span class='executed'>        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);</span>
  77 | *   | <span class='executed'>        IActivePool activePool = troveManager.activePool();</span>
  78 |     | <span class='neutral'></span>
  79 | *   | <span class='executed'>        TroveChange memory openTrove;</span>
  80 | *   | <span class='executed'>        openTrove.debtIncrease = _borrowedAmount;</span>
  81 | *   | <span class='executed'>        openTrove.newWeightedRecordedDebt = openTrove.debtIncrease * _interestRate;</span>
  82 |     | <span class='neutral'></span>
  83 | *   | <span class='executed'>        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(openTrove);</span>
  84 | *   | <span class='executed'>        return _calcUpfrontFee(openTrove.debtIncrease, avgInterestRate);</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 | *   | <span class='executed'>    function predictAdjustInterestRateUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _newInterestRate)</span>
  88 |     | <span class='neutral'>        external</span>
  89 |     | <span class='neutral'>        view</span>
  90 | *   | <span class='executed'>        returns (uint256)</span>
  91 |     | <span class='neutral'>    {</span>
  92 | *   | <span class='executed'>        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);</span>
  93 | *   | <span class='executed'>        IActivePool activePool = troveManager.activePool();</span>
  94 | *   | <span class='executed'>        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);</span>
  95 |     | <span class='neutral'></span>
  96 | *   | <span class='executed'>        if (</span>
  97 | *   | <span class='executed'>            _newInterestRate == trove.annualInterestRate</span>
  98 | *   | <span class='executed'>                || block.timestamp &gt;= trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN</span>
  99 |     | <span class='neutral'>        ) {</span>
 100 | *   | <span class='executed'>            return 0;</span>
 101 |     | <span class='neutral'>        }</span>
 102 |     | <span class='neutral'></span>
 103 | *   | <span class='executed'>        return _predictAdjustInterestRateUpfrontFee(activePool, trove, _newInterestRate);</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>    function forcePredictAdjustInterestRateUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _newInterestRate)</span>
 107 |     | <span class='neutral'>        external</span>
 108 |     | <span class='neutral'>        view</span>
 109 |     | <span class='unexecuted'>        returns (uint256)</span>
 110 |     | <span class='neutral'>    {</span>
 111 |     | <span class='unexecuted'>        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);</span>
 112 |     | <span class='unexecuted'>        IActivePool activePool = troveManager.activePool();</span>
 113 |     | <span class='unexecuted'>        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>        return _predictAdjustInterestRateUpfrontFee(activePool, trove, _newInterestRate);</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 | *   | <span class='executed'>    function _predictAdjustInterestRateUpfrontFee(</span>
 119 |     | <span class='neutral'>        IActivePool _activePool,</span>
 120 |     | <span class='neutral'>        LatestTroveData memory _trove,</span>
 121 |     | <span class='neutral'>        uint256 _newInterestRate</span>
 122 | *   | <span class='executed'>    ) internal view returns (uint256) {</span>
 123 | *   | <span class='executed'>        TroveChange memory troveChange;</span>
 124 | *   | <span class='executed'>        troveChange.appliedRedistBoldDebtGain = _trove.redistBoldDebtGain;</span>
 125 | *   | <span class='executed'>        troveChange.newWeightedRecordedDebt = _trove.entireDebt * _newInterestRate;</span>
 126 | *   | <span class='executed'>        troveChange.oldWeightedRecordedDebt = _trove.weightedRecordedDebt;</span>
 127 |     | <span class='neutral'></span>
 128 | *   | <span class='executed'>        uint256 avgInterestRate = _activePool.getNewApproxAvgInterestRateFromTroveChange(troveChange);</span>
 129 | *   | <span class='executed'>        return _calcUpfrontFee(_trove.entireDebt, avgInterestRate);</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='unexecuted'>    function predictAdjustTroveUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _debtIncrease)</span>
 133 |     | <span class='neutral'>        external</span>
 134 |     | <span class='neutral'>        view</span>
 135 |     | <span class='unexecuted'>        returns (uint256)</span>
 136 |     | <span class='neutral'>    {</span>
 137 |     | <span class='unexecuted'>        if (_debtIncrease == 0) return 0;</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);</span>
 140 |     | <span class='unexecuted'>        IActivePool activePool = troveManager.activePool();</span>
 141 |     | <span class='unexecuted'>        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);</span>
 142 |     | <span class='unexecuted'>        (,,,,,,,, address batchManager,) = troveManager.Troves(_troveId);</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>        TroveChange memory troveChange;</span>
 145 |     | <span class='unexecuted'>        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;</span>
 146 |     | <span class='unexecuted'>        troveChange.debtIncrease = _debtIncrease;</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='unexecuted'>        if (batchManager == address(0)) {</span>
 149 |     | <span class='unexecuted'>            troveChange.newWeightedRecordedDebt = (trove.entireDebt + _debtIncrease) * trove.annualInterestRate;</span>
 150 |     | <span class='unexecuted'>            troveChange.oldWeightedRecordedDebt = trove.weightedRecordedDebt;</span>
 151 |     | <span class='neutral'>        } else {</span>
 152 |     | <span class='unexecuted'>            LatestBatchData memory batch = troveManager.getLatestBatchData(batchManager);</span>
 153 |     | <span class='unexecuted'>            troveChange.batchAccruedManagementFee = batch.accruedManagementFee;</span>
 154 |     | <span class='unexecuted'>            troveChange.newWeightedRecordedDebt = (</span>
 155 |     | <span class='unexecuted'>                batch.entireDebtWithoutRedistribution + trove.redistBoldDebtGain + _debtIncrease</span>
 156 |     | <span class='unexecuted'>            ) * batch.annualInterestRate;</span>
 157 |     | <span class='unexecuted'>            troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(troveChange);</span>
 161 |     | <span class='unexecuted'>        return _calcUpfrontFee(_debtIncrease, avgInterestRate);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='unexecuted'>    function predictAdjustBatchInterestRateUpfrontFee(</span>
 165 |     | <span class='neutral'>        uint256 _collIndex,</span>
 166 |     | <span class='neutral'>        address _batchAddress,</span>
 167 |     | <span class='neutral'>        uint256 _newInterestRate</span>
 168 |     | <span class='unexecuted'>    ) external view returns (uint256) {</span>
 169 |     | <span class='unexecuted'>        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);</span>
 170 |     | <span class='unexecuted'>        IActivePool activePool = troveManager.activePool();</span>
 171 |     | <span class='unexecuted'>        LatestBatchData memory batch = troveManager.getLatestBatchData(_batchAddress);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='unexecuted'>        if (</span>
 174 |     | <span class='unexecuted'>            _newInterestRate == batch.annualInterestRate</span>
 175 |     | <span class='unexecuted'>                || block.timestamp &gt;= batch.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN</span>
 176 |     | <span class='neutral'>        ) {</span>
 177 |     | <span class='unexecuted'>            return 0;</span>
 178 |     | <span class='neutral'>        }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='unexecuted'>        TroveChange memory troveChange;</span>
 181 |     | <span class='unexecuted'>        troveChange.batchAccruedManagementFee = batch.accruedManagementFee;</span>
 182 |     | <span class='unexecuted'>        troveChange.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * _newInterestRate;</span>
 183 |     | <span class='unexecuted'>        troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='unexecuted'>        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(troveChange);</span>
 186 |     | <span class='unexecuted'>        return _calcUpfrontFee(batch.entireDebtWithoutRedistribution, avgInterestRate);</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='unexecuted'>    function predictOpenTroveAndJoinBatchUpfrontFee(uint256 _collIndex, uint256 _borrowedAmount, address _batchAddress)</span>
 190 |     | <span class='neutral'>        external</span>
 191 |     | <span class='neutral'>        view</span>
 192 |     | <span class='unexecuted'>        returns (uint256)</span>
 193 |     | <span class='neutral'>    {</span>
 194 |     | <span class='unexecuted'>        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);</span>
 195 |     | <span class='unexecuted'>        IActivePool activePool = troveManager.activePool();</span>
 196 |     | <span class='unexecuted'>        LatestBatchData memory batch = troveManager.getLatestBatchData(_batchAddress);</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>        TroveChange memory openTrove;</span>
 199 |     | <span class='unexecuted'>        openTrove.debtIncrease = _borrowedAmount;</span>
 200 |     | <span class='unexecuted'>        openTrove.batchAccruedManagementFee = batch.accruedManagementFee;</span>
 201 |     | <span class='unexecuted'>        openTrove.oldWeightedRecordedDebt = batch.weightedRecordedDebt;</span>
 202 |     | <span class='unexecuted'>        openTrove.newWeightedRecordedDebt =</span>
 203 |     | <span class='unexecuted'>            (batch.entireDebtWithoutRedistribution + _borrowedAmount) * batch.annualInterestRate;</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='unexecuted'>        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(openTrove);</span>
 206 |     | <span class='unexecuted'>        return _calcUpfrontFee(_borrowedAmount, avgInterestRate);</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='unexecuted'>    function predictJoinBatchInterestRateUpfrontFee(uint256 _collIndex, uint256 _troveId, address _batchAddress)</span>
 210 |     | <span class='neutral'>        external</span>
 211 |     | <span class='neutral'>        view</span>
 212 |     | <span class='unexecuted'>        returns (uint256)</span>
 213 |     | <span class='neutral'>    {</span>
 214 |     | <span class='unexecuted'>        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);</span>
 215 |     | <span class='unexecuted'>        IActivePool activePool = troveManager.activePool();</span>
 216 |     | <span class='unexecuted'>        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);</span>
 217 |     | <span class='unexecuted'>        LatestBatchData memory batch = troveManager.getLatestBatchData(_batchAddress);</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='unexecuted'>        TroveChange memory newBatchTroveChange;</span>
 220 |     | <span class='unexecuted'>        newBatchTroveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;</span>
 221 |     | <span class='unexecuted'>        newBatchTroveChange.batchAccruedManagementFee = batch.accruedManagementFee;</span>
 222 |     | <span class='unexecuted'>        newBatchTroveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt + trove.weightedRecordedDebt;</span>
 223 |     | <span class='unexecuted'>        newBatchTroveChange.newWeightedRecordedDebt =</span>
 224 |     | <span class='unexecuted'>            (batch.entireDebtWithoutRedistribution + trove.entireDebt) * batch.annualInterestRate;</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='unexecuted'>        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(newBatchTroveChange);</span>
 227 |     | <span class='unexecuted'>        return _calcUpfrontFee(trove.entireDebt, avgInterestRate);</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='unexecuted'>    function predictRemoveFromBatchUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _newInterestRate)</span>
 231 |     | <span class='neutral'>        external</span>
 232 |     | <span class='neutral'>        view</span>
 233 |     | <span class='unexecuted'>        returns (uint256)</span>
 234 |     | <span class='neutral'>    {</span>
 235 |     | <span class='unexecuted'>        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);</span>
 236 |     | <span class='unexecuted'>        IActivePool activePool = troveManager.activePool();</span>
 237 |     | <span class='unexecuted'>        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);</span>
 238 |     | <span class='unexecuted'>        (,,,,,,,, address batchManager,) = troveManager.Troves(_troveId);</span>
 239 |     | <span class='unexecuted'>        LatestBatchData memory batch = troveManager.getLatestBatchData(batchManager);</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='unexecuted'>        if (</span>
 242 |     | <span class='unexecuted'>            _newInterestRate == batch.annualInterestRate</span>
 243 |     | <span class='unexecuted'>                || block.timestamp &gt;= trove.lastInterestRateAdjTime + INTEREST_RATE_ADJ_COOLDOWN</span>
 244 |     | <span class='neutral'>        ) {</span>
 245 |     | <span class='unexecuted'>            return 0;</span>
 246 |     | <span class='neutral'>        }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='unexecuted'>        TroveChange memory troveChange;</span>
 249 |     | <span class='unexecuted'>        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;</span>
 250 |     | <span class='unexecuted'>        troveChange.batchAccruedManagementFee = batch.accruedManagementFee;</span>
 251 |     | <span class='unexecuted'>        troveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;</span>
 252 |     | <span class='unexecuted'>        troveChange.newWeightedRecordedDebt = (</span>
 253 |     | <span class='unexecuted'>            batch.entireDebtWithoutRedistribution - (trove.entireDebt - trove.redistBoldDebtGain)</span>
 254 |     | <span class='unexecuted'>        ) * batch.annualInterestRate + trove.entireDebt * _newInterestRate;</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='unexecuted'>        uint256 avgInterestRate = activePool.getNewApproxAvgInterestRateFromTroveChange(troveChange);</span>
 257 |     | <span class='unexecuted'>        return _calcUpfrontFee(trove.entireDebt, avgInterestRate);</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'>}</span>
 260 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IActivePool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./IInterestRouter.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./IBoldRewardsReceiver.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../Types/TroveChange.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>interface IActivePool {</span>
 10 |     | <span class='neutral'>    function defaultPoolAddress() external view returns (address);</span>
 11 |     | <span class='neutral'>    function borrowerOperationsAddress() external view returns (address);</span>
 12 |     | <span class='neutral'>    function troveManagerAddress() external view returns (address);</span>
 13 |     | <span class='neutral'>    function interestRouter() external view returns (IInterestRouter);</span>
 14 |     | <span class='neutral'>    // We avoid IStabilityPool here in order to prevent creating a dependency cycle that would break flattening</span>
 15 |     | <span class='neutral'>    function stabilityPool() external view returns (IBoldRewardsReceiver);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function getCollBalance() external view returns (uint256);</span>
 18 |     | <span class='neutral'>    function getBoldDebt() external view returns (uint256);</span>
 19 |     | <span class='neutral'>    function lastAggUpdateTime() external view returns (uint256);</span>
 20 |     | <span class='neutral'>    function aggRecordedDebt() external view returns (uint256);</span>
 21 |     | <span class='neutral'>    function aggWeightedDebtSum() external view returns (uint256);</span>
 22 |     | <span class='neutral'>    function aggBatchManagementFees() external view returns (uint256);</span>
 23 |     | <span class='neutral'>    function aggWeightedBatchManagementFeeSum() external view returns (uint256);</span>
 24 |     | <span class='neutral'>    function calcPendingAggInterest() external view returns (uint256);</span>
 25 |     | <span class='neutral'>    function calcPendingSPYield() external view returns (uint256);</span>
 26 |     | <span class='neutral'>    function calcPendingAggBatchManagementFee() external view returns (uint256);</span>
 27 |     | <span class='neutral'>    function getNewApproxAvgInterestRateFromTroveChange(TroveChange calldata _troveChange)</span>
 28 |     | <span class='neutral'>        external</span>
 29 |     | <span class='neutral'>        view</span>
 30 |     | <span class='neutral'>        returns (uint256);</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    function mintAggInterest() external;</span>
 33 |     | <span class='neutral'>    function mintAggInterestAndAccountForTroveChange(TroveChange calldata _troveChange, address _batchManager)</span>
 34 |     | <span class='neutral'>        external;</span>
 35 |     | <span class='neutral'>    function mintBatchManagementFeeAndAccountForChange(TroveChange calldata _troveChange, address _batchAddress)</span>
 36 |     | <span class='neutral'>        external;</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    function setShutdownFlag() external;</span>
 39 |     | <span class='neutral'>    function hasBeenShutDown() external view returns (bool);</span>
 40 |     | <span class='neutral'>    function shutdownTime() external view returns (uint256);</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    function sendColl(address _account, uint256 _amount) external;</span>
 43 |     | <span class='neutral'>    function sendCollToDefaultPool(uint256 _amount) external;</span>
 44 |     | <span class='neutral'>    function receiveColl(uint256 _amount) external;</span>
 45 |     | <span class='neutral'>    function accountForReceivedColl(uint256 _amount) external;</span>
 46 |     | <span class='neutral'>}</span>
 47 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IAddRemoveManagers.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface IAddRemoveManagers {</span>
  6 |     | <span class='neutral'>    function setAddManager(uint256 _troveId, address _manager) external;</span>
  7 |     | <span class='neutral'>    function setRemoveManager(uint256 _troveId, address _manager) external;</span>
  8 |     | <span class='neutral'>    function setRemoveManagerWithReceiver(uint256 _troveId, address _manager, address _receiver) external;</span>
  9 |     | <span class='neutral'>    function addManagerOf(uint256 _troveId) external view returns (address);</span>
 10 |     | <span class='neutral'>    function removeManagerReceiverOf(uint256 _troveId) external view returns (address, address);</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IAddressesRegistry.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./IActivePool.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./IBoldToken.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./IBorrowerOperations.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;./ICollSurplusPool.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;./IDefaultPool.sol&quot;;</span>
 10 |     | <span class='neutral'>import &quot;./IHintHelpers.sol&quot;;</span>
 11 |     | <span class='neutral'>import &quot;./IMultiTroveGetter.sol&quot;;</span>
 12 |     | <span class='neutral'>import &quot;./ISortedTroves.sol&quot;;</span>
 13 |     | <span class='neutral'>import &quot;./IStabilityPool.sol&quot;;</span>
 14 |     | <span class='neutral'>import &quot;./ITroveManager.sol&quot;;</span>
 15 |     | <span class='neutral'>import &quot;./ITroveNFT.sol&quot;;</span>
 16 |     | <span class='neutral'>import {IMetadataNFT} from &quot;../NFTMetadata/MetadataNFT.sol&quot;;</span>
 17 |     | <span class='neutral'>import &quot;./ICollateralRegistry.sol&quot;;</span>
 18 |     | <span class='neutral'>import &quot;./IInterestRouter.sol&quot;;</span>
 19 |     | <span class='neutral'>import &quot;./IPriceFeed.sol&quot;;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>interface IAddressesRegistry {</span>
 22 |     | <span class='neutral'>    struct AddressVars {</span>
 23 |     | <span class='neutral'>        IERC20Metadata collToken;</span>
 24 |     | <span class='neutral'>        IBorrowerOperations borrowerOperations;</span>
 25 |     | <span class='neutral'>        ITroveManager troveManager;</span>
 26 |     | <span class='neutral'>        ITroveNFT troveNFT;</span>
 27 |     | <span class='neutral'>        IMetadataNFT metadataNFT;</span>
 28 |     | <span class='neutral'>        IStabilityPool stabilityPool;</span>
 29 |     | <span class='neutral'>        IPriceFeed priceFeed;</span>
 30 |     | <span class='neutral'>        IActivePool activePool;</span>
 31 |     | <span class='neutral'>        IDefaultPool defaultPool; //</span>
 32 |     | <span class='neutral'>        address gasPoolAddress;</span>
 33 |     | <span class='neutral'>        ICollSurplusPool collSurplusPool;</span>
 34 |     | <span class='neutral'>        ISortedTroves sortedTroves;</span>
 35 |     | <span class='neutral'>        IInterestRouter interestRouter;</span>
 36 |     | <span class='neutral'>        IHintHelpers hintHelpers;</span>
 37 |     | <span class='neutral'>        IMultiTroveGetter multiTroveGetter;</span>
 38 |     | <span class='neutral'>        ICollateralRegistry collateralRegistry;</span>
 39 |     | <span class='neutral'>        IBoldToken boldToken;</span>
 40 |     | <span class='neutral'>        IWETH WETH;</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    function CCR() external returns (uint256);</span>
 44 |     | <span class='neutral'>    function SCR() external returns (uint256);</span>
 45 |     | <span class='neutral'>    function MCR() external returns (uint256);</span>
 46 |     | <span class='neutral'>    function LIQUIDATION_PENALTY_SP() external returns (uint256);</span>
 47 |     | <span class='neutral'>    function LIQUIDATION_PENALTY_REDISTRIBUTION() external returns (uint256);</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    function collToken() external view returns (IERC20Metadata);</span>
 50 |     | <span class='neutral'>    function borrowerOperations() external view returns (IBorrowerOperations);</span>
 51 |     | <span class='neutral'>    function troveManager() external view returns (ITroveManager);</span>
 52 |     | <span class='neutral'>    function troveNFT() external view returns (ITroveNFT);</span>
 53 |     | <span class='neutral'>    function metadataNFT() external view returns (IMetadataNFT);</span>
 54 |     | <span class='neutral'>    function stabilityPool() external view returns (IStabilityPool);</span>
 55 |     | <span class='neutral'>    function priceFeed() external view returns (IPriceFeed);</span>
 56 |     | <span class='neutral'>    function activePool() external view returns (IActivePool);</span>
 57 |     | <span class='neutral'>    function defaultPool() external view returns (IDefaultPool);</span>
 58 |     | <span class='neutral'>    function gasPoolAddress() external view returns (address);</span>
 59 |     | <span class='neutral'>    function collSurplusPool() external view returns (ICollSurplusPool);</span>
 60 |     | <span class='neutral'>    function sortedTroves() external view returns (ISortedTroves);</span>
 61 |     | <span class='neutral'>    function interestRouter() external view returns (IInterestRouter);</span>
 62 |     | <span class='neutral'>    function hintHelpers() external view returns (IHintHelpers);</span>
 63 |     | <span class='neutral'>    function multiTroveGetter() external view returns (IMultiTroveGetter);</span>
 64 |     | <span class='neutral'>    function collateralRegistry() external view returns (ICollateralRegistry);</span>
 65 |     | <span class='neutral'>    function boldToken() external view returns (IBoldToken);</span>
 66 |     | <span class='neutral'>    function WETH() external returns (IWETH);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    function setAddresses(AddressVars memory _vars) external;</span>
 69 |     | <span class='neutral'>}</span>
 70 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IBoldRewardsReceiver.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'></span>
 3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 4 |     | <span class='neutral'></span>
 5 |     | <span class='neutral'>interface IBoldRewardsReceiver {</span>
 6 |     | <span class='neutral'>    function triggerBoldRewards(uint256 _boldYield) external;</span>
 7 |     | <span class='neutral'>}</span>
 8 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IBoldToken.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/interfaces/IERC5267.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>interface IBoldToken is IERC20Metadata, IERC20Permit, IERC5267 {</span>
 10 |     | <span class='neutral'>    function setBranchAddresses(</span>
 11 |     | <span class='neutral'>        address _troveManagerAddress,</span>
 12 |     | <span class='neutral'>        address _stabilityPoolAddress,</span>
 13 |     | <span class='neutral'>        address _borrowerOperationsAddress,</span>
 14 |     | <span class='neutral'>        address _activePoolAddress</span>
 15 |     | <span class='neutral'>    ) external;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function setCollateralRegistry(address _collateralRegistryAddress) external;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function mint(address _account, uint256 _amount) external;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function burn(address _account, uint256 _amount) external;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function sendToPool(address _sender, address poolAddress, uint256 _amount) external;</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function returnFromPool(address poolAddress, address user, uint256 _amount) external;</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IBorrowerOperations.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./ILiquityBase.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./IAddRemoveManagers.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./IBoldToken.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./IPriceFeed.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./ISortedTroves.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;./ITroveManager.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;./IWETH.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>// Common interface for the Borrower Operations.</span>
  14 |     | <span class='neutral'>interface IBorrowerOperations is ILiquityBase, IAddRemoveManagers {</span>
  15 |     | <span class='neutral'>    function CCR() external view returns (uint256);</span>
  16 |     | <span class='neutral'>    function MCR() external view returns (uint256);</span>
  17 |     | <span class='neutral'>    function SCR() external view returns (uint256);</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    function openTrove(</span>
  20 |     | <span class='neutral'>        address _owner,</span>
  21 |     | <span class='neutral'>        uint256 _ownerIndex,</span>
  22 |     | <span class='neutral'>        uint256 _ETHAmount,</span>
  23 |     | <span class='neutral'>        uint256 _boldAmount,</span>
  24 |     | <span class='neutral'>        uint256 _upperHint,</span>
  25 |     | <span class='neutral'>        uint256 _lowerHint,</span>
  26 |     | <span class='neutral'>        uint256 _annualInterestRate,</span>
  27 |     | <span class='neutral'>        uint256 _maxUpfrontFee,</span>
  28 |     | <span class='neutral'>        address _addManager,</span>
  29 |     | <span class='neutral'>        address _removeManager,</span>
  30 |     | <span class='neutral'>        address _receiver</span>
  31 |     | <span class='neutral'>    ) external returns (uint256);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    struct OpenTroveAndJoinInterestBatchManagerParams {</span>
  34 |     | <span class='neutral'>        address owner;</span>
  35 |     | <span class='neutral'>        uint256 ownerIndex;</span>
  36 |     | <span class='neutral'>        uint256 collAmount;</span>
  37 |     | <span class='neutral'>        uint256 boldAmount;</span>
  38 |     | <span class='neutral'>        uint256 upperHint;</span>
  39 |     | <span class='neutral'>        uint256 lowerHint;</span>
  40 |     | <span class='neutral'>        address interestBatchManager;</span>
  41 |     | <span class='neutral'>        uint256 maxUpfrontFee;</span>
  42 |     | <span class='neutral'>        address addManager;</span>
  43 |     | <span class='neutral'>        address removeManager;</span>
  44 |     | <span class='neutral'>        address receiver;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    function openTroveAndJoinInterestBatchManager(OpenTroveAndJoinInterestBatchManagerParams calldata _params)</span>
  48 |     | <span class='neutral'>        external</span>
  49 |     | <span class='neutral'>        returns (uint256);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    function addColl(uint256 _troveId, uint256 _ETHAmount) external;</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    function withdrawColl(uint256 _troveId, uint256 _amount) external;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    function withdrawBold(uint256 _troveId, uint256 _amount, uint256 _maxUpfrontFee) external;</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    function repayBold(uint256 _troveId, uint256 _amount) external;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    function closeTrove(uint256 _troveId) external;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    function adjustTrove(</span>
  62 |     | <span class='neutral'>        uint256 _troveId,</span>
  63 |     | <span class='neutral'>        uint256 _collChange,</span>
  64 |     | <span class='neutral'>        bool _isCollIncrease,</span>
  65 |     | <span class='neutral'>        uint256 _debtChange,</span>
  66 |     | <span class='neutral'>        bool isDebtIncrease,</span>
  67 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
  68 |     | <span class='neutral'>    ) external;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    function adjustZombieTrove(</span>
  71 |     | <span class='neutral'>        uint256 _troveId,</span>
  72 |     | <span class='neutral'>        uint256 _collChange,</span>
  73 |     | <span class='neutral'>        bool _isCollIncrease,</span>
  74 |     | <span class='neutral'>        uint256 _boldChange,</span>
  75 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
  76 |     | <span class='neutral'>        uint256 _upperHint,</span>
  77 |     | <span class='neutral'>        uint256 _lowerHint,</span>
  78 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
  79 |     | <span class='neutral'>    ) external;</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    function adjustTroveInterestRate(</span>
  82 |     | <span class='neutral'>        uint256 _troveId,</span>
  83 |     | <span class='neutral'>        uint256 _newAnnualInterestRate,</span>
  84 |     | <span class='neutral'>        uint256 _upperHint,</span>
  85 |     | <span class='neutral'>        uint256 _lowerHint,</span>
  86 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
  87 |     | <span class='neutral'>    ) external;</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    function applyPendingDebt(uint256 _troveId, uint256 _lowerHint, uint256 _upperHint) external;</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    function onLiquidateTrove(uint256 _troveId) external;</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    function claimCollateral() external;</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    function hasBeenShutDown() external view returns (bool);</span>
  96 |     | <span class='neutral'>    function shutdown() external;</span>
  97 |     | <span class='neutral'>    function shutdownFromOracleFailure() external;</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    function checkBatchManagerExists(address _batchMananger) external view returns (bool);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    // -- individual delegation --</span>
 102 |     | <span class='neutral'>    struct InterestIndividualDelegate {</span>
 103 |     | <span class='neutral'>        address account;</span>
 104 |     | <span class='neutral'>        uint128 minInterestRate;</span>
 105 |     | <span class='neutral'>        uint128 maxInterestRate;</span>
 106 |     | <span class='neutral'>        uint256 minInterestRateChangePeriod;</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    function getInterestIndividualDelegateOf(uint256 _troveId)</span>
 110 |     | <span class='neutral'>        external</span>
 111 |     | <span class='neutral'>        view</span>
 112 |     | <span class='neutral'>        returns (InterestIndividualDelegate memory);</span>
 113 |     | <span class='neutral'>    function setInterestIndividualDelegate(</span>
 114 |     | <span class='neutral'>        uint256 _troveId,</span>
 115 |     | <span class='neutral'>        address _delegate,</span>
 116 |     | <span class='neutral'>        uint128 _minInterestRate,</span>
 117 |     | <span class='neutral'>        uint128 _maxInterestRate,</span>
 118 |     | <span class='neutral'>        // only needed if trove was previously in a batch:</span>
 119 |     | <span class='neutral'>        uint256 _newAnnualInterestRate,</span>
 120 |     | <span class='neutral'>        uint256 _upperHint,</span>
 121 |     | <span class='neutral'>        uint256 _lowerHint,</span>
 122 |     | <span class='neutral'>        uint256 _maxUpfrontFee,</span>
 123 |     | <span class='neutral'>        uint256 _minInterestRateChangePeriod</span>
 124 |     | <span class='neutral'>    ) external;</span>
 125 |     | <span class='neutral'>    function removeInterestIndividualDelegate(uint256 _troveId) external;</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    // -- batches --</span>
 128 |     | <span class='neutral'>    struct InterestBatchManager {</span>
 129 |     | <span class='neutral'>        uint128 minInterestRate;</span>
 130 |     | <span class='neutral'>        uint128 maxInterestRate;</span>
 131 |     | <span class='neutral'>        uint256 minInterestRateChangePeriod;</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    function registerBatchManager(</span>
 135 |     | <span class='neutral'>        uint128 minInterestRate,</span>
 136 |     | <span class='neutral'>        uint128 maxInterestRate,</span>
 137 |     | <span class='neutral'>        uint128 currentInterestRate,</span>
 138 |     | <span class='neutral'>        uint128 fee,</span>
 139 |     | <span class='neutral'>        uint128 minInterestRateChangePeriod</span>
 140 |     | <span class='neutral'>    ) external;</span>
 141 |     | <span class='neutral'>    function lowerBatchManagementFee(uint256 _newAnnualFee) external;</span>
 142 |     | <span class='neutral'>    function setBatchManagerAnnualInterestRate(</span>
 143 |     | <span class='neutral'>        uint128 _newAnnualInterestRate,</span>
 144 |     | <span class='neutral'>        uint256 _upperHint,</span>
 145 |     | <span class='neutral'>        uint256 _lowerHint,</span>
 146 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
 147 |     | <span class='neutral'>    ) external;</span>
 148 |     | <span class='neutral'>    function interestBatchManagerOf(uint256 _troveId) external view returns (address);</span>
 149 |     | <span class='neutral'>    function getInterestBatchManager(address _account) external view returns (InterestBatchManager memory);</span>
 150 |     | <span class='neutral'>    function setInterestBatchManager(</span>
 151 |     | <span class='neutral'>        uint256 _troveId,</span>
 152 |     | <span class='neutral'>        address _newBatchManager,</span>
 153 |     | <span class='neutral'>        uint256 _upperHint,</span>
 154 |     | <span class='neutral'>        uint256 _lowerHint,</span>
 155 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
 156 |     | <span class='neutral'>    ) external;</span>
 157 |     | <span class='neutral'>    function removeFromBatch(</span>
 158 |     | <span class='neutral'>        uint256 _troveId,</span>
 159 |     | <span class='neutral'>        uint256 _newAnnualInterestRate,</span>
 160 |     | <span class='neutral'>        uint256 _upperHint,</span>
 161 |     | <span class='neutral'>        uint256 _lowerHint,</span>
 162 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
 163 |     | <span class='neutral'>    ) external;</span>
 164 |     | <span class='neutral'>    function switchBatchManager(</span>
 165 |     | <span class='neutral'>        uint256 _troveId,</span>
 166 |     | <span class='neutral'>        uint256 _removeUpperHint,</span>
 167 |     | <span class='neutral'>        uint256 _removeLowerHint,</span>
 168 |     | <span class='neutral'>        address _newBatchManager,</span>
 169 |     | <span class='neutral'>        uint256 _addUpperHint,</span>
 170 |     | <span class='neutral'>        uint256 _addLowerHint,</span>
 171 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
 172 |     | <span class='neutral'>    ) external;</span>
 173 |     | <span class='neutral'>}</span>
 174 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/ICollSurplusPool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface ICollSurplusPool {</span>
  6 |     | <span class='neutral'>    function getCollBalance() external view returns (uint256);</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    function getCollateral(address _account) external view returns (uint256);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function accountSurplus(address _account, uint256 _amount) external;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function claimColl(address _account) external;</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/ICollateralRegistry.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./IBoldToken.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./ITroveManager.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>interface ICollateralRegistry {</span>
 10 |     | <span class='neutral'>    function baseRate() external view returns (uint256);</span>
 11 |     | <span class='neutral'>    function lastFeeOperationTime() external view returns (uint256);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function redeemCollateral(uint256 _boldamount, uint256 _maxIterations, uint256 _maxFeePercentage) external;</span>
 14 |     | <span class='neutral'>    // getters</span>
 15 |     | <span class='neutral'>    function totalCollaterals() external view returns (uint256);</span>
 16 |     | <span class='neutral'>    function getToken(uint256 _index) external view returns (IERC20Metadata);</span>
 17 |     | <span class='neutral'>    function getTroveManager(uint256 _index) external view returns (ITroveManager);</span>
 18 |     | <span class='neutral'>    function boldToken() external view returns (IBoldToken);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function getRedemptionRate() external view returns (uint256);</span>
 21 |     | <span class='neutral'>    function getRedemptionRateWithDecay() external view returns (uint256);</span>
 22 |     | <span class='neutral'>    function getRedemptionRateForRedeemedAmount(uint256 _redeemAmount) external view returns (uint256);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    function getRedemptionFeeWithDecay(uint256 _ETHDrawn) external view returns (uint256);</span>
 25 |     | <span class='neutral'>    function getEffectiveRedemptionFeeInBold(uint256 _redeemAmount) external view returns (uint256);</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/ICommunityIssuance.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface ICommunityIssuance {</span>
  6 |     | <span class='neutral'>    function setAddresses(address _lqtyTokenAddress, address _stabilityPoolAddress) external;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    function issueLQTY() external returns (uint256);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function sendLQTY(address _account, uint256 _LQTYamount) external;</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IDefaultPool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface IDefaultPool {</span>
  6 |     | <span class='neutral'>    function troveManagerAddress() external view returns (address);</span>
  7 |     | <span class='neutral'>    function activePoolAddress() external view returns (address);</span>
  8 |     | <span class='neutral'>    // --- Functions ---</span>
  9 |     | <span class='neutral'>    function getCollBalance() external view returns (uint256);</span>
 10 |     | <span class='neutral'>    function getBoldDebt() external view returns (uint256);</span>
 11 |     | <span class='neutral'>    function sendCollToActivePool(uint256 _amount) external;</span>
 12 |     | <span class='neutral'>    function receiveColl(uint256 _amount) external;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function increaseBoldDebt(uint256 _amount) external;</span>
 15 |     | <span class='neutral'>    function decreaseBoldDebt(uint256 _amount) external;</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IHintHelpers.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface IHintHelpers {</span>
  6 |     | <span class='neutral'>    function getApproxHint(uint256 _collIndex, uint256 _interestRate, uint256 _numTrials, uint256 _inputRandomSeed)</span>
  7 |     | <span class='neutral'>        external</span>
  8 |     | <span class='neutral'>        view</span>
  9 |     | <span class='neutral'>        returns (uint256 hintId, uint256 diff, uint256 latestRandomSeed);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function predictOpenTroveUpfrontFee(uint256 _collIndex, uint256 _borrowedAmount, uint256 _interestRate)</span>
 12 |     | <span class='neutral'>        external</span>
 13 |     | <span class='neutral'>        view</span>
 14 |     | <span class='neutral'>        returns (uint256);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function predictAdjustInterestRateUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _newInterestRate)</span>
 17 |     | <span class='neutral'>        external</span>
 18 |     | <span class='neutral'>        view</span>
 19 |     | <span class='neutral'>        returns (uint256);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function forcePredictAdjustInterestRateUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _newInterestRate)</span>
 22 |     | <span class='neutral'>        external</span>
 23 |     | <span class='neutral'>        view</span>
 24 |     | <span class='neutral'>        returns (uint256);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    function predictAdjustTroveUpfrontFee(uint256 _collIndex, uint256 _troveId, uint256 _debtIncrease)</span>
 27 |     | <span class='neutral'>        external</span>
 28 |     | <span class='neutral'>        view</span>
 29 |     | <span class='neutral'>        returns (uint256);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function predictAdjustBatchInterestRateUpfrontFee(</span>
 32 |     | <span class='neutral'>        uint256 _collIndex,</span>
 33 |     | <span class='neutral'>        address _batchAddress,</span>
 34 |     | <span class='neutral'>        uint256 _newInterestRate</span>
 35 |     | <span class='neutral'>    ) external view returns (uint256);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function predictJoinBatchInterestRateUpfrontFee(uint256 _collIndex, uint256 _troveId, address _batchAddress)</span>
 38 |     | <span class='neutral'>        external</span>
 39 |     | <span class='neutral'>        view</span>
 40 |     | <span class='neutral'>        returns (uint256);</span>
 41 |     | <span class='neutral'>}</span>
 42 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IInterestRouter.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'></span>
 3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 4 |     | <span class='neutral'></span>
 5 |     | <span class='neutral'>interface IInterestRouter {</span>
 6 |     | <span class='neutral'>// Currently the Interest Router doesn’t need any specific function</span>
 7 |     | <span class='neutral'>}</span>
 8 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/ILQTYStaking.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface ILQTYStaking {</span>
  6 |     | <span class='neutral'>    function setAddresses(</span>
  7 |     | <span class='neutral'>        address _lqtyTokenAddress,</span>
  8 |     | <span class='neutral'>        address _boldTokenAddress,</span>
  9 |     | <span class='neutral'>        address _troveManagerAddress,</span>
 10 |     | <span class='neutral'>        address _borrowerOperationsAddress,</span>
 11 |     | <span class='neutral'>        address _activePoolAddress</span>
 12 |     | <span class='neutral'>    ) external;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function stake(uint256 _LQTYamount) external;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function unstake(uint256 _LQTYamount) external;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function increaseF_ETH(uint256 _ETHFee) external;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function increaseF_bold(uint256 _LQTYFee) external;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    function getPendingETHGain(address _user) external view returns (uint256);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    function getPendingBoldGain(address _user) external view returns (uint256);</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/ILQTYToken.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>interface ILQTYToken is IERC20, IERC20Permit {</span>
  9 |     | <span class='neutral'>    function sendToLQTYStaking(address _sender, uint256 _amount) external;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function getDeploymentStartTime() external view returns (uint256);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function getLpRewardsEntitlement() external view returns (uint256);</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/ILiquityBase.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./IActivePool.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./IDefaultPool.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./IPriceFeed.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>interface ILiquityBase {</span>
 10 |     | <span class='neutral'>    function activePool() external view returns (IActivePool);</span>
 11 |     | <span class='neutral'>    function getEntireSystemDebt() external view returns (uint256);</span>
 12 |     | <span class='neutral'>    function getEntireSystemColl() external view returns (uint256);</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IMainnetPriceFeed.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>import &quot;../Interfaces/IPriceFeed.sol&quot;;</span>
  3 |     | <span class='neutral'>import &quot;../Dependencies/AggregatorV3Interface.sol&quot;;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IMainnetPriceFeed is IPriceFeed {</span>
  8 |     | <span class='neutral'>    enum PriceSource {</span>
  9 |     | <span class='neutral'>        primary,</span>
 10 |     | <span class='neutral'>        ETHUSDxCanonical,</span>
 11 |     | <span class='neutral'>        lastGoodPrice</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function ethUsdOracle() external view returns (AggregatorV3Interface, uint256, uint8);</span>
 15 |     | <span class='neutral'>    function priceSource() external view returns (PriceSource);</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IMultiTroveGetter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface IMultiTroveGetter {</span>
  6 |     | <span class='neutral'>    struct CombinedTroveData {</span>
  7 |     | <span class='neutral'>        uint256 id;</span>
  8 |     | <span class='neutral'>        uint256 debt;</span>
  9 |     | <span class='neutral'>        uint256 coll;</span>
 10 |     | <span class='neutral'>        uint256 stake;</span>
 11 |     | <span class='neutral'>        uint256 annualInterestRate;</span>
 12 |     | <span class='neutral'>        uint256 lastDebtUpdateTime;</span>
 13 |     | <span class='neutral'>        uint256 lastInterestRateAdjTime;</span>
 14 |     | <span class='neutral'>        address interestBatchManager;</span>
 15 |     | <span class='neutral'>        uint256 batchDebtShares;</span>
 16 |     | <span class='neutral'>        uint256 batchCollShares;</span>
 17 |     | <span class='neutral'>        uint256 snapshotETH;</span>
 18 |     | <span class='neutral'>        uint256 snapshotBoldDebt;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    struct DebtPerInterestRate {</span>
 22 |     | <span class='neutral'>        address interestBatchManager;</span>
 23 |     | <span class='neutral'>        uint256 interestRate;</span>
 24 |     | <span class='neutral'>        uint256 debt;</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function getMultipleSortedTroves(uint256 _collIndex, int256 _startIdx, uint256 _count)</span>
 28 |     | <span class='neutral'>        external</span>
 29 |     | <span class='neutral'>        view</span>
 30 |     | <span class='neutral'>        returns (CombinedTroveData[] memory _troves);</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    function getDebtPerInterestRateAscending(uint256 _collIndex, uint256 _startId, uint256 _maxIterations)</span>
 33 |     | <span class='neutral'>        external</span>
 34 |     | <span class='neutral'>        view</span>
 35 |     | <span class='neutral'>        returns (DebtPerInterestRate[] memory, uint256 currId);</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IPriceFeed.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface IPriceFeed {</span>
  6 |     | <span class='neutral'>    function fetchPrice() external returns (uint256, bool);</span>
  7 |     | <span class='neutral'>    function fetchRedemptionPrice() external returns (uint256, bool);</span>
  8 |     | <span class='neutral'>    function lastGoodPrice() external view returns (uint256);</span>
  9 |     | <span class='neutral'>    function setAddresses(address _borrowerOperationsAddress) external;</span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IRETHPriceFeed.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>import &quot;./IMainnetPriceFeed.sol&quot;;</span>
  3 |     | <span class='neutral'>import &quot;../Dependencies/AggregatorV3Interface.sol&quot;;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IRETHPriceFeed is IMainnetPriceFeed {</span>
  8 |     | <span class='neutral'>    function rEthEthOracle() external view returns (AggregatorV3Interface, uint256, uint8);</span>
  9 |     | <span class='neutral'>}</span>
 10 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IRETHToken.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'></span>
 3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
 4 |     | <span class='neutral'></span>
 5 |     | <span class='neutral'>interface IRETHToken {</span>
 6 |     | <span class='neutral'>    function getExchangeRate() external view returns (uint256);</span>
 7 |     | <span class='neutral'>}</span>
 8 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/ISortedTroves.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./ITroveManager.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BatchId, BATCH_ID_ZERO} from &quot;../Types/BatchId.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>interface ISortedTroves {</span>
  9 |     | <span class='neutral'>    // -- Mutating functions (permissioned) --</span>
 10 |     | <span class='neutral'>    function insert(uint256 _id, uint256 _annualInterestRate, uint256 _prevId, uint256 _nextId) external;</span>
 11 |     | <span class='neutral'>    function insertIntoBatch(</span>
 12 |     | <span class='neutral'>        uint256 _troveId,</span>
 13 |     | <span class='neutral'>        BatchId _batchId,</span>
 14 |     | <span class='neutral'>        uint256 _annualInterestRate,</span>
 15 |     | <span class='neutral'>        uint256 _prevId,</span>
 16 |     | <span class='neutral'>        uint256 _nextId</span>
 17 |     | <span class='neutral'>    ) external;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function remove(uint256 _id) external;</span>
 20 |     | <span class='neutral'>    function removeFromBatch(uint256 _id) external;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    function reInsert(uint256 _id, uint256 _newAnnualInterestRate, uint256 _prevId, uint256 _nextId) external;</span>
 23 |     | <span class='neutral'>    function reInsertBatch(BatchId _id, uint256 _newAnnualInterestRate, uint256 _prevId, uint256 _nextId) external;</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    // -- View functions --</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function contains(uint256 _id) external view returns (bool);</span>
 28 |     | <span class='neutral'>    function isBatchedNode(uint256 _id) external view returns (bool);</span>
 29 |     | <span class='neutral'>    function isEmptyBatch(BatchId _id) external view returns (bool);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function isEmpty() external view returns (bool);</span>
 32 |     | <span class='neutral'>    function getSize() external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    function getFirst() external view returns (uint256);</span>
 35 |     | <span class='neutral'>    function getLast() external view returns (uint256);</span>
 36 |     | <span class='neutral'>    function getNext(uint256 _id) external view returns (uint256);</span>
 37 |     | <span class='neutral'>    function getPrev(uint256 _id) external view returns (uint256);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    function validInsertPosition(uint256 _annualInterestRate, uint256 _prevId, uint256 _nextId)</span>
 40 |     | <span class='neutral'>        external</span>
 41 |     | <span class='neutral'>        view</span>
 42 |     | <span class='neutral'>        returns (bool);</span>
 43 |     | <span class='neutral'>    function findInsertPosition(uint256 _annualInterestRate, uint256 _prevId, uint256 _nextId)</span>
 44 |     | <span class='neutral'>        external</span>
 45 |     | <span class='neutral'>        view</span>
 46 |     | <span class='neutral'>        returns (uint256, uint256);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    // Public state variable getters</span>
 49 |     | <span class='neutral'>    function borrowerOperationsAddress() external view returns (address);</span>
 50 |     | <span class='neutral'>    function troveManager() external view returns (ITroveManager);</span>
 51 |     | <span class='neutral'>    function size() external view returns (uint256);</span>
 52 |     | <span class='neutral'>    function nodes(uint256 _id) external view returns (uint256 nextId, uint256 prevId, BatchId batchId, bool exists);</span>
 53 |     | <span class='neutral'>    function batches(BatchId _id) external view returns (uint256 head, uint256 tail);</span>
 54 |     | <span class='neutral'>}</span>
 55 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IStabilityPool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./IActivePool.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./ILiquityBase.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./IBoldToken.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./ITroveManager.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./IBoldRewardsReceiver.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/*</span>
  12 |     | <span class='neutral'> * The Stability Pool holds Bold tokens deposited by Stability Pool depositors.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * When a trove is liquidated, then depending on system conditions, some of its Bold debt gets offset with</span>
  15 |     | <span class='neutral'> * Bold in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of Bold tokens in the Stability Pool is burned.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * Thus, a liquidation causes each depositor to receive a Bold loss, in proportion to their deposit as a share of total deposits.</span>
  18 |     | <span class='neutral'> * They also receive an Coll gain, as the collateral of the liquidated trove is distributed among Stability depositors,</span>
  19 |     | <span class='neutral'> * in the same proportion.</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%</span>
  22 |     | <span class='neutral'> * of the total Bold in the Stability Pool, depletes 40% of each deposit.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * A deposit that has experienced a series of liquidations is termed a &quot;compounded deposit&quot;: each liquidation depletes the deposit,</span>
  25 |     | <span class='neutral'> * multiplying it by some factor in range ]0,1[</span>
  26 |     | <span class='neutral'> *</span>
  27 |     | <span class='neutral'> * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Coll gain derivations:</span>
  28 |     | <span class='neutral'> * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf</span>
  29 |     | <span class='neutral'> *</span>
  30 |     | <span class='neutral'>*/</span>
  31 |     | <span class='neutral'>interface IStabilityPool is ILiquityBase, IBoldRewardsReceiver {</span>
  32 |     | <span class='neutral'>    function boldToken() external view returns (IBoldToken);</span>
  33 |     | <span class='neutral'>    function troveManager() external view returns (ITroveManager);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /*  provideToSP():</span>
  36 |     | <span class='neutral'>    * - Calculates depositor&#39;s Coll gain</span>
  37 |     | <span class='neutral'>    * - Calculates the compounded deposit</span>
  38 |     | <span class='neutral'>    * - Increases deposit, and takes new snapshots of accumulators P and S</span>
  39 |     | <span class='neutral'>    * - Sends depositor&#39;s accumulated Coll gains to depositor</span>
  40 |     | <span class='neutral'>    */</span>
  41 |     | <span class='neutral'>    function provideToSP(uint256 _amount, bool _doClaim) external;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /*  withdrawFromSP():</span>
  44 |     | <span class='neutral'>    * - Calculates depositor&#39;s Coll gain</span>
  45 |     | <span class='neutral'>    * - Calculates the compounded deposit</span>
  46 |     | <span class='neutral'>    * - Sends the requested BOLD withdrawal to depositor</span>
  47 |     | <span class='neutral'>    * - (If _amount &gt; userDeposit, the user withdraws all of their compounded deposit)</span>
  48 |     | <span class='neutral'>    * - Decreases deposit by withdrawn amount and takes new snapshots of accumulators P and S</span>
  49 |     | <span class='neutral'>    */</span>
  50 |     | <span class='neutral'>    function withdrawFromSP(uint256 _amount, bool doClaim) external;</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function claimAllCollGains() external;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /*</span>
  55 |     | <span class='neutral'>     * Initial checks:</span>
  56 |     | <span class='neutral'>     * - Caller is TroveManager</span>
  57 |     | <span class='neutral'>     * ---</span>
  58 |     | <span class='neutral'>     * Cancels out the specified debt against the Bold contained in the Stability Pool (as far as possible)</span>
  59 |     | <span class='neutral'>     * and transfers the Trove&#39;s collateral from ActivePool to StabilityPool.</span>
  60 |     | <span class='neutral'>     * Only called by liquidation functions in the TroveManager.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='neutral'>    function offset(uint256 _debt, uint256 _coll) external;</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function deposits(address _depositor) external view returns (uint256 initialValue);</span>
  65 |     | <span class='neutral'>    function stashedColl(address _depositor) external view returns (uint256);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /*</span>
  68 |     | <span class='neutral'>     * Returns the total amount of Coll held by the pool, accounted in an internal variable instead of `balance`,</span>
  69 |     | <span class='neutral'>     * to exclude edge cases like Coll received from a self-destruct.</span>
  70 |     | <span class='neutral'>     */</span>
  71 |     | <span class='neutral'>    function getCollBalance() external view returns (uint256);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /*</span>
  74 |     | <span class='neutral'>     * Returns Bold held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.</span>
  75 |     | <span class='neutral'>     */</span>
  76 |     | <span class='neutral'>    function getTotalBoldDeposits() external view returns (uint256);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function getYieldGainsOwed() external view returns (uint256);</span>
  79 |     | <span class='neutral'>    function getYieldGainsPending() external view returns (uint256);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /*</span>
  82 |     | <span class='neutral'>     * Calculates the Coll gain earned by the deposit since its last snapshots were taken.</span>
  83 |     | <span class='neutral'>     */</span>
  84 |     | <span class='neutral'>    function getDepositorCollGain(address _depositor) external view returns (uint256);</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /*</span>
  87 |     | <span class='neutral'>     * Calculates the BOLD yield gain earned by the deposit since its last snapshots were taken.</span>
  88 |     | <span class='neutral'>     */</span>
  89 |     | <span class='neutral'>    function getDepositorYieldGain(address _depositor) external view returns (uint256);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /*</span>
  92 |     | <span class='neutral'>     * Calculates what `getDepositorYieldGain` will be if interest is minted now.</span>
  93 |     | <span class='neutral'>     */</span>
  94 |     | <span class='neutral'>    function getDepositorYieldGainWithPending(address _depositor) external view returns (uint256);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /*</span>
  97 |     | <span class='neutral'>     * Return the user&#39;s compounded deposit.</span>
  98 |     | <span class='neutral'>     */</span>
  99 |     | <span class='neutral'>    function getCompoundedBoldDeposit(address _depositor) external view returns (uint256);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    function epochToScaleToS(uint128 _epoch, uint128 _scale) external view returns (uint256);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function epochToScaleToB(uint128 _epoch, uint128 _scale) external view returns (uint256);</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    function P() external view returns (uint256);</span>
 106 |     | <span class='neutral'>    function currentScale() external view returns (uint128);</span>
 107 |     | <span class='neutral'>    function currentEpoch() external view returns (uint128);</span>
 108 |     | <span class='neutral'>}</span>
 109 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IStabilityPoolEvents.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface IStabilityPoolEvents {</span>
  6 |     | <span class='neutral'>    enum Operation {</span>
  7 |     | <span class='neutral'>        provideToSP,</span>
  8 |     | <span class='neutral'>        withdrawFromSP,</span>
  9 |     | <span class='neutral'>        claimAllCollGains</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    event StabilityPoolCollBalanceUpdated(uint256 _newBalance);</span>
 13 |     | <span class='neutral'>    event StabilityPoolBoldBalanceUpdated(uint256 _newBalance);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    event P_Updated(uint256 _P);</span>
 16 |     | <span class='neutral'>    event S_Updated(uint256 _S, uint128 _epoch, uint128 _scale);</span>
 17 |     | <span class='neutral'>    event B_Updated(uint256 _B, uint128 _epoch, uint128 _scale);</span>
 18 |     | <span class='neutral'>    event EpochUpdated(uint128 _currentEpoch);</span>
 19 |     | <span class='neutral'>    event ScaleUpdated(uint128 _currentScale);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    event DepositUpdated(</span>
 22 |     | <span class='neutral'>        address indexed _depositor,</span>
 23 |     | <span class='neutral'>        uint256 _newDeposit,</span>
 24 |     | <span class='neutral'>        uint256 _stashedColl,</span>
 25 |     | <span class='neutral'>        uint256 _snapshotP,</span>
 26 |     | <span class='neutral'>        uint256 _snapshotS,</span>
 27 |     | <span class='neutral'>        uint256 _snapshotB,</span>
 28 |     | <span class='neutral'>        uint256 _snapshotScale,</span>
 29 |     | <span class='neutral'>        uint256 _snapshotEpoch</span>
 30 |     | <span class='neutral'>    );</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    event DepositOperation(</span>
 33 |     | <span class='neutral'>        address indexed _depositor,</span>
 34 |     | <span class='neutral'>        Operation _operation,</span>
 35 |     | <span class='neutral'>        uint256 _depositLossSinceLastOperation,</span>
 36 |     | <span class='neutral'>        int256 _depositChange,</span>
 37 |     | <span class='neutral'>        uint256 _yieldGainSinceLastOperation,</span>
 38 |     | <span class='neutral'>        uint256 _yieldGainClaimed,</span>
 39 |     | <span class='neutral'>        uint256 _ethGainSinceLastOperation,</span>
 40 |     | <span class='neutral'>        uint256 _ethGainClaimed</span>
 41 |     | <span class='neutral'>    );</span>
 42 |     | <span class='neutral'>}</span>
 43 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/ITroveEvents.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface ITroveEvents {</span>
  6 |     | <span class='neutral'>    enum Operation {</span>
  7 |     | <span class='neutral'>        openTrove,</span>
  8 |     | <span class='neutral'>        closeTrove,</span>
  9 |     | <span class='neutral'>        adjustTrove,</span>
 10 |     | <span class='neutral'>        adjustTroveInterestRate,</span>
 11 |     | <span class='neutral'>        applyPendingDebt,</span>
 12 |     | <span class='neutral'>        liquidate,</span>
 13 |     | <span class='neutral'>        redeemCollateral,</span>
 14 |     | <span class='neutral'>        // batch management</span>
 15 |     | <span class='neutral'>        openTroveAndJoinBatch,</span>
 16 |     | <span class='neutral'>        setInterestBatchManager,</span>
 17 |     | <span class='neutral'>        removeFromBatch</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    event Liquidation(</span>
 21 |     | <span class='neutral'>        uint256 _debtOffsetBySP,</span>
 22 |     | <span class='neutral'>        uint256 _debtRedistributed,</span>
 23 |     | <span class='neutral'>        uint256 _boldGasCompensation,</span>
 24 |     | <span class='neutral'>        uint256 _collGasCompensation,</span>
 25 |     | <span class='neutral'>        uint256 _collSentToSP,</span>
 26 |     | <span class='neutral'>        uint256 _collRedistributed,</span>
 27 |     | <span class='neutral'>        uint256 _collSurplus,</span>
 28 |     | <span class='neutral'>        uint256 _L_ETH,</span>
 29 |     | <span class='neutral'>        uint256 _L_boldDebt,</span>
 30 |     | <span class='neutral'>        uint256 _price</span>
 31 |     | <span class='neutral'>    );</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    event Redemption(</span>
 34 |     | <span class='neutral'>        uint256 _attemptedBoldAmount, uint256 _actualBoldAmount, uint256 _ETHSent, uint256 _ETHFee, uint256 _price</span>
 35 |     | <span class='neutral'>    );</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    // A snapshot of the Trove&#39;s latest state on-chain</span>
 38 |     | <span class='neutral'>    event TroveUpdated(</span>
 39 |     | <span class='neutral'>        uint256 indexed _troveId,</span>
 40 |     | <span class='neutral'>        uint256 _debt,</span>
 41 |     | <span class='neutral'>        uint256 _coll,</span>
 42 |     | <span class='neutral'>        uint256 _stake,</span>
 43 |     | <span class='neutral'>        uint256 _annualInterestRate,</span>
 44 |     | <span class='neutral'>        uint256 _snapshotOfTotalCollRedist,</span>
 45 |     | <span class='neutral'>        uint256 _snapshotOfTotalDebtRedist</span>
 46 |     | <span class='neutral'>    );</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    // Details of an operation that modifies a Trove</span>
 49 |     | <span class='neutral'>    event TroveOperation(</span>
 50 |     | <span class='neutral'>        uint256 indexed _troveId,</span>
 51 |     | <span class='neutral'>        Operation _operation,</span>
 52 |     | <span class='neutral'>        uint256 _annualInterestRate,</span>
 53 |     | <span class='neutral'>        uint256 _debtIncreaseFromRedist,</span>
 54 |     | <span class='neutral'>        uint256 _debtIncreaseFromUpfrontFee,</span>
 55 |     | <span class='neutral'>        int256 _debtChangeFromOperation,</span>
 56 |     | <span class='neutral'>        uint256 _collIncreaseFromRedist,</span>
 57 |     | <span class='neutral'>        int256 _collChangeFromOperation</span>
 58 |     | <span class='neutral'>    );</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>    event RedemptionFeePaidToTrove(uint256 indexed _troveId, uint256 _ETHFee);</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    // Batch management</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>    enum BatchOperation {</span>
 65 |     | <span class='neutral'>        registerBatchManager,</span>
 66 |     | <span class='neutral'>        lowerBatchManagerAnnualFee,</span>
 67 |     | <span class='neutral'>        setBatchManagerAnnualInterestRate,</span>
 68 |     | <span class='neutral'>        applyBatchInterestAndFee,</span>
 69 |     | <span class='neutral'>        joinBatch,</span>
 70 |     | <span class='neutral'>        exitBatch,</span>
 71 |     | <span class='neutral'>        // used when the batch is updated as a result of a Trove change inside the batch</span>
 72 |     | <span class='neutral'>        troveChange</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='neutral'>    event BatchUpdated(</span>
 76 |     | <span class='neutral'>        address indexed _interestBatchManager,</span>
 77 |     | <span class='neutral'>        BatchOperation _operation,</span>
 78 |     | <span class='neutral'>        uint256 _debt,</span>
 79 |     | <span class='neutral'>        uint256 _coll,</span>
 80 |     | <span class='neutral'>        uint256 _annualInterestRate,</span>
 81 |     | <span class='neutral'>        uint256 _annualManagementFee,</span>
 82 |     | <span class='neutral'>        uint256 _totalDebtShares,</span>
 83 |     | <span class='neutral'>        uint256 _debtIncreaseFromUpfrontFee</span>
 84 |     | <span class='neutral'>    );</span>
 85 |     | <span class='neutral'></span>
 86 |     | <span class='neutral'>    event BatchedTroveUpdated(</span>
 87 |     | <span class='neutral'>        uint256 indexed _troveId,</span>
 88 |     | <span class='neutral'>        address _interestBatchManager,</span>
 89 |     | <span class='neutral'>        uint256 _batchDebtShares,</span>
 90 |     | <span class='neutral'>        uint256 _coll,</span>
 91 |     | <span class='neutral'>        uint256 _stake,</span>
 92 |     | <span class='neutral'>        uint256 _snapshotOfTotalCollRedist,</span>
 93 |     | <span class='neutral'>        uint256 _snapshotOfTotalDebtRedist</span>
 94 |     | <span class='neutral'>    );</span>
 95 |     | <span class='neutral'>}</span>
 96 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/ITroveManager.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./ILiquityBase.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./ITroveNFT.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./IBorrowerOperations.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./IStabilityPool.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./IBoldToken.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;./ISortedTroves.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../Types/LatestTroveData.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;../Types/LatestBatchData.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>// Common interface for the Trove Manager.</span>
  15 |     | <span class='neutral'>interface ITroveManager is ILiquityBase {</span>
  16 |     | <span class='neutral'>    enum Status {</span>
  17 |     | <span class='neutral'>        nonExistent,</span>
  18 |     | <span class='neutral'>        active,</span>
  19 |     | <span class='neutral'>        closedByOwner,</span>
  20 |     | <span class='neutral'>        closedByLiquidation,</span>
  21 |     | <span class='neutral'>        zombie</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    function shutdownTime() external view returns (uint256);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    function troveNFT() external view returns (ITroveNFT);</span>
  27 |     | <span class='neutral'>    function stabilityPool() external view returns (IStabilityPool);</span>
  28 |     | <span class='neutral'>    //function boldToken() external view returns (IBoldToken);</span>
  29 |     | <span class='neutral'>    function sortedTroves() external view returns (ISortedTroves);</span>
  30 |     | <span class='neutral'>    function borrowerOperations() external view returns (IBorrowerOperations);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function Troves(uint256 _id)</span>
  33 |     | <span class='neutral'>        external</span>
  34 |     | <span class='neutral'>        view</span>
  35 |     | <span class='neutral'>        returns (</span>
  36 |     | <span class='neutral'>            uint256 debt,</span>
  37 |     | <span class='neutral'>            uint256 coll,</span>
  38 |     | <span class='neutral'>            uint256 stake,</span>
  39 |     | <span class='neutral'>            Status status,</span>
  40 |     | <span class='neutral'>            uint64 arrayIndex,</span>
  41 |     | <span class='neutral'>            uint64 lastDebtUpdateTime,</span>
  42 |     | <span class='neutral'>            uint64 lastInterestRateAdjTime,</span>
  43 |     | <span class='neutral'>            uint256 annualInterestRate,</span>
  44 |     | <span class='neutral'>            address interestBatchManager,</span>
  45 |     | <span class='neutral'>            uint256 batchDebtShares</span>
  46 |     | <span class='neutral'>        );</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function rewardSnapshots(uint256 _id) external view returns (uint256 coll, uint256 boldDebt);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    function getTroveIdsCount() external view returns (uint256);</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function getTroveFromTroveIdsArray(uint256 _index) external view returns (uint256);</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    function getCurrentICR(uint256 _troveId, uint256 _price) external view returns (uint256);</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function lastZombieTroveId() external view returns (uint256);</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    function batchLiquidateTroves(uint256[] calldata _troveArray) external;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function redeemCollateral(</span>
  61 |     | <span class='neutral'>        address _sender,</span>
  62 |     | <span class='neutral'>        uint256 _boldAmount,</span>
  63 |     | <span class='neutral'>        uint256 _price,</span>
  64 |     | <span class='neutral'>        uint256 _redemptionRate,</span>
  65 |     | <span class='neutral'>        uint256 _maxIterations</span>
  66 |     | <span class='neutral'>    ) external returns (uint256 _redemeedAmount);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function shutdown() external;</span>
  69 |     | <span class='neutral'>    function urgentRedemption(uint256 _boldAmount, uint256[] calldata _troveIds, uint256 _minCollateral) external;</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    function getUnbackedPortionPriceAndRedeemability() external returns (uint256, uint256, bool);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    function getLatestTroveData(uint256 _troveId) external view returns (LatestTroveData memory);</span>
  74 |     | <span class='neutral'>    function getTroveAnnualInterestRate(uint256 _troveId) external view returns (uint256);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function getTroveStatus(uint256 _troveId) external view returns (Status);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function getLatestBatchData(address _batchAddress) external view returns (LatestBatchData memory);</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    // -- permissioned functions called by BorrowerOperations</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    function onOpenTrove(address _owner, uint256 _troveId, TroveChange memory _troveChange, uint256 _annualInterestRate)</span>
  83 |     | <span class='neutral'>        external;</span>
  84 |     | <span class='neutral'>    function onOpenTroveAndJoinBatch(</span>
  85 |     | <span class='neutral'>        address _owner,</span>
  86 |     | <span class='neutral'>        uint256 _troveId,</span>
  87 |     | <span class='neutral'>        TroveChange memory _troveChange,</span>
  88 |     | <span class='neutral'>        address _batchAddress,</span>
  89 |     | <span class='neutral'>        uint256 _batchColl,</span>
  90 |     | <span class='neutral'>        uint256 _batchDebt</span>
  91 |     | <span class='neutral'>    ) external;</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    // Called from `adjustZombieTrove()`</span>
  94 |     | <span class='neutral'>    function setTroveStatusToActive(uint256 _troveId) external;</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function onAdjustTroveInterestRate(</span>
  97 |     | <span class='neutral'>        uint256 _troveId,</span>
  98 |     | <span class='neutral'>        uint256 _newColl,</span>
  99 |     | <span class='neutral'>        uint256 _newDebt,</span>
 100 |     | <span class='neutral'>        uint256 _newAnnualInterestRate,</span>
 101 |     | <span class='neutral'>        TroveChange calldata _troveChange</span>
 102 |     | <span class='neutral'>    ) external;</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    function onAdjustTrove(uint256 _troveId, uint256 _newColl, uint256 _newDebt, TroveChange calldata _troveChange)</span>
 105 |     | <span class='neutral'>        external;</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function onAdjustTroveInsideBatch(</span>
 108 |     | <span class='neutral'>        uint256 _troveId,</span>
 109 |     | <span class='neutral'>        uint256 _newTroveColl,</span>
 110 |     | <span class='neutral'>        uint256 _newTroveDebt,</span>
 111 |     | <span class='neutral'>        TroveChange memory _troveChange,</span>
 112 |     | <span class='neutral'>        address _batchAddress,</span>
 113 |     | <span class='neutral'>        uint256 _newBatchColl,</span>
 114 |     | <span class='neutral'>        uint256 _newBatchDebt</span>
 115 |     | <span class='neutral'>    ) external;</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    function onApplyTroveInterest(</span>
 118 |     | <span class='neutral'>        uint256 _troveId,</span>
 119 |     | <span class='neutral'>        uint256 _newTroveColl,</span>
 120 |     | <span class='neutral'>        uint256 _newTroveDebt,</span>
 121 |     | <span class='neutral'>        address _batchAddress,</span>
 122 |     | <span class='neutral'>        uint256 _newBatchColl,</span>
 123 |     | <span class='neutral'>        uint256 _newBatchDebt,</span>
 124 |     | <span class='neutral'>        TroveChange calldata _troveChange</span>
 125 |     | <span class='neutral'>    ) external;</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function onCloseTrove(</span>
 128 |     | <span class='neutral'>        uint256 _troveId,</span>
 129 |     | <span class='neutral'>        TroveChange memory _troveChange, // decrease vars: entire, with interest, batch fee and redistribution</span>
 130 |     | <span class='neutral'>        address _batchAddress,</span>
 131 |     | <span class='neutral'>        uint256 _newBatchColl,</span>
 132 |     | <span class='neutral'>        uint256 _newBatchDebt // entire, with interest and batch fee</span>
 133 |     | <span class='neutral'>    ) external;</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    // -- batches --</span>
 136 |     | <span class='neutral'>    function onRegisterBatchManager(address _batchAddress, uint256 _annualInterestRate, uint256 _annualFee) external;</span>
 137 |     | <span class='neutral'>    function onLowerBatchManagerAnnualFee(</span>
 138 |     | <span class='neutral'>        address _batchAddress,</span>
 139 |     | <span class='neutral'>        uint256 _newColl,</span>
 140 |     | <span class='neutral'>        uint256 _newDebt,</span>
 141 |     | <span class='neutral'>        uint256 _newAnnualManagementFee</span>
 142 |     | <span class='neutral'>    ) external;</span>
 143 |     | <span class='neutral'>    function onSetBatchManagerAnnualInterestRate(</span>
 144 |     | <span class='neutral'>        address _batchAddress,</span>
 145 |     | <span class='neutral'>        uint256 _newColl,</span>
 146 |     | <span class='neutral'>        uint256 _newDebt,</span>
 147 |     | <span class='neutral'>        uint256 _newAnnualInterestRate,</span>
 148 |     | <span class='neutral'>        uint256 _upfrontFee // needed by BatchUpdated event</span>
 149 |     | <span class='neutral'>    ) external;</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    struct OnSetInterestBatchManagerParams {</span>
 152 |     | <span class='neutral'>        uint256 troveId;</span>
 153 |     | <span class='neutral'>        uint256 troveColl; // entire, with redistribution</span>
 154 |     | <span class='neutral'>        uint256 troveDebt; // entire, with interest, batch fee and redistribution</span>
 155 |     | <span class='neutral'>        TroveChange troveChange;</span>
 156 |     | <span class='neutral'>        address newBatchAddress;</span>
 157 |     | <span class='neutral'>        uint256 newBatchColl; // updated collateral for new batch manager</span>
 158 |     | <span class='neutral'>        uint256 newBatchDebt; // updated debt for new batch manager</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    function onSetInterestBatchManager(OnSetInterestBatchManagerParams calldata _params) external;</span>
 162 |     | <span class='neutral'>    function onRemoveFromBatch(</span>
 163 |     | <span class='neutral'>        uint256 _troveId,</span>
 164 |     | <span class='neutral'>        uint256 _newTroveColl, // entire, with redistribution</span>
 165 |     | <span class='neutral'>        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution</span>
 166 |     | <span class='neutral'>        TroveChange memory _troveChange,</span>
 167 |     | <span class='neutral'>        address _batchAddress,</span>
 168 |     | <span class='neutral'>        uint256 _newBatchColl,</span>
 169 |     | <span class='neutral'>        uint256 _newBatchDebt, // entire, with interest and batch fee</span>
 170 |     | <span class='neutral'>        uint256 _newAnnualInterestRate</span>
 171 |     | <span class='neutral'>    ) external;</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    // -- end of permissioned functions --</span>
 174 |     | <span class='neutral'>}</span>
 175 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/ITroveNFT.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>import &quot;./ITroveManager.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>interface ITroveNFT is IERC721Metadata {</span>
 10 |     | <span class='neutral'>    function mint(address _owner, uint256 _troveId) external;</span>
 11 |     | <span class='neutral'>    function burn(uint256 _troveId) external;</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IWETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IWETH is IERC20Metadata {</span>
  8 |     | <span class='neutral'>    function deposit() external payable;</span>
  9 |     | <span class='neutral'>    function withdraw(uint256 wad) external;</span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IWSTETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface IWSTETH {</span>
  6 |     | <span class='neutral'>    function wrap(uint256 _stETHAmount) external returns (uint256);</span>
  7 |     | <span class='neutral'>    function unwrap(uint256 _wstETHAmount) external returns (uint256);</span>
  8 |     | <span class='neutral'>    function getWstETHByStETH(uint256 _stETHAmount) external view returns (uint256);</span>
  9 |     | <span class='neutral'>    function getStETHByWstETH(uint256 _wstETHAmount) external view returns (uint256);</span>
 10 |     | <span class='neutral'>    function stEthPerToken() external view returns (uint256);</span>
 11 |     | <span class='neutral'>    function tokensPerStEth() external view returns (uint256);</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Interfaces/IWSTETHPriceFeed.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>import &quot;./IMainnetPriceFeed.sol&quot;;</span>
  3 |     | <span class='neutral'>import &quot;../Dependencies/AggregatorV3Interface.sol&quot;;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IWSTETHPriceFeed is IMainnetPriceFeed {</span>
  8 |     | <span class='neutral'>    function stEthUsdOracle() external view returns (AggregatorV3Interface, uint256, uint8);</span>
  9 |     | <span class='neutral'>}</span>
 10 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/MultiTroveGetter.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./Interfaces/ICollateralRegistry.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Interfaces/IMultiTroveGetter.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Types/BatchId.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/*  Helper contract for grabbing Trove data for the front end. Not part of the core Liquity system. */</span>
  10 | *   | <span class='executed'>contract MultiTroveGetter is IMultiTroveGetter {</span>
  11 |     | <span class='unexecuted'>    ICollateralRegistry public immutable collateralRegistry;</span>
  12 |     | <span class='neutral'></span>
  13 | *   | <span class='executed'>    constructor(ICollateralRegistry _collateralRegistry) {</span>
  14 | *   | <span class='executed'>        collateralRegistry = _collateralRegistry;</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>    function getMultipleSortedTroves(uint256 _collIndex, int256 _startIdx, uint256 _count)</span>
  18 |     | <span class='neutral'>        external</span>
  19 |     | <span class='neutral'>        view</span>
  20 |     | <span class='unexecuted'>        returns (CombinedTroveData[] memory _troves)</span>
  21 |     | <span class='unexecuted'>    {</span>
  22 |     | <span class='unexecuted'>        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);</span>
  23 |     | <span class='unexecuted'>        require(address(troveManager) != address(0), &quot;Invalid collateral index&quot;);</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>        ISortedTroves sortedTroves = troveManager.sortedTroves();</span>
  26 |     | <span class='unexecuted'>        assert(address(sortedTroves) != address(0));</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>        uint256 startIdx;</span>
  29 |     | <span class='unexecuted'>        bool descend;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>        if (_startIdx &gt;= 0) {</span>
  32 |     | <span class='unexecuted'>            startIdx = uint256(_startIdx);</span>
  33 |     | <span class='unexecuted'>            descend = true;</span>
  34 |     | <span class='neutral'>        } else {</span>
  35 |     | <span class='unexecuted'>            startIdx = uint256(-(_startIdx + 1));</span>
  36 |     | <span class='unexecuted'>            descend = false;</span>
  37 |     | <span class='neutral'>        }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>        uint256 sortedTrovesSize = sortedTroves.getSize();</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>        if (startIdx &gt;= sortedTrovesSize) {</span>
  42 |     | <span class='unexecuted'>            _troves = new CombinedTroveData[](0);</span>
  43 |     | <span class='unexecuted'>        } else {</span>
  44 |     | <span class='unexecuted'>            uint256 maxCount = sortedTrovesSize - startIdx;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>            if (_count &gt; maxCount) {</span>
  47 |     | <span class='unexecuted'>                _count = maxCount;</span>
  48 |     | <span class='neutral'>            }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>            if (descend) {</span>
  51 |     | <span class='unexecuted'>                _troves = _getMultipleSortedTrovesFromHead(troveManager, sortedTroves, startIdx, _count);</span>
  52 |     | <span class='neutral'>            } else {</span>
  53 |     | <span class='unexecuted'>                _troves = _getMultipleSortedTrovesFromTail(troveManager, sortedTroves, startIdx, _count);</span>
  54 |     | <span class='neutral'>            }</span>
  55 |     | <span class='neutral'>        }</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>    function _getOneTrove(ITroveManager _troveManager, uint256 _id, CombinedTroveData memory _out) internal view {</span>
  59 |     | <span class='unexecuted'>        _out.id = _id;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>        (</span>
  62 |     | <span class='unexecuted'>            _out.debt,</span>
  63 |     | <span class='unexecuted'>            _out.coll,</span>
  64 |     | <span class='unexecuted'>            _out.stake,</span>
  65 |     | <span class='neutral'>            , // status</span>
  66 |     | <span class='neutral'>            , // arrayIndex</span>
  67 |     | <span class='unexecuted'>            _out.annualInterestRate,</span>
  68 |     | <span class='unexecuted'>            _out.lastDebtUpdateTime,</span>
  69 |     | <span class='unexecuted'>            _out.lastInterestRateAdjTime,</span>
  70 |     | <span class='unexecuted'>            _out.interestBatchManager,</span>
  71 |     | <span class='neutral'>            //_out.batchDebtShares,</span>
  72 |     | <span class='unexecuted'>        ) = _troveManager.Troves(_id);</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>        (_out.snapshotETH, _out.snapshotBoldDebt) = _troveManager.rewardSnapshots(_id);</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>    function _getMultipleSortedTrovesFromHead(</span>
  78 |     | <span class='neutral'>        ITroveManager _troveManager,</span>
  79 |     | <span class='neutral'>        ISortedTroves _sortedTroves,</span>
  80 |     | <span class='neutral'>        uint256 _startIdx,</span>
  81 |     | <span class='neutral'>        uint256 _count</span>
  82 |     | <span class='unexecuted'>    ) internal view returns (CombinedTroveData[] memory _troves) {</span>
  83 |     | <span class='unexecuted'>        uint256 currentTroveId = _sortedTroves.getFirst();</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>        for (uint256 idx = 0; idx &lt; _startIdx; ++idx) {</span>
  86 |     | <span class='unexecuted'>            currentTroveId = _sortedTroves.getNext(currentTroveId);</span>
  87 |     | <span class='neutral'>        }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>        _troves = new CombinedTroveData[](_count);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>        for (uint256 idx = 0; idx &lt; _count; ++idx) {</span>
  92 |     | <span class='unexecuted'>            _getOneTrove(_troveManager, currentTroveId, _troves[idx]);</span>
  93 |     | <span class='unexecuted'>            currentTroveId = _sortedTroves.getNext(currentTroveId);</span>
  94 |     | <span class='neutral'>        }</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>    function _getMultipleSortedTrovesFromTail(</span>
  98 |     | <span class='neutral'>        ITroveManager _troveManager,</span>
  99 |     | <span class='neutral'>        ISortedTroves _sortedTroves,</span>
 100 |     | <span class='neutral'>        uint256 _startIdx,</span>
 101 |     | <span class='neutral'>        uint256 _count</span>
 102 |     | <span class='unexecuted'>    ) internal view returns (CombinedTroveData[] memory _troves) {</span>
 103 |     | <span class='unexecuted'>        uint256 currentTroveId = _sortedTroves.getLast();</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>        for (uint256 idx = 0; idx &lt; _startIdx; ++idx) {</span>
 106 |     | <span class='unexecuted'>            currentTroveId = _sortedTroves.getPrev(currentTroveId);</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        _troves = new CombinedTroveData[](_count);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        for (uint256 idx = 0; idx &lt; _count; ++idx) {</span>
 112 |     | <span class='unexecuted'>            _getOneTrove(_troveManager, currentTroveId, _troves[idx]);</span>
 113 |     | <span class='unexecuted'>            currentTroveId = _sortedTroves.getPrev(currentTroveId);</span>
 114 |     | <span class='neutral'>        }</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>    function getDebtPerInterestRateAscending(uint256 _collIndex, uint256 _startId, uint256 _maxIterations)</span>
 118 |     | <span class='neutral'>        external</span>
 119 |     | <span class='neutral'>        view</span>
 120 |     | <span class='unexecuted'>        returns (DebtPerInterestRate[] memory data, uint256 currId)</span>
 121 |     | <span class='unexecuted'>    {</span>
 122 |     | <span class='unexecuted'>        ITroveManager troveManager = collateralRegistry.getTroveManager(_collIndex);</span>
 123 |     | <span class='unexecuted'>        require(address(troveManager) != address(0), &quot;Invalid collateral index&quot;);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        ISortedTroves sortedTroves = troveManager.sortedTroves();</span>
 126 |     | <span class='unexecuted'>        assert(address(sortedTroves) != address(0));</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>        data = new DebtPerInterestRate[](_maxIterations);</span>
 129 |     | <span class='unexecuted'>        currId = _startId == 0 ? sortedTroves.getLast() : _startId;</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _maxIterations; ++i) {</span>
 132 |     | <span class='unexecuted'>            if (currId == 0) break;</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>            (, uint256 prevId, BatchId interestBatchManager,) = sortedTroves.nodes(currId);</span>
 135 |     | <span class='unexecuted'>            LatestTroveData memory trove = troveManager.getLatestTroveData(currId);</span>
 136 |     | <span class='unexecuted'>            data[i].interestBatchManager = BatchId.unwrap(interestBatchManager);</span>
 137 |     | <span class='unexecuted'>            data[i].interestRate = trove.annualInterestRate;</span>
 138 |     | <span class='unexecuted'>            data[i].debt = trove.entireDebt;</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>            currId = prevId;</span>
 141 |     | <span class='neutral'>        }</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'>}</span>
 144 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/NFTMetadata/MetadataNFT.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;lib/Solady/src/utils/SSTORE2.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./utils/JSON.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>import &quot;./utils/baseSVG.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;./utils/bauhaus.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>import {ITroveManager} from &quot;src/Interfaces/ITroveManager.sol&quot;;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>interface IMetadataNFT {</span>
 15 |     | <span class='neutral'>    struct TroveData {</span>
 16 |     | <span class='neutral'>        uint256 _tokenId;</span>
 17 |     | <span class='neutral'>        address _owner;</span>
 18 |     | <span class='neutral'>        address _collToken;</span>
 19 |     | <span class='neutral'>        address _boldToken;</span>
 20 |     | <span class='neutral'>        uint256 _collAmount;</span>
 21 |     | <span class='neutral'>        uint256 _debtAmount;</span>
 22 |     | <span class='neutral'>        uint256 _interestRate;</span>
 23 |     | <span class='neutral'>        ITroveManager.Status _status;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    function uri(TroveData memory _troveData) external view returns (string memory);</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>
 29 | *   | <span class='executed'>contract MetadataNFT is IMetadataNFT {</span>
 30 |     | <span class='unexecuted'>    FixedAssetReader public immutable assetReader;</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    string public constant name = &quot;Liquity V2 Trove&quot;;</span>
 33 |     | <span class='unexecuted'>    string public constant description = &quot;Liquity V2 Trove position&quot;;</span>
 34 |     | <span class='neutral'></span>
 35 | *   | <span class='executed'>    constructor(FixedAssetReader _assetReader) {</span>
 36 | *   | <span class='executed'>        assetReader = _assetReader;</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function uri(TroveData memory _troveData) public view returns (string memory) {</span>
 40 |     | <span class='unexecuted'>        string memory attr = attributes(_troveData);</span>
 41 |     | <span class='unexecuted'>        return json.formattedMetadata(name, description, renderSVGImage(_troveData), attr);</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='unexecuted'>    function renderSVGImage(TroveData memory _troveData) internal view returns (string memory) {</span>
 45 |     | <span class='unexecuted'>        return svg._svg(</span>
 46 |     | <span class='unexecuted'>            baseSVG._svgProps(),</span>
 47 |     | <span class='unexecuted'>            string.concat(</span>
 48 |     | <span class='unexecuted'>                baseSVG._baseElements(assetReader),</span>
 49 |     | <span class='unexecuted'>                bauhaus._bauhaus(IERC20Metadata(_troveData._collToken).symbol(), _troveData._tokenId),</span>
 50 |     | <span class='unexecuted'>                dynamicTextComponents(_troveData)</span>
 51 |     | <span class='neutral'>            )</span>
 52 |     | <span class='neutral'>        );</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>    function attributes(TroveData memory _troveData) public pure returns (string memory) {</span>
 56 |     | <span class='neutral'>        //include: collateral token address, collateral amount, debt token address, debt amount, interest rate, status</span>
 57 |     | <span class='unexecuted'>        return string.concat(</span>
 58 |     | <span class='neutral'>            &#39;[{&quot;trait_type&quot;: &quot;Collateral Token&quot;, &quot;value&quot;: &quot;&#39;,</span>
 59 |     | <span class='unexecuted'>            LibString.toHexString(_troveData._collToken),</span>
 60 |     | <span class='neutral'>            &#39;&quot;}, {&quot;trait_type&quot;: &quot;Collateral Amount&quot;, &quot;value&quot;: &quot;&#39;,</span>
 61 |     | <span class='unexecuted'>            LibString.toString(_troveData._collAmount),</span>
 62 |     | <span class='neutral'>            &#39;&quot;}, {&quot;trait_type&quot;: &quot;Debt Token&quot;, &quot;value&quot;: &quot;&#39;,</span>
 63 |     | <span class='unexecuted'>            LibString.toHexString(_troveData._boldToken),</span>
 64 |     | <span class='neutral'>            &#39;&quot;}, {&quot;trait_type&quot;: &quot;Debt Amount&quot;, &quot;value&quot;: &quot;&#39;,</span>
 65 |     | <span class='unexecuted'>            LibString.toString(_troveData._debtAmount),</span>
 66 |     | <span class='neutral'>            &#39;&quot;}, {&quot;trait_type&quot;: &quot;Interest Rate&quot;, &quot;value&quot;: &quot;&#39;,</span>
 67 |     | <span class='unexecuted'>            LibString.toString(_troveData._interestRate),</span>
 68 |     | <span class='neutral'>            &#39;&quot;}, {&quot;trait_type&quot;: &quot;Status&quot;, &quot;value&quot;: &quot;&#39;,</span>
 69 |     | <span class='unexecuted'>            _status2Str(_troveData._status),</span>
 70 |     | <span class='neutral'>            &#39;&quot;} ]&#39;</span>
 71 |     | <span class='neutral'>        );</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='unexecuted'>    function dynamicTextComponents(TroveData memory _troveData) public view returns (string memory) {</span>
 75 |     | <span class='unexecuted'>        string memory id = LibString.toHexString(_troveData._tokenId);</span>
 76 |     | <span class='unexecuted'>        id = string.concat(LibString.slice(id, 0, 6), &quot;...&quot;, LibString.slice(id, 38, 42));</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='unexecuted'>        return string.concat(</span>
 79 |     | <span class='unexecuted'>            baseSVG._formattedIdEl(id),</span>
 80 |     | <span class='unexecuted'>            baseSVG._formattedAddressEl(_troveData._owner),</span>
 81 |     | <span class='unexecuted'>            baseSVG._collLogo(IERC20Metadata(_troveData._collToken).symbol(), assetReader),</span>
 82 |     | <span class='unexecuted'>            baseSVG._statusEl(_status2Str(_troveData._status)),</span>
 83 |     | <span class='unexecuted'>            baseSVG._dynamicTextEls(_troveData._debtAmount, _troveData._collAmount, _troveData._interestRate)</span>
 84 |     | <span class='neutral'>        );</span>
 85 |     | <span class='neutral'>    }</span>
 86 |     | <span class='neutral'></span>
 87 |     | <span class='unexecuted'>    function _status2Str(ITroveManager.Status status) internal pure returns (string memory) {</span>
 88 |     | <span class='unexecuted'>        if (status == ITroveManager.Status.active) return &quot;Active&quot;;</span>
 89 |     | <span class='unexecuted'>        if (status == ITroveManager.Status.closedByOwner) return &quot;Closed&quot;;</span>
 90 |     | <span class='unexecuted'>        if (status == ITroveManager.Status.closedByLiquidation) return &quot;Liquidated&quot;;</span>
 91 |     | <span class='unexecuted'>        if (status == ITroveManager.Status.zombie) return &quot;Below Min Debt&quot;;</span>
 92 |     | <span class='unexecuted'>        return &quot;&quot;;</span>
 93 |     | <span class='neutral'>    }</span>
 94 |     | <span class='neutral'>}</span>
 95 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/NFTMetadata/utils/FixedAssets.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;lib/Solady/src/utils/SSTORE2.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 | *   | <span class='executed'>contract FixedAssetReader {</span>
  7 |     | <span class='neutral'>    struct Asset {</span>
  8 |     | <span class='neutral'>        uint128 start;</span>
  9 |     | <span class='neutral'>        uint128 end;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    address public immutable pointer;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    mapping(bytes4 =&gt; Asset) public assets;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    function readAsset(bytes4 _sig) public view returns (string memory) {</span>
 17 |     | <span class='unexecuted'>        return string(SSTORE2.read(pointer, uint256(assets[_sig].start), uint256(assets[_sig].end)));</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 | *   | <span class='executed'>    constructor(address _pointer, bytes4[] memory _sigs, Asset[] memory _assets) {</span>
 21 | *   | <span class='executed'>        pointer = _pointer;</span>
 22 | *   | <span class='executed'>        require(_sigs.length == _assets.length, &quot;FixedAssetReader: Invalid input&quot;);</span>
 23 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; _sigs.length; i++) {</span>
 24 |     | <span class='unexecuted'>            assets[_sigs[i]] = _assets[i];</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/NFTMetadata/utils/JSON.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.12;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// JSON utilities for base64 encoded ERC721 JSON metadata scheme</span>
   5 |     | <span class='unexecuted'>library json {</span>
   6 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////////////////////////////////////////////////////</span>
   7 |     | <span class='neutral'>    /// @dev JSON requires that double quotes be escaped or JSONs will not build correctly</span>
   8 |     | <span class='neutral'>    /// string.concat also requires an escape, use \\&quot; or the constant DOUBLE_QUOTES to represent &quot; in JSON</span>
   9 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////////////////////////////////////////////////////</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    string constant DOUBLE_QUOTES = &#39;\\&quot;&#39;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>    function formattedMetadata(</span>
  14 |     | <span class='neutral'>        string memory name,</span>
  15 |     | <span class='neutral'>        string memory description,</span>
  16 |     | <span class='neutral'>        string memory svgImg,</span>
  17 |     | <span class='neutral'>        string memory attributes</span>
  18 |     | <span class='unexecuted'>    ) internal pure returns (string memory) {</span>
  19 |     | <span class='unexecuted'>        return string.concat(</span>
  20 |     | <span class='neutral'>            &quot;data:application/json;base64,&quot;,</span>
  21 |     | <span class='unexecuted'>            encode(</span>
  22 |     | <span class='neutral'>                bytes(</span>
  23 |     | <span class='unexecuted'>                    string.concat(</span>
  24 |     | <span class='neutral'>                        &quot;{&quot;,</span>
  25 |     | <span class='unexecuted'>                        _prop(&quot;name&quot;, name),</span>
  26 |     | <span class='unexecuted'>                        _prop(&quot;description&quot;, description),</span>
  27 |     | <span class='unexecuted'>                        _xmlImage(svgImg),</span>
  28 |     | <span class='neutral'>                        &#39;,&quot;attributes&quot;:&#39;,</span>
  29 |     | <span class='unexecuted'>                        attributes,</span>
  30 |     | <span class='neutral'>                        &quot;}&quot;</span>
  31 |     | <span class='neutral'>                    )</span>
  32 |     | <span class='neutral'>                )</span>
  33 |     | <span class='neutral'>            )</span>
  34 |     | <span class='neutral'>        );</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>    function _xmlImage(string memory _svgImg) internal pure returns (string memory) {</span>
  38 |     | <span class='unexecuted'>        return _prop(&quot;image&quot;, string.concat(&quot;data:image/svg+xml;base64,&quot;, encode(bytes(_svgImg))), true);</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>    function _prop(string memory _key, string memory _val) internal pure returns (string memory) {</span>
  42 |     | <span class='unexecuted'>        return string.concat(&#39;&quot;&#39;, _key, &#39;&quot;: &#39;, &#39;&quot;&#39;, _val, &#39;&quot;, &#39;);</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>    function _prop(string memory _key, string memory _val, bool last) internal pure returns (string memory) {</span>
  46 |     | <span class='unexecuted'>        if (last) {</span>
  47 |     | <span class='unexecuted'>            return string.concat(&#39;&quot;&#39;, _key, &#39;&quot;: &#39;, &#39;&quot;&#39;, _val, &#39;&quot;&#39;);</span>
  48 |     | <span class='neutral'>        } else {</span>
  49 |     | <span class='unexecuted'>            return string.concat(&#39;&quot;&#39;, _key, &#39;&quot;: &#39;, &#39;&quot;&#39;, _val, &#39;&quot;, &#39;);</span>
  50 |     | <span class='neutral'>        }</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    function _object(string memory _key, string memory _val) internal pure returns (string memory) {</span>
  54 |     | <span class='neutral'>        return string.concat(&#39;&quot;&#39;, _key, &#39;&quot;: &#39;, &quot;{&quot;, _val, &quot;}&quot;);</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /**</span>
  58 |     | <span class='neutral'>     * taken from Openzeppelin</span>
  59 |     | <span class='neutral'>     * @dev Base64 Encoding/Decoding Table</span>
  60 |     | <span class='neutral'>     */</span>
  61 |     | <span class='neutral'>    string internal constant _TABLE = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /**</span>
  64 |     | <span class='neutral'>     * @dev Converts a `bytes` to its Bytes64 `string` representation.</span>
  65 |     | <span class='neutral'>     */</span>
  66 |     | <span class='unexecuted'>    function encode(bytes memory data) internal pure returns (string memory) {</span>
  67 |     | <span class='neutral'>        /**</span>
  68 |     | <span class='neutral'>         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence</span>
  69 |     | <span class='neutral'>         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol</span>
  70 |     | <span class='neutral'>         */</span>
  71 |     | <span class='unexecuted'>        if (data.length == 0) return &quot;&quot;;</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>        // Loads the table into memory</span>
  74 |     | <span class='unexecuted'>        string memory table = _TABLE;</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter</span>
  77 |     | <span class='neutral'>        // and split into 4 numbers of 6 bits.</span>
  78 |     | <span class='neutral'>        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up</span>
  79 |     | <span class='neutral'>        // - `data.length + 2`  -&gt; Round up</span>
  80 |     | <span class='neutral'>        // - `/ 3`              -&gt; Number of 3-bytes chunks</span>
  81 |     | <span class='neutral'>        // - `4 *`              -&gt; 4 characters for each chunk</span>
  82 |     | <span class='unexecuted'>        string memory result = new string(4 * ((data.length + 2) / 3));</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        assembly {</span>
  85 |     | <span class='neutral'>            // Prepare the lookup table (skip the first &quot;length&quot; byte)</span>
  86 |     | <span class='unexecuted'>            let tablePtr := add(table, 1)</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>            // Prepare result pointer, jump over length</span>
  89 |     | <span class='unexecuted'>            let resultPtr := add(result, 32)</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>            // Run over the input, 3 bytes at a time</span>
  92 |     | <span class='unexecuted'>            for {</span>
  93 |     | <span class='unexecuted'>                let dataPtr := data</span>
  94 |     | <span class='unexecuted'>                let endPtr := add(data, mload(data))</span>
  95 |     | <span class='unexecuted'>            } lt(dataPtr, endPtr) {} {</span>
  96 |     | <span class='neutral'>                // Advance 3 bytes</span>
  97 |     | <span class='unexecuted'>                dataPtr := add(dataPtr, 3)</span>
  98 |     | <span class='unexecuted'>                let input := mload(dataPtr)</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>                // To write each character, shift the 3 bytes (18 bits) chunk</span>
 101 |     | <span class='neutral'>                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)</span>
 102 |     | <span class='neutral'>                // and apply logical AND with 0x3F which is the number of</span>
 103 |     | <span class='neutral'>                // the previous character in the ASCII table prior to the Base64 Table</span>
 104 |     | <span class='neutral'>                // The result is then added to the table to get the character to write,</span>
 105 |     | <span class='neutral'>                // and finally write it in the result pointer but with a left shift</span>
 106 |     | <span class='neutral'>                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))</span>
 109 |     | <span class='unexecuted'>                resultPtr := add(resultPtr, 1) // Advance</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))</span>
 112 |     | <span class='unexecuted'>                resultPtr := add(resultPtr, 1) // Advance</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))</span>
 115 |     | <span class='unexecuted'>                resultPtr := add(resultPtr, 1) // Advance</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))</span>
 118 |     | <span class='unexecuted'>                resultPtr := add(resultPtr, 1) // Advance</span>
 119 |     | <span class='neutral'>            }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>            // When data `bytes` is not exactly 3 bytes long</span>
 122 |     | <span class='neutral'>            // it is padded with `=` characters at the end</span>
 123 |     | <span class='unexecuted'>            switch mod(mload(data), 3)</span>
 124 |     | <span class='unexecuted'>            case 1 {</span>
 125 |     | <span class='unexecuted'>                mstore8(sub(resultPtr, 1), 0x3d)</span>
 126 |     | <span class='unexecuted'>                mstore8(sub(resultPtr, 2), 0x3d)</span>
 127 |     | <span class='neutral'>            }</span>
 128 |     | <span class='unexecuted'>            case 2 { mstore8(sub(resultPtr, 1), 0x3d) }</span>
 129 |     | <span class='neutral'>        }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>        return result;</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'>}</span>
 134 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/NFTMetadata/utils/SVG.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.18;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {utils, LibString} from &quot;./Utils.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @notice Core SVG utility library which helps us construct onchain SVG&#39;s with a simple, web-like API.</span>
   7 |     | <span class='neutral'>/// @author Modified from (https://github.com/w1nt3r-eth/hot-chain-svg/blob/main/contracts/SVG.sol) by w1nt3r-eth.</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='unexecuted'>library svg {</span>
  10 |     | <span class='neutral'>    /* GLOBAL CONSTANTS */</span>
  11 |     | <span class='neutral'>    string internal constant _SVG = &#39;xmlns=&quot;http://www.w3.org/2000/svg&quot;&#39;;</span>
  12 |     | <span class='neutral'>    string internal constant _HTML = &#39;xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&#39;;</span>
  13 |     | <span class='neutral'>    string internal constant _XMLNS = &quot;http://www.w3.org/2000/xmlns/ &quot;;</span>
  14 |     | <span class='neutral'>    string internal constant _XLINK = &quot;http://www.w3.org/1999/xlink &quot;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /* MAIN ELEMENTS */</span>
  17 |     | <span class='neutral'>    function g(string memory _props, string memory _children) internal pure returns (string memory) {</span>
  18 |     | <span class='neutral'>        return el(&quot;g&quot;, _props, _children);</span>
  19 |     | <span class='neutral'>    }</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    function _svg(string memory _props, string memory _children) internal pure returns (string memory) {</span>
  22 |     | <span class='unexecuted'>        return el(&quot;svg&quot;, string.concat(_SVG, &quot; &quot;, _props), _children);</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    function style(string memory _title, string memory _props) internal pure returns (string memory) {</span>
  26 |     | <span class='neutral'>        return el(&quot;style&quot;, string.concat(&quot;.&quot;, _title, &quot; &quot;, _props));</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    function path(string memory _d) internal pure returns (string memory) {</span>
  30 |     | <span class='neutral'>        return el(&quot;path&quot;, prop(&quot;d&quot;, _d, true));</span>
  31 |     | <span class='neutral'>    }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>    function path(string memory _d, string memory _props) internal pure returns (string memory) {</span>
  34 |     | <span class='unexecuted'>        return el(&quot;path&quot;, string.concat(prop(&quot;d&quot;, _d), _props));</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    function path(string memory _d, string memory _props, string memory _children)</span>
  38 |     | <span class='neutral'>        internal</span>
  39 |     | <span class='neutral'>        pure</span>
  40 |     | <span class='neutral'>        returns (string memory)</span>
  41 |     | <span class='neutral'>    {</span>
  42 |     | <span class='neutral'>        return el(&quot;path&quot;, string.concat(prop(&quot;d&quot;, _d), _props), _children);</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>    function text(string memory _props, string memory _children) internal pure returns (string memory) {</span>
  46 |     | <span class='unexecuted'>        return el(&quot;text&quot;, _props, _children);</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    function line(string memory _props) internal pure returns (string memory) {</span>
  50 |     | <span class='neutral'>        return el(&quot;line&quot;, _props);</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    function line(string memory _props, string memory _children) internal pure returns (string memory) {</span>
  54 |     | <span class='neutral'>        return el(&quot;line&quot;, _props, _children);</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>    function circle(string memory _props) internal pure returns (string memory) {</span>
  58 |     | <span class='unexecuted'>        return el(&quot;circle&quot;, _props);</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    function circle(string memory _props, string memory _children) internal pure returns (string memory) {</span>
  62 |     | <span class='neutral'>        return el(&quot;circle&quot;, _props, _children);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    function circle(string memory cx, string memory cy, string memory r) internal pure returns (string memory) {</span>
  66 |     | <span class='neutral'>        return el(&quot;circle&quot;, string.concat(prop(&quot;cx&quot;, cx), prop(&quot;cy&quot;, cy), prop(&quot;r&quot;, r, true)));</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    function circle(string memory cx, string memory cy, string memory r, string memory _children)</span>
  70 |     | <span class='neutral'>        internal</span>
  71 |     | <span class='neutral'>        pure</span>
  72 |     | <span class='neutral'>        returns (string memory)</span>
  73 |     | <span class='neutral'>    {</span>
  74 |     | <span class='neutral'>        return el(&quot;circle&quot;, string.concat(prop(&quot;cx&quot;, cx), prop(&quot;cy&quot;, cy), prop(&quot;r&quot;, r, true)), _children);</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    function circle(string memory cx, string memory cy, string memory r, string memory _props, string memory _children)</span>
  78 |     | <span class='neutral'>        internal</span>
  79 |     | <span class='neutral'>        pure</span>
  80 |     | <span class='neutral'>        returns (string memory)</span>
  81 |     | <span class='neutral'>    {</span>
  82 |     | <span class='neutral'>        return el(&quot;circle&quot;, string.concat(prop(&quot;cx&quot;, cx), prop(&quot;cy&quot;, cy), prop(&quot;r&quot;, r), _props), _children);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    function ellipse(string memory _props) internal pure returns (string memory) {</span>
  86 |     | <span class='neutral'>        return el(&quot;ellipse&quot;, _props);</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    function ellipse(string memory _props, string memory _children) internal pure returns (string memory) {</span>
  90 |     | <span class='neutral'>        return el(&quot;ellipse&quot;, _props, _children);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    function polygon(string memory _props) internal pure returns (string memory) {</span>
  94 |     | <span class='unexecuted'>        return el(&quot;polygon&quot;, _props);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    function polygon(string memory _props, string memory _children) internal pure returns (string memory) {</span>
  98 |     | <span class='neutral'>        return el(&quot;polygon&quot;, _props, _children);</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    function polyline(string memory _props) internal pure returns (string memory) {</span>
 102 |     | <span class='neutral'>        return el(&quot;polyline&quot;, _props);</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    function polyline(string memory _props, string memory _children) internal pure returns (string memory) {</span>
 106 |     | <span class='neutral'>        return el(&quot;polyline&quot;, _props, _children);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>    function rect(string memory _props) internal pure returns (string memory) {</span>
 110 |     | <span class='unexecuted'>        return el(&quot;rect&quot;, _props);</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    function rect(string memory _props, string memory _children) internal pure returns (string memory) {</span>
 114 |     | <span class='neutral'>        return el(&quot;rect&quot;, _props, _children);</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    function filter(string memory _props, string memory _children) internal pure returns (string memory) {</span>
 118 |     | <span class='neutral'>        return el(&quot;filter&quot;, _props, _children);</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    function cdata(string memory _content) internal pure returns (string memory) {</span>
 122 |     | <span class='neutral'>        return string.concat(&quot;&lt;![CDATA[&quot;, _content, &quot;]]&gt;&quot;);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    /* GRADIENTS */</span>
 126 |     | <span class='neutral'>    function radialGradient(string memory _props, string memory _children) internal pure returns (string memory) {</span>
 127 |     | <span class='neutral'>        return el(&quot;radialGradient&quot;, _props, _children);</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    function linearGradient(string memory _props, string memory _children) internal pure returns (string memory) {</span>
 131 |     | <span class='neutral'>        return el(&quot;linearGradient&quot;, _props, _children);</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    function gradientStop(uint256 offset, string memory stopColor, string memory _props)</span>
 135 |     | <span class='neutral'>        internal</span>
 136 |     | <span class='neutral'>        pure</span>
 137 |     | <span class='neutral'>        returns (string memory)</span>
 138 |     | <span class='neutral'>    {</span>
 139 |     | <span class='neutral'>        return el(</span>
 140 |     | <span class='neutral'>            &quot;stop&quot;,</span>
 141 |     | <span class='neutral'>            string.concat(</span>
 142 |     | <span class='neutral'>                prop(&quot;stop-color&quot;, stopColor),</span>
 143 |     | <span class='neutral'>                &quot; &quot;,</span>
 144 |     | <span class='neutral'>                prop(&quot;offset&quot;, string.concat(LibString.toString(offset), &quot;%&quot;)),</span>
 145 |     | <span class='neutral'>                &quot; &quot;,</span>
 146 |     | <span class='neutral'>                _props</span>
 147 |     | <span class='neutral'>            ),</span>
 148 |     | <span class='neutral'>            utils.NULL</span>
 149 |     | <span class='neutral'>        );</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    /* ANIMATION */</span>
 153 |     | <span class='neutral'>    function animateTransform(string memory _props) internal pure returns (string memory) {</span>
 154 |     | <span class='neutral'>        return el(&quot;animateTransform&quot;, _props);</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    function animate(string memory _props) internal pure returns (string memory) {</span>
 158 |     | <span class='neutral'>        return el(&quot;animate&quot;, _props);</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    /* COMMON */</span>
 162 |     | <span class='neutral'>    // A generic element, can be used to construct any SVG (or HTML) element</span>
 163 |     | <span class='unexecuted'>    function el(string memory _tag, string memory _props, string memory _children)</span>
 164 |     | <span class='neutral'>        internal</span>
 165 |     | <span class='neutral'>        pure</span>
 166 |     | <span class='unexecuted'>        returns (string memory)</span>
 167 |     | <span class='neutral'>    {</span>
 168 |     | <span class='unexecuted'>        return string.concat(&quot;&lt;&quot;, _tag, &quot; &quot;, _props, &quot;&gt;&quot;, _children, &quot;&lt;/&quot;, _tag, &quot;&gt;&quot;);</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    // A generic element, can be used to construct SVG (or HTML) elements without children</span>
 172 |     | <span class='unexecuted'>    function el(string memory _tag, string memory _props) internal pure returns (string memory) {</span>
 173 |     | <span class='unexecuted'>        return string.concat(&quot;&lt;&quot;, _tag, &quot; &quot;, _props, &quot;/&gt;&quot;);</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    // an SVG attribute</span>
 177 |     | <span class='unexecuted'>    function prop(string memory _key, string memory _val) internal pure returns (string memory) {</span>
 178 |     | <span class='unexecuted'>        return string.concat(_key, &quot;=&quot;, &#39;&quot;&#39;, _val, &#39;&quot; &#39;);</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    function prop(string memory _key, string memory _val, bool last) internal pure returns (string memory) {</span>
 182 |     | <span class='neutral'>        if (last) {</span>
 183 |     | <span class='neutral'>            return string.concat(_key, &quot;=&quot;, &#39;&quot;&#39;, _val, &#39;&quot;&#39;);</span>
 184 |     | <span class='neutral'>        } else {</span>
 185 |     | <span class='neutral'>            return string.concat(_key, &quot;=&quot;, &#39;&quot;&#39;, _val, &#39;&quot; &#39;);</span>
 186 |     | <span class='neutral'>        }</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'>}</span>
 189 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/NFTMetadata/utils/Utils.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;lib/Solady/src/utils/LibString.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='unexecuted'>library numUtils {</span>
   7 |     | <span class='unexecuted'>    function toLocale(string memory _wholeNumber) internal pure returns (string memory) {</span>
   8 |     | <span class='unexecuted'>        bytes memory b = bytes(_wholeNumber);</span>
   9 |     | <span class='unexecuted'>        uint256 len = b.length;</span>
  10 |     | <span class='unexecuted'>        if (len &lt; 4) return _wholeNumber;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>        uint256 numCommas = (len - 1) / 3;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>        bytes memory result = new bytes(len + numCommas);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>        uint256 j = result.length - 1;</span>
  17 |     | <span class='unexecuted'>        uint256 k = len;</span>
  18 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; len; i++) {</span>
  19 |     | <span class='unexecuted'>            result[j] = b[k - 1];</span>
  20 |     | <span class='unexecuted'>            j = j &gt; 1 ? j - 1 : 0;</span>
  21 |     | <span class='unexecuted'>            k--;</span>
  22 |     | <span class='unexecuted'>            if (k &gt; 0 &amp;&amp; (len - k) % 3 == 0) {</span>
  23 |     | <span class='unexecuted'>                result[j] = &quot;,&quot;;</span>
  24 |     | <span class='unexecuted'>                j = j &gt; 1 ? j - 1 : 0;</span>
  25 |     | <span class='neutral'>            }</span>
  26 |     | <span class='neutral'>        }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>        return string(result);</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    // returns a string representation of a number with commas, where result = _value / 10 ** _divisor</span>
  32 |     | <span class='unexecuted'>    function toLocaleString(uint256 _value, uint8 _divisor, uint8 _precision) internal pure returns (string memory) {</span>
  33 |     | <span class='unexecuted'>        uint256 whole;</span>
  34 |     | <span class='neutral'>        uint256 fraction;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>        if (_divisor &gt; 0) {</span>
  37 |     | <span class='unexecuted'>            whole = _value / 10 ** _divisor;</span>
  38 |     | <span class='neutral'>            // check if the divisor is less than the precision</span>
  39 |     | <span class='unexecuted'>            if (_divisor &lt;= _precision) {</span>
  40 |     | <span class='unexecuted'>                fraction = (_value % 10 ** _divisor);</span>
  41 |     | <span class='neutral'>                // adjust fraction to be the same as the precision</span>
  42 |     | <span class='unexecuted'>                fraction = fraction * 10 ** (_precision - _divisor);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>                // if whole is zero, then add another zero to the fraction, special case if the value is 1</span>
  45 |     | <span class='unexecuted'>                fraction = (whole == 0 &amp;&amp; _value != 1) ? fraction * 10 : fraction;</span>
  46 |     | <span class='neutral'>            } else {</span>
  47 |     | <span class='unexecuted'>                fraction = (_value % 10 ** _divisor) / 10 ** (_divisor - _precision - 1);</span>
  48 |     | <span class='neutral'>            }</span>
  49 |     | <span class='neutral'>        } else {</span>
  50 |     | <span class='unexecuted'>            whole = _value;</span>
  51 |     | <span class='neutral'>        }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>        string memory wholeStr = toLocale(LibString.toString(whole));</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>        if (fraction == 0) {</span>
  56 |     | <span class='unexecuted'>            if (whole &gt; 0 &amp;&amp; _precision &gt; 0) wholeStr = string.concat(wholeStr, &quot;.&quot;);</span>
  57 |     | <span class='unexecuted'>            for (uint8 i = 0; i &lt; _precision; i++) {</span>
  58 |     | <span class='unexecuted'>                wholeStr = string.concat(wholeStr, &quot;0&quot;);</span>
  59 |     | <span class='neutral'>            }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>            return wholeStr;</span>
  62 |     | <span class='neutral'>        }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>        string memory fractionStr = LibString.slice(LibString.toString(fraction), 0, _precision);</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        // pad with leading zeros</span>
  67 |     | <span class='unexecuted'>        if (_precision &gt; bytes(fractionStr).length) {</span>
  68 |     | <span class='unexecuted'>            uint256 len = _precision - bytes(fractionStr).length;</span>
  69 |     | <span class='unexecuted'>            string memory zeroStr = &quot;&quot;;</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>            for (uint8 i = 0; i &lt; len; i++) {</span>
  72 |     | <span class='unexecuted'>                zeroStr = string.concat(zeroStr, &quot;0&quot;);</span>
  73 |     | <span class='neutral'>            }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>            fractionStr = string.concat(zeroStr, fractionStr);</span>
  76 |     | <span class='neutral'>        }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>        return string.concat(wholeStr, _precision &gt; 0 ? &quot;.&quot; : &quot;&quot;, fractionStr);</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'>}</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>/// @notice Core utils used extensively to format CSS and numbers.</span>
  83 |     | <span class='neutral'>/// @author Modified from (https://github.com/w1nt3r-eth/hot-chain-svg/blob/main/contracts/Utils.sol) by w1nt3r-eth.</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>library utils {</span>
  86 |     | <span class='neutral'>    // used to simulate empty strings</span>
  87 |     | <span class='neutral'>    string internal constant NULL = &quot;&quot;;</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    // formats a CSS variable line. includes a semicolon for formatting.</span>
  90 |     | <span class='neutral'>    function setCssVar(string memory _key, string memory _val) internal pure returns (string memory) {</span>
  91 |     | <span class='neutral'>        return string.concat(&quot;--&quot;, _key, &quot;:&quot;, _val, &quot;;&quot;);</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    // formats getting a css variable</span>
  95 |     | <span class='neutral'>    function getCssVar(string memory _key) internal pure returns (string memory) {</span>
  96 |     | <span class='neutral'>        return string.concat(&quot;var(--&quot;, _key, &quot;)&quot;);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    // formats getting a def URL</span>
 100 |     | <span class='neutral'>    function getDefURL(string memory _id) internal pure returns (string memory) {</span>
 101 |     | <span class='neutral'>        return string.concat(&quot;url(#&quot;, _id, &quot;)&quot;);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    // formats rgba white with a specified opacity / alpha</span>
 105 |     | <span class='neutral'>    function white_a(uint256 _a) internal pure returns (string memory) {</span>
 106 |     | <span class='neutral'>        return rgba(255, 255, 255, _a);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    // formats rgba black with a specified opacity / alpha</span>
 110 |     | <span class='neutral'>    function black_a(uint256 _a) internal pure returns (string memory) {</span>
 111 |     | <span class='neutral'>        return rgba(0, 0, 0, _a);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    // formats generic rgba color in css</span>
 115 |     | <span class='neutral'>    function rgba(uint256 _r, uint256 _g, uint256 _b, uint256 _a) internal pure returns (string memory) {</span>
 116 |     | <span class='neutral'>        string memory formattedA = _a &lt; 100 ? string.concat(&quot;0.&quot;, LibString.toString(_a)) : &quot;1&quot;;</span>
 117 |     | <span class='neutral'>        return string.concat(</span>
 118 |     | <span class='neutral'>            &quot;rgba(&quot;,</span>
 119 |     | <span class='neutral'>            LibString.toString(_r),</span>
 120 |     | <span class='neutral'>            &quot;,&quot;,</span>
 121 |     | <span class='neutral'>            LibString.toString(_g),</span>
 122 |     | <span class='neutral'>            &quot;,&quot;,</span>
 123 |     | <span class='neutral'>            LibString.toString(_b),</span>
 124 |     | <span class='neutral'>            &quot;,&quot;,</span>
 125 |     | <span class='neutral'>            formattedA,</span>
 126 |     | <span class='neutral'>            &quot;)&quot;</span>
 127 |     | <span class='neutral'>        );</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    function cssBraces(string memory _attribute, string memory _value) internal pure returns (string memory) {</span>
 131 |     | <span class='neutral'>        return string.concat(&quot; {&quot;, _attribute, &quot;: &quot;, _value, &quot;}&quot;);</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    function cssBraces(string[] memory _attributes, string[] memory _values) internal pure returns (string memory) {</span>
 135 |     | <span class='neutral'>        require(_attributes.length == _values.length, &quot;Utils: Unbalanced Arrays&quot;);</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>        uint256 len = _attributes.length;</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>        string memory results = &quot; {&quot;;</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; len; i++) {</span>
 142 |     | <span class='neutral'>            results = string.concat(results, _attributes[i], &quot;: &quot;, _values[i], &quot;; &quot;);</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>        return string.concat(results, &quot;}&quot;);</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    //deals with integers (i.e. no decimals)</span>
 149 |     | <span class='neutral'>    function points(uint256[2][] memory pointsArray) internal pure returns (string memory) {</span>
 150 |     | <span class='neutral'>        require(pointsArray.length &gt;= 3, &quot;Utils: Array too short&quot;);</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>        uint256 len = pointsArray.length - 1;</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>        string memory results = &#39;points=&quot;&#39;;</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; len; i++) {</span>
 157 |     | <span class='neutral'>            results = string.concat(</span>
 158 |     | <span class='neutral'>                results, LibString.toString(pointsArray[i][0]), &quot;,&quot;, LibString.toString(pointsArray[i][1]), &quot; &quot;</span>
 159 |     | <span class='neutral'>            );</span>
 160 |     | <span class='neutral'>        }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>        return string.concat(</span>
 163 |     | <span class='neutral'>            results, LibString.toString(pointsArray[len][0]), &quot;,&quot;, LibString.toString(pointsArray[len][1]), &#39;&quot;&#39;</span>
 164 |     | <span class='neutral'>        );</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    // allows for a uniform precision to be applied to all points</span>
 168 |     | <span class='neutral'>    function points(uint256[2][] memory pointsArray, uint256 decimalPrecision) internal pure returns (string memory) {</span>
 169 |     | <span class='neutral'>        require(pointsArray.length &gt;= 3, &quot;Utils: Array too short&quot;);</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>        uint256 len = pointsArray.length - 1;</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>        string memory results = &#39;points=&quot;&#39;;</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; len; i++) {</span>
 176 |     | <span class='neutral'>            results = string.concat(</span>
 177 |     | <span class='neutral'>                results,</span>
 178 |     | <span class='neutral'>                toString(pointsArray[i][0], decimalPrecision),</span>
 179 |     | <span class='neutral'>                &quot;,&quot;,</span>
 180 |     | <span class='neutral'>                toString(pointsArray[i][1], decimalPrecision),</span>
 181 |     | <span class='neutral'>                &quot; &quot;</span>
 182 |     | <span class='neutral'>            );</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>        return string.concat(</span>
 186 |     | <span class='neutral'>            results,</span>
 187 |     | <span class='neutral'>            toString(pointsArray[len][0], decimalPrecision),</span>
 188 |     | <span class='neutral'>            &quot;,&quot;,</span>
 189 |     | <span class='neutral'>            toString(pointsArray[len][1], decimalPrecision),</span>
 190 |     | <span class='neutral'>            &#39;&quot;&#39;</span>
 191 |     | <span class='neutral'>        );</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    // checks if two strings are equal</span>
 195 |     | <span class='neutral'>    function stringsEqual(string memory _a, string memory _b) internal pure returns (bool) {</span>
 196 |     | <span class='neutral'>        return keccak256(abi.encodePacked(_a)) == keccak256(abi.encodePacked(_b));</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>    // returns the length of a string in characters</span>
 200 |     | <span class='neutral'>    function utfStringLength(string memory _str) internal pure returns (uint256 length) {</span>
 201 |     | <span class='neutral'>        uint256 i = 0;</span>
 202 |     | <span class='neutral'>        bytes memory string_rep = bytes(_str);</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>        while (i &lt; string_rep.length) {</span>
 205 |     | <span class='neutral'>            if (string_rep[i] &gt;&gt; 7 == 0) {</span>
 206 |     | <span class='neutral'>                i += 1;</span>
 207 |     | <span class='neutral'>            } else if (string_rep[i] &gt;&gt; 5 == bytes1(uint8(0x6))) {</span>
 208 |     | <span class='neutral'>                i += 2;</span>
 209 |     | <span class='neutral'>            } else if (string_rep[i] &gt;&gt; 4 == bytes1(uint8(0xE))) {</span>
 210 |     | <span class='neutral'>                i += 3;</span>
 211 |     | <span class='neutral'>            } else if (string_rep[i] &gt;&gt; 3 == bytes1(uint8(0x1E))) {</span>
 212 |     | <span class='neutral'>                i += 4;</span>
 213 |     | <span class='neutral'>            }</span>
 214 |     | <span class='neutral'>            //For safety</span>
 215 |     | <span class='neutral'>            else {</span>
 216 |     | <span class='neutral'>                i += 1;</span>
 217 |     | <span class='neutral'>            }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>            length++;</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    // allows the insertion of a decimal point in the returned string at precision</span>
 224 |     | <span class='neutral'>    function toString(uint256 value, uint256 precision) internal pure returns (string memory) {</span>
 225 |     | <span class='neutral'>        // Inspired by OraclizeAPI&#39;s implementation - MIT licence</span>
 226 |     | <span class='neutral'>        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>        if (value == 0) {</span>
 229 |     | <span class='neutral'>            return &quot;0&quot;;</span>
 230 |     | <span class='neutral'>        }</span>
 231 |     | <span class='neutral'>        uint256 temp = value;</span>
 232 |     | <span class='neutral'>        uint256 digits;</span>
 233 |     | <span class='neutral'>        while (temp != 0) {</span>
 234 |     | <span class='neutral'>            digits++;</span>
 235 |     | <span class='neutral'>            temp /= 10;</span>
 236 |     | <span class='neutral'>        }</span>
 237 |     | <span class='neutral'>        require(precision &lt;= digits &amp;&amp; precision &gt; 0, &quot;Utils: precision invalid&quot;);</span>
 238 |     | <span class='neutral'>        precision == digits ? digits += 2 : digits++; //adds a space for the decimal point, 2 if it is the whole uint</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>        uint256 decimalPlacement = digits - precision - 1;</span>
 241 |     | <span class='neutral'>        bytes memory buffer = new bytes(digits);</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>        buffer[decimalPlacement] = 0x2E; // add the decimal point, ASCII 46/hex 2E</span>
 244 |     | <span class='neutral'>        if (decimalPlacement == 1) {</span>
 245 |     | <span class='neutral'>            buffer[0] = 0x30;</span>
 246 |     | <span class='neutral'>        }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>        while (value != 0) {</span>
 249 |     | <span class='neutral'>            digits -= 1;</span>
 250 |     | <span class='neutral'>            if (digits != decimalPlacement) {</span>
 251 |     | <span class='neutral'>                buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));</span>
 252 |     | <span class='neutral'>                value /= 10;</span>
 253 |     | <span class='neutral'>            }</span>
 254 |     | <span class='neutral'>        }</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>        return string(buffer);</span>
 257 |     | <span class='neutral'>    }</span>
 258 |     | <span class='neutral'>}</span>
 259 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/NFTMetadata/utils/baseSVG.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {svg} from &quot;./SVG.sol&quot;;</span>
   5 |     | <span class='neutral'>import {utils, LibString, numUtils} from &quot;./Utils.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./FixedAssets.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>library baseSVG {</span>
   9 |     | <span class='neutral'>    string constant GEIST = &#39;style=&quot;font-family: Geist&quot; &#39;;</span>
  10 |     | <span class='neutral'>    string constant DARK_BLUE = &quot;#121B44&quot;;</span>
  11 |     | <span class='neutral'>    string constant STOIC_WHITE = &quot;#DEE4FB&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>    function _svgProps() internal pure returns (string memory) {</span>
  14 |     | <span class='unexecuted'>        return string.concat(</span>
  15 |     | <span class='unexecuted'>            svg.prop(&quot;width&quot;, &quot;300&quot;),</span>
  16 |     | <span class='unexecuted'>            svg.prop(&quot;height&quot;, &quot;484&quot;),</span>
  17 |     | <span class='unexecuted'>            svg.prop(&quot;viewBox&quot;, &quot;0 0 300 484&quot;),</span>
  18 |     | <span class='unexecuted'>            svg.prop(&quot;style&quot;, &quot;background:none&quot;)</span>
  19 |     | <span class='neutral'>        );</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>    function _baseElements(FixedAssetReader _assetReader) internal view returns (string memory) {</span>
  23 |     | <span class='unexecuted'>        return string.concat(</span>
  24 |     | <span class='unexecuted'>            svg.rect(</span>
  25 |     | <span class='unexecuted'>                string.concat(</span>
  26 |     | <span class='unexecuted'>                    svg.prop(&quot;fill&quot;, DARK_BLUE),</span>
  27 |     | <span class='unexecuted'>                    svg.prop(&quot;rx&quot;, &quot;8&quot;),</span>
  28 |     | <span class='unexecuted'>                    svg.prop(&quot;width&quot;, &quot;300&quot;),</span>
  29 |     | <span class='unexecuted'>                    svg.prop(&quot;height&quot;, &quot;484&quot;)</span>
  30 |     | <span class='neutral'>                )</span>
  31 |     | <span class='neutral'>            ),</span>
  32 |     | <span class='unexecuted'>            _styles(_assetReader),</span>
  33 |     | <span class='unexecuted'>            _leverageLogo(),</span>
  34 |     | <span class='unexecuted'>            _boldLogo(_assetReader),</span>
  35 |     | <span class='unexecuted'>            _staticTextEls()</span>
  36 |     | <span class='neutral'>        );</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    function _styles(FixedAssetReader _assetReader) private view returns (string memory) {</span>
  40 |     | <span class='unexecuted'>        return svg.el(</span>
  41 |     | <span class='neutral'>            &quot;style&quot;,</span>
  42 |     | <span class='unexecuted'>            utils.NULL,</span>
  43 |     | <span class='unexecuted'>            string.concat(</span>
  44 |     | <span class='neutral'>                &#39;@font-face { font-family: &quot;Geist&quot;; src: url(&quot;data:font/woff2;utf-8;base64,&#39;,</span>
  45 |     | <span class='unexecuted'>                _assetReader.readAsset(bytes4(keccak256(&quot;geist&quot;))),</span>
  46 |     | <span class='neutral'>                &#39;&quot;); }&#39;</span>
  47 |     | <span class='neutral'>            )</span>
  48 |     | <span class='neutral'>        );</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>    function _leverageLogo() internal pure returns (string memory) {</span>
  52 |     | <span class='unexecuted'>        return string.concat(</span>
  53 |     | <span class='unexecuted'>            svg.path(</span>
  54 |     | <span class='neutral'>                &quot;M20.2 31.2C19.1 32.4 17.6 33 16 33L16 21C17.6 21 19.1 21.6 20.2 22.7C21.4 23.9 22 25.4 22 27C22 28.6 21.4 30.1 20.2 31.2Z&quot;,</span>
  55 |     | <span class='unexecuted'>                svg.prop(&quot;fill&quot;, STOIC_WHITE)</span>
  56 |     | <span class='neutral'>            ),</span>
  57 |     | <span class='unexecuted'>            svg.path(</span>
  58 |     | <span class='neutral'>                &quot;M22 27C22 25.4 22.6 23.9 23.8 22.7C25 21.6 26.4 21 28 21V33C26.4 33 25 32.4 24 31.2C22.6 30.1 22 28.6 22 27Z&quot;,</span>
  59 |     | <span class='unexecuted'>                svg.prop(&quot;fill&quot;, STOIC_WHITE)</span>
  60 |     | <span class='neutral'>            )</span>
  61 |     | <span class='neutral'>        );</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>    function _boldLogo(FixedAssetReader _assetReader) internal view returns (string memory) {</span>
  65 |     | <span class='unexecuted'>        return svg.el(</span>
  66 |     | <span class='neutral'>            &quot;image&quot;,</span>
  67 |     | <span class='neutral'>            string.concat(</span>
  68 |     | <span class='unexecuted'>                svg.prop(&quot;x&quot;, &quot;264&quot;),</span>
  69 |     | <span class='unexecuted'>                svg.prop(&quot;y&quot;, &quot;373.5&quot;),</span>
  70 |     | <span class='unexecuted'>                svg.prop(&quot;width&quot;, &quot;20&quot;),</span>
  71 |     | <span class='unexecuted'>                svg.prop(&quot;height&quot;, &quot;20&quot;),</span>
  72 |     | <span class='unexecuted'>                svg.prop(</span>
  73 |     | <span class='neutral'>                    &quot;href&quot;,</span>
  74 |     | <span class='unexecuted'>                    string.concat(&quot;data:image/svg+xml;base64,&quot;, _assetReader.readAsset(bytes4(keccak256(&quot;BOLD&quot;))))</span>
  75 |     | <span class='neutral'>                )</span>
  76 |     | <span class='neutral'>            )</span>
  77 |     | <span class='neutral'>        );</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>    function _staticTextEls() internal pure returns (string memory) {</span>
  81 |     | <span class='unexecuted'>        return string.concat(</span>
  82 |     | <span class='unexecuted'>            svg.text(</span>
  83 |     | <span class='unexecuted'>                string.concat(</span>
  84 |     | <span class='unexecuted'>                    GEIST,</span>
  85 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;16&quot;),</span>
  86 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;358&quot;),</span>
  87 |     | <span class='unexecuted'>                    svg.prop(&quot;font-size&quot;, &quot;14&quot;),</span>
  88 |     | <span class='unexecuted'>                    svg.prop(&quot;fill&quot;, &quot;white&quot;)</span>
  89 |     | <span class='neutral'>                ),</span>
  90 |     | <span class='neutral'>                &quot;Collateral&quot;</span>
  91 |     | <span class='neutral'>            ),</span>
  92 |     | <span class='unexecuted'>            svg.text(</span>
  93 |     | <span class='unexecuted'>                string.concat(</span>
  94 |     | <span class='unexecuted'>                    GEIST,</span>
  95 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;16&quot;),</span>
  96 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;389&quot;),</span>
  97 |     | <span class='unexecuted'>                    svg.prop(&quot;font-size&quot;, &quot;14&quot;),</span>
  98 |     | <span class='unexecuted'>                    svg.prop(&quot;fill&quot;, &quot;white&quot;)</span>
  99 |     | <span class='neutral'>                ),</span>
 100 |     | <span class='neutral'>                &quot;Debt&quot;</span>
 101 |     | <span class='neutral'>            ),</span>
 102 |     | <span class='unexecuted'>            svg.text(</span>
 103 |     | <span class='unexecuted'>                string.concat(</span>
 104 |     | <span class='unexecuted'>                    GEIST,</span>
 105 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;16&quot;),</span>
 106 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;420&quot;),</span>
 107 |     | <span class='unexecuted'>                    svg.prop(&quot;font-size&quot;, &quot;14&quot;),</span>
 108 |     | <span class='unexecuted'>                    svg.prop(&quot;fill&quot;, &quot;white&quot;)</span>
 109 |     | <span class='neutral'>                ),</span>
 110 |     | <span class='neutral'>                &quot;Interest Rate&quot;</span>
 111 |     | <span class='neutral'>            ),</span>
 112 |     | <span class='unexecuted'>            svg.text(</span>
 113 |     | <span class='unexecuted'>                string.concat(</span>
 114 |     | <span class='unexecuted'>                    GEIST,</span>
 115 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;265&quot;),</span>
 116 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;422&quot;),</span>
 117 |     | <span class='unexecuted'>                    svg.prop(&quot;font-size&quot;, &quot;20&quot;),</span>
 118 |     | <span class='unexecuted'>                    svg.prop(&quot;fill&quot;, &quot;white&quot;)</span>
 119 |     | <span class='neutral'>                ),</span>
 120 |     | <span class='neutral'>                &quot;%&quot;</span>
 121 |     | <span class='neutral'>            ),</span>
 122 |     | <span class='unexecuted'>            svg.text(</span>
 123 |     | <span class='unexecuted'>                string.concat(</span>
 124 |     | <span class='unexecuted'>                    GEIST,</span>
 125 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;16&quot;),</span>
 126 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;462&quot;),</span>
 127 |     | <span class='unexecuted'>                    svg.prop(&quot;font-size&quot;, &quot;14&quot;),</span>
 128 |     | <span class='unexecuted'>                    svg.prop(&quot;fill&quot;, &quot;white&quot;)</span>
 129 |     | <span class='neutral'>                ),</span>
 130 |     | <span class='neutral'>                &quot;Owner&quot;</span>
 131 |     | <span class='neutral'>            )</span>
 132 |     | <span class='neutral'>        );</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>    function _formattedDynamicEl(string memory _value, uint256 _x, uint256 _y) internal pure returns (string memory) {</span>
 136 |     | <span class='unexecuted'>        return svg.text(</span>
 137 |     | <span class='unexecuted'>            string.concat(</span>
 138 |     | <span class='unexecuted'>                GEIST,</span>
 139 |     | <span class='unexecuted'>                svg.prop(&quot;text-anchor&quot;, &quot;end&quot;),</span>
 140 |     | <span class='unexecuted'>                svg.prop(&quot;x&quot;, LibString.toString(_x)),</span>
 141 |     | <span class='unexecuted'>                svg.prop(&quot;y&quot;, LibString.toString(_y)),</span>
 142 |     | <span class='unexecuted'>                svg.prop(&quot;font-size&quot;, &quot;20&quot;),</span>
 143 |     | <span class='unexecuted'>                svg.prop(&quot;fill&quot;, &quot;white&quot;)</span>
 144 |     | <span class='neutral'>            ),</span>
 145 |     | <span class='unexecuted'>            _value</span>
 146 |     | <span class='neutral'>        );</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='unexecuted'>    function _formattedIdEl(string memory _id) internal pure returns (string memory) {</span>
 150 |     | <span class='unexecuted'>        return svg.text(</span>
 151 |     | <span class='unexecuted'>            string.concat(</span>
 152 |     | <span class='unexecuted'>                GEIST,</span>
 153 |     | <span class='unexecuted'>                svg.prop(&quot;text-anchor&quot;, &quot;end&quot;),</span>
 154 |     | <span class='unexecuted'>                svg.prop(&quot;x&quot;, &quot;284&quot;),</span>
 155 |     | <span class='unexecuted'>                svg.prop(&quot;y&quot;, &quot;33&quot;),</span>
 156 |     | <span class='unexecuted'>                svg.prop(&quot;font-size&quot;, &quot;14&quot;),</span>
 157 |     | <span class='unexecuted'>                svg.prop(&quot;fill&quot;, &quot;white&quot;)</span>
 158 |     | <span class='neutral'>            ),</span>
 159 |     | <span class='unexecuted'>            _id</span>
 160 |     | <span class='neutral'>        );</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>    function _formattedAddressEl(address _address) internal pure returns (string memory) {</span>
 164 |     | <span class='unexecuted'>        return svg.text(</span>
 165 |     | <span class='unexecuted'>            string.concat(</span>
 166 |     | <span class='unexecuted'>                GEIST,</span>
 167 |     | <span class='unexecuted'>                svg.prop(&quot;text-anchor&quot;, &quot;end&quot;),</span>
 168 |     | <span class='unexecuted'>                svg.prop(&quot;x&quot;, &quot;284&quot;),</span>
 169 |     | <span class='unexecuted'>                svg.prop(&quot;y&quot;, &quot;462&quot;),</span>
 170 |     | <span class='unexecuted'>                svg.prop(&quot;font-size&quot;, &quot;14&quot;),</span>
 171 |     | <span class='unexecuted'>                svg.prop(&quot;fill&quot;, &quot;white&quot;)</span>
 172 |     | <span class='neutral'>            ),</span>
 173 |     | <span class='unexecuted'>            string.concat(</span>
 174 |     | <span class='unexecuted'>                LibString.slice(LibString.toHexStringChecksummed(_address), 0, 6),</span>
 175 |     | <span class='neutral'>                &quot;...&quot;,</span>
 176 |     | <span class='unexecuted'>                LibString.slice(LibString.toHexStringChecksummed(_address), 38, 42)</span>
 177 |     | <span class='neutral'>            )</span>
 178 |     | <span class='neutral'>        );</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>    function _collLogo(string memory _collName, FixedAssetReader _assetReader) internal view returns (string memory) {</span>
 182 |     | <span class='unexecuted'>        return svg.el(</span>
 183 |     | <span class='neutral'>            &quot;image&quot;,</span>
 184 |     | <span class='unexecuted'>            string.concat(</span>
 185 |     | <span class='unexecuted'>                svg.prop(&quot;x&quot;, &quot;264&quot;),</span>
 186 |     | <span class='unexecuted'>                svg.prop(&quot;y&quot;, &quot;342.5&quot;),</span>
 187 |     | <span class='unexecuted'>                svg.prop(&quot;width&quot;, &quot;20&quot;),</span>
 188 |     | <span class='unexecuted'>                svg.prop(&quot;height&quot;, &quot;20&quot;),</span>
 189 |     | <span class='unexecuted'>                svg.prop(</span>
 190 |     | <span class='neutral'>                    &quot;href&quot;,</span>
 191 |     | <span class='unexecuted'>                    string.concat(</span>
 192 |     | <span class='unexecuted'>                        &quot;data:image/svg+xml;base64,&quot;, _assetReader.readAsset(bytes4(keccak256(bytes(_collName))))</span>
 193 |     | <span class='neutral'>                    )</span>
 194 |     | <span class='neutral'>                )</span>
 195 |     | <span class='neutral'>            )</span>
 196 |     | <span class='neutral'>        );</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='unexecuted'>    function _statusEl(string memory _status) internal pure returns (string memory) {</span>
 200 |     | <span class='unexecuted'>        return svg.text(</span>
 201 |     | <span class='unexecuted'>            string.concat(</span>
 202 |     | <span class='unexecuted'>                GEIST, svg.prop(&quot;x&quot;, &quot;40&quot;), svg.prop(&quot;y&quot;, &quot;33&quot;), svg.prop(&quot;font-size&quot;, &quot;14&quot;), svg.prop(&quot;fill&quot;, &quot;white&quot;)</span>
 203 |     | <span class='neutral'>            ),</span>
 204 |     | <span class='neutral'>            _status</span>
 205 |     | <span class='neutral'>        );</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='unexecuted'>    function _dynamicTextEls(uint256 _debt, uint256 _coll, uint256 _annualInterestRate)</span>
 209 |     | <span class='neutral'>        internal</span>
 210 |     | <span class='neutral'>        pure</span>
 211 |     | <span class='unexecuted'>        returns (string memory)</span>
 212 |     | <span class='neutral'>    {</span>
 213 |     | <span class='unexecuted'>        return string.concat(</span>
 214 |     | <span class='unexecuted'>            _formattedDynamicEl(numUtils.toLocaleString(_coll, 18, 4), 256, 360),</span>
 215 |     | <span class='unexecuted'>            _formattedDynamicEl(numUtils.toLocaleString(_debt, 18, 2), 256, 391),</span>
 216 |     | <span class='unexecuted'>            _formattedDynamicEl(numUtils.toLocaleString(_annualInterestRate, 16, 2), 256, 422)</span>
 217 |     | <span class='neutral'>        );</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'>}</span>
 220 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/NFTMetadata/utils/bauhaus.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./SVG.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='unexecuted'>library bauhaus {</span>
   7 |     | <span class='neutral'>    string constant GOLDEN = &quot;#F5D93A&quot;;</span>
   8 |     | <span class='neutral'>    string constant CORAL = &quot;#FB7C59&quot;;</span>
   9 |     | <span class='neutral'>    string constant GREEN = &quot;#63D77D&quot;;</span>
  10 |     | <span class='neutral'>    string constant CYAN = &quot;#95CBF3&quot;;</span>
  11 |     | <span class='neutral'>    string constant BLUE = &quot;#405AE5&quot;;</span>
  12 |     | <span class='neutral'>    string constant DARK_BLUE = &quot;#121B44&quot;;</span>
  13 |     | <span class='neutral'>    string constant BROWN = &quot;#D99664&quot;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    enum colorCode {</span>
  16 |     | <span class='neutral'>        GOLDEN,</span>
  17 |     | <span class='neutral'>        CORAL,</span>
  18 |     | <span class='neutral'>        GREEN,</span>
  19 |     | <span class='neutral'>        CYAN,</span>
  20 |     | <span class='neutral'>        BLUE,</span>
  21 |     | <span class='neutral'>        DARK_BLUE,</span>
  22 |     | <span class='neutral'>        BROWN</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    function _bauhaus(string memory _collName, uint256 _troveId) internal pure returns (string memory) {</span>
  26 |     | <span class='unexecuted'>        bytes32 collSig = keccak256(bytes(_collName));</span>
  27 |     | <span class='unexecuted'>        uint256 variant = _troveId % 4;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>        if (collSig == keccak256(&quot;WETH&quot;)) {</span>
  30 |     | <span class='unexecuted'>            return _img1(variant);</span>
  31 |     | <span class='unexecuted'>        } else if (collSig == keccak256(&quot;wstETH&quot;)) {</span>
  32 |     | <span class='unexecuted'>            return _img2(variant);</span>
  33 |     | <span class='neutral'>        } else {</span>
  34 |     | <span class='neutral'>            // assume rETH</span>
  35 |     | <span class='unexecuted'>            return _img3(variant);</span>
  36 |     | <span class='neutral'>        }</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    function _colorCode2Hex(colorCode _color) private pure returns (string memory) {</span>
  40 |     | <span class='unexecuted'>        if (_color == colorCode.GOLDEN) {</span>
  41 |     | <span class='unexecuted'>            return GOLDEN;</span>
  42 |     | <span class='unexecuted'>        } else if (_color == colorCode.CORAL) {</span>
  43 |     | <span class='unexecuted'>            return CORAL;</span>
  44 |     | <span class='unexecuted'>        } else if (_color == colorCode.GREEN) {</span>
  45 |     | <span class='unexecuted'>            return GREEN;</span>
  46 |     | <span class='unexecuted'>        } else if (_color == colorCode.CYAN) {</span>
  47 |     | <span class='unexecuted'>            return CYAN;</span>
  48 |     | <span class='unexecuted'>        } else if (_color == colorCode.BLUE) {</span>
  49 |     | <span class='unexecuted'>            return BLUE;</span>
  50 |     | <span class='unexecuted'>        } else if (_color == colorCode.DARK_BLUE) {</span>
  51 |     | <span class='unexecuted'>            return DARK_BLUE;</span>
  52 |     | <span class='neutral'>        } else {</span>
  53 |     | <span class='unexecuted'>            return BROWN;</span>
  54 |     | <span class='neutral'>        }</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    struct COLORS {</span>
  58 |     | <span class='neutral'>        colorCode rect1;</span>
  59 |     | <span class='neutral'>        colorCode rect2;</span>
  60 |     | <span class='neutral'>        colorCode rect3;</span>
  61 |     | <span class='neutral'>        colorCode rect4;</span>
  62 |     | <span class='neutral'>        colorCode rect5;</span>
  63 |     | <span class='neutral'>        colorCode poly;</span>
  64 |     | <span class='neutral'>        colorCode circle1;</span>
  65 |     | <span class='neutral'>        colorCode circle2;</span>
  66 |     | <span class='neutral'>        colorCode circle3;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>    function _colors1(uint256 _variant) internal pure returns (COLORS memory) {</span>
  70 |     | <span class='unexecuted'>        if (_variant == 0) {</span>
  71 |     | <span class='unexecuted'>            return COLORS(</span>
  72 |     | <span class='unexecuted'>                colorCode.BLUE, // rect1</span>
  73 |     | <span class='unexecuted'>                colorCode.GOLDEN, // rect2</span>
  74 |     | <span class='unexecuted'>                colorCode.GOLDEN, // rect3</span>
  75 |     | <span class='unexecuted'>                colorCode.BROWN, // rect4</span>
  76 |     | <span class='unexecuted'>                colorCode.CORAL, // rect5</span>
  77 |     | <span class='unexecuted'>                colorCode.CYAN, // poly</span>
  78 |     | <span class='unexecuted'>                colorCode.GREEN, // circle1</span>
  79 |     | <span class='unexecuted'>                colorCode.DARK_BLUE, // circle2</span>
  80 |     | <span class='unexecuted'>                colorCode.GOLDEN // circle3</span>
  81 |     | <span class='neutral'>            );</span>
  82 |     | <span class='unexecuted'>        } else if (_variant == 1) {</span>
  83 |     | <span class='unexecuted'>            return COLORS(</span>
  84 |     | <span class='unexecuted'>                colorCode.GREEN, // rect1</span>
  85 |     | <span class='unexecuted'>                colorCode.BLUE, // rect2</span>
  86 |     | <span class='unexecuted'>                colorCode.GOLDEN, // rect3</span>
  87 |     | <span class='unexecuted'>                colorCode.BROWN, // rect4</span>
  88 |     | <span class='unexecuted'>                colorCode.GOLDEN, // rect5</span>
  89 |     | <span class='unexecuted'>                colorCode.CORAL, // poly</span>
  90 |     | <span class='unexecuted'>                colorCode.BLUE, // circle1</span>
  91 |     | <span class='unexecuted'>                colorCode.DARK_BLUE, // circle2</span>
  92 |     | <span class='unexecuted'>                colorCode.BLUE // circle3</span>
  93 |     | <span class='neutral'>            );</span>
  94 |     | <span class='unexecuted'>        } else if (_variant == 2) {</span>
  95 |     | <span class='unexecuted'>            return COLORS(</span>
  96 |     | <span class='unexecuted'>                colorCode.BLUE, // rect1</span>
  97 |     | <span class='unexecuted'>                colorCode.GOLDEN, // rect2</span>
  98 |     | <span class='unexecuted'>                colorCode.CYAN, // rect3</span>
  99 |     | <span class='unexecuted'>                colorCode.GOLDEN, // rect4</span>
 100 |     | <span class='unexecuted'>                colorCode.BROWN, // rect5</span>
 101 |     | <span class='unexecuted'>                colorCode.GREEN, // poly</span>
 102 |     | <span class='unexecuted'>                colorCode.CORAL, // circle1</span>
 103 |     | <span class='unexecuted'>                colorCode.DARK_BLUE, // circle2</span>
 104 |     | <span class='unexecuted'>                colorCode.BROWN // circle3</span>
 105 |     | <span class='neutral'>            );</span>
 106 |     | <span class='neutral'>        } else {</span>
 107 |     | <span class='unexecuted'>            return COLORS(</span>
 108 |     | <span class='unexecuted'>                colorCode.CYAN, // rect1</span>
 109 |     | <span class='unexecuted'>                colorCode.BLUE, // rect2</span>
 110 |     | <span class='unexecuted'>                colorCode.BLUE, // rect3</span>
 111 |     | <span class='unexecuted'>                colorCode.BROWN, // rect4</span>
 112 |     | <span class='unexecuted'>                colorCode.BLUE, // rect5</span>
 113 |     | <span class='unexecuted'>                colorCode.GREEN, // poly</span>
 114 |     | <span class='unexecuted'>                colorCode.GOLDEN, // circle1</span>
 115 |     | <span class='neutral'>                colorCode.DARK_BLUE, // circle2</span>
 116 |     | <span class='neutral'>                colorCode.BLUE // circle3</span>
 117 |     | <span class='neutral'>            );</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>    function _img1(uint256 _variant) internal pure returns (string memory) {</span>
 122 |     | <span class='unexecuted'>        COLORS memory colors = _colors1(_variant);</span>
 123 |     | <span class='unexecuted'>        return string.concat(_rects1(colors), _polygons1(colors), _circles1(colors));</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>    function _rects1(COLORS memory _colors) internal pure returns (string memory) {</span>
 127 |     | <span class='unexecuted'>        return string.concat(</span>
 128 |     | <span class='neutral'>            //background</span>
 129 |     | <span class='unexecuted'>            svg.rect(</span>
 130 |     | <span class='unexecuted'>                string.concat(</span>
 131 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;16&quot;),</span>
 132 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;55&quot;),</span>
 133 |     | <span class='unexecuted'>                    svg.prop(&quot;width&quot;, &quot;268&quot;),</span>
 134 |     | <span class='unexecuted'>                    svg.prop(&quot;height&quot;, &quot;268&quot;),</span>
 135 |     | <span class='unexecuted'>                    svg.prop(&quot;fill&quot;, DARK_BLUE)</span>
 136 |     | <span class='neutral'>                )</span>
 137 |     | <span class='neutral'>            ),</span>
 138 |     | <span class='neutral'>            // large right rect | rect1</span>
 139 |     | <span class='unexecuted'>            svg.rect(</span>
 140 |     | <span class='neutral'>                string.concat(</span>
 141 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;128&quot;),</span>
 142 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;55&quot;),</span>
 143 |     | <span class='unexecuted'>                    svg.prop(&quot;width&quot;, &quot;156&quot;),</span>
 144 |     | <span class='unexecuted'>                    svg.prop(&quot;height&quot;, &quot;268&quot;),</span>
 145 |     | <span class='unexecuted'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.rect1))</span>
 146 |     | <span class='neutral'>                )</span>
 147 |     | <span class='neutral'>            ),</span>
 148 |     | <span class='neutral'>            // small upper right rect | rect2</span>
 149 |     | <span class='unexecuted'>            svg.rect(</span>
 150 |     | <span class='neutral'>                string.concat(</span>
 151 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;228&quot;),</span>
 152 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;55&quot;),</span>
 153 |     | <span class='unexecuted'>                    svg.prop(&quot;width&quot;, &quot;56&quot;),</span>
 154 |     | <span class='unexecuted'>                    svg.prop(&quot;height&quot;, &quot;56&quot;),</span>
 155 |     | <span class='unexecuted'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.rect2))</span>
 156 |     | <span class='neutral'>                )</span>
 157 |     | <span class='neutral'>            ),</span>
 158 |     | <span class='neutral'>            // large central left rect | rect3</span>
 159 |     | <span class='unexecuted'>            svg.rect(</span>
 160 |     | <span class='neutral'>                string.concat(</span>
 161 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;16&quot;),</span>
 162 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;111&quot;),</span>
 163 |     | <span class='unexecuted'>                    svg.prop(&quot;width&quot;, &quot;134&quot;),</span>
 164 |     | <span class='unexecuted'>                    svg.prop(&quot;height&quot;, &quot;156&quot;),</span>
 165 |     | <span class='unexecuted'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.rect3))</span>
 166 |     | <span class='neutral'>                )</span>
 167 |     | <span class='neutral'>            ),</span>
 168 |     | <span class='neutral'>            // small lower left rect | rect4</span>
 169 |     | <span class='unexecuted'>            svg.rect(</span>
 170 |     | <span class='neutral'>                string.concat(</span>
 171 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;16&quot;),</span>
 172 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;267&quot;),</span>
 173 |     | <span class='unexecuted'>                    svg.prop(&quot;width&quot;, &quot;112&quot;),</span>
 174 |     | <span class='unexecuted'>                    svg.prop(&quot;height&quot;, &quot;56&quot;),</span>
 175 |     | <span class='unexecuted'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.rect4))</span>
 176 |     | <span class='neutral'>                )</span>
 177 |     | <span class='neutral'>            ),</span>
 178 |     | <span class='neutral'>            // small lower right rect | rect5</span>
 179 |     | <span class='unexecuted'>            svg.rect(</span>
 180 |     | <span class='neutral'>                string.concat(</span>
 181 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;228&quot;),</span>
 182 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;267&quot;),</span>
 183 |     | <span class='unexecuted'>                    svg.prop(&quot;width&quot;, &quot;56&quot;),</span>
 184 |     | <span class='unexecuted'>                    svg.prop(&quot;height&quot;, &quot;56&quot;),</span>
 185 |     | <span class='unexecuted'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.rect5))</span>
 186 |     | <span class='neutral'>                )</span>
 187 |     | <span class='neutral'>            )</span>
 188 |     | <span class='neutral'>        );</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='unexecuted'>    function _polygons1(COLORS memory _colors) internal pure returns (string memory) {</span>
 192 |     | <span class='unexecuted'>        return string.concat(</span>
 193 |     | <span class='neutral'>            // left triangle | poly1</span>
 194 |     | <span class='unexecuted'>            svg.polygon(</span>
 195 |     | <span class='unexecuted'>                string.concat(svg.prop(&quot;points&quot;, &quot;16,55 72,55 16,111&quot;), svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.poly)))</span>
 196 |     | <span class='neutral'>            ),</span>
 197 |     | <span class='neutral'>            // right triangle | poly2</span>
 198 |     | <span class='unexecuted'>            svg.polygon(</span>
 199 |     | <span class='unexecuted'>                string.concat(svg.prop(&quot;points&quot;, &quot;72,55 128,55 72,111&quot;), svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.poly)))</span>
 200 |     | <span class='neutral'>            )</span>
 201 |     | <span class='neutral'>        );</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='unexecuted'>    function _circles1(COLORS memory _colors) internal pure returns (string memory) {</span>
 205 |     | <span class='unexecuted'>        return string.concat(</span>
 206 |     | <span class='neutral'>            //large central circle | circle1</span>
 207 |     | <span class='unexecuted'>            svg.circle(</span>
 208 |     | <span class='unexecuted'>                string.concat(</span>
 209 |     | <span class='unexecuted'>                    svg.prop(&quot;cx&quot;, &quot;150&quot;),</span>
 210 |     | <span class='unexecuted'>                    svg.prop(&quot;cy&quot;, &quot;189&quot;),</span>
 211 |     | <span class='unexecuted'>                    svg.prop(&quot;r&quot;, &quot;78&quot;),</span>
 212 |     | <span class='unexecuted'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.circle1))</span>
 213 |     | <span class='neutral'>                )</span>
 214 |     | <span class='neutral'>            ),</span>
 215 |     | <span class='neutral'>            //small right circle | circle2</span>
 216 |     | <span class='unexecuted'>            svg.circle(</span>
 217 |     | <span class='neutral'>                string.concat(</span>
 218 |     | <span class='unexecuted'>                    svg.prop(&quot;cx&quot;, &quot;228&quot;),</span>
 219 |     | <span class='unexecuted'>                    svg.prop(&quot;cy&quot;, &quot;295&quot;),</span>
 220 |     | <span class='unexecuted'>                    svg.prop(&quot;r&quot;, &quot;28&quot;),</span>
 221 |     | <span class='unexecuted'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.circle2))</span>
 222 |     | <span class='neutral'>                )</span>
 223 |     | <span class='neutral'>            ),</span>
 224 |     | <span class='neutral'>            //small right half circle | circle3</span>
 225 |     | <span class='unexecuted'>            svg.path(</span>
 226 |     | <span class='neutral'>                &quot;M228 267C220.574 267 213.452 269.95 208.201 275.201C202.95 280.452 200 287.574 200 295C200 302.426 202.95 309.548 208.201 314.799C213.452 320.05 220.574 323 228 323L228 267Z&quot;,</span>
 227 |     | <span class='unexecuted'>                svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.circle3))</span>
 228 |     | <span class='neutral'>            )</span>
 229 |     | <span class='neutral'>        );</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='unexecuted'>    function _colors2(uint256 _variant) internal pure returns (COLORS memory) {</span>
 233 |     | <span class='unexecuted'>        if (_variant == 0) {</span>
 234 |     | <span class='unexecuted'>            return COLORS(</span>
 235 |     | <span class='unexecuted'>                colorCode.BROWN, // rect1</span>
 236 |     | <span class='unexecuted'>                colorCode.GOLDEN, // rect2</span>
 237 |     | <span class='unexecuted'>                colorCode.BLUE, // rect3</span>
 238 |     | <span class='unexecuted'>                colorCode.GREEN, // rect4</span>
 239 |     | <span class='unexecuted'>                colorCode.CORAL, // rect5</span>
 240 |     | <span class='unexecuted'>                colorCode.GOLDEN, // unused</span>
 241 |     | <span class='unexecuted'>                colorCode.GOLDEN, // circle1</span>
 242 |     | <span class='unexecuted'>                colorCode.CYAN, // circle2</span>
 243 |     | <span class='unexecuted'>                colorCode.GREEN // circle3</span>
 244 |     | <span class='neutral'>            );</span>
 245 |     | <span class='unexecuted'>        } else if (_variant == 1) {</span>
 246 |     | <span class='unexecuted'>            return COLORS(</span>
 247 |     | <span class='unexecuted'>                colorCode.GREEN, // rect1</span>
 248 |     | <span class='unexecuted'>                colorCode.BROWN, // rect2</span>
 249 |     | <span class='unexecuted'>                colorCode.GOLDEN, // rect3</span>
 250 |     | <span class='unexecuted'>                colorCode.BLUE, // rect4</span>
 251 |     | <span class='unexecuted'>                colorCode.CYAN, // rect5</span>
 252 |     | <span class='unexecuted'>                colorCode.GOLDEN, // unused</span>
 253 |     | <span class='unexecuted'>                colorCode.GREEN, // circle1</span>
 254 |     | <span class='unexecuted'>                colorCode.CORAL, // circle2</span>
 255 |     | <span class='neutral'>                colorCode.BLUE // circle3</span>
 256 |     | <span class='neutral'>            );</span>
 257 |     | <span class='unexecuted'>        } else if (_variant == 2) {</span>
 258 |     | <span class='unexecuted'>            return COLORS(</span>
 259 |     | <span class='unexecuted'>                colorCode.BLUE, // rect1</span>
 260 |     | <span class='unexecuted'>                colorCode.GOLDEN, // rect2</span>
 261 |     | <span class='unexecuted'>                colorCode.GREEN, // rect3</span>
 262 |     | <span class='unexecuted'>                colorCode.BLUE, // rect4</span>
 263 |     | <span class='unexecuted'>                colorCode.CORAL, // rect5</span>
 264 |     | <span class='unexecuted'>                colorCode.GOLDEN, // unused</span>
 265 |     | <span class='unexecuted'>                colorCode.CYAN, // circle1</span>
 266 |     | <span class='unexecuted'>                colorCode.BROWN, // circle2</span>
 267 |     | <span class='neutral'>                colorCode.BROWN // circle3</span>
 268 |     | <span class='neutral'>            );</span>
 269 |     | <span class='neutral'>        } else {</span>
 270 |     | <span class='unexecuted'>            return COLORS(</span>
 271 |     | <span class='neutral'>                colorCode.GOLDEN, // rect1</span>
 272 |     | <span class='unexecuted'>                colorCode.GREEN, // rect2</span>
 273 |     | <span class='unexecuted'>                colorCode.BLUE, // rect3</span>
 274 |     | <span class='unexecuted'>                colorCode.GOLDEN, // rect4</span>
 275 |     | <span class='unexecuted'>                colorCode.BROWN, // rect5</span>
 276 |     | <span class='unexecuted'>                colorCode.GOLDEN, // unused</span>
 277 |     | <span class='unexecuted'>                colorCode.BROWN, // circle1</span>
 278 |     | <span class='unexecuted'>                colorCode.CYAN, // circle2</span>
 279 |     | <span class='unexecuted'>                colorCode.CORAL // circle3</span>
 280 |     | <span class='neutral'>            );</span>
 281 |     | <span class='neutral'>        }</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='unexecuted'>    function _img2(uint256 _variant) internal pure returns (string memory) {</span>
 285 |     | <span class='unexecuted'>        COLORS memory colors = _colors2(_variant);</span>
 286 |     | <span class='unexecuted'>        return string.concat(_rects2(colors), _circles2(colors));</span>
 287 |     | <span class='neutral'>    }</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='unexecuted'>    function _rects2(COLORS memory _colors) internal pure returns (string memory) {</span>
 290 |     | <span class='neutral'>        return string.concat(</span>
 291 |     | <span class='neutral'>            //background</span>
 292 |     | <span class='unexecuted'>            svg.rect(</span>
 293 |     | <span class='neutral'>                string.concat(</span>
 294 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;16&quot;),</span>
 295 |     | <span class='neutral'>                    svg.prop(&quot;y&quot;, &quot;55&quot;),</span>
 296 |     | <span class='neutral'>                    svg.prop(&quot;width&quot;, &quot;268&quot;),</span>
 297 |     | <span class='neutral'>                    svg.prop(&quot;height&quot;, &quot;268&quot;),</span>
 298 |     | <span class='neutral'>                    svg.prop(&quot;fill&quot;, DARK_BLUE)</span>
 299 |     | <span class='neutral'>                )</span>
 300 |     | <span class='neutral'>            ),</span>
 301 |     | <span class='neutral'>            // large upper right rect | rect1</span>
 302 |     | <span class='unexecuted'>            svg.rect(</span>
 303 |     | <span class='neutral'>                string.concat(</span>
 304 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;128&quot;),</span>
 305 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;55&quot;),</span>
 306 |     | <span class='unexecuted'>                    svg.prop(&quot;width&quot;, &quot;156&quot;),</span>
 307 |     | <span class='unexecuted'>                    svg.prop(&quot;height&quot;, &quot;156&quot;),</span>
 308 |     | <span class='neutral'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.rect1))</span>
 309 |     | <span class='neutral'>                )</span>
 310 |     | <span class='neutral'>            ),</span>
 311 |     | <span class='neutral'>            // large central left rect | rect2</span>
 312 |     | <span class='unexecuted'>            svg.rect(</span>
 313 |     | <span class='neutral'>                string.concat(</span>
 314 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;16&quot;),</span>
 315 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;111&quot;),</span>
 316 |     | <span class='unexecuted'>                    svg.prop(&quot;width&quot;, &quot;134&quot;),</span>
 317 |     | <span class='unexecuted'>                    svg.prop(&quot;height&quot;, &quot;100&quot;),</span>
 318 |     | <span class='neutral'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.rect2))</span>
 319 |     | <span class='neutral'>                )</span>
 320 |     | <span class='neutral'>            ),</span>
 321 |     | <span class='neutral'>            // large lower left rect | rect3</span>
 322 |     | <span class='unexecuted'>            svg.rect(</span>
 323 |     | <span class='neutral'>                string.concat(</span>
 324 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;16&quot;),</span>
 325 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;211&quot;),</span>
 326 |     | <span class='unexecuted'>                    svg.prop(&quot;width&quot;, &quot;212&quot;),</span>
 327 |     | <span class='unexecuted'>                    svg.prop(&quot;height&quot;, &quot;56&quot;),</span>
 328 |     | <span class='neutral'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.rect3))</span>
 329 |     | <span class='neutral'>                )</span>
 330 |     | <span class='neutral'>            ),</span>
 331 |     | <span class='neutral'>            // small lower central rect | rect4</span>
 332 |     | <span class='unexecuted'>            svg.rect(</span>
 333 |     | <span class='neutral'>                string.concat(</span>
 334 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;72&quot;),</span>
 335 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;267&quot;),</span>
 336 |     | <span class='unexecuted'>                    svg.prop(&quot;width&quot;, &quot;78&quot;),</span>
 337 |     | <span class='neutral'>                    svg.prop(&quot;height&quot;, &quot;56&quot;),</span>
 338 |     | <span class='neutral'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.rect4))</span>
 339 |     | <span class='neutral'>                )</span>
 340 |     | <span class='neutral'>            ),</span>
 341 |     | <span class='neutral'>            // small lower right rect | rect5</span>
 342 |     | <span class='unexecuted'>            svg.rect(</span>
 343 |     | <span class='neutral'>                string.concat(</span>
 344 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;150&quot;),</span>
 345 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;267&quot;),</span>
 346 |     | <span class='unexecuted'>                    svg.prop(&quot;width&quot;, &quot;134&quot;),</span>
 347 |     | <span class='neutral'>                    svg.prop(&quot;height&quot;, &quot;56&quot;),</span>
 348 |     | <span class='neutral'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.rect5))</span>
 349 |     | <span class='neutral'>                )</span>
 350 |     | <span class='neutral'>            )</span>
 351 |     | <span class='neutral'>        );</span>
 352 |     | <span class='neutral'>    }</span>
 353 |     | <span class='neutral'></span>
 354 |     | <span class='unexecuted'>    function _circles2(COLORS memory _colors) internal pure returns (string memory) {</span>
 355 |     | <span class='neutral'>        return string.concat(</span>
 356 |     | <span class='neutral'>            //lower left circle | circle1</span>
 357 |     | <span class='unexecuted'>            svg.circle(</span>
 358 |     | <span class='neutral'>                string.concat(</span>
 359 |     | <span class='unexecuted'>                    svg.prop(&quot;cx&quot;, &quot;44&quot;),</span>
 360 |     | <span class='unexecuted'>                    svg.prop(&quot;cy&quot;, &quot;295&quot;),</span>
 361 |     | <span class='unexecuted'>                    svg.prop(&quot;r&quot;, &quot;28&quot;),</span>
 362 |     | <span class='neutral'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.circle1))</span>
 363 |     | <span class='neutral'>                )</span>
 364 |     | <span class='neutral'>            ),</span>
 365 |     | <span class='neutral'>            //upper left half circle | circle2</span>
 366 |     | <span class='unexecuted'>            svg.path(</span>
 367 |     | <span class='neutral'>                &quot;M16 55C16 62.4 17.4 69.6 20.3 76.4C23.1 83.2 27.2 89.4 32.4 94.6C37.6 99.8 43.8 103.9 50.6 106.7C57.4 109.6 64.6 111 72 111C79.4 111 86.6 109.6 93.4 106.7C100.2 103.9 106.4 99.8 111.6 94.6C116.8 89.4 120.9 83.2 123.7 76.4C126.6 69.6 128 62.4 128 55L16 55Z&quot;,</span>
 368 |     | <span class='unexecuted'>                svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.circle2))</span>
 369 |     | <span class='neutral'>            ),</span>
 370 |     | <span class='neutral'>            //central right half circle | circle3</span>
 371 |     | <span class='unexecuted'>            svg.path(</span>
 372 |     | <span class='neutral'>                &quot;M284 211C284 190.3 275.8 170.5 261.2 155.8C246.5 141.2 226.7 133 206 133C185.3 133 165.5 141.2 150.9 155.86C136.2 170.5 128 190.3 128 211L284 211Z&quot;,</span>
 373 |     | <span class='unexecuted'>                svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.circle3))</span>
 374 |     | <span class='neutral'>            )</span>
 375 |     | <span class='neutral'>        );</span>
 376 |     | <span class='neutral'>    }</span>
 377 |     | <span class='neutral'></span>
 378 |     | <span class='unexecuted'>    function _colors3(uint256 _variant) internal pure returns (COLORS memory) {</span>
 379 |     | <span class='unexecuted'>        if (_variant == 0) {</span>
 380 |     | <span class='unexecuted'>            return COLORS(</span>
 381 |     | <span class='unexecuted'>                colorCode.BLUE, // rect1</span>
 382 |     | <span class='unexecuted'>                colorCode.CORAL, // rect2</span>
 383 |     | <span class='unexecuted'>                colorCode.BLUE, // rect3</span>
 384 |     | <span class='unexecuted'>                colorCode.GREEN, // rect4</span>
 385 |     | <span class='unexecuted'>                colorCode.GOLDEN, // unused</span>
 386 |     | <span class='unexecuted'>                colorCode.GOLDEN, // unused</span>
 387 |     | <span class='unexecuted'>                colorCode.GOLDEN, // circle1</span>
 388 |     | <span class='unexecuted'>                colorCode.CYAN, // circle2</span>
 389 |     | <span class='neutral'>                colorCode.GOLDEN // circle3</span>
 390 |     | <span class='neutral'>            );</span>
 391 |     | <span class='unexecuted'>        } else if (_variant == 1) {</span>
 392 |     | <span class='unexecuted'>            return COLORS(</span>
 393 |     | <span class='unexecuted'>                colorCode.CORAL, // rect1</span>
 394 |     | <span class='unexecuted'>                colorCode.GREEN, // rect2</span>
 395 |     | <span class='unexecuted'>                colorCode.BROWN, // rect3</span>
 396 |     | <span class='unexecuted'>                colorCode.GOLDEN, // rect4</span>
 397 |     | <span class='unexecuted'>                colorCode.GOLDEN, // unused</span>
 398 |     | <span class='unexecuted'>                colorCode.GOLDEN, // unused</span>
 399 |     | <span class='unexecuted'>                colorCode.BLUE, // circle1</span>
 400 |     | <span class='unexecuted'>                colorCode.BLUE, // circle2</span>
 401 |     | <span class='unexecuted'>                colorCode.CYAN // circle3</span>
 402 |     | <span class='neutral'>            );</span>
 403 |     | <span class='unexecuted'>        } else if (_variant == 2) {</span>
 404 |     | <span class='unexecuted'>            return COLORS(</span>
 405 |     | <span class='unexecuted'>                colorCode.CORAL, // rect1</span>
 406 |     | <span class='unexecuted'>                colorCode.CYAN, // rect2</span>
 407 |     | <span class='unexecuted'>                colorCode.CORAL, // rect3</span>
 408 |     | <span class='unexecuted'>                colorCode.GOLDEN, // rect4</span>
 409 |     | <span class='unexecuted'>                colorCode.GOLDEN, // unused</span>
 410 |     | <span class='unexecuted'>                colorCode.GOLDEN, // unused</span>
 411 |     | <span class='unexecuted'>                colorCode.GREEN, // circle1</span>
 412 |     | <span class='unexecuted'>                colorCode.BLUE, // circle2</span>
 413 |     | <span class='neutral'>                colorCode.GREEN // circle3</span>
 414 |     | <span class='neutral'>            );</span>
 415 |     | <span class='neutral'>        } else {</span>
 416 |     | <span class='unexecuted'>            return COLORS(</span>
 417 |     | <span class='neutral'>                colorCode.GOLDEN, // rect1</span>
 418 |     | <span class='unexecuted'>                colorCode.CORAL, // rect2</span>
 419 |     | <span class='unexecuted'>                colorCode.GREEN, // rect3</span>
 420 |     | <span class='unexecuted'>                colorCode.BLUE, // rect4</span>
 421 |     | <span class='unexecuted'>                colorCode.GOLDEN, // unused</span>
 422 |     | <span class='unexecuted'>                colorCode.GOLDEN, // unused</span>
 423 |     | <span class='unexecuted'>                colorCode.BROWN, // circle1</span>
 424 |     | <span class='neutral'>                colorCode.BLUE, // circle2</span>
 425 |     | <span class='neutral'>                colorCode.GREEN // circle3</span>
 426 |     | <span class='neutral'>            );</span>
 427 |     | <span class='neutral'>        }</span>
 428 |     | <span class='neutral'>    }</span>
 429 |     | <span class='neutral'></span>
 430 |     | <span class='unexecuted'>    function _img3(uint256 _variant) internal pure returns (string memory) {</span>
 431 |     | <span class='unexecuted'>        COLORS memory colors = _colors3(_variant);</span>
 432 |     | <span class='unexecuted'>        return string.concat(_rects3(colors), _circles3(colors));</span>
 433 |     | <span class='neutral'>    }</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='unexecuted'>    function _rects3(COLORS memory _colors) internal pure returns (string memory) {</span>
 436 |     | <span class='neutral'>        return string.concat(</span>
 437 |     | <span class='neutral'>            //background</span>
 438 |     | <span class='unexecuted'>            svg.rect(</span>
 439 |     | <span class='neutral'>                string.concat(</span>
 440 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;16&quot;),</span>
 441 |     | <span class='neutral'>                    svg.prop(&quot;y&quot;, &quot;55&quot;),</span>
 442 |     | <span class='neutral'>                    svg.prop(&quot;width&quot;, &quot;268&quot;),</span>
 443 |     | <span class='neutral'>                    svg.prop(&quot;height&quot;, &quot;268&quot;),</span>
 444 |     | <span class='neutral'>                    svg.prop(&quot;fill&quot;, DARK_BLUE)</span>
 445 |     | <span class='neutral'>                )</span>
 446 |     | <span class='neutral'>            ),</span>
 447 |     | <span class='neutral'>            // lower left rect | rect1</span>
 448 |     | <span class='unexecuted'>            svg.rect(</span>
 449 |     | <span class='neutral'>                string.concat(</span>
 450 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;16&quot;),</span>
 451 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;205&quot;),</span>
 452 |     | <span class='unexecuted'>                    svg.prop(&quot;width&quot;, &quot;75&quot;),</span>
 453 |     | <span class='unexecuted'>                    svg.prop(&quot;height&quot;, &quot;118&quot;),</span>
 454 |     | <span class='neutral'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.rect1))</span>
 455 |     | <span class='neutral'>                )</span>
 456 |     | <span class='neutral'>            ),</span>
 457 |     | <span class='neutral'>            // central rect | rect2</span>
 458 |     | <span class='unexecuted'>            svg.rect(</span>
 459 |     | <span class='neutral'>                string.concat(</span>
 460 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;91&quot;),</span>
 461 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;205&quot;),</span>
 462 |     | <span class='unexecuted'>                    svg.prop(&quot;width&quot;, &quot;136&quot;),</span>
 463 |     | <span class='unexecuted'>                    svg.prop(&quot;height&quot;, &quot;59&quot;),</span>
 464 |     | <span class='neutral'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.rect2))</span>
 465 |     | <span class='neutral'>                )</span>
 466 |     | <span class='neutral'>            ),</span>
 467 |     | <span class='neutral'>            // central right rect | rect3</span>
 468 |     | <span class='unexecuted'>            svg.rect(</span>
 469 |     | <span class='neutral'>                string.concat(</span>
 470 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;166&quot;),</span>
 471 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;180&quot;),</span>
 472 |     | <span class='unexecuted'>                    svg.prop(&quot;width&quot;, &quot;118&quot;),</span>
 473 |     | <span class='unexecuted'>                    svg.prop(&quot;height&quot;, &quot;25&quot;),</span>
 474 |     | <span class='neutral'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.rect3))</span>
 475 |     | <span class='neutral'>                )</span>
 476 |     | <span class='neutral'>            ),</span>
 477 |     | <span class='neutral'>            // upper right rect | rect4</span>
 478 |     | <span class='unexecuted'>            svg.rect(</span>
 479 |     | <span class='neutral'>                string.concat(</span>
 480 |     | <span class='unexecuted'>                    svg.prop(&quot;x&quot;, &quot;166&quot;),</span>
 481 |     | <span class='unexecuted'>                    svg.prop(&quot;y&quot;, &quot;55&quot;),</span>
 482 |     | <span class='unexecuted'>                    svg.prop(&quot;width&quot;, &quot;118&quot;),</span>
 483 |     | <span class='unexecuted'>                    svg.prop(&quot;height&quot;, &quot;126&quot;),</span>
 484 |     | <span class='neutral'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.rect4))</span>
 485 |     | <span class='neutral'>                )</span>
 486 |     | <span class='neutral'>            )</span>
 487 |     | <span class='neutral'>        );</span>
 488 |     | <span class='neutral'>    }</span>
 489 |     | <span class='neutral'></span>
 490 |     | <span class='unexecuted'>    function _circles3(COLORS memory _colors) internal pure returns (string memory) {</span>
 491 |     | <span class='neutral'>        return string.concat(</span>
 492 |     | <span class='neutral'>            //upper left circle | circle1</span>
 493 |     | <span class='unexecuted'>            svg.circle(</span>
 494 |     | <span class='neutral'>                string.concat(</span>
 495 |     | <span class='unexecuted'>                    svg.prop(&quot;cx&quot;, &quot;91&quot;),</span>
 496 |     | <span class='unexecuted'>                    svg.prop(&quot;cy&quot;, &quot;130&quot;),</span>
 497 |     | <span class='unexecuted'>                    svg.prop(&quot;r&quot;, &quot;75&quot;),</span>
 498 |     | <span class='neutral'>                    svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.circle1))</span>
 499 |     | <span class='neutral'>                )</span>
 500 |     | <span class='neutral'>            ),</span>
 501 |     | <span class='neutral'>            //upper right half circle | circle2</span>
 502 |     | <span class='unexecuted'>            svg.path(</span>
 503 |     | <span class='neutral'>                &quot;M284 264 166 264 166 263C166 232 193 206 225 205C258 206 284 232 284 264C284 264 284 264 284 264Z&quot;,</span>
 504 |     | <span class='unexecuted'>                svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.circle2))</span>
 505 |     | <span class='neutral'>            ),</span>
 506 |     | <span class='neutral'>            //lower right half circle | circle3</span>
 507 |     | <span class='unexecuted'>            svg.path(</span>
 508 |     | <span class='neutral'>                &quot;M284 323 166 323 166 323C166 290 193 265 225 264C258 265 284 290 284 323C284 323 284 323 284 323Z&quot;,</span>
 509 |     | <span class='unexecuted'>                svg.prop(&quot;fill&quot;, _colorCode2Hex(_colors.circle3))</span>
 510 |     | <span class='neutral'>            )</span>
 511 |     | <span class='neutral'>        );</span>
 512 |     | <span class='neutral'>    }</span>
 513 |     | <span class='neutral'>}</span>
 514 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/PriceFeeds/CompositePriceFeed.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;../Dependencies/LiquityMath.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./MainnetPriceFeedBase.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// import &quot;forge-std/console2.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>// The CompositePriceFeed is used for feeds that incorporate both a market price oracle (e.g. STETH-USD, or RETH-ETH)</span>
  11 |     | <span class='neutral'>// and an LST canonical rate (e.g. WSTETH:STETH, or RETH:ETH).</span>
  12 |     | <span class='neutral'>abstract contract CompositePriceFeed is MainnetPriceFeedBase {</span>
  13 |     | <span class='unexecuted'>    address public rateProviderAddress;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    constructor(</span>
  16 |     | <span class='neutral'>        address _owner,</span>
  17 |     | <span class='neutral'>        address _ethUsdOracleAddress,</span>
  18 |     | <span class='neutral'>        address _rateProviderAddress,</span>
  19 |     | <span class='neutral'>        uint256 _ethUsdStalenessThreshold</span>
  20 |     | <span class='neutral'>    ) MainnetPriceFeedBase(_owner, _ethUsdOracleAddress, _ethUsdStalenessThreshold) {</span>
  21 |     | <span class='neutral'>        // Store rate provider</span>
  22 |     | <span class='unexecuted'>        rateProviderAddress = _rateProviderAddress;</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    // Returns:</span>
  26 |     | <span class='neutral'>    // - The price, using the current price calculation</span>
  27 |     | <span class='neutral'>    // - A bool that is true if:</span>
  28 |     | <span class='neutral'>    // --- a) the system was not shut down prior to this call, and</span>
  29 |     | <span class='neutral'>    // --- b) an oracle or exchange rate contract failed during this call.</span>
  30 |     | <span class='unexecuted'>    function fetchPrice() public returns (uint256, bool) {</span>
  31 |     | <span class='neutral'>        // If branch is live and the primary oracle setup has been working, try to use it</span>
  32 |     | <span class='unexecuted'>        if (priceSource == PriceSource.primary) return _fetchPricePrimary(false);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>        return _fetchPriceDuringShutdown();</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>    function fetchRedemptionPrice() external returns (uint256, bool) {</span>
  38 |     | <span class='neutral'>        // If branch is live and the primary oracle setup has been working, try to use it</span>
  39 |     | <span class='unexecuted'>        if (priceSource == PriceSource.primary) return _fetchPricePrimary(true);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>        return _fetchPriceDuringShutdown();</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='unexecuted'>    function _shutDownAndSwitchToETHUSDxCanonical(address _failedOracleAddr, uint256 _ethUsdPrice)</span>
  45 |     | <span class='neutral'>        internal</span>
  46 |     | <span class='unexecuted'>        returns (uint256)</span>
  47 |     | <span class='neutral'>    {</span>
  48 |     | <span class='neutral'>        // Shut down the branch</span>
  49 |     | <span class='unexecuted'>        borrowerOperations.shutdownFromOracleFailure();</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>        priceSource = PriceSource.ETHUSDxCanonical;</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>        emit ShutDownFromOracleFailure(_failedOracleAddr);</span>
  54 |     | <span class='unexecuted'>        return _fetchPriceETHUSDxCanonical(_ethUsdPrice);</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>    function _fetchPriceDuringShutdown() internal returns (uint256, bool) {</span>
  58 |     | <span class='neutral'>        // When branch is already shut down and using ETH-USD * canonical_rate, try to use that</span>
  59 |     | <span class='unexecuted'>        if (priceSource == PriceSource.ETHUSDxCanonical) {</span>
  60 |     | <span class='unexecuted'>            (uint256 ethUsdPrice, bool ethUsdOracleDown) = _getOracleAnswer(ethUsdOracle);</span>
  61 |     | <span class='neutral'>            //... but if the ETH-USD oracle *also* fails here, switch to using the lastGoodPrice</span>
  62 |     | <span class='unexecuted'>            if (ethUsdOracleDown) {</span>
  63 |     | <span class='neutral'>                // No need to shut down, since branch already is shut down</span>
  64 |     | <span class='unexecuted'>                priceSource = PriceSource.lastGoodPrice;</span>
  65 |     | <span class='unexecuted'>                return (lastGoodPrice, false);</span>
  66 |     | <span class='neutral'>            } else {</span>
  67 |     | <span class='unexecuted'>                return (_fetchPriceETHUSDxCanonical(ethUsdPrice), false);</span>
  68 |     | <span class='neutral'>            }</span>
  69 |     | <span class='neutral'>        }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        // Otherwise when branch is shut down and already using the lastGoodPrice, continue with it</span>
  72 |     | <span class='unexecuted'>        assert(priceSource == PriceSource.lastGoodPrice);</span>
  73 |     | <span class='unexecuted'>        return (lastGoodPrice, false);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    // Only called if the primary LST oracle has failed, branch has shut down,</span>
  77 |     | <span class='neutral'>    // and we&#39;ve switched to using: ETH-USD * canonical_rate.</span>
  78 |     | <span class='unexecuted'>    function _fetchPriceETHUSDxCanonical(uint256 _ethUsdPrice) internal returns (uint256) {</span>
  79 |     | <span class='unexecuted'>        assert(priceSource == PriceSource.ETHUSDxCanonical);</span>
  80 |     | <span class='neutral'>        // Get the underlying_per_LST canonical rate directly from the LST contract</span>
  81 |     | <span class='unexecuted'>        (uint256 lstRate, bool exchangeRateIsDown) = _getCanonicalRate();</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>        // If the exchange rate contract is down, switch to (and return) lastGoodPrice.</span>
  84 |     | <span class='unexecuted'>        if (exchangeRateIsDown) {</span>
  85 |     | <span class='unexecuted'>            priceSource = PriceSource.lastGoodPrice;</span>
  86 |     | <span class='unexecuted'>            return lastGoodPrice;</span>
  87 |     | <span class='neutral'>        }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        // Calculate the canonical LST-USD price: USD_per_LST = USD_per_ETH * underlying_per_LST</span>
  90 |     | <span class='unexecuted'>        uint256 lstUsdCanonicalPrice = _ethUsdPrice * lstRate / 1e18;</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>        uint256 bestPrice = LiquityMath._min(lstUsdCanonicalPrice, lastGoodPrice);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        lastGoodPrice = bestPrice;</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>        return bestPrice;</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>    function _withinDeviationThreshold(uint256 _priceToCheck, uint256 _referencePrice, uint256 _deviationThreshold)</span>
 100 |     | <span class='neutral'>        internal</span>
 101 |     | <span class='neutral'>        pure</span>
 102 |     | <span class='unexecuted'>        returns (bool)</span>
 103 |     | <span class='neutral'>    {</span>
 104 |     | <span class='neutral'>        // Calculate the price deviation of the oracle market price relative to the canonical price</span>
 105 |     | <span class='unexecuted'>        uint256 max = _referencePrice * (DECIMAL_PRECISION + _deviationThreshold) / 1e18;</span>
 106 |     | <span class='unexecuted'>        uint256 min = _referencePrice * (DECIMAL_PRECISION - _deviationThreshold) / 1e18;</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>        return _priceToCheck &gt;= min &amp;&amp; _priceToCheck &lt;= max;</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    // An individual Pricefeed instance implements _fetchPricePrimary according to the data sources it uses. Returns:</span>
 112 |     | <span class='neutral'>    // - The price</span>
 113 |     | <span class='neutral'>    // - A bool indicating whether a new oracle failure or exchange rate failure was detected in the call</span>
 114 |     | <span class='neutral'>    function _fetchPricePrimary(bool _isRedemption) internal virtual returns (uint256, bool);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    // Returns the LST exchange rate and a bool indicating whether the exchange rate failed to return a valid rate.</span>
 117 |     | <span class='neutral'>    // Implementation depends on the specific LST.</span>
 118 |     | <span class='neutral'>    function _getCanonicalRate() internal view virtual returns (uint256, bool);</span>
 119 |     | <span class='neutral'>}</span>
 120 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/PriceFeeds/MainnetPriceFeedBase.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;../Dependencies/Ownable.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../Dependencies/AggregatorV3Interface.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../Interfaces/IMainnetPriceFeed.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../BorrowerOperations.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>// import &quot;forge-std/console2.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>abstract contract MainnetPriceFeedBase is IMainnetPriceFeed, Ownable {</span>
  13 |     | <span class='neutral'>    // Determines where the PriceFeed sources data from. Possible states:</span>
  14 |     | <span class='neutral'>    // - primary: Uses the primary price calcuation, which depends on the specific feed</span>
  15 |     | <span class='neutral'>    // - ETHUSDxCanonical: Uses Chainlink&#39;s ETH-USD multiplied by the LST&#39; canonical rate</span>
  16 |     | <span class='neutral'>    // - lastGoodPrice: the last good price recorded by this PriceFeed.</span>
  17 |     | <span class='unexecuted'>    PriceSource public priceSource;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    // Last good price tracker for the derived USD price</span>
  20 |     | <span class='unexecuted'>    uint256 public lastGoodPrice;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    struct Oracle {</span>
  23 |     | <span class='neutral'>        AggregatorV3Interface aggregator;</span>
  24 |     | <span class='neutral'>        uint256 stalenessThreshold;</span>
  25 |     | <span class='neutral'>        uint8 decimals;</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    struct ChainlinkResponse {</span>
  29 |     | <span class='neutral'>        uint80 roundId;</span>
  30 |     | <span class='neutral'>        int256 answer;</span>
  31 |     | <span class='neutral'>        uint256 timestamp;</span>
  32 |     | <span class='neutral'>        bool success;</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    error InsufficientGasForExternalCall();</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    event ShutDownFromOracleFailure(address _failedOracleAddr);</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    Oracle public ethUsdOracle;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    IBorrowerOperations borrowerOperations;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    constructor(address _owner, address _ethUsdOracleAddress, uint256 _ethUsdStalenessThreshold) Ownable(_owner) {</span>
  44 |     | <span class='neutral'>        // Store ETH-USD oracle</span>
  45 |     | <span class='unexecuted'>        ethUsdOracle.aggregator = AggregatorV3Interface(_ethUsdOracleAddress);</span>
  46 |     | <span class='unexecuted'>        ethUsdOracle.stalenessThreshold = _ethUsdStalenessThreshold;</span>
  47 |     | <span class='unexecuted'>        ethUsdOracle.decimals = ethUsdOracle.aggregator.decimals();</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>        assert(ethUsdOracle.decimals == 8);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    // TODO: remove this and set address in constructor, since we&#39;ll use CREATE2</span>
  53 |     | <span class='unexecuted'>    function setAddresses(address _borrowOperationsAddress) external onlyOwner {</span>
  54 |     | <span class='unexecuted'>        borrowerOperations = IBorrowerOperations(_borrowOperationsAddress);</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>        _renounceOwnership();</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>    function _getOracleAnswer(Oracle memory _oracle) internal view returns (uint256, bool) {</span>
  60 |     | <span class='unexecuted'>        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse(_oracle.aggregator);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>        uint256 scaledPrice;</span>
  63 |     | <span class='unexecuted'>        bool oracleIsDown;</span>
  64 |     | <span class='neutral'>        // Check oracle is serving an up-to-date and sensible price. If not, shut down this collateral branch.</span>
  65 |     | <span class='unexecuted'>        if (!_isValidChainlinkPrice(chainlinkResponse, _oracle.stalenessThreshold)) {</span>
  66 |     | <span class='unexecuted'>            oracleIsDown = true;</span>
  67 |     | <span class='neutral'>        } else {</span>
  68 |     | <span class='unexecuted'>            scaledPrice = _scaleChainlinkPriceTo18decimals(chainlinkResponse.answer, _oracle.decimals);</span>
  69 |     | <span class='neutral'>        }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>        return (scaledPrice, oracleIsDown);</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>    function _shutDownAndSwitchToLastGoodPrice(address _failedOracleAddr) internal returns (uint256) {</span>
  75 |     | <span class='neutral'>        // Shut down the branch</span>
  76 |     | <span class='unexecuted'>        borrowerOperations.shutdownFromOracleFailure();</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>        priceSource = PriceSource.lastGoodPrice;</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>        emit ShutDownFromOracleFailure(_failedOracleAddr);</span>
  81 |     | <span class='unexecuted'>        return lastGoodPrice;</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>    function _getCurrentChainlinkResponse(AggregatorV3Interface _aggregator)</span>
  85 |     | <span class='neutral'>        internal</span>
  86 |     | <span class='neutral'>        view</span>
  87 |     | <span class='neutral'>        returns (ChainlinkResponse memory chainlinkResponse)</span>
  88 |     | <span class='neutral'>    {</span>
  89 |     | <span class='unexecuted'>        uint256 gasBefore = gasleft();</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        // Try to get latest price data:</span>
  92 |     | <span class='unexecuted'>        try _aggregator.latestRoundData() returns (</span>
  93 |     | <span class='neutral'>            uint80 roundId, int256 answer, uint256, /* startedAt */ uint256 updatedAt, uint80 /* answeredInRound */</span>
  94 |     | <span class='neutral'>        ) {</span>
  95 |     | <span class='neutral'>            // If call to Chainlink succeeds, return the response and success = true</span>
  96 |     | <span class='unexecuted'>            chainlinkResponse.roundId = roundId;</span>
  97 |     | <span class='unexecuted'>            chainlinkResponse.answer = answer;</span>
  98 |     | <span class='unexecuted'>            chainlinkResponse.timestamp = updatedAt;</span>
  99 |     | <span class='unexecuted'>            chainlinkResponse.success = true;</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>            return chainlinkResponse;</span>
 102 |     | <span class='neutral'>        } catch {</span>
 103 |     | <span class='neutral'>            // Require that enough gas was provided to prevent an OOG revert in the call to Chainlink</span>
 104 |     | <span class='neutral'>            // causing a shutdown. Instead, just revert. Slightly conservative, as it includes gas used</span>
 105 |     | <span class='neutral'>            // in the check itself.</span>
 106 |     | <span class='unexecuted'>            if (gasleft() &lt;= gasBefore / 64) revert InsufficientGasForExternalCall();</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>            // If call to Chainlink aggregator reverts, return a zero response with success = false</span>
 109 |     | <span class='unexecuted'>            return chainlinkResponse;</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    // False if:</span>
 114 |     | <span class='neutral'>    // - Call to Chainlink aggregator reverts</span>
 115 |     | <span class='neutral'>    // - price is too stale, i.e. older than the oracle&#39;s staleness threshold</span>
 116 |     | <span class='neutral'>    // - Price answer is 0 or negative</span>
 117 |     | <span class='unexecuted'>    function _isValidChainlinkPrice(ChainlinkResponse memory chainlinkResponse, uint256 _stalenessThreshold)</span>
 118 |     | <span class='neutral'>        internal</span>
 119 |     | <span class='neutral'>        view</span>
 120 |     | <span class='unexecuted'>        returns (bool)</span>
 121 |     | <span class='neutral'>    {</span>
 122 |     | <span class='unexecuted'>        return chainlinkResponse.success &amp;&amp; block.timestamp - chainlinkResponse.timestamp &lt; _stalenessThreshold</span>
 123 |     | <span class='unexecuted'>            &amp;&amp; chainlinkResponse.answer &gt; 0;</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    // Trust assumption: Chainlink won&#39;t change the decimal precision on any feed used in v2 after deployment</span>
 127 |     | <span class='unexecuted'>    function _scaleChainlinkPriceTo18decimals(int256 _price, uint256 _decimals) internal pure returns (uint256) {</span>
 128 |     | <span class='neutral'>        // Scale an int price to a uint with 18 decimals</span>
 129 |     | <span class='unexecuted'>        return uint256(_price) * 10 ** (18 - _decimals);</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'>}</span>
 132 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/PriceFeeds/RETHPriceFeed.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./CompositePriceFeed.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../Interfaces/IRETHToken.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../Interfaces/IRETHPriceFeed.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>// import &quot;forge-std/console2.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>contract RETHPriceFeed is CompositePriceFeed, IRETHPriceFeed {</span>
  12 |     | <span class='unexecuted'>    constructor(</span>
  13 |     | <span class='neutral'>        address _owner,</span>
  14 |     | <span class='neutral'>        address _ethUsdOracleAddress,</span>
  15 |     | <span class='neutral'>        address _rEthEthOracleAddress,</span>
  16 |     | <span class='neutral'>        address _rEthTokenAddress,</span>
  17 |     | <span class='neutral'>        uint256 _ethUsdStalenessThreshold,</span>
  18 |     | <span class='neutral'>        uint256 _rEthEthStalenessThreshold</span>
  19 |     | <span class='unexecuted'>    ) CompositePriceFeed(_owner, _ethUsdOracleAddress, _rEthTokenAddress, _ethUsdStalenessThreshold) {</span>
  20 |     | <span class='neutral'>        // Store RETH-ETH oracle</span>
  21 |     | <span class='unexecuted'>        rEthEthOracle.aggregator = AggregatorV3Interface(_rEthEthOracleAddress);</span>
  22 |     | <span class='unexecuted'>        rEthEthOracle.stalenessThreshold = _rEthEthStalenessThreshold;</span>
  23 |     | <span class='unexecuted'>        rEthEthOracle.decimals = rEthEthOracle.aggregator.decimals();</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>        _fetchPricePrimary(false);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>        // Check the oracle didn&#39;t already fail</span>
  28 |     | <span class='unexecuted'>        assert(priceSource == PriceSource.primary);</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    Oracle public rEthEthOracle;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>    uint256 public constant RETH_ETH_DEVIATION_THRESHOLD = 2e16; // 2%</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    function _fetchPricePrimary(bool _isRedemption) internal override returns (uint256, bool) {</span>
  36 |     | <span class='unexecuted'>        assert(priceSource == PriceSource.primary);</span>
  37 |     | <span class='unexecuted'>        (uint256 ethUsdPrice, bool ethUsdOracleDown) = _getOracleAnswer(ethUsdOracle);</span>
  38 |     | <span class='unexecuted'>        (uint256 rEthEthPrice, bool rEthEthOracleDown) = _getOracleAnswer(rEthEthOracle);</span>
  39 |     | <span class='unexecuted'>        (uint256 rEthPerEth, bool exchangeRateIsDown) = _getCanonicalRate();</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>        // If either the ETH-USD feed or exchange rate is down, shut down and switch to the last good price</span>
  42 |     | <span class='neutral'>        // seen by the system since we need both for primary and fallback price calcs</span>
  43 |     | <span class='unexecuted'>        if (ethUsdOracleDown) {</span>
  44 |     | <span class='unexecuted'>            return (_shutDownAndSwitchToLastGoodPrice(address(ethUsdOracle.aggregator)), true);</span>
  45 |     | <span class='neutral'>        }</span>
  46 |     | <span class='unexecuted'>        if (exchangeRateIsDown) {</span>
  47 |     | <span class='unexecuted'>            return (_shutDownAndSwitchToLastGoodPrice(rateProviderAddress), true);</span>
  48 |     | <span class='neutral'>        }</span>
  49 |     | <span class='neutral'>        // If the ETH-USD feed is live but the RETH-ETH oracle is down, shutdown and substitute RETH-ETH with the canonical rate</span>
  50 |     | <span class='unexecuted'>        if (rEthEthOracleDown) {</span>
  51 |     | <span class='unexecuted'>            return (_shutDownAndSwitchToETHUSDxCanonical(address(rEthEthOracle.aggregator), ethUsdPrice), true);</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>        // Otherwise, use the primary price calculation:</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>        // Calculate the market RETH-USD price: USD_per_RETH = USD_per_ETH * ETH_per_RETH</span>
  57 |     | <span class='unexecuted'>        uint256 rEthUsdMarketPrice = ethUsdPrice * rEthEthPrice / 1e18;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        // Calculate the canonical LST-USD price: USD_per_RETH = USD_per_ETH * ETH_per_RETH</span>
  60 |     | <span class='unexecuted'>        uint256 rEthUsdCanonicalPrice = ethUsdPrice * rEthPerEth / 1e18;</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>        uint256 rEthUsdPrice;</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>        // If it&#39;s a redemption and canonical is within 2% of market, use the max to mitigate unwanted redemption oracle arb</span>
  65 |     | <span class='unexecuted'>        if (</span>
  66 |     | <span class='unexecuted'>            _isRedemption</span>
  67 |     | <span class='unexecuted'>                &amp;&amp; _withinDeviationThreshold(rEthUsdMarketPrice, rEthUsdCanonicalPrice, RETH_ETH_DEVIATION_THRESHOLD)</span>
  68 |     | <span class='neutral'>        ) {</span>
  69 |     | <span class='unexecuted'>            rEthUsdPrice = LiquityMath._max(rEthUsdMarketPrice, rEthUsdCanonicalPrice);</span>
  70 |     | <span class='neutral'>        } else {</span>
  71 |     | <span class='neutral'>            // Take the minimum of (market, canonical) in order to mitigate against upward market price manipulation.</span>
  72 |     | <span class='neutral'>            // Assumes a deviation between market &lt;&gt; canonical of &gt;2% represents a legitimate market price difference.</span>
  73 |     | <span class='unexecuted'>            rEthUsdPrice = LiquityMath._min(rEthUsdMarketPrice, rEthUsdCanonicalPrice);</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>        lastGoodPrice = rEthUsdPrice;</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>        return (rEthUsdPrice, false);</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>    function _getCanonicalRate() internal view override returns (uint256, bool) {</span>
  82 |     | <span class='unexecuted'>        uint256 gasBefore = gasleft();</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        try IRETHToken(rateProviderAddress).getExchangeRate() returns (uint256 ethPerReth) {</span>
  85 |     | <span class='neutral'>            // If rate is 0, return true</span>
  86 |     | <span class='unexecuted'>            if (ethPerReth == 0) return (0, true);</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>            return (ethPerReth, false);</span>
  89 |     | <span class='neutral'>        } catch {</span>
  90 |     | <span class='neutral'>            // Require that enough gas was provided to prevent an OOG revert in the external call</span>
  91 |     | <span class='neutral'>            // causing a shutdown. Instead, just revert. Slightly conservative, as it includes gas used</span>
  92 |     | <span class='neutral'>            // in the check itself.</span>
  93 |     | <span class='unexecuted'>            if (gasleft() &lt;= gasBefore / 64) revert InsufficientGasForExternalCall();</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>            // If call to exchange rate reverts, return true</span>
  96 |     | <span class='unexecuted'>            return (0, true);</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'>}</span>
 100 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/PriceFeeds/WETHPriceFeed.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./MainnetPriceFeedBase.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>// import &quot;forge-std/console2.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>contract WETHPriceFeed is MainnetPriceFeedBase {</span>
 10 |     | <span class='unexecuted'>    constructor(address _owner, address _ethUsdOracleAddress, uint256 _ethUsdStalenessThreshold)</span>
 11 |     | <span class='unexecuted'>        MainnetPriceFeedBase(_owner, _ethUsdOracleAddress, _ethUsdStalenessThreshold)</span>
 12 |     | <span class='neutral'>    {</span>
 13 |     | <span class='unexecuted'>        _fetchPricePrimary();</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>        // Check the oracle didn&#39;t already fail</span>
 16 |     | <span class='unexecuted'>        assert(priceSource == PriceSource.primary);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function fetchPrice() public returns (uint256, bool) {</span>
 20 |     | <span class='neutral'>        // If branch is live and the primary oracle setup has been working, try to use it</span>
 21 |     | <span class='unexecuted'>        if (priceSource == PriceSource.primary) return _fetchPricePrimary();</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>        // Otherwise if branch is shut down and already using the lastGoodPrice, continue with it</span>
 24 |     | <span class='unexecuted'>        assert(priceSource == PriceSource.lastGoodPrice);</span>
 25 |     | <span class='unexecuted'>        return (lastGoodPrice, false);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>    function fetchRedemptionPrice() external returns (uint256, bool) {</span>
 29 |     | <span class='neutral'>        // Use same price for redemption as all other ops in WETH branch</span>
 30 |     | <span class='unexecuted'>        return fetchPrice();</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    //  _fetchPricePrimary returns:</span>
 34 |     | <span class='neutral'>    // - The price</span>
 35 |     | <span class='neutral'>    // - A bool indicating whether a new oracle failure was detected in the call</span>
 36 |     | <span class='neutral'>    function _fetchPricePrimary(bool /* _isRedemption */ ) internal virtual returns (uint256, bool) {</span>
 37 |     | <span class='neutral'>        return _fetchPricePrimary();</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>    function _fetchPricePrimary() internal returns (uint256, bool) {</span>
 41 |     | <span class='unexecuted'>        assert(priceSource == PriceSource.primary);</span>
 42 |     | <span class='unexecuted'>        (uint256 ethUsdPrice, bool ethUsdOracleDown) = _getOracleAnswer(ethUsdOracle);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>        // If the ETH-USD Chainlink response was invalid in this transaction, return the last good ETH-USD price calculated</span>
 45 |     | <span class='unexecuted'>        if (ethUsdOracleDown) return (_shutDownAndSwitchToLastGoodPrice(address(ethUsdOracle.aggregator)), true);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>        lastGoodPrice = ethUsdPrice;</span>
 48 |     | <span class='unexecuted'>        return (ethUsdPrice, false);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'>}</span>
 51 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/PriceFeeds/WSTETHPriceFeed.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./CompositePriceFeed.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../Interfaces/IWSTETH.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../Interfaces/IWSTETHPriceFeed.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>// import &quot;forge-std/console2.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>contract WSTETHPriceFeed is CompositePriceFeed, IWSTETHPriceFeed {</span>
 12 |     | <span class='unexecuted'>    Oracle public stEthUsdOracle;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    uint256 public constant STETH_USD_DEVIATION_THRESHOLD = 1e16; // 1%</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    constructor(</span>
 17 |     | <span class='neutral'>        address _owner,</span>
 18 |     | <span class='neutral'>        address _ethUsdOracleAddress,</span>
 19 |     | <span class='neutral'>        address _stEthUsdOracleAddress,</span>
 20 |     | <span class='neutral'>        address _wstEthTokenAddress,</span>
 21 |     | <span class='neutral'>        uint256 _ethUsdStalenessThreshold,</span>
 22 |     | <span class='neutral'>        uint256 _stEthUsdStalenessThreshold</span>
 23 |     | <span class='unexecuted'>    ) CompositePriceFeed(_owner, _ethUsdOracleAddress, _wstEthTokenAddress, _ethUsdStalenessThreshold) {</span>
 24 |     | <span class='unexecuted'>        stEthUsdOracle.aggregator = AggregatorV3Interface(_stEthUsdOracleAddress);</span>
 25 |     | <span class='unexecuted'>        stEthUsdOracle.stalenessThreshold = _stEthUsdStalenessThreshold;</span>
 26 |     | <span class='unexecuted'>        stEthUsdOracle.decimals = stEthUsdOracle.aggregator.decimals();</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>        _fetchPricePrimary(false);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>        // Check the oracle didn&#39;t already fail</span>
 31 |     | <span class='unexecuted'>        assert(priceSource == PriceSource.primary);</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>    function _fetchPricePrimary(bool _isRedemption) internal override returns (uint256, bool) {</span>
 35 |     | <span class='unexecuted'>        assert(priceSource == PriceSource.primary);</span>
 36 |     | <span class='unexecuted'>        (uint256 stEthUsdPrice, bool stEthUsdOracleDown) = _getOracleAnswer(stEthUsdOracle);</span>
 37 |     | <span class='unexecuted'>        (uint256 stEthPerWstEth, bool exchangeRateIsDown) = _getCanonicalRate();</span>
 38 |     | <span class='unexecuted'>        (uint256 ethUsdPrice, bool ethUsdOracleDown) = _getOracleAnswer(ethUsdOracle);</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>        // - If exchange rate or ETH-USD is down, shut down and switch to last good price. Reasoning:</span>
 41 |     | <span class='neutral'>        // - Exchange rate is used in all price calcs</span>
 42 |     | <span class='neutral'>        // - ETH-USD is used in the fallback calc, and for redemptions in the primary price calc</span>
 43 |     | <span class='unexecuted'>        if (exchangeRateIsDown) {</span>
 44 |     | <span class='unexecuted'>            return (_shutDownAndSwitchToLastGoodPrice(rateProviderAddress), true);</span>
 45 |     | <span class='neutral'>        }</span>
 46 |     | <span class='unexecuted'>        if (ethUsdOracleDown) {</span>
 47 |     | <span class='unexecuted'>            return (_shutDownAndSwitchToLastGoodPrice(address(ethUsdOracle.aggregator)), true);</span>
 48 |     | <span class='neutral'>        }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>        // If the STETH-USD feed is down, shut down and try to substitute it with the ETH-USD price</span>
 51 |     | <span class='unexecuted'>        if (stEthUsdOracleDown) {</span>
 52 |     | <span class='unexecuted'>            return (_shutDownAndSwitchToETHUSDxCanonical(address(stEthUsdOracle.aggregator), ethUsdPrice), true);</span>
 53 |     | <span class='neutral'>        }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>        // Otherwise, use the primary price calculation:</span>
 56 |     | <span class='unexecuted'>        uint256 wstEthUsdPrice;</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='unexecuted'>        if (_isRedemption &amp;&amp; _withinDeviationThreshold(stEthUsdPrice, ethUsdPrice, STETH_USD_DEVIATION_THRESHOLD)) {</span>
 59 |     | <span class='neutral'>            // If it&#39;s a redemption and within 1%, take the max of (STETH-USD, ETH-USD) to mitigate unwanted redemption arb and convert to WSTETH-USD</span>
 60 |     | <span class='unexecuted'>            wstEthUsdPrice = LiquityMath._max(stEthUsdPrice, ethUsdPrice) * stEthPerWstEth / 1e18;</span>
 61 |     | <span class='neutral'>        } else {</span>
 62 |     | <span class='neutral'>            // Otherwise, just calculate WSTETH-USD price: USD_per_WSTETH = USD_per_STETH * STETH_per_WSTETH</span>
 63 |     | <span class='unexecuted'>            wstEthUsdPrice = stEthUsdPrice * stEthPerWstEth / 1e18;</span>
 64 |     | <span class='neutral'>        }</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='unexecuted'>        lastGoodPrice = wstEthUsdPrice;</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='unexecuted'>        return (wstEthUsdPrice, false);</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='unexecuted'>    function _getCanonicalRate() internal view override returns (uint256, bool) {</span>
 72 |     | <span class='unexecuted'>        uint256 gasBefore = gasleft();</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='unexecuted'>        try IWSTETH(rateProviderAddress).stEthPerToken() returns (uint256 stEthPerWstEth) {</span>
 75 |     | <span class='neutral'>            // If rate is 0, return true</span>
 76 |     | <span class='unexecuted'>            if (stEthPerWstEth == 0) return (0, true);</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='unexecuted'>            return (stEthPerWstEth, false);</span>
 79 |     | <span class='neutral'>        } catch {</span>
 80 |     | <span class='neutral'>            // Require that enough gas was provided to prevent an OOG revert in the external call</span>
 81 |     | <span class='neutral'>            // causing a shutdown. Instead, just revert. Slightly conservative, as it includes gas used</span>
 82 |     | <span class='neutral'>            // in the check itself.</span>
 83 |     | <span class='unexecuted'>            if (gasleft() &lt;= gasBefore / 64) revert InsufficientGasForExternalCall();</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='neutral'>            // If call to exchange rate reverted for another reason, return true</span>
 86 |     | <span class='unexecuted'>            return (0, true);</span>
 87 |     | <span class='neutral'>        }</span>
 88 |     | <span class='neutral'>    }</span>
 89 |     | <span class='neutral'>}</span>
 90 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/SortedTroves.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./Interfaces/ISortedTroves.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Interfaces/IAddressesRegistry.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Interfaces/ITroveManager.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./Interfaces/IBorrowerOperations.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>// ID of head &amp; tail of the list. Callers should stop iterating with `getNext()` / `getPrev()`</span>
  11 |     | <span class='neutral'>// when encountering this node ID.</span>
  12 | *   | <span class='executed'>uint256 constant ROOT_NODE_ID = 0;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/*</span>
  15 |     | <span class='neutral'>* A sorted doubly linked list with nodes sorted in descending order.</span>
  16 |     | <span class='neutral'>*</span>
  17 |     | <span class='neutral'>* Nodes map to active Troves in the system - the ID property is the address of a Trove owner.</span>
  18 |     | <span class='neutral'>* Nodes are ordered according to the borrower&#39;s chosen annual interest rate.</span>
  19 |     | <span class='neutral'>*</span>
  20 |     | <span class='neutral'>* The list optionally accepts insert position hints.</span>
  21 |     | <span class='neutral'>*</span>
  22 |     | <span class='neutral'>* The annual interest rate is stored on the Trove struct in TroveManager, not directly on the Node.</span>
  23 |     | <span class='neutral'>*</span>
  24 |     | <span class='neutral'>* A node need only be re-inserted when the borrower adjusts their interest rate. Interest rate order is preserved</span>
  25 |     | <span class='neutral'>* under all other system operations.</span>
  26 |     | <span class='neutral'>*</span>
  27 |     | <span class='neutral'>* The list is a modification of the following audited SortedDoublyLinkedList:</span>
  28 |     | <span class='neutral'>* https://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol</span>
  29 |     | <span class='neutral'>*</span>
  30 |     | <span class='neutral'>* Changes made in the Bold implementation:</span>
  31 |     | <span class='neutral'>*</span>
  32 |     | <span class='neutral'>* - Keys have been removed from nodes</span>
  33 |     | <span class='neutral'>*</span>
  34 |     | <span class='neutral'>* - Ordering checks for insertion are performed by comparing an interest rate argument to the Trove&#39;s current interest rate.</span>
  35 |     | <span class='neutral'>*</span>
  36 |     | <span class='neutral'>* - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access</span>
  37 |     | <span class='neutral'>*/</span>
  38 | *   | <span class='executed'>contract SortedTroves is ISortedTroves {</span>
  39 |     | <span class='unexecuted'>    string public constant NAME = &quot;SortedTroves&quot;;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    // Constants used for documentation purposes</span>
  42 |     | <span class='neutral'>    uint256 constant UNINITIALIZED_ID = 0;</span>
  43 | *   | <span class='executed'>    uint256 constant BAD_HINT = 0;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    event TroveManagerAddressChanged(address _troveManagerAddress);</span>
  46 |     | <span class='neutral'>    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>    address public immutable borrowerOperationsAddress;</span>
  49 |     | <span class='unexecuted'>    ITroveManager public immutable troveManager;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    // Information for a node in the list</span>
  52 |     | <span class='neutral'>    struct Node {</span>
  53 |     | <span class='neutral'>        uint256 nextId; // Id of next node (smaller interest rate) in the list</span>
  54 |     | <span class='neutral'>        uint256 prevId; // Id of previous node (larger interest rate) in the list</span>
  55 |     | <span class='neutral'>        BatchId batchId; // Id of this node&#39;s batch manager, or zero in case of non-batched nodes</span>
  56 |     | <span class='neutral'>        bool exists;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    struct Batch {</span>
  60 |     | <span class='neutral'>        uint256 head;</span>
  61 |     | <span class='neutral'>        uint256 tail;</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    struct Position {</span>
  65 |     | <span class='neutral'>        uint256 prevId;</span>
  66 |     | <span class='neutral'>        uint256 nextId;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    // Current size of the list</span>
  70 |     | <span class='unexecuted'>    uint256 public size;</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    // Stores the forward and reverse links of each node in the list.</span>
  73 |     | <span class='neutral'>    // nodes[ROOT_NODE_ID] holds the head and tail of the list. This avoids the need for special</span>
  74 |     | <span class='neutral'>    // handling when inserting into or removing from a terminal position (head or tail), inserting</span>
  75 |     | <span class='neutral'>    // into an empty list or removing the element of a singleton list.</span>
  76 |     | <span class='unexecuted'>    mapping(uint256 =&gt; Node) public nodes;</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    // Lookup batches by the address of their manager</span>
  79 |     | <span class='unexecuted'>    mapping(BatchId =&gt; Batch) public batches;</span>
  80 |     | <span class='neutral'></span>
  81 | *   | <span class='executed'>    constructor(IAddressesRegistry _addressesRegistry) {</span>
  82 |     | <span class='neutral'>        // Technically, this is not needed as long as ROOT_NODE_ID is 0, but it doesn&#39;t hurt</span>
  83 | *   | <span class='executed'>        nodes[ROOT_NODE_ID].nextId = ROOT_NODE_ID;</span>
  84 | *   | <span class='executed'>        nodes[ROOT_NODE_ID].prevId = ROOT_NODE_ID;</span>
  85 |     | <span class='neutral'></span>
  86 | *   | <span class='executed'>        troveManager = ITroveManager(_addressesRegistry.troveManager());</span>
  87 | *   | <span class='executed'>        borrowerOperationsAddress = address(_addressesRegistry.borrowerOperations());</span>
  88 |     | <span class='neutral'></span>
  89 | *   | <span class='executed'>        emit TroveManagerAddressChanged(address(troveManager));</span>
  90 | *   | <span class='executed'>        emit BorrowerOperationsAddressChanged(borrowerOperationsAddress);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    // Insert an entire list slice (such as a batch of Troves sharing the same interest rate)</span>
  94 |     | <span class='neutral'>    // between adjacent nodes `_prevId` and `_nextId`.</span>
  95 |     | <span class='neutral'>    // Can be used to insert a single node by passing its ID as both `_sliceHead` and `_sliceTail`.</span>
  96 | *   | <span class='executed'>    function _insertSliceIntoVerifiedPosition(uint256 _sliceHead, uint256 _sliceTail, uint256 _prevId, uint256 _nextId)</span>
  97 |     | <span class='neutral'>        internal</span>
  98 |     | <span class='neutral'>    {</span>
  99 | *   | <span class='executed'>        nodes[_prevId].nextId = _sliceHead;</span>
 100 | *   | <span class='executed'>        nodes[_sliceHead].prevId = _prevId;</span>
 101 | *   | <span class='executed'>        nodes[_sliceTail].nextId = _nextId;</span>
 102 | *   | <span class='executed'>        nodes[_nextId].prevId = _sliceTail;</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 | *   | <span class='executed'>    function _insertSlice(</span>
 106 |     | <span class='neutral'>        ITroveManager _troveManager,</span>
 107 |     | <span class='neutral'>        uint256 _sliceHead,</span>
 108 |     | <span class='neutral'>        uint256 _sliceTail,</span>
 109 |     | <span class='neutral'>        uint256 _annualInterestRate,</span>
 110 |     | <span class='neutral'>        uint256 _prevId,</span>
 111 |     | <span class='neutral'>        uint256 _nextId</span>
 112 |     | <span class='neutral'>    ) internal {</span>
 113 | *   | <span class='executed'>        if (!_validInsertPosition(_troveManager, _annualInterestRate, _prevId, _nextId)) {</span>
 114 |     | <span class='neutral'>            // Sender&#39;s hint was not a valid insert position</span>
 115 |     | <span class='neutral'>            // Use sender&#39;s hint to find a valid insert position</span>
 116 | *   | <span class='executed'>            (_prevId, _nextId) = _findInsertPosition(_troveManager, _annualInterestRate, _prevId, _nextId);</span>
 117 |     | <span class='neutral'>        }</span>
 118 |     | <span class='neutral'></span>
 119 | *   | <span class='executed'>        _insertSliceIntoVerifiedPosition(_sliceHead, _sliceTail, _prevId, _nextId);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /*</span>
 123 |     | <span class='neutral'>     * @dev Add a Trove to the list</span>
 124 |     | <span class='neutral'>     * @param _id Trove&#39;s id</span>
 125 |     | <span class='neutral'>     * @param _annualInterestRate Trove&#39;s annual interest rate</span>
 126 |     | <span class='neutral'>     * @param _prevId Id of previous Trove for the insert position</span>
 127 |     | <span class='neutral'>     * @param _nextId Id of next Trove for the insert position</span>
 128 |     | <span class='neutral'>     */</span>
 129 | *   | <span class='executed'>    function insert(uint256 _id, uint256 _annualInterestRate, uint256 _prevId, uint256 _nextId) external override {</span>
 130 | *   | <span class='executed'>        _requireCallerIsBorrowerOperations();</span>
 131 | *   | <span class='executed'>        require(!contains(_id), &quot;SortedTroves: List already contains the node&quot;);</span>
 132 | *   | <span class='executed'>        require(_id != ROOT_NODE_ID, &quot;SortedTroves: _id cannot be the root node&#39;s ID&quot;);</span>
 133 |     | <span class='neutral'></span>
 134 | *   | <span class='executed'>        _insertSlice(troveManager, _id, _id, _annualInterestRate, _prevId, _nextId);</span>
 135 | *   | <span class='executed'>        nodes[_id].exists = true;</span>
 136 | *   | <span class='executed'>        ++size;</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    // Remove the entire slice between `_sliceHead` and `_sliceTail` from the list while keeping</span>
 140 |     | <span class='neutral'>    // the removed nodes connected to each other, such that they can be reinserted into a different</span>
 141 |     | <span class='neutral'>    // position with `_insertSlice()`.</span>
 142 |     | <span class='neutral'>    // Can be used to remove a single node by passing its ID as both `_sliceHead` and `_sliceTail`.</span>
 143 |     | <span class='neutral'>    function _removeSlice(uint256 _sliceHead, uint256 _sliceTail) internal {</span>
 144 | *   | <span class='executed'>        nodes[nodes[_sliceHead].prevId].nextId = nodes[_sliceTail].nextId;</span>
 145 | *   | <span class='executed'>        nodes[nodes[_sliceTail].nextId].prevId = nodes[_sliceHead].prevId;</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    /*</span>
 149 |     | <span class='neutral'>     * @dev Remove a non-batched Trove from the list</span>
 150 |     | <span class='neutral'>     * @param _id Trove&#39;s id</span>
 151 |     | <span class='neutral'>     */</span>
 152 | *   | <span class='executed'>    function remove(uint256 _id) external override {</span>
 153 | *   | <span class='executed'>        _requireCallerIsBOorTM();</span>
 154 | *   | <span class='executed'>        require(contains(_id), &quot;SortedTroves: List does not contain the id&quot;);</span>
 155 | *   | <span class='executed'>        require(!isBatchedNode(_id), &quot;SortedTroves: Must use removeFromBatch() to remove batched node&quot;);</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>        _removeSlice(_id, _id);</span>
 158 | *   | <span class='executed'>        delete nodes[_id];</span>
 159 | *   | <span class='executed'>        --size;</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 | *   | <span class='executed'>    function _reInsertSlice(</span>
 163 |     | <span class='neutral'>        ITroveManager _troveManager,</span>
 164 |     | <span class='neutral'>        uint256 _sliceHead,</span>
 165 |     | <span class='neutral'>        uint256 _sliceTail,</span>
 166 |     | <span class='neutral'>        uint256 _annualInterestRate,</span>
 167 |     | <span class='neutral'>        uint256 _prevId,</span>
 168 |     | <span class='neutral'>        uint256 _nextId</span>
 169 |     | <span class='neutral'>    ) internal {</span>
 170 | *   | <span class='executed'>        if (!_validInsertPosition(_troveManager, _annualInterestRate, _prevId, _nextId)) {</span>
 171 |     | <span class='neutral'>            // Sender&#39;s hint was not a valid insert position</span>
 172 |     | <span class='neutral'>            // Use sender&#39;s hint to find a valid insert position</span>
 173 | *   | <span class='executed'>            (_prevId, _nextId) = _findInsertPosition(_troveManager, _annualInterestRate, _prevId, _nextId);</span>
 174 |     | <span class='neutral'>        }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>        // Check that the new insert position isn&#39;t the same as the existing one</span>
 177 | *   | <span class='executed'>        if (_nextId != _sliceHead &amp;&amp; _prevId != _sliceTail) {</span>
 178 | *   | <span class='executed'>            _removeSlice(_sliceHead, _sliceTail);</span>
 179 | *   | <span class='executed'>            _insertSliceIntoVerifiedPosition(_sliceHead, _sliceTail, _prevId, _nextId);</span>
 180 |     | <span class='neutral'>        }</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /*</span>
 184 |     | <span class='neutral'>     * @dev Re-insert a non-batched Trove at a new position, based on its new annual interest rate</span>
 185 |     | <span class='neutral'>     * @param _id Trove&#39;s id</span>
 186 |     | <span class='neutral'>     * @param _newAnnualInterestRate Trove&#39;s new annual interest rate</span>
 187 |     | <span class='neutral'>     * @param _prevId Id of previous Trove for the new insert position</span>
 188 |     | <span class='neutral'>     * @param _nextId Id of next Trove for the new insert position</span>
 189 |     | <span class='neutral'>     */</span>
 190 | *   | <span class='executed'>    function reInsert(uint256 _id, uint256 _newAnnualInterestRate, uint256 _prevId, uint256 _nextId)</span>
 191 |     | <span class='neutral'>        external</span>
 192 |     | <span class='neutral'>        override</span>
 193 |     | <span class='neutral'>    {</span>
 194 | *   | <span class='executed'>        _requireCallerIsBorrowerOperations();</span>
 195 | *   | <span class='executed'>        require(contains(_id), &quot;SortedTroves: List does not contain the id&quot;);</span>
 196 | *   | <span class='executed'>        require(!isBatchedNode(_id), &quot;SortedTroves: Must not reInsert() batched node&quot;);</span>
 197 |     | <span class='neutral'></span>
 198 | *   | <span class='executed'>        _reInsertSlice(troveManager, _id, _id, _newAnnualInterestRate, _prevId, _nextId);</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>    /*</span>
 202 |     | <span class='neutral'>     * @dev Add a Trove to a Batch within the list</span>
 203 |     | <span class='neutral'>     * @param _troveId Trove&#39;s id</span>
 204 |     | <span class='neutral'>     * @param _batchId Batch&#39;s id</span>
 205 |     | <span class='neutral'>     * @param _annualInterestRate Batch&#39;s annual interest rate</span>
 206 |     | <span class='neutral'>     * @param _prevId Id of previous Trove for the insert position, in case the Batch is empty</span>
 207 |     | <span class='neutral'>     * @param _nextId Id of next Trove for the insert position, in case the Batch is empty</span>
 208 |     | <span class='neutral'>     */</span>
 209 | *   | <span class='executed'>    function insertIntoBatch(</span>
 210 |     | <span class='neutral'>        uint256 _troveId,</span>
 211 |     | <span class='neutral'>        BatchId _batchId,</span>
 212 |     | <span class='neutral'>        uint256 _annualInterestRate,</span>
 213 |     | <span class='neutral'>        uint256 _prevId,</span>
 214 |     | <span class='neutral'>        uint256 _nextId</span>
 215 |     | <span class='neutral'>    ) external override {</span>
 216 | *   | <span class='executed'>        _requireCallerIsBorrowerOperations();</span>
 217 | *   | <span class='executed'>        require(!contains(_troveId), &quot;SortedTroves: List already contains the node&quot;);</span>
 218 | *   | <span class='executed'>        require(_troveId != ROOT_NODE_ID, &quot;SortedTroves: _troveId cannot be the root node&#39;s ID&quot;);</span>
 219 | *   | <span class='executed'>        require(_batchId.isNotZero(), &quot;SortedTroves: _batchId cannot be zero&quot;);</span>
 220 |     | <span class='neutral'></span>
 221 | *   | <span class='executed'>        uint256 batchTail = batches[_batchId].tail;</span>
 222 |     | <span class='neutral'></span>
 223 | *   | <span class='executed'>        if (batchTail == UNINITIALIZED_ID) {</span>
 224 | *   | <span class='executed'>            _insertSlice(troveManager, _troveId, _troveId, _annualInterestRate, _prevId, _nextId);</span>
 225 |     | <span class='neutral'>            // Initialize the batch by setting both its head &amp; tail to its singular node</span>
 226 | *   | <span class='executed'>            batches[_batchId].head = _troveId;</span>
 227 |     | <span class='neutral'>            // (Tail will be set outside the &quot;if&quot;)</span>
 228 |     | <span class='neutral'>        } else {</span>
 229 | *   | <span class='executed'>            _insertSliceIntoVerifiedPosition(_troveId, _troveId, batchTail, nodes[batchTail].nextId);</span>
 230 |     | <span class='neutral'>        }</span>
 231 |     | <span class='neutral'></span>
 232 | *   | <span class='executed'>        batches[_batchId].tail = _troveId;</span>
 233 | *   | <span class='executed'>        nodes[_troveId].batchId = _batchId;</span>
 234 | *   | <span class='executed'>        nodes[_troveId].exists = true;</span>
 235 | *   | <span class='executed'>        ++size;</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>    /*</span>
 239 |     | <span class='neutral'>     * @dev Remove a batched Trove from the list</span>
 240 |     | <span class='neutral'>     * @param _id Trove&#39;s id</span>
 241 |     | <span class='neutral'>     */</span>
 242 | *   | <span class='executed'>    function removeFromBatch(uint256 _id) external override {</span>
 243 | *   | <span class='executed'>        _requireCallerIsBOorTM();</span>
 244 | *   | <span class='executed'>        BatchId batchId = nodes[_id].batchId;</span>
 245 |     | <span class='neutral'>        // batchId.isNotZero() implies that the list contains the node</span>
 246 | *   | <span class='executed'>        require(batchId.isNotZero(), &quot;SortedTroves: Must use remove() to remove non-batched node&quot;);</span>
 247 |     | <span class='neutral'></span>
 248 | *   | <span class='executed'>        Batch memory batch = batches[batchId];</span>
 249 |     | <span class='neutral'></span>
 250 | *   | <span class='executed'>        if (batch.head == _id &amp;&amp; batch.tail == _id) {</span>
 251 |     | <span class='neutral'>            // Remove singleton batch</span>
 252 | *   | <span class='executed'>            delete batches[batchId];</span>
 253 |     | <span class='unexecuted'>        } else if (batch.head == _id) {</span>
 254 |     | <span class='unexecuted'>            batches[batchId].head = nodes[_id].nextId;</span>
 255 | *   | <span class='executed'>        } else if (batch.tail == _id) {</span>
 256 |     | <span class='unexecuted'>            batches[batchId].tail = nodes[_id].prevId;</span>
 257 |     | <span class='neutral'>        }</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='neutral'>        _removeSlice(_id, _id);</span>
 260 | *   | <span class='executed'>        delete nodes[_id];</span>
 261 | *   | <span class='executed'>        --size;</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>    /*</span>
 265 |     | <span class='neutral'>     * @dev Re-insert an entire Batch of Troves at a new position, based on their new annual interest rate</span>
 266 |     | <span class='neutral'>     * @param _id Batch&#39;s id</span>
 267 |     | <span class='neutral'>     * @param _newAnnualInterestRate Trove&#39;s new annual interest rate</span>
 268 |     | <span class='neutral'>     * @param _prevId Id of previous Trove for the new insert position</span>
 269 |     | <span class='neutral'>     * @param _nextId Id of next Trove for the new insert position</span>
 270 |     | <span class='neutral'>     */</span>
 271 | *   | <span class='executed'>    function reInsertBatch(BatchId _id, uint256 _newAnnualInterestRate, uint256 _prevId, uint256 _nextId)</span>
 272 |     | <span class='neutral'>        external</span>
 273 |     | <span class='neutral'>        override</span>
 274 |     | <span class='unexecuted'>    {</span>
 275 |     | <span class='unexecuted'>        Batch memory batch = batches[_id];</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>        _requireCallerIsBorrowerOperations();</span>
 278 |     | <span class='unexecuted'>        require(batch.head != UNINITIALIZED_ID, &quot;SortedTroves: List does not contain the batch&quot;);</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='unexecuted'>        _reInsertSlice(troveManager, batch.head, batch.tail, _newAnnualInterestRate, _prevId, _nextId);</span>
 281 |     | <span class='neutral'>    }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>    /*</span>
 284 |     | <span class='neutral'>     * @dev Checks if the list contains a node</span>
 285 |     | <span class='neutral'>     */</span>
 286 | *   | <span class='executed'>    function contains(uint256 _id) public view override returns (bool) {</span>
 287 | *   | <span class='executed'>        return nodes[_id].exists;</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>    /*</span>
 291 |     | <span class='neutral'>     * @dev Checks whether the node is part of a batch</span>
 292 |     | <span class='neutral'>     */</span>
 293 | *   | <span class='executed'>    function isBatchedNode(uint256 _id) public view override returns (bool) {</span>
 294 | *   | <span class='executed'>        return nodes[_id].batchId.isNotZero();</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 | *   | <span class='executed'>    function isEmptyBatch(BatchId _id) external view override returns (bool) {</span>
 298 |     | <span class='unexecuted'>        return batches[_id].head == UNINITIALIZED_ID;</span>
 299 |     | <span class='neutral'>    }</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='neutral'>    /*</span>
 302 |     | <span class='neutral'>     * @dev Checks if the list is empty</span>
 303 |     | <span class='neutral'>     */</span>
 304 |     | <span class='unexecuted'>    function isEmpty() external view override returns (bool) {</span>
 305 |     | <span class='unexecuted'>        return size == 0;</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='neutral'>    /*</span>
 309 |     | <span class='neutral'>     * @dev Returns the current size of the list</span>
 310 |     | <span class='neutral'>     */</span>
 311 |     | <span class='unexecuted'>    function getSize() external view override returns (uint256) {</span>
 312 |     | <span class='unexecuted'>        return size;</span>
 313 |     | <span class='neutral'>    }</span>
 314 |     | <span class='neutral'></span>
 315 |     | <span class='neutral'>    /*</span>
 316 |     | <span class='neutral'>     * @dev Returns the first node in the list (node with the largest annual interest rate)</span>
 317 |     | <span class='neutral'>     */</span>
 318 |     | <span class='unexecuted'>    function getFirst() external view override returns (uint256) {</span>
 319 |     | <span class='unexecuted'>        return nodes[ROOT_NODE_ID].nextId;</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>    /*</span>
 323 |     | <span class='neutral'>     * @dev Returns the last node in the list (node with the smallest annual interest rate)</span>
 324 |     | <span class='neutral'>     */</span>
 325 | *   | <span class='executed'>    function getLast() external view override returns (uint256) {</span>
 326 | *   | <span class='executed'>        return nodes[ROOT_NODE_ID].prevId;</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>    /*</span>
 330 |     | <span class='neutral'>     * @dev Returns the next node (with a smaller interest rate) in the list for a given node</span>
 331 |     | <span class='neutral'>     * @param _id Node&#39;s id</span>
 332 |     | <span class='neutral'>     */</span>
 333 | *   | <span class='executed'>    function getNext(uint256 _id) external view override returns (uint256) {</span>
 334 |     | <span class='unexecuted'>        return nodes[_id].nextId;</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='neutral'>    /*</span>
 338 |     | <span class='neutral'>     * @dev Returns the previous node (with a larger interest rate) in the list for a given node</span>
 339 |     | <span class='neutral'>     * @param _id Node&#39;s id</span>
 340 |     | <span class='neutral'>     */</span>
 341 | *   | <span class='executed'>    function getPrev(uint256 _id) external view override returns (uint256) {</span>
 342 | *   | <span class='executed'>        return nodes[_id].prevId;</span>
 343 |     | <span class='neutral'>    }</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>    /*</span>
 346 |     | <span class='neutral'>     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given interest rate</span>
 347 |     | <span class='neutral'>     * @param _annualInterestRate Node&#39;s annual interest rate</span>
 348 |     | <span class='neutral'>     * @param _prevId Id of previous node for the insert position</span>
 349 |     | <span class='neutral'>     * @param _nextId Id of next node for the insert position</span>
 350 |     | <span class='neutral'>     */</span>
 351 | *   | <span class='executed'>    function validInsertPosition(uint256 _annualInterestRate, uint256 _prevId, uint256 _nextId)</span>
 352 |     | <span class='neutral'>        external</span>
 353 |     | <span class='neutral'>        view</span>
 354 |     | <span class='neutral'>        override</span>
 355 |     | <span class='unexecuted'>        returns (bool)</span>
 356 |     | <span class='neutral'>    {</span>
 357 |     | <span class='unexecuted'>        return _validInsertPosition(troveManager, _annualInterestRate, _prevId, _nextId);</span>
 358 |     | <span class='neutral'>    }</span>
 359 |     | <span class='neutral'></span>
 360 | *   | <span class='executed'>    function _validInsertPosition(</span>
 361 |     | <span class='neutral'>        ITroveManager _troveManager,</span>
 362 |     | <span class='neutral'>        uint256 _annualInterestRate,</span>
 363 |     | <span class='neutral'>        uint256 _prevId,</span>
 364 |     | <span class='neutral'>        uint256 _nextId</span>
 365 | *   | <span class='executed'>    ) internal view returns (bool) {</span>
 366 | *   | <span class='executed'>        BatchId prevBatchId = nodes[_prevId].batchId;</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='neutral'>        // `(_prevId, _nextId)` is a valid insert position if:</span>
 369 | *   | <span class='executed'>        return</span>
 370 |     | <span class='neutral'>        // they are adjacent nodes</span>
 371 |     | <span class='neutral'>        (</span>
 372 | *   | <span class='executed'>            nodes[_prevId].nextId == _nextId &amp;&amp; nodes[_nextId].prevId == _prevId</span>
 373 |     | <span class='neutral'>            // they aren&#39;t part of the same batch</span>
 374 | *   | <span class='executed'>            &amp;&amp; (prevBatchId != nodes[_nextId].batchId || prevBatchId.isZero())</span>
 375 |     | <span class='neutral'>            // `_annualInterestRate` falls between the two nodes&#39; interest rates</span>
 376 | *   | <span class='executed'>            &amp;&amp; (_prevId == ROOT_NODE_ID || _troveManager.getTroveAnnualInterestRate(_prevId) &gt;= _annualInterestRate)</span>
 377 | *   | <span class='executed'>                &amp;&amp; (_nextId == ROOT_NODE_ID || _annualInterestRate &gt; _troveManager.getTroveAnnualInterestRate(_nextId))</span>
 378 |     | <span class='neutral'>        );</span>
 379 |     | <span class='neutral'>    }</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='unexecuted'>    function _skipToBatchTail(uint256 _id) internal view returns (uint256) {</span>
 382 |     | <span class='unexecuted'>        BatchId batchId = nodes[_id].batchId;</span>
 383 |     | <span class='unexecuted'>        return batchId.isNotZero() ? batches[batchId].tail : _id;</span>
 384 |     | <span class='neutral'>    }</span>
 385 |     | <span class='neutral'></span>
 386 |     | <span class='unexecuted'>    function _skipToBatchHead(uint256 _id) internal view returns (uint256) {</span>
 387 |     | <span class='unexecuted'>        BatchId batchId = nodes[_id].batchId;</span>
 388 |     | <span class='unexecuted'>        return batchId.isNotZero() ? batches[batchId].head : _id;</span>
 389 |     | <span class='neutral'>    }</span>
 390 |     | <span class='neutral'></span>
 391 | *   | <span class='executed'>    function _descendOne(ITroveManager _troveManager, uint256 _annualInterestRate, Position memory _pos)</span>
 392 |     | <span class='neutral'>        internal</span>
 393 |     | <span class='neutral'>        view</span>
 394 | *   | <span class='executed'>        returns (bool found)</span>
 395 |     | <span class='neutral'>    {</span>
 396 | *   | <span class='executed'>        if (_pos.nextId == ROOT_NODE_ID || _annualInterestRate &gt; _troveManager.getTroveAnnualInterestRate(_pos.nextId))</span>
 397 |     | <span class='neutral'>        {</span>
 398 | *   | <span class='executed'>            found = true;</span>
 399 |     | <span class='neutral'>        } else {</span>
 400 |     | <span class='unexecuted'>            _pos.prevId = _skipToBatchTail(_pos.nextId);</span>
 401 |     | <span class='unexecuted'>            _pos.nextId = nodes[_pos.prevId].nextId;</span>
 402 |     | <span class='neutral'>        }</span>
 403 |     | <span class='neutral'>    }</span>
 404 |     | <span class='neutral'></span>
 405 |     | <span class='unexecuted'>    function _ascendOne(ITroveManager _troveManager, uint256 _annualInterestRate, Position memory _pos)</span>
 406 |     | <span class='neutral'>        internal</span>
 407 |     | <span class='neutral'>        view</span>
 408 |     | <span class='unexecuted'>        returns (bool found)</span>
 409 |     | <span class='neutral'>    {</span>
 410 |     | <span class='unexecuted'>        if (_pos.prevId == ROOT_NODE_ID || _troveManager.getTroveAnnualInterestRate(_pos.prevId) &gt;= _annualInterestRate)</span>
 411 |     | <span class='neutral'>        {</span>
 412 |     | <span class='unexecuted'>            found = true;</span>
 413 |     | <span class='neutral'>        } else {</span>
 414 |     | <span class='unexecuted'>            _pos.nextId = _skipToBatchHead(_pos.prevId);</span>
 415 |     | <span class='unexecuted'>            _pos.prevId = nodes[_pos.nextId].prevId;</span>
 416 |     | <span class='neutral'>        }</span>
 417 |     | <span class='neutral'>    }</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='neutral'>    /*</span>
 420 |     | <span class='neutral'>     * @dev Descend the list (larger interest rates to smaller interest rates) to find a valid insert position</span>
 421 |     | <span class='neutral'>     * @param _troveManager TroveManager contract, passed in as param to save SLOAD’s</span>
 422 |     | <span class='neutral'>     * @param _annualInterestRate Node&#39;s annual interest rate</span>
 423 |     | <span class='neutral'>     * @param _startId Id of node to start descending the list from</span>
 424 |     | <span class='neutral'>     */</span>
 425 | *   | <span class='executed'>    function _descendList(ITroveManager _troveManager, uint256 _annualInterestRate, uint256 _startId)</span>
 426 |     | <span class='neutral'>        internal</span>
 427 |     | <span class='neutral'>        view</span>
 428 | *   | <span class='executed'>        returns (uint256, uint256)</span>
 429 |     | <span class='neutral'>    {</span>
 430 | *   | <span class='executed'>        Position memory pos = Position(_startId, nodes[_startId].nextId);</span>
 431 |     | <span class='neutral'></span>
 432 | *   | <span class='executed'>        while (!_descendOne(_troveManager, _annualInterestRate, pos)) {}</span>
 433 | *   | <span class='executed'>        return (pos.prevId, pos.nextId);</span>
 434 |     | <span class='neutral'>    }</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='neutral'>    /*</span>
 437 |     | <span class='neutral'>     * @dev Ascend the list (smaller interest rates to larger interest rates) to find a valid insert position</span>
 438 |     | <span class='neutral'>     * @param _troveManager TroveManager contract, passed in as param to save SLOAD’s</span>
 439 |     | <span class='neutral'>     * @param _annualInterestRate Node&#39;s annual interest rate</span>
 440 |     | <span class='neutral'>     * @param _startId Id of node to start ascending the list from</span>
 441 |     | <span class='neutral'>     */</span>
 442 |     | <span class='unexecuted'>    function _ascendList(ITroveManager _troveManager, uint256 _annualInterestRate, uint256 _startId)</span>
 443 |     | <span class='neutral'>        internal</span>
 444 |     | <span class='neutral'>        view</span>
 445 |     | <span class='unexecuted'>        returns (uint256, uint256)</span>
 446 |     | <span class='neutral'>    {</span>
 447 |     | <span class='unexecuted'>        Position memory pos = Position(nodes[_startId].prevId, _startId);</span>
 448 |     | <span class='neutral'></span>
 449 |     | <span class='unexecuted'>        while (!_ascendOne(_troveManager, _annualInterestRate, pos)) {}</span>
 450 |     | <span class='unexecuted'>        return (pos.prevId, pos.nextId);</span>
 451 |     | <span class='neutral'>    }</span>
 452 |     | <span class='neutral'></span>
 453 |     | <span class='unexecuted'>    function _descendAndAscendList(</span>
 454 |     | <span class='neutral'>        ITroveManager _troveManager,</span>
 455 |     | <span class='neutral'>        uint256 _annualInterestRate,</span>
 456 |     | <span class='neutral'>        uint256 _descentStartId,</span>
 457 |     | <span class='neutral'>        uint256 _ascentStartId</span>
 458 |     | <span class='unexecuted'>    ) internal view returns (uint256 prevId, uint256 nextId) {</span>
 459 |     | <span class='unexecuted'>        Position memory descentPos = Position(_descentStartId, nodes[_descentStartId].nextId);</span>
 460 |     | <span class='unexecuted'>        Position memory ascentPos = Position(nodes[_ascentStartId].prevId, _ascentStartId);</span>
 461 |     | <span class='neutral'></span>
 462 |     | <span class='unexecuted'>        for (;;) {</span>
 463 |     | <span class='unexecuted'>            if (_descendOne(_troveManager, _annualInterestRate, descentPos)) {</span>
 464 |     | <span class='unexecuted'>                return (descentPos.prevId, descentPos.nextId);</span>
 465 |     | <span class='neutral'>            }</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='unexecuted'>            if (_ascendOne(_troveManager, _annualInterestRate, ascentPos)) {</span>
 468 |     | <span class='unexecuted'>                return (ascentPos.prevId, ascentPos.nextId);</span>
 469 |     | <span class='neutral'>            }</span>
 470 |     | <span class='neutral'>        }</span>
 471 |     | <span class='neutral'></span>
 472 |     | <span class='neutral'>        assert(false); // Should not reach</span>
 473 |     | <span class='neutral'>    }</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='neutral'>    /*</span>
 476 |     | <span class='neutral'>     * @dev Find the insert position for a new node with the given interest rate</span>
 477 |     | <span class='neutral'>     * @param _annualInterestRate Node&#39;s annual interest rate</span>
 478 |     | <span class='neutral'>     * @param _prevId Id of previous node for the insert position</span>
 479 |     | <span class='neutral'>     * @param _nextId Id of next node for the insert position</span>
 480 |     | <span class='neutral'>     */</span>
 481 |     | <span class='unexecuted'>    function findInsertPosition(uint256 _annualInterestRate, uint256 _prevId, uint256 _nextId)</span>
 482 |     | <span class='neutral'>        external</span>
 483 |     | <span class='neutral'>        view</span>
 484 |     | <span class='neutral'>        override</span>
 485 |     | <span class='unexecuted'>        returns (uint256, uint256)</span>
 486 |     | <span class='neutral'>    {</span>
 487 |     | <span class='unexecuted'>        return _findInsertPosition(troveManager, _annualInterestRate, _prevId, _nextId);</span>
 488 |     | <span class='neutral'>    }</span>
 489 |     | <span class='neutral'></span>
 490 |     | <span class='neutral'>    // This function is optimized under the assumption that only one of the original neighbours has been (re)moved.</span>
 491 |     | <span class='neutral'>    // In other words, we assume that the correct position can be found close to one of the two.</span>
 492 |     | <span class='neutral'>    // Nevertheless, the function will always find the correct position, regardless of hints or interference.</span>
 493 | *   | <span class='executed'>    function _findInsertPosition(</span>
 494 |     | <span class='neutral'>        ITroveManager _troveManager,</span>
 495 |     | <span class='neutral'>        uint256 _annualInterestRate,</span>
 496 |     | <span class='neutral'>        uint256 _prevId,</span>
 497 |     | <span class='neutral'>        uint256 _nextId</span>
 498 | *   | <span class='executed'>    ) internal view returns (uint256, uint256) {</span>
 499 | *   | <span class='executed'>        if (_prevId == ROOT_NODE_ID) {</span>
 500 |     | <span class='neutral'>            // The original correct position was found before the head of the list.</span>
 501 |     | <span class='neutral'>            // Assuming minimal interference, the new correct position is still close to the head.</span>
 502 | *   | <span class='executed'>            return _descendList(_troveManager, _annualInterestRate, ROOT_NODE_ID);</span>
 503 |     | <span class='neutral'>        } else {</span>
 504 | *   | <span class='executed'>            if (!contains(_prevId) || _troveManager.getTroveAnnualInterestRate(_prevId) &lt; _annualInterestRate) {</span>
 505 |     | <span class='neutral'>                // `prevId` does not exist anymore or now has a smaller interest rate than the given interest rate</span>
 506 | *   | <span class='executed'>                _prevId = BAD_HINT;</span>
 507 |     | <span class='neutral'>            }</span>
 508 |     | <span class='neutral'>        }</span>
 509 |     | <span class='neutral'></span>
 510 | *   | <span class='executed'>        if (_nextId == ROOT_NODE_ID) {</span>
 511 |     | <span class='neutral'>            // The original correct position was found after the tail of the list.</span>
 512 |     | <span class='neutral'>            // Assuming minimal interference, the new correct position is still close to the tail.</span>
 513 |     | <span class='unexecuted'>            return _ascendList(_troveManager, _annualInterestRate, ROOT_NODE_ID);</span>
 514 |     | <span class='neutral'>        } else {</span>
 515 | *   | <span class='executed'>            if (!contains(_nextId) || _annualInterestRate &lt;= _troveManager.getTroveAnnualInterestRate(_nextId)) {</span>
 516 |     | <span class='neutral'>                // `nextId` does not exist anymore or now has a larger interest rate than the given interest rate</span>
 517 | *   | <span class='executed'>                _nextId = BAD_HINT;</span>
 518 |     | <span class='neutral'>            }</span>
 519 |     | <span class='neutral'>        }</span>
 520 |     | <span class='neutral'></span>
 521 | *   | <span class='executed'>        if (_prevId == BAD_HINT &amp;&amp; _nextId == BAD_HINT) {</span>
 522 |     | <span class='neutral'>            // Both original neighbours have been moved or removed.</span>
 523 |     | <span class='neutral'>            // We default to descending the list, starting from the head.</span>
 524 | *   | <span class='executed'>            return _descendList(_troveManager, _annualInterestRate, ROOT_NODE_ID);</span>
 525 |     | <span class='unexecuted'>        } else if (_prevId == BAD_HINT) {</span>
 526 |     | <span class='neutral'>            // No `prevId` for hint - ascend list starting from `nextId`</span>
 527 |     | <span class='unexecuted'>            return _ascendList(_troveManager, _annualInterestRate, _skipToBatchHead(_nextId));</span>
 528 | *   | <span class='executed'>        } else if (_nextId == BAD_HINT) {</span>
 529 |     | <span class='neutral'>            // No `nextId` for hint - descend list starting from `prevId`</span>
 530 |     | <span class='unexecuted'>            return _descendList(_troveManager, _annualInterestRate, _skipToBatchTail(_prevId));</span>
 531 |     | <span class='neutral'>        } else {</span>
 532 |     | <span class='neutral'>            // The correct position is still somewhere between the 2 hints, so it&#39;s not obvious</span>
 533 |     | <span class='neutral'>            // which of the 2 has been moved (assuming only one of them has been).</span>
 534 |     | <span class='neutral'>            // We simultaneously descend &amp; ascend in the hope that one of them is very close.</span>
 535 |     | <span class='unexecuted'>            return _descendAndAscendList(</span>
 536 |     | <span class='unexecuted'>                _troveManager, _annualInterestRate, _skipToBatchTail(_prevId), _skipToBatchHead(_nextId)</span>
 537 |     | <span class='neutral'>            );</span>
 538 |     | <span class='neutral'>        }</span>
 539 |     | <span class='neutral'>    }</span>
 540 |     | <span class='neutral'></span>
 541 |     | <span class='neutral'>    // --- &#39;require&#39; functions ---</span>
 542 |     | <span class='neutral'></span>
 543 | *   | <span class='executed'>    function _requireCallerIsBOorTM() internal view {</span>
 544 | *   | <span class='executed'>        require(</span>
 545 | *   | <span class='executed'>            msg.sender == borrowerOperationsAddress || msg.sender == address(troveManager),</span>
 546 |     | <span class='neutral'>            &quot;SortedTroves: Caller is not BorrowerOperations nor TroveManager&quot;</span>
 547 |     | <span class='neutral'>        );</span>
 548 |     | <span class='neutral'>    }</span>
 549 |     | <span class='neutral'></span>
 550 | *   | <span class='executed'>    function _requireCallerIsBorrowerOperations() internal view {</span>
 551 | *   | <span class='executed'>        require(msg.sender == borrowerOperationsAddress, &quot;SortedTroves: Caller is not BorrowerOperations&quot;);</span>
 552 |     | <span class='neutral'>    }</span>
 553 |     | <span class='neutral'>}</span>
 554 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/StabilityPool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;./Interfaces/IStabilityPool.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./Interfaces/IAddressesRegistry.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./Interfaces/IStabilityPoolEvents.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;./Interfaces/ITroveManager.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;./Interfaces/IBoldToken.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;./Dependencies/LiquityBase.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/*</span>
  15 |     | <span class='neutral'> * The Stability Pool holds Bold tokens deposited by Stability Pool depositors.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * When a trove is liquidated, then depending on system conditions, some of its Bold debt gets offset with</span>
  18 |     | <span class='neutral'> * Bold in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of Bold tokens in the Stability Pool is burned.</span>
  19 |     | <span class='neutral'> *</span>
  20 |     | <span class='neutral'> * Thus, a liquidation causes each depositor to receive a Bold loss, in proportion to their deposit as a share of total deposits.</span>
  21 |     | <span class='neutral'> * They also receive an Coll gain, as the collateral of the liquidated trove is distributed among Stability depositors,</span>
  22 |     | <span class='neutral'> * in the same proportion.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%</span>
  25 |     | <span class='neutral'> * of the total Bold in the Stability Pool, depletes 40% of each deposit.</span>
  26 |     | <span class='neutral'> *</span>
  27 |     | <span class='neutral'> * A deposit that has experienced a series of liquidations is termed a &quot;compounded deposit&quot;: each liquidation depletes the deposit,</span>
  28 |     | <span class='neutral'> * multiplying it by some factor in range ]0,1[</span>
  29 |     | <span class='neutral'> *</span>
  30 |     | <span class='neutral'> *</span>
  31 |     | <span class='neutral'> * --- IMPLEMENTATION ---</span>
  32 |     | <span class='neutral'> *</span>
  33 |     | <span class='neutral'> * We use a highly scalable method of tracking deposits and Coll gains that has O(1) complexity.</span>
  34 |     | <span class='neutral'> *</span>
  35 |     | <span class='neutral'> * When a liquidation occurs, rather than updating each depositor&#39;s deposit and Coll gain, we simply update two state variables:</span>
  36 |     | <span class='neutral'> * a product P, and a sum S.</span>
  37 |     | <span class='neutral'> *</span>
  38 |     | <span class='neutral'> * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors&#39; compounded deposits</span>
  39 |     | <span class='neutral'> * and accumulated Coll gains over time, as liquidations occur, using just these two variables P and S. When depositors join the</span>
  40 |     | <span class='neutral'> * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.</span>
  41 |     | <span class='neutral'> *</span>
  42 |     | <span class='neutral'> * The formula for a depositor&#39;s accumulated Coll gain is derived here:</span>
  43 |     | <span class='neutral'> * https://github.com/liquity/dev/blob/main/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf</span>
  44 |     | <span class='neutral'> *</span>
  45 |     | <span class='neutral'> * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,</span>
  46 |     | <span class='neutral'> * and the term d_t * (S - S_t)/P_t gives us the deposit&#39;s total accumulated Coll gain.</span>
  47 |     | <span class='neutral'> *</span>
  48 |     | <span class='neutral'> * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Coll gain</span>
  49 |     | <span class='neutral'> * can be calculated using the initial deposit, the depositor’s snapshots of P and S, and the latest values of P and S.</span>
  50 |     | <span class='neutral'> *</span>
  51 |     | <span class='neutral'> * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Coll gain is paid out, their new deposit is recorded</span>
  52 |     | <span class='neutral'> * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.</span>
  53 |     | <span class='neutral'> * Essentially, they make a fresh deposit that overwrites the old one.</span>
  54 |     | <span class='neutral'> *</span>
  55 |     | <span class='neutral'> *</span>
  56 |     | <span class='neutral'> * --- SCALE FACTOR ---</span>
  57 |     | <span class='neutral'> *</span>
  58 |     | <span class='neutral'> * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.</span>
  59 |     | <span class='neutral'> * Unfortunately, Solidity floor division always reaches 0, sooner or later.</span>
  60 |     | <span class='neutral'> *</span>
  61 |     | <span class='neutral'> * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P</span>
  62 |     | <span class='neutral'> * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn&#39;t been emptied: this would break deposit tracking.</span>
  63 |     | <span class='neutral'> *</span>
  64 |     | <span class='neutral'> * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),</span>
  65 |     | <span class='neutral'> * we first multiply P by 1e9, and increment a currentScale factor by 1.</span>
  66 |     | <span class='neutral'> *</span>
  67 |     | <span class='neutral'> * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the</span>
  68 |     | <span class='neutral'> * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the</span>
  69 |     | <span class='neutral'> * order of 1e-9.</span>
  70 |     | <span class='neutral'> *</span>
  71 |     | <span class='neutral'> * --- EPOCHS ---</span>
  72 |     | <span class='neutral'> *</span>
  73 |     | <span class='neutral'> * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0</span>
  74 |     | <span class='neutral'> * forever, and break all future reward calculations.</span>
  75 |     | <span class='neutral'> *</span>
  76 |     | <span class='neutral'> * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.</span>
  77 |     | <span class='neutral'> *</span>
  78 |     | <span class='neutral'> * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---</span>
  79 |     | <span class='neutral'> *</span>
  80 |     | <span class='neutral'> * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.</span>
  81 |     | <span class='neutral'> *</span>
  82 |     | <span class='neutral'> * When calculating a compounded deposit, we compare the current epoch to the deposit&#39;s epoch snapshot. If the current epoch is newer,</span>
  83 |     | <span class='neutral'> * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.</span>
  84 |     | <span class='neutral'> *</span>
  85 |     | <span class='neutral'> * Otherwise, we then compare the current scale to the deposit&#39;s scale snapshot. If they&#39;re equal, the compounded deposit is given by d_t * P/P_t.</span>
  86 |     | <span class='neutral'> * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit</span>
  87 |     | <span class='neutral'> * as 0, since it is now less than 1e-9&#39;th of its initial value (e.g. a deposit of 1 billion Bold has depleted to &lt; 1 Bold).</span>
  88 |     | <span class='neutral'> *</span>
  89 |     | <span class='neutral'> *</span>
  90 |     | <span class='neutral'> *  --- TRACKING DEPOSITOR&#39;S Coll GAIN OVER SCALE CHANGES AND EPOCHS ---</span>
  91 |     | <span class='neutral'> *</span>
  92 |     | <span class='neutral'> * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.</span>
  93 |     | <span class='neutral'> *</span>
  94 |     | <span class='neutral'> * This allows us to calculate a deposit&#39;s accumulated Coll gain, during the epoch in which the deposit was non-zero and earned Coll.</span>
  95 |     | <span class='neutral'> *</span>
  96 |     | <span class='neutral'> * We calculate the depositor&#39;s accumulated Coll gain for the scale at which they made the deposit, using the Coll gain formula:</span>
  97 |     | <span class='neutral'> * e_1 = d_t * (S - S_t) / P_t</span>
  98 |     | <span class='neutral'> *</span>
  99 |     | <span class='neutral'> * and also for scale after, taking care to divide the latter by a factor of 1e9:</span>
 100 |     | <span class='neutral'> * e_2 = d_t * S / (P_t * 1e9)</span>
 101 |     | <span class='neutral'> *</span>
 102 |     | <span class='neutral'> * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.</span>
 103 |     | <span class='neutral'> * The deposit therefore was present for reward events from the beginning of that second scale.</span>
 104 |     | <span class='neutral'> *</span>
 105 |     | <span class='neutral'> *        S_i-S_t + S_{i+1}</span>
 106 |     | <span class='neutral'> *      .&lt;--------.------------&gt;</span>
 107 |     | <span class='neutral'> *      .         .</span>
 108 |     | <span class='neutral'> *      . S_i     .   S_{i+1}</span>
 109 |     | <span class='neutral'> *   &lt;--.--------&gt;.&lt;-----------&gt;</span>
 110 |     | <span class='neutral'> *   S_t.         .</span>
 111 |     | <span class='neutral'> *   &lt;-&gt;.         .</span>
 112 |     | <span class='neutral'> *      t         .</span>
 113 |     | <span class='neutral'> *  |---+---------|-------------|-----...</span>
 114 |     | <span class='neutral'> *         i            i+1</span>
 115 |     | <span class='neutral'> *</span>
 116 |     | <span class='neutral'> * The sum of (e_1 + e_2) captures the depositor&#39;s total accumulated Coll gain, handling the case where their</span>
 117 |     | <span class='neutral'> * deposit spanned one scale change. We only care about gains across one scale change, since the compounded</span>
 118 |     | <span class='neutral'> * deposit is defined as being 0 once it has spanned more than one scale change.</span>
 119 |     | <span class='neutral'> *</span>
 120 |     | <span class='neutral'> *</span>
 121 |     | <span class='neutral'> * --- UPDATING P WHEN A LIQUIDATION OCCURS ---</span>
 122 |     | <span class='neutral'> *</span>
 123 |     | <span class='neutral'> * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Coll gain derivations:</span>
 124 |     | <span class='neutral'> * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf</span>
 125 |     | <span class='neutral'> *</span>
 126 |     | <span class='neutral'> *</span>
 127 |     | <span class='neutral'> */</span>
 128 | *   | <span class='executed'>contract StabilityPool is LiquityBase, IStabilityPool, IStabilityPoolEvents {</span>
 129 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>    string public constant NAME = &quot;StabilityPool&quot;;</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>    IERC20 public immutable collToken;</span>
 134 |     | <span class='unexecuted'>    ITroveManager public immutable troveManager;</span>
 135 |     | <span class='unexecuted'>    IBoldToken public immutable boldToken;</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    uint256 internal collBalance; // deposited coll tracker</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    // Tracker for Bold held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.</span>
 140 |     | <span class='neutral'>    uint256 internal totalBoldDeposits;</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    // Total remaining Bold yield gains (from Trove interest mints) held by SP, and not yet paid out to depositors</span>
 143 |     | <span class='neutral'>    // From the contract&#39;s perspective, this is a write-only variable.</span>
 144 |     | <span class='neutral'>    uint256 internal yieldGainsOwed;</span>
 145 |     | <span class='neutral'>    // Total remaining Bold yield gains (from Trove interest mints) held by SP, not yet paid out to depositors,</span>
 146 |     | <span class='neutral'>    // and not accounted for because they were received when the total deposits were too small</span>
 147 |     | <span class='neutral'>    uint256 internal yieldGainsPending;</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    // --- Data structures ---</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    struct Deposit {</span>
 152 |     | <span class='neutral'>        uint256 initialValue;</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    struct Snapshots {</span>
 156 |     | <span class='neutral'>        uint256 S; // Coll reward sum liqs</span>
 157 |     | <span class='neutral'>        uint256 P;</span>
 158 |     | <span class='neutral'>        uint256 B; // Bold reward sum from minted interest</span>
 159 |     | <span class='neutral'>        uint128 scale;</span>
 160 |     | <span class='neutral'>        uint128 epoch;</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>    mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct</span>
 164 |     | <span class='unexecuted'>    mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct</span>
 165 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public stashedColl;</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /*  Product &#39;P&#39;: Running product by which to multiply an initial deposit, in order to find the current compounded deposit,</span>
 168 |     | <span class='neutral'>    * after a series of liquidations have occurred, each of which cancel some Bold debt with the deposit.</span>
 169 |     | <span class='neutral'>    *</span>
 170 |     | <span class='neutral'>    * During its lifetime, a deposit&#39;s value evolves from d_t to d_t * P / P_t , where P_t</span>
 171 |     | <span class='neutral'>    * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.</span>
 172 |     | <span class='neutral'>    */</span>
 173 | *   | <span class='executed'>    uint256 public P = DECIMAL_PRECISION;</span>
 174 |     | <span class='neutral'></span>
 175 | *   | <span class='executed'>    uint256 public constant SCALE_FACTOR = 1e9;</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1</span>
 178 |     | <span class='unexecuted'>    uint128 public currentScale;</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    // With each offset that fully empties the Pool, the epoch is incremented by 1</span>
 181 |     | <span class='unexecuted'>    uint128 public currentEpoch;</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /* Coll Gain sum &#39;S&#39;: During its lifetime, each deposit d_t earns an Coll gain of ( d_t * [S - S_t] )/P_t, where S_t</span>
 184 |     | <span class='neutral'>    * is the depositor&#39;s snapshot of S taken at the time t when the deposit was made.</span>
 185 |     | <span class='neutral'>    *</span>
 186 |     | <span class='neutral'>    * The &#39;S&#39; sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):</span>
 187 |     | <span class='neutral'>    *</span>
 188 |     | <span class='neutral'>    * - The inner mapping records the sum S at different scales</span>
 189 |     | <span class='neutral'>    * - The outer mapping records the (scale =&gt; sum) mappings, for different epochs.</span>
 190 |     | <span class='neutral'>    */</span>
 191 |     | <span class='unexecuted'>    mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToS;</span>
 192 |     | <span class='unexecuted'>    mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToB;</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    // Error trackers for the error correction in the offset calculation</span>
 195 |     | <span class='unexecuted'>    uint256 public lastCollError_Offset;</span>
 196 |     | <span class='unexecuted'>    uint256 public lastBoldLossErrorByP_Offset;</span>
 197 |     | <span class='unexecuted'>    uint256 public lastBoldLossError_TotalDeposits;</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>    // Error tracker fror the error correction in the BOLD reward calculation</span>
 200 |     | <span class='unexecuted'>    uint256 public lastYieldError;</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    // --- Events ---</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>    event TroveManagerAddressChanged(address _newTroveManagerAddress);</span>
 205 |     | <span class='neutral'>    event BoldTokenAddressChanged(address _newBoldTokenAddress);</span>
 206 |     | <span class='neutral'></span>
 207 | *   | <span class='executed'>    constructor(IAddressesRegistry _addressesRegistry) LiquityBase(_addressesRegistry) {</span>
 208 | *   | <span class='executed'>        collToken = _addressesRegistry.collToken();</span>
 209 | *   | <span class='executed'>        troveManager = _addressesRegistry.troveManager();</span>
 210 | *   | <span class='executed'>        boldToken = _addressesRegistry.boldToken();</span>
 211 |     | <span class='neutral'></span>
 212 | *   | <span class='executed'>        emit TroveManagerAddressChanged(address(troveManager));</span>
 213 | *   | <span class='executed'>        emit BoldTokenAddressChanged(address(boldToken));</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    // --- Getters for public variables. Required by IPool interface ---</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='unexecuted'>    function getCollBalance() external view override returns (uint256) {</span>
 219 |     | <span class='unexecuted'>        return collBalance;</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 | *   | <span class='executed'>    function getTotalBoldDeposits() external view override returns (uint256) {</span>
 223 | *   | <span class='executed'>        return totalBoldDeposits;</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 | *   | <span class='executed'>    function getYieldGainsOwed() external view override returns (uint256) {</span>
 227 |     | <span class='unexecuted'>        return yieldGainsOwed;</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='unexecuted'>    function getYieldGainsPending() external view override returns (uint256) {</span>
 231 |     | <span class='unexecuted'>        return yieldGainsPending;</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    // --- External Depositor Functions ---</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>    /*  provideToSP():</span>
 237 |     | <span class='neutral'>    * - Calculates depositor&#39;s Coll gain</span>
 238 |     | <span class='neutral'>    * - Calculates the compounded deposit</span>
 239 |     | <span class='neutral'>    * - Increases deposit, and takes new snapshots of accumulators P and S</span>
 240 |     | <span class='neutral'>    * - Sends depositor&#39;s accumulated Coll gains to depositor</span>
 241 |     | <span class='neutral'>    */</span>
 242 | *   | <span class='executed'>    function provideToSP(uint256 _topUp, bool _doClaim) external override {</span>
 243 | *   | <span class='executed'>        _requireNonZeroAmount(_topUp);</span>
 244 |     | <span class='neutral'></span>
 245 | *   | <span class='executed'>        activePool.mintAggInterest();</span>
 246 |     | <span class='neutral'></span>
 247 | *   | <span class='executed'>        uint256 initialDeposit = deposits[msg.sender].initialValue;</span>
 248 |     | <span class='neutral'></span>
 249 | *   | <span class='executed'>        uint256 currentCollGain = getDepositorCollGain(msg.sender);</span>
 250 | *   | <span class='executed'>        uint256 currentYieldGain = getDepositorYieldGain(msg.sender);</span>
 251 | *   | <span class='executed'>        uint256 compoundedBoldDeposit = getCompoundedBoldDeposit(msg.sender);</span>
 252 | *   | <span class='executed'>        (uint256 keptYieldGain, uint256 yieldGainToSend) = _getYieldToKeepOrSend(currentYieldGain, _doClaim);</span>
 253 | *   | <span class='executed'>        uint256 newDeposit = compoundedBoldDeposit + _topUp + keptYieldGain;</span>
 254 | *   | <span class='executed'>        (uint256 newStashedColl, uint256 collToSend) =</span>
 255 | *   | <span class='executed'>            _getNewStashedCollAndCollToSend(msg.sender, currentCollGain, _doClaim);</span>
 256 |     | <span class='neutral'></span>
 257 | *   | <span class='executed'>        emit DepositOperation(</span>
 258 | *   | <span class='executed'>            msg.sender,</span>
 259 | *   | <span class='executed'>            Operation.provideToSP,</span>
 260 | *   | <span class='executed'>            initialDeposit - compoundedBoldDeposit,</span>
 261 | *   | <span class='executed'>            int256(_topUp),</span>
 262 | *   | <span class='executed'>            currentYieldGain,</span>
 263 | *   | <span class='executed'>            yieldGainToSend,</span>
 264 | *   | <span class='executed'>            currentCollGain,</span>
 265 | *   | <span class='executed'>            collToSend</span>
 266 |     | <span class='neutral'>        );</span>
 267 |     | <span class='neutral'></span>
 268 | *   | <span class='executed'>        _updateDepositAndSnapshots(msg.sender, newDeposit, newStashedColl);</span>
 269 | *   | <span class='executed'>        boldToken.sendToPool(msg.sender, address(this), _topUp);</span>
 270 | *   | <span class='executed'>        _updateTotalBoldDeposits(_topUp + keptYieldGain, 0);</span>
 271 | *   | <span class='executed'>        _decreaseYieldGainsOwed(currentYieldGain);</span>
 272 | *   | <span class='executed'>        _sendBoldtoDepositor(msg.sender, yieldGainToSend);</span>
 273 | *   | <span class='executed'>        _sendCollGainToDepositor(collToSend);</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='neutral'>        // If there were pending yields and with the new deposit we are reaching the threshold, let’s move the yield to owed</span>
 276 | *   | <span class='executed'>        _updateYieldRewardsSum(0);</span>
 277 |     | <span class='neutral'>    }</span>
 278 |     | <span class='neutral'></span>
 279 | *   | <span class='executed'>    function _getYieldToKeepOrSend(uint256 _currentYieldGain, bool _doClaim) internal pure returns (uint256, uint256) {</span>
 280 | *   | <span class='executed'>        uint256 yieldToKeep;</span>
 281 | *   | <span class='executed'>        uint256 yieldToSend;</span>
 282 |     | <span class='neutral'></span>
 283 | *   | <span class='executed'>        if (_doClaim) {</span>
 284 | *   | <span class='executed'>            yieldToKeep = 0;</span>
 285 | *   | <span class='executed'>            yieldToSend = _currentYieldGain;</span>
 286 |     | <span class='neutral'>        } else {</span>
 287 | *   | <span class='executed'>            yieldToKeep = _currentYieldGain;</span>
 288 | *   | <span class='executed'>            yieldToSend = 0;</span>
 289 |     | <span class='neutral'>        }</span>
 290 |     | <span class='neutral'></span>
 291 | *   | <span class='executed'>        return (yieldToKeep, yieldToSend);</span>
 292 |     | <span class='neutral'>    }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>    /*  withdrawFromSP():</span>
 295 |     | <span class='neutral'>    * - Calculates depositor&#39;s Coll gain</span>
 296 |     | <span class='neutral'>    * - Calculates the compounded deposit</span>
 297 |     | <span class='neutral'>    * - Sends the requested BOLD withdrawal to depositor</span>
 298 |     | <span class='neutral'>    * - (If _amount &gt; userDeposit, the user withdraws all of their compounded deposit)</span>
 299 |     | <span class='neutral'>    * - Decreases deposit by withdrawn amount and takes new snapshots of accumulators P and S</span>
 300 |     | <span class='neutral'>    */</span>
 301 | *   | <span class='executed'>    function withdrawFromSP(uint256 _amount, bool _doClaim) external override {</span>
 302 | *   | <span class='executed'>        uint256 initialDeposit = deposits[msg.sender].initialValue;</span>
 303 | *   | <span class='executed'>        _requireUserHasDeposit(initialDeposit);</span>
 304 |     | <span class='neutral'></span>
 305 | *   | <span class='executed'>        activePool.mintAggInterest();</span>
 306 |     | <span class='neutral'></span>
 307 | *   | <span class='executed'>        uint256 currentCollGain = getDepositorCollGain(msg.sender);</span>
 308 | *   | <span class='executed'>        uint256 currentYieldGain = getDepositorYieldGain(msg.sender);</span>
 309 | *   | <span class='executed'>        uint256 compoundedBoldDeposit = getCompoundedBoldDeposit(msg.sender);</span>
 310 | *   | <span class='executed'>        uint256 boldToWithdraw = LiquityMath._min(_amount, compoundedBoldDeposit);</span>
 311 | *   | <span class='executed'>        (uint256 keptYieldGain, uint256 yieldGainToSend) = _getYieldToKeepOrSend(currentYieldGain, _doClaim);</span>
 312 | *   | <span class='executed'>        uint256 newDeposit = compoundedBoldDeposit - boldToWithdraw + keptYieldGain;</span>
 313 | *   | <span class='executed'>        (uint256 newStashedColl, uint256 collToSend) =</span>
 314 | *   | <span class='executed'>            _getNewStashedCollAndCollToSend(msg.sender, currentCollGain, _doClaim);</span>
 315 |     | <span class='neutral'></span>
 316 | *   | <span class='executed'>        emit DepositOperation(</span>
 317 | *   | <span class='executed'>            msg.sender,</span>
 318 | *   | <span class='executed'>            Operation.withdrawFromSP,</span>
 319 | *   | <span class='executed'>            initialDeposit - compoundedBoldDeposit,</span>
 320 | *   | <span class='executed'>            -int256(boldToWithdraw),</span>
 321 | *   | <span class='executed'>            currentYieldGain,</span>
 322 | *   | <span class='executed'>            yieldGainToSend,</span>
 323 | *   | <span class='executed'>            currentCollGain,</span>
 324 | *   | <span class='executed'>            collToSend</span>
 325 |     | <span class='neutral'>        );</span>
 326 |     | <span class='neutral'></span>
 327 | *   | <span class='executed'>        _updateDepositAndSnapshots(msg.sender, newDeposit, newStashedColl);</span>
 328 | *   | <span class='executed'>        _decreaseYieldGainsOwed(currentYieldGain);</span>
 329 | *   | <span class='executed'>        _updateTotalBoldDeposits(keptYieldGain, boldToWithdraw);</span>
 330 | *   | <span class='executed'>        _sendBoldtoDepositor(msg.sender, boldToWithdraw + yieldGainToSend);</span>
 331 | *   | <span class='executed'>        _sendCollGainToDepositor(collToSend);</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='neutral'>        // If there were pending yields and with the new deposit we are reaching the threshold, let’s move the yield to owed</span>
 334 |     | <span class='neutral'>        // (it may happen if the user is not claiming)</span>
 335 | *   | <span class='executed'>        _updateYieldRewardsSum(0);</span>
 336 |     | <span class='neutral'>    }</span>
 337 |     | <span class='neutral'></span>
 338 | *   | <span class='executed'>    function _getNewStashedCollAndCollToSend(address _depositor, uint256 _currentCollGain, bool _doClaim)</span>
 339 |     | <span class='neutral'>        internal</span>
 340 |     | <span class='neutral'>        view</span>
 341 | *   | <span class='executed'>        returns (uint256 newStashedColl, uint256 collToSend)</span>
 342 |     | <span class='neutral'>    {</span>
 343 | *   | <span class='executed'>        if (_doClaim) {</span>
 344 | *   | <span class='executed'>            newStashedColl = 0;</span>
 345 | *   | <span class='executed'>            collToSend = stashedColl[_depositor] + _currentCollGain;</span>
 346 |     | <span class='neutral'>        } else {</span>
 347 | *   | <span class='executed'>            newStashedColl = stashedColl[_depositor] + _currentCollGain;</span>
 348 | *   | <span class='executed'>            collToSend = 0;</span>
 349 |     | <span class='neutral'>        }</span>
 350 |     | <span class='neutral'>    }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>    // This function is only needed in the case a user has no deposit but still has remaining stashed Coll gains.</span>
 353 | *   | <span class='executed'>    function claimAllCollGains() external {</span>
 354 | *   | <span class='executed'>        _requireUserHasNoDeposit(msg.sender);</span>
 355 |     | <span class='neutral'></span>
 356 | *   | <span class='executed'>        activePool.mintAggInterest();</span>
 357 |     | <span class='neutral'></span>
 358 | *   | <span class='executed'>        uint256 collToSend = stashedColl[msg.sender];</span>
 359 | *   | <span class='executed'>        _requireNonZeroAmount(collToSend);</span>
 360 |     | <span class='unexecuted'>        stashedColl[msg.sender] = 0;</span>
 361 |     | <span class='neutral'></span>
 362 |     | <span class='unexecuted'>        emit DepositOperation(msg.sender, Operation.claimAllCollGains, 0, 0, 0, 0, 0, collToSend);</span>
 363 |     | <span class='unexecuted'>        emit DepositUpdated(msg.sender, 0, 0, 0, 0, 0, 0, 0);</span>
 364 |     | <span class='neutral'></span>
 365 | *   | <span class='executed'>        _sendCollGainToDepositor(collToSend);</span>
 366 |     | <span class='neutral'>    }</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='neutral'>    // --- BOLD reward functions ---</span>
 369 |     | <span class='neutral'></span>
 370 | *   | <span class='executed'>    function triggerBoldRewards(uint256 _boldYield) external {</span>
 371 | *   | <span class='executed'>        _requireCallerIsActivePool();</span>
 372 | *   | <span class='executed'>        assert(_boldYield &gt; 0); // TODO: remove before deploying</span>
 373 |     | <span class='neutral'></span>
 374 | *   | <span class='executed'>        _updateYieldRewardsSum(_boldYield);</span>
 375 |     | <span class='neutral'>    }</span>
 376 |     | <span class='neutral'></span>
 377 | *   | <span class='executed'>    function _updateYieldRewardsSum(uint256 _newYield) internal {</span>
 378 | *   | <span class='executed'>        uint256 accumulatedYieldGains = yieldGainsPending + _newYield;</span>
 379 | *   | <span class='executed'>        if (accumulatedYieldGains == 0) return;</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>        // When total deposits is very small, B is not updated. In this case, the BOLD issued is hold</span>
 382 |     | <span class='neutral'>        // until the total deposits reach 1 BOLD (remains in the balance of the SP).</span>
 383 | *   | <span class='executed'>        uint256 totalBoldDepositsCached = totalBoldDeposits; // cached to save an SLOAD</span>
 384 | *   | <span class='executed'>        if (totalBoldDepositsCached &lt; DECIMAL_PRECISION) {</span>
 385 | *   | <span class='executed'>            yieldGainsPending = accumulatedYieldGains;</span>
 386 |     | <span class='neutral'>            return;</span>
 387 |     | <span class='neutral'>        }</span>
 388 |     | <span class='neutral'></span>
 389 | *   | <span class='executed'>        yieldGainsOwed += accumulatedYieldGains;</span>
 390 | *   | <span class='executed'>        yieldGainsPending = 0;</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='neutral'>        /*</span>
 393 |     | <span class='neutral'>         * Calculate the BOLD-per-unit staked.  Division uses a &quot;feedback&quot; error correction, to keep the</span>
 394 |     | <span class='neutral'>         * cumulative error low in the running total B:</span>
 395 |     | <span class='neutral'>         *</span>
 396 |     | <span class='neutral'>         * 1) Form a numerator which compensates for the floor division error that occurred the last time this</span>
 397 |     | <span class='neutral'>         * function was called.</span>
 398 |     | <span class='neutral'>         * 2) Calculate &quot;per-unit-staked&quot; ratio.</span>
 399 |     | <span class='neutral'>         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.</span>
 400 |     | <span class='neutral'>         * 4) Store this error for use in the next correction when this function is called.</span>
 401 |     | <span class='neutral'>         * 5) Note: static analysis tools complain about this &quot;division before multiplication&quot;, however, it is intended.</span>
 402 |     | <span class='neutral'>         */</span>
 403 | *   | <span class='executed'>        uint256 yieldNumerator = accumulatedYieldGains * DECIMAL_PRECISION + lastYieldError;</span>
 404 |     | <span class='neutral'></span>
 405 | *   | <span class='executed'>        uint256 yieldPerUnitStaked = yieldNumerator / totalBoldDepositsCached;</span>
 406 | *   | <span class='executed'>        lastYieldError = yieldNumerator - yieldPerUnitStaked * totalBoldDepositsCached;</span>
 407 |     | <span class='neutral'></span>
 408 | *   | <span class='executed'>        uint256 marginalYieldGain = yieldPerUnitStaked * (P - 1);</span>
 409 | *   | <span class='executed'>        epochToScaleToB[currentEpoch][currentScale] = epochToScaleToB[currentEpoch][currentScale] + marginalYieldGain;</span>
 410 |     | <span class='neutral'></span>
 411 | *   | <span class='executed'>        emit B_Updated(epochToScaleToB[currentEpoch][currentScale], currentEpoch, currentScale);</span>
 412 |     | <span class='neutral'>    }</span>
 413 |     | <span class='neutral'></span>
 414 |     | <span class='neutral'>    // --- Liquidation functions ---</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>    /*</span>
 417 |     | <span class='neutral'>    * Cancels out the specified debt against the Bold contained in the Stability Pool (as far as possible)</span>
 418 |     | <span class='neutral'>    * and transfers the Trove&#39;s Coll collateral from ActivePool to StabilityPool.</span>
 419 |     | <span class='neutral'>    * Only called by liquidation functions in the TroveManager.</span>
 420 |     | <span class='neutral'>    */</span>
 421 | *   | <span class='executed'>    function offset(uint256 _debtToOffset, uint256 _collToAdd) external override {</span>
 422 |     | <span class='unexecuted'>        _requireCallerIsTroveManager();</span>
 423 |     | <span class='unexecuted'>        uint256 totalBold = totalBoldDeposits; // cached to save an SLOAD</span>
 424 |     | <span class='unexecuted'>        if (totalBold == 0 || _debtToOffset == 0) return;</span>
 425 |     | <span class='neutral'></span>
 426 |     | <span class='unexecuted'>        _updateCollRewardSumAndProduct(_collToAdd, _debtToOffset, totalBold); // updates S and P</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='unexecuted'>        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);</span>
 429 |     | <span class='neutral'>    }</span>
 430 |     | <span class='neutral'></span>
 431 |     | <span class='neutral'>    // --- Offset helper functions ---</span>
 432 |     | <span class='neutral'></span>
 433 |     | <span class='unexecuted'>    function _computeCollRewardsPerUnitStaked(uint256 _collToAdd, uint256 _debtToOffset, uint256 _totalBoldDeposits)</span>
 434 |     | <span class='neutral'>        internal</span>
 435 |     | <span class='unexecuted'>        returns (uint256 collGainPerUnitStaked, uint256 boldLossPerUnitStaked, uint256 newLastBoldLossErrorOffset)</span>
 436 |     | <span class='neutral'>    {</span>
 437 |     | <span class='neutral'>        /*</span>
 438 |     | <span class='neutral'>        * Compute the Bold and Coll rewards. Uses a &quot;feedback&quot; error correction, to keep</span>
 439 |     | <span class='neutral'>        * the cumulative error in the P and S state variables low:</span>
 440 |     | <span class='neutral'>        *</span>
 441 |     | <span class='neutral'>        * 1) Form numerators which compensate for the floor division errors that occurred the last time this</span>
 442 |     | <span class='neutral'>        * function was called.</span>
 443 |     | <span class='neutral'>        * 2) Calculate &quot;per-unit-staked&quot; ratios.</span>
 444 |     | <span class='neutral'>        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.</span>
 445 |     | <span class='neutral'>        * 4) Store these errors for use in the next correction when this function is called.</span>
 446 |     | <span class='neutral'>        * 5) Note: static analysis tools complain about this &quot;division before multiplication&quot;, however, it is intended.</span>
 447 |     | <span class='neutral'>        */</span>
 448 |     | <span class='unexecuted'>        uint256 collNumerator = _collToAdd * DECIMAL_PRECISION + lastCollError_Offset;</span>
 449 |     | <span class='neutral'></span>
 450 |     | <span class='unexecuted'>        assert(_debtToOffset &lt;= _totalBoldDeposits);</span>
 451 |     | <span class='unexecuted'>        if (_debtToOffset == _totalBoldDeposits) {</span>
 452 |     | <span class='unexecuted'>            boldLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit</span>
 453 |     | <span class='unexecuted'>            newLastBoldLossErrorOffset = 0;</span>
 454 |     | <span class='unexecuted'>        } else {</span>
 455 |     | <span class='unexecuted'>            uint256 boldLossNumerator = _debtToOffset * DECIMAL_PRECISION;</span>
 456 |     | <span class='neutral'>            /*</span>
 457 |     | <span class='neutral'>            * Add 1 to make error in quotient positive. We want &quot;slightly too much&quot; Bold loss,</span>
 458 |     | <span class='neutral'>            * which ensures the error in any given compoundedBoldDeposit favors the Stability Pool.</span>
 459 |     | <span class='neutral'>            */</span>
 460 |     | <span class='unexecuted'>            boldLossPerUnitStaked = boldLossNumerator / _totalBoldDeposits + 1;</span>
 461 |     | <span class='unexecuted'>            newLastBoldLossErrorOffset = boldLossPerUnitStaked * _totalBoldDeposits - boldLossNumerator;</span>
 462 |     | <span class='neutral'>        }</span>
 463 |     | <span class='neutral'></span>
 464 |     | <span class='unexecuted'>        collGainPerUnitStaked = collNumerator / _totalBoldDeposits;</span>
 465 |     | <span class='unexecuted'>        lastCollError_Offset = collNumerator - collGainPerUnitStaked * _totalBoldDeposits;</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='neutral'>        return (collGainPerUnitStaked, boldLossPerUnitStaked, newLastBoldLossErrorOffset);</span>
 468 |     | <span class='neutral'>    }</span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='neutral'>    // Update the Stability Pool reward sum S and product P</span>
 471 |     | <span class='unexecuted'>    function _updateCollRewardSumAndProduct(uint256 _collToAdd, uint256 _debtToOffset, uint256 _totalBoldDeposits)</span>
 472 |     | <span class='neutral'>        internal</span>
 473 |     | <span class='unexecuted'>    {</span>
 474 |     | <span class='unexecuted'>        (uint256 collGainPerUnitStaked, uint256 boldLossPerUnitStaked, uint256 newLastBoldLossErrorOffset) =</span>
 475 |     | <span class='unexecuted'>            _computeCollRewardsPerUnitStaked(_collToAdd, _debtToOffset, _totalBoldDeposits);</span>
 476 |     | <span class='neutral'></span>
 477 |     | <span class='unexecuted'>        uint256 currentP = P;</span>
 478 |     | <span class='neutral'>        uint256 newP;</span>
 479 |     | <span class='neutral'></span>
 480 |     | <span class='unexecuted'>        assert(boldLossPerUnitStaked &lt;= DECIMAL_PRECISION);</span>
 481 |     | <span class='neutral'>        /*</span>
 482 |     | <span class='neutral'>        * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool Bold in the liquidation.</span>
 483 |     | <span class='neutral'>        * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - boldLossPerUnitStaked)</span>
 484 |     | <span class='neutral'>        */</span>
 485 |     | <span class='unexecuted'>        uint256 newProductFactor = uint256(DECIMAL_PRECISION) - boldLossPerUnitStaked;</span>
 486 |     | <span class='neutral'></span>
 487 |     | <span class='unexecuted'>        uint128 currentScaleCached = currentScale;</span>
 488 |     | <span class='unexecuted'>        uint128 currentEpochCached = currentEpoch;</span>
 489 |     | <span class='unexecuted'>        uint256 currentS = epochToScaleToS[currentEpochCached][currentScaleCached];</span>
 490 |     | <span class='neutral'></span>
 491 |     | <span class='neutral'>        /*</span>
 492 |     | <span class='neutral'>        * Calculate the new S first, before we update P.</span>
 493 |     | <span class='neutral'>        * The Coll gain for any given depositor from a liquidation depends on the value of their deposit</span>
 494 |     | <span class='neutral'>        * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.</span>
 495 |     | <span class='neutral'>        *</span>
 496 |     | <span class='neutral'>        * Since S corresponds to Coll gain, and P to deposit loss, we update S first.</span>
 497 |     | <span class='neutral'>        */</span>
 498 |     | <span class='unexecuted'>        uint256 marginalCollGain = collGainPerUnitStaked * (currentP - 1);</span>
 499 |     | <span class='unexecuted'>        uint256 newS = currentS + marginalCollGain;</span>
 500 |     | <span class='unexecuted'>        epochToScaleToS[currentEpochCached][currentScaleCached] = newS;</span>
 501 |     | <span class='unexecuted'>        emit S_Updated(newS, currentEpochCached, currentScaleCached);</span>
 502 |     | <span class='neutral'></span>
 503 |     | <span class='neutral'>        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P</span>
 504 |     | <span class='unexecuted'>        if (newProductFactor == 0) {</span>
 505 |     | <span class='unexecuted'>            currentEpoch = currentEpochCached + 1;</span>
 506 |     | <span class='unexecuted'>            emit EpochUpdated(currentEpoch);</span>
 507 |     | <span class='unexecuted'>            currentScale = 0;</span>
 508 |     | <span class='unexecuted'>            emit ScaleUpdated(currentScale);</span>
 509 |     | <span class='unexecuted'>            newP = DECIMAL_PRECISION;</span>
 510 |     | <span class='unexecuted'>        } else {</span>
 511 |     | <span class='unexecuted'>            uint256 lastBoldLossErrorByP_Offset_Cached = lastBoldLossErrorByP_Offset;</span>
 512 |     | <span class='unexecuted'>            uint256 lastBoldLossError_TotalDeposits_Cached = lastBoldLossError_TotalDeposits;</span>
 513 |     | <span class='unexecuted'>            newP = _getNewPByScale(</span>
 514 |     | <span class='unexecuted'>                currentP,</span>
 515 |     | <span class='unexecuted'>                newProductFactor,</span>
 516 |     | <span class='neutral'>                lastBoldLossErrorByP_Offset_Cached,</span>
 517 |     | <span class='neutral'>                lastBoldLossError_TotalDeposits_Cached,</span>
 518 |     | <span class='unexecuted'>                1</span>
 519 |     | <span class='neutral'>            );</span>
 520 |     | <span class='neutral'></span>
 521 |     | <span class='neutral'>            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale</span>
 522 |     | <span class='unexecuted'>            if (newP &lt; SCALE_FACTOR) {</span>
 523 |     | <span class='unexecuted'>                newP = _getNewPByScale(</span>
 524 |     | <span class='unexecuted'>                    currentP,</span>
 525 |     | <span class='unexecuted'>                    newProductFactor,</span>
 526 |     | <span class='unexecuted'>                    lastBoldLossErrorByP_Offset_Cached,</span>
 527 |     | <span class='unexecuted'>                    lastBoldLossError_TotalDeposits_Cached,</span>
 528 |     | <span class='neutral'>                    SCALE_FACTOR</span>
 529 |     | <span class='neutral'>                );</span>
 530 |     | <span class='unexecuted'>                currentScale = currentScaleCached + 1;</span>
 531 |     | <span class='neutral'></span>
 532 |     | <span class='neutral'>                // Increment the scale again if it&#39;s still below the boundary. This ensures the invariant P &gt;= 1e9 holds and</span>
 533 |     | <span class='neutral'>                // addresses this issue from Liquity v1: https://github.com/liquity/dev/security/advisories/GHSA-m9f3-hrx8-x2g3</span>
 534 |     | <span class='unexecuted'>                if (newP &lt; SCALE_FACTOR) {</span>
 535 |     | <span class='unexecuted'>                    newP = _getNewPByScale(</span>
 536 |     | <span class='unexecuted'>                        currentP,</span>
 537 |     | <span class='unexecuted'>                        newProductFactor,</span>
 538 |     | <span class='unexecuted'>                        lastBoldLossErrorByP_Offset_Cached,</span>
 539 |     | <span class='unexecuted'>                        lastBoldLossError_TotalDeposits_Cached,</span>
 540 |     | <span class='unexecuted'>                        SCALE_FACTOR * SCALE_FACTOR</span>
 541 |     | <span class='neutral'>                    );</span>
 542 |     | <span class='unexecuted'>                    currentScale = currentScaleCached + 2;</span>
 543 |     | <span class='neutral'>                }</span>
 544 |     | <span class='neutral'>            }</span>
 545 |     | <span class='unexecuted'>            emit ScaleUpdated(currentScale);</span>
 546 |     | <span class='neutral'>            // If there&#39;s no scale change and no pool-emptying, just do a standard multiplication</span>
 547 |     | <span class='neutral'>        }</span>
 548 |     | <span class='unexecuted'>        lastBoldLossErrorByP_Offset = currentP * newLastBoldLossErrorOffset;</span>
 549 |     | <span class='unexecuted'>        lastBoldLossError_TotalDeposits = _totalBoldDeposits;</span>
 550 |     | <span class='neutral'></span>
 551 |     | <span class='unexecuted'>        assert(newP &gt; 0);</span>
 552 |     | <span class='unexecuted'>        P = newP;</span>
 553 |     | <span class='neutral'></span>
 554 |     | <span class='unexecuted'>        emit P_Updated(newP);</span>
 555 |     | <span class='neutral'>    }</span>
 556 |     | <span class='neutral'></span>
 557 |     | <span class='unexecuted'>    function _getNewPByScale(</span>
 558 |     | <span class='neutral'>        uint256 _currentP,</span>
 559 |     | <span class='neutral'>        uint256 _newProductFactor,</span>
 560 |     | <span class='neutral'>        uint256 _lastBoldLossErrorByP_Offset,</span>
 561 |     | <span class='neutral'>        uint256 _lastBoldLossError_TotalDeposits,</span>
 562 |     | <span class='neutral'>        uint256 _scale</span>
 563 |     | <span class='unexecuted'>    ) internal pure returns (uint256) {</span>
 564 |     | <span class='neutral'>        uint256 errorFactor;</span>
 565 |     | <span class='unexecuted'>        if (_lastBoldLossErrorByP_Offset &gt; 0) {</span>
 566 |     | <span class='unexecuted'>            errorFactor = _lastBoldLossErrorByP_Offset * _newProductFactor * _scale / _lastBoldLossError_TotalDeposits</span>
 567 |     | <span class='neutral'>                / DECIMAL_PRECISION;</span>
 568 |     | <span class='neutral'>        }</span>
 569 |     | <span class='unexecuted'>        return (_currentP * _newProductFactor * _scale + errorFactor) / DECIMAL_PRECISION;</span>
 570 |     | <span class='neutral'>    }</span>
 571 |     | <span class='neutral'></span>
 572 | *   | <span class='executed'>    function _moveOffsetCollAndDebt(uint256 _collToAdd, uint256 _debtToOffset) internal {</span>
 573 |     | <span class='neutral'>        // Cancel the liquidated Bold debt with the Bold in the stability pool</span>
 574 |     | <span class='unexecuted'>        _updateTotalBoldDeposits(0, _debtToOffset);</span>
 575 |     | <span class='neutral'></span>
 576 |     | <span class='neutral'>        // Burn the debt that was successfully offset</span>
 577 |     | <span class='unexecuted'>        boldToken.burn(address(this), _debtToOffset);</span>
 578 |     | <span class='neutral'></span>
 579 |     | <span class='neutral'>        // Update internal Coll balance tracker</span>
 580 |     | <span class='unexecuted'>        uint256 newCollBalance = collBalance + _collToAdd;</span>
 581 |     | <span class='unexecuted'>        collBalance = newCollBalance;</span>
 582 |     | <span class='neutral'></span>
 583 |     | <span class='neutral'>        // Pull Coll from Active Pool</span>
 584 |     | <span class='unexecuted'>        activePool.sendColl(address(this), _collToAdd);</span>
 585 |     | <span class='neutral'></span>
 586 | *   | <span class='executed'>        emit StabilityPoolCollBalanceUpdated(newCollBalance);</span>
 587 |     | <span class='neutral'>    }</span>
 588 |     | <span class='neutral'></span>
 589 | *   | <span class='executed'>    function _updateTotalBoldDeposits(uint256 _depositIncrease, uint256 _depositDecrease) internal {</span>
 590 | *   | <span class='executed'>        if (_depositIncrease == 0 &amp;&amp; _depositDecrease == 0) return;</span>
 591 | *   | <span class='executed'>        uint256 newTotalBoldDeposits = totalBoldDeposits + _depositIncrease - _depositDecrease;</span>
 592 | *   | <span class='executed'>        totalBoldDeposits = newTotalBoldDeposits;</span>
 593 | *   | <span class='executed'>        emit StabilityPoolBoldBalanceUpdated(newTotalBoldDeposits);</span>
 594 |     | <span class='neutral'>    }</span>
 595 |     | <span class='neutral'></span>
 596 | *   | <span class='executed'>    function _decreaseYieldGainsOwed(uint256 _amount) internal {</span>
 597 | *   | <span class='executed'>        if (_amount == 0) return;</span>
 598 | *   | <span class='executed'>        uint256 newYieldGainsOwed = yieldGainsOwed - _amount;</span>
 599 | *   | <span class='executed'>        yieldGainsOwed = newYieldGainsOwed;</span>
 600 |     | <span class='neutral'>    }</span>
 601 |     | <span class='neutral'></span>
 602 |     | <span class='neutral'>    // --- Reward calculator functions for depositor ---</span>
 603 |     | <span class='neutral'></span>
 604 |     | <span class='neutral'>    /* Calculates the Coll gain earned by the deposit since its last snapshots were taken.</span>
 605 |     | <span class='neutral'>    * Given by the formula:  E = d0 * (S - S(0))/P(0)</span>
 606 |     | <span class='neutral'>    * where S(0) and P(0) are the depositor&#39;s snapshots of the sum S and product P, respectively.</span>
 607 |     | <span class='neutral'>    * d0 is the last recorded deposit value.</span>
 608 |     | <span class='neutral'>    */</span>
 609 | *   | <span class='executed'>    function getDepositorCollGain(address _depositor) public view override returns (uint256) {</span>
 610 | *   | <span class='executed'>        uint256 initialDeposit = deposits[_depositor].initialValue;</span>
 611 |     | <span class='neutral'></span>
 612 | *   | <span class='executed'>        if (initialDeposit == 0) return 0;</span>
 613 |     | <span class='neutral'></span>
 614 | *   | <span class='executed'>        Snapshots memory snapshots = depositSnapshots[_depositor];</span>
 615 |     | <span class='neutral'></span>
 616 |     | <span class='neutral'>        /*</span>
 617 |     | <span class='neutral'>         * Grab the sum &#39;S&#39; from the epoch at which the stake was made. The Coll gain may span up to one scale change.</span>
 618 |     | <span class='neutral'>         * If it does, the second portion of the Coll gain is scaled by 1e9.</span>
 619 |     | <span class='neutral'>         * If the gain spans no scale change, the second portion will be 0.</span>
 620 |     | <span class='neutral'>         */</span>
 621 |     | <span class='neutral'>        uint128 epochSnapshot = snapshots.epoch;</span>
 622 |     | <span class='neutral'>        uint128 scaleSnapshot = snapshots.scale;</span>
 623 |     | <span class='neutral'>        uint256 S_Snapshot = snapshots.S;</span>
 624 |     | <span class='neutral'>        uint256 P_Snapshot = snapshots.P;</span>
 625 |     | <span class='neutral'></span>
 626 | *   | <span class='executed'>        uint256 firstPortion = epochToScaleToS[epochSnapshot][scaleSnapshot] - S_Snapshot;</span>
 627 | *   | <span class='executed'>        uint256 secondPortion = epochToScaleToS[epochSnapshot][scaleSnapshot + 1] / SCALE_FACTOR;</span>
 628 |     | <span class='neutral'></span>
 629 | *   | <span class='executed'>        uint256 collGain = initialDeposit * (firstPortion + secondPortion) / P_Snapshot / DECIMAL_PRECISION;</span>
 630 |     | <span class='neutral'></span>
 631 | *   | <span class='executed'>        return LiquityMath._min(collGain, collBalance);</span>
 632 |     | <span class='neutral'>    }</span>
 633 |     | <span class='neutral'></span>
 634 | *   | <span class='executed'>    function getDepositorYieldGain(address _depositor) public view override returns (uint256) {</span>
 635 | *   | <span class='executed'>        uint256 initialDeposit = deposits[_depositor].initialValue;</span>
 636 |     | <span class='neutral'></span>
 637 | *   | <span class='executed'>        if (initialDeposit == 0) return 0;</span>
 638 |     | <span class='neutral'></span>
 639 | *   | <span class='executed'>        Snapshots memory snapshots = depositSnapshots[_depositor];</span>
 640 |     | <span class='neutral'></span>
 641 |     | <span class='neutral'>        /*</span>
 642 |     | <span class='neutral'>         * Grab the sum &#39;B&#39; from the epoch at which the stake was made. The Bold gain may span up to one scale change.</span>
 643 |     | <span class='neutral'>         * If it does, the second portion of the Bold gain is scaled by 1e9.</span>
 644 |     | <span class='neutral'>         * If the gain spans no scale change, the second portion will be 0.</span>
 645 |     | <span class='neutral'>         */</span>
 646 |     | <span class='neutral'>        uint128 epochSnapshot = snapshots.epoch;</span>
 647 |     | <span class='neutral'>        uint128 scaleSnapshot = snapshots.scale;</span>
 648 |     | <span class='neutral'>        uint256 B_Snapshot = snapshots.B;</span>
 649 |     | <span class='neutral'>        uint256 P_Snapshot = snapshots.P;</span>
 650 |     | <span class='neutral'></span>
 651 | *   | <span class='executed'>        uint256 firstPortion = epochToScaleToB[epochSnapshot][scaleSnapshot] - B_Snapshot;</span>
 652 | *   | <span class='executed'>        uint256 secondPortion = epochToScaleToB[epochSnapshot][scaleSnapshot + 1] / SCALE_FACTOR;</span>
 653 |     | <span class='neutral'></span>
 654 | *   | <span class='executed'>        uint256 yieldGain = initialDeposit * (firstPortion + secondPortion) / P_Snapshot / DECIMAL_PRECISION;</span>
 655 |     | <span class='neutral'></span>
 656 | *   | <span class='executed'>        return LiquityMath._min(yieldGain, yieldGainsOwed);</span>
 657 |     | <span class='neutral'>    }</span>
 658 |     | <span class='neutral'></span>
 659 |     | <span class='unexecuted'>    function getDepositorYieldGainWithPending(address _depositor) external view override returns (uint256) {</span>
 660 |     | <span class='unexecuted'>        uint256 initialDeposit = deposits[_depositor].initialValue;</span>
 661 |     | <span class='neutral'></span>
 662 |     | <span class='unexecuted'>        if (initialDeposit == 0) return 0;</span>
 663 |     | <span class='neutral'></span>
 664 |     | <span class='unexecuted'>        Snapshots memory snapshots = depositSnapshots[_depositor];</span>
 665 |     | <span class='neutral'></span>
 666 |     | <span class='unexecuted'>        uint256 pendingSPYield = activePool.calcPendingSPYield() + yieldGainsPending;</span>
 667 |     | <span class='unexecuted'>        uint256 newYieldGainsOwed = yieldGainsOwed + (totalBoldDeposits &gt;= DECIMAL_PRECISION ? pendingSPYield : 0);</span>
 668 |     | <span class='unexecuted'>        uint256 firstPortionPending;</span>
 669 |     | <span class='unexecuted'>        uint256 secondPortionPending;</span>
 670 |     | <span class='neutral'></span>
 671 |     | <span class='unexecuted'>        if (pendingSPYield &gt; 0 &amp;&amp; snapshots.epoch == currentEpoch &amp;&amp; totalBoldDeposits &gt;= DECIMAL_PRECISION) {</span>
 672 |     | <span class='unexecuted'>            uint256 yieldNumerator = pendingSPYield * DECIMAL_PRECISION + lastYieldError;</span>
 673 |     | <span class='unexecuted'>            uint256 yieldPerUnitStaked = yieldNumerator / totalBoldDeposits;</span>
 674 |     | <span class='unexecuted'>            uint256 marginalYieldGain = yieldPerUnitStaked * (P - 1);</span>
 675 |     | <span class='neutral'></span>
 676 |     | <span class='unexecuted'>            if (currentScale == snapshots.scale) firstPortionPending = marginalYieldGain;</span>
 677 |     | <span class='unexecuted'>            else if (currentScale == snapshots.scale + 1) secondPortionPending = marginalYieldGain;</span>
 678 |     | <span class='neutral'>        }</span>
 679 |     | <span class='neutral'></span>
 680 |     | <span class='unexecuted'>        uint256 firstPortion = epochToScaleToB[snapshots.epoch][snapshots.scale] + firstPortionPending - snapshots.B;</span>
 681 |     | <span class='unexecuted'>        uint256 secondPortion =</span>
 682 |     | <span class='unexecuted'>            (epochToScaleToB[snapshots.epoch][snapshots.scale + 1] + secondPortionPending) / SCALE_FACTOR;</span>
 683 |     | <span class='neutral'></span>
 684 |     | <span class='unexecuted'>        uint256 yieldGain = initialDeposit * (firstPortion + secondPortion) / snapshots.P / DECIMAL_PRECISION;</span>
 685 |     | <span class='neutral'></span>
 686 |     | <span class='unexecuted'>        return LiquityMath._min(yieldGain, newYieldGainsOwed);</span>
 687 |     | <span class='neutral'>    }</span>
 688 |     | <span class='neutral'></span>
 689 |     | <span class='neutral'>    // --- Compounded deposit ---</span>
 690 |     | <span class='neutral'></span>
 691 |     | <span class='neutral'>    /*</span>
 692 |     | <span class='neutral'>    * Return the user&#39;s compounded deposit. Given by the formula:  d = d0 * P/P(0)</span>
 693 |     | <span class='neutral'>    * where P(0) is the depositor&#39;s snapshot of the product P, taken when they last updated their deposit.</span>
 694 |     | <span class='neutral'>    */</span>
 695 | *   | <span class='executed'>    function getCompoundedBoldDeposit(address _depositor) public view override returns (uint256) {</span>
 696 | *   | <span class='executed'>        uint256 initialDeposit = deposits[_depositor].initialValue;</span>
 697 | *   | <span class='executed'>        if (initialDeposit == 0) return 0;</span>
 698 |     | <span class='neutral'></span>
 699 | *   | <span class='executed'>        Snapshots memory snapshots = depositSnapshots[_depositor];</span>
 700 |     | <span class='neutral'></span>
 701 | *   | <span class='executed'>        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);</span>
 702 |     | <span class='neutral'>        return compoundedDeposit;</span>
 703 |     | <span class='neutral'>    }</span>
 704 |     | <span class='neutral'></span>
 705 |     | <span class='neutral'>    // Internal function, used to calculcate compounded deposits and compounded front end stakes.</span>
 706 | *   | <span class='executed'>    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots memory snapshots)</span>
 707 |     | <span class='neutral'>        internal</span>
 708 |     | <span class='neutral'>        view</span>
 709 | *   | <span class='executed'>        returns (uint256)</span>
 710 |     | <span class='neutral'>    {</span>
 711 | *   | <span class='executed'>        uint256 snapshot_P = snapshots.P;</span>
 712 | *   | <span class='executed'>        uint128 scaleSnapshot = snapshots.scale;</span>
 713 | *   | <span class='executed'>        uint128 epochSnapshot = snapshots.epoch;</span>
 714 |     | <span class='neutral'></span>
 715 |     | <span class='neutral'>        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0</span>
 716 | *   | <span class='executed'>        if (epochSnapshot &lt; currentEpoch) return 0;</span>
 717 |     | <span class='neutral'></span>
 718 | *   | <span class='executed'>        uint256 compoundedStake;</span>
 719 | *   | <span class='executed'>        uint128 scaleDiff = currentScale - scaleSnapshot;</span>
 720 |     | <span class='neutral'></span>
 721 |     | <span class='neutral'>        // To make sure rouning errors favour the system, we use P - 1 if P decreased</span>
 722 | *   | <span class='executed'>        uint256 cachedP = P;</span>
 723 | *   | <span class='executed'>        uint256 currentPToUse = cachedP != snapshot_P ? cachedP - 1 : cachedP;</span>
 724 |     | <span class='neutral'></span>
 725 |     | <span class='neutral'>        /* Compute the compounded stake. If a scale change in P was made during the stake&#39;s lifetime,</span>
 726 |     | <span class='neutral'>        * account for it. If more than one scale change was made, then the stake has decreased by a factor of</span>
 727 |     | <span class='neutral'>        * at least 1e-9 -- so return 0.</span>
 728 |     | <span class='neutral'>        */</span>
 729 | *   | <span class='executed'>        if (scaleDiff == 0) {</span>
 730 | *   | <span class='executed'>            compoundedStake = initialStake * currentPToUse / snapshot_P;</span>
 731 | *   | <span class='executed'>        } else if (scaleDiff == 1) {</span>
 732 |     | <span class='unexecuted'>            compoundedStake = initialStake * currentPToUse / snapshot_P / SCALE_FACTOR;</span>
 733 |     | <span class='neutral'>        } else {</span>
 734 |     | <span class='neutral'>            // if scaleDiff &gt;= 2</span>
 735 |     | <span class='unexecuted'>            compoundedStake = 0;</span>
 736 |     | <span class='neutral'>        }</span>
 737 |     | <span class='neutral'></span>
 738 |     | <span class='neutral'>        /*</span>
 739 |     | <span class='neutral'>        * If compounded deposit is less than a billionth of the initial deposit, return 0.</span>
 740 |     | <span class='neutral'>        *</span>
 741 |     | <span class='neutral'>        * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error</span>
 742 |     | <span class='neutral'>        * corrections should ensure the error in P &quot;favors the Pool&quot;, i.e. any given compounded deposit should slightly less</span>
 743 |     | <span class='neutral'>        * than it&#39;s theoretical value.</span>
 744 |     | <span class='neutral'>        *</span>
 745 |     | <span class='neutral'>        * Thus it&#39;s unclear whether this line is still really needed.</span>
 746 |     | <span class='neutral'>        */</span>
 747 | *   | <span class='executed'>        if (compoundedStake &lt; initialStake / 1e9) return 0;</span>
 748 |     | <span class='neutral'></span>
 749 | *   | <span class='executed'>        return compoundedStake;</span>
 750 |     | <span class='neutral'>    }</span>
 751 |     | <span class='neutral'></span>
 752 |     | <span class='neutral'>    // --- Sender functions for Bold deposit and Coll gains ---</span>
 753 |     | <span class='neutral'></span>
 754 | *   | <span class='executed'>    function _sendCollGainToDepositor(uint256 _collAmount) internal {</span>
 755 | *   | <span class='executed'>        if (_collAmount == 0) return;</span>
 756 |     | <span class='neutral'></span>
 757 |     | <span class='unexecuted'>        uint256 newCollBalance = collBalance - _collAmount;</span>
 758 |     | <span class='unexecuted'>        collBalance = newCollBalance;</span>
 759 |     | <span class='unexecuted'>        emit StabilityPoolCollBalanceUpdated(newCollBalance);</span>
 760 |     | <span class='unexecuted'>        collToken.safeTransfer(msg.sender, _collAmount);</span>
 761 |     | <span class='neutral'>    }</span>
 762 |     | <span class='neutral'></span>
 763 |     | <span class='neutral'>    // Send Bold to user and decrease Bold in Pool</span>
 764 | *   | <span class='executed'>    function _sendBoldtoDepositor(address _depositor, uint256 _boldToSend) internal {</span>
 765 | *   | <span class='executed'>        if (_boldToSend == 0) return;</span>
 766 | *   | <span class='executed'>        boldToken.returnFromPool(address(this), _depositor, _boldToSend);</span>
 767 |     | <span class='neutral'>    }</span>
 768 |     | <span class='neutral'></span>
 769 |     | <span class='neutral'>    // --- Stability Pool Deposit Functionality ---</span>
 770 |     | <span class='neutral'></span>
 771 | *   | <span class='executed'>    function _updateDepositAndSnapshots(address _depositor, uint256 _newDeposit, uint256 _newStashedColl) internal {</span>
 772 | *   | <span class='executed'>        deposits[_depositor].initialValue = _newDeposit;</span>
 773 | *   | <span class='executed'>        stashedColl[_depositor] = _newStashedColl;</span>
 774 |     | <span class='neutral'></span>
 775 | *   | <span class='executed'>        if (_newDeposit == 0) {</span>
 776 | *   | <span class='executed'>            delete depositSnapshots[_depositor];</span>
 777 | *   | <span class='executed'>            emit DepositUpdated(_depositor, 0, _newStashedColl, 0, 0, 0, 0, 0);</span>
 778 |     | <span class='neutral'>            return;</span>
 779 |     | <span class='neutral'>        }</span>
 780 |     | <span class='neutral'></span>
 781 | *   | <span class='executed'>        uint128 currentScaleCached = currentScale;</span>
 782 | *   | <span class='executed'>        uint128 currentEpochCached = currentEpoch;</span>
 783 | *   | <span class='executed'>        uint256 currentP = P;</span>
 784 |     | <span class='neutral'></span>
 785 |     | <span class='neutral'>        // Get S for the current epoch and current scale</span>
 786 | *   | <span class='executed'>        uint256 currentS = epochToScaleToS[currentEpochCached][currentScaleCached];</span>
 787 | *   | <span class='executed'>        uint256 currentB = epochToScaleToB[currentEpochCached][currentScaleCached];</span>
 788 |     | <span class='neutral'></span>
 789 |     | <span class='neutral'>        // Record new snapshots of the latest running product P and sum S for the depositor</span>
 790 | *   | <span class='executed'>        depositSnapshots[_depositor].P = currentP;</span>
 791 | *   | <span class='executed'>        depositSnapshots[_depositor].S = currentS;</span>
 792 | *   | <span class='executed'>        depositSnapshots[_depositor].B = currentB;</span>
 793 | *   | <span class='executed'>        depositSnapshots[_depositor].scale = currentScaleCached;</span>
 794 | *   | <span class='executed'>        depositSnapshots[_depositor].epoch = currentEpochCached;</span>
 795 |     | <span class='neutral'></span>
 796 | *   | <span class='executed'>        emit DepositUpdated(</span>
 797 |     | <span class='neutral'>            _depositor,</span>
 798 |     | <span class='neutral'>            _newDeposit,</span>
 799 |     | <span class='neutral'>            _newStashedColl,</span>
 800 |     | <span class='neutral'>            currentP,</span>
 801 |     | <span class='neutral'>            currentS,</span>
 802 |     | <span class='neutral'>            currentB,</span>
 803 |     | <span class='neutral'>            currentScaleCached,</span>
 804 |     | <span class='neutral'>            currentEpochCached</span>
 805 |     | <span class='neutral'>        );</span>
 806 |     | <span class='neutral'>    }</span>
 807 |     | <span class='neutral'></span>
 808 |     | <span class='neutral'>    // --- &#39;require&#39; functions ---</span>
 809 |     | <span class='neutral'></span>
 810 | *   | <span class='executed'>    function _requireCallerIsActivePool() internal view {</span>
 811 | *   | <span class='executed'>        require(msg.sender == address(activePool), &quot;StabilityPool: Caller is not ActivePool&quot;);</span>
 812 |     | <span class='neutral'>    }</span>
 813 |     | <span class='neutral'></span>
 814 | *   | <span class='executed'>    function _requireCallerIsTroveManager() internal view {</span>
 815 | *   | <span class='executed'>        require(msg.sender == address(troveManager), &quot;StabilityPool: Caller is not TroveManager&quot;);</span>
 816 |     | <span class='neutral'>    }</span>
 817 |     | <span class='neutral'></span>
 818 | *   | <span class='executed'>    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {</span>
 819 | *   | <span class='executed'>        require(_initialDeposit &gt; 0, &quot;StabilityPool: User must have a non-zero deposit&quot;);</span>
 820 |     | <span class='neutral'>    }</span>
 821 |     | <span class='neutral'></span>
 822 | *   | <span class='executed'>    function _requireUserHasNoDeposit(address _address) internal view {</span>
 823 | *   | <span class='executed'>        uint256 initialDeposit = deposits[_address].initialValue;</span>
 824 | *   | <span class='executed'>        require(initialDeposit == 0, &quot;StabilityPool: User must have no deposit&quot;);</span>
 825 |     | <span class='neutral'>    }</span>
 826 |     | <span class='neutral'></span>
 827 | *   | <span class='executed'>    function _requireNonZeroAmount(uint256 _amount) internal pure {</span>
 828 | *   | <span class='executed'>        require(_amount &gt; 0, &quot;StabilityPool: Amount must be non-zero&quot;);</span>
 829 |     | <span class='neutral'>    }</span>
 830 |     | <span class='neutral'>}</span>
 831 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/TroveManager.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
    2 |     | <span class='neutral'></span>
    3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
    4 |     | <span class='neutral'></span>
    5 |     | <span class='neutral'>import &quot;./Interfaces/ITroveManager.sol&quot;;</span>
    6 |     | <span class='neutral'>import &quot;./Interfaces/IAddressesRegistry.sol&quot;;</span>
    7 |     | <span class='neutral'>import &quot;./Interfaces/IStabilityPool.sol&quot;;</span>
    8 |     | <span class='neutral'>import &quot;./Interfaces/ICollSurplusPool.sol&quot;;</span>
    9 |     | <span class='neutral'>import &quot;./Interfaces/IBoldToken.sol&quot;;</span>
   10 |     | <span class='neutral'>import &quot;./Interfaces/ISortedTroves.sol&quot;;</span>
   11 |     | <span class='neutral'>import &quot;./Interfaces/ITroveEvents.sol&quot;;</span>
   12 |     | <span class='neutral'>import &quot;./Interfaces/ITroveNFT.sol&quot;;</span>
   13 |     | <span class='neutral'>import &quot;./Interfaces/ICollateralRegistry.sol&quot;;</span>
   14 |     | <span class='neutral'>import &quot;./Interfaces/IWETH.sol&quot;;</span>
   15 |     | <span class='neutral'>import &quot;./Dependencies/LiquityBase.sol&quot;;</span>
   16 |     | <span class='neutral'></span>
   17 | *   | <span class='executed'>contract TroveManager is LiquityBase, ITroveManager, ITroveEvents {</span>
   18 |     | <span class='neutral'>    // --- Connected contract declarations ---</span>
   19 |     | <span class='neutral'></span>
   20 |     | <span class='unexecuted'>    ITroveNFT public troveNFT;</span>
   21 |     | <span class='unexecuted'>    IBorrowerOperations public borrowerOperations;</span>
   22 | *   | <span class='executed'>    IStabilityPool public stabilityPool;</span>
   23 |     | <span class='neutral'>    address internal gasPoolAddress;</span>
   24 |     | <span class='neutral'>    ICollSurplusPool internal collSurplusPool;</span>
   25 |     | <span class='neutral'>    IBoldToken internal boldToken;</span>
   26 |     | <span class='neutral'>    // A doubly linked list of Troves, sorted by their interest rate</span>
   27 |     | <span class='unexecuted'>    ISortedTroves public sortedTroves;</span>
   28 |     | <span class='neutral'>    ICollateralRegistry internal collateralRegistry;</span>
   29 |     | <span class='neutral'>    // Wrapped ETH for liquidation reserve (gas compensation)</span>
   30 |     | <span class='neutral'>    IWETH internal immutable WETH;</span>
   31 |     | <span class='neutral'></span>
   32 |     | <span class='neutral'>    // Critical system collateral ratio. If the system&#39;s total collateral ratio (TCR) falls below the CCR, some borrowing operation restrictions are applied</span>
   33 |     | <span class='unexecuted'>    uint256 public immutable CCR;</span>
   34 |     | <span class='neutral'></span>
   35 |     | <span class='neutral'>    // Minimum collateral ratio for individual troves</span>
   36 |     | <span class='neutral'>    uint256 internal immutable MCR;</span>
   37 |     | <span class='neutral'>    // Shutdown system collateral ratio. If the system&#39;s total collateral ratio (TCR) for a given collateral falls below the SCR,</span>
   38 |     | <span class='neutral'>    // the protocol triggers the shutdown of the borrow market and permanently disables all borrowing operations except for closing Troves.</span>
   39 |     | <span class='neutral'>    uint256 internal immutable SCR;</span>
   40 |     | <span class='neutral'></span>
   41 |     | <span class='neutral'>    // Liquidation penalty for troves offset to the SP</span>
   42 |     | <span class='neutral'>    uint256 internal immutable LIQUIDATION_PENALTY_SP;</span>
   43 |     | <span class='neutral'>    // Liquidation penalty for troves redistributed</span>
   44 |     | <span class='neutral'>    uint256 internal immutable LIQUIDATION_PENALTY_REDISTRIBUTION;</span>
   45 |     | <span class='neutral'></span>
   46 |     | <span class='neutral'>    // --- Data structures ---</span>
   47 |     | <span class='neutral'></span>
   48 |     | <span class='neutral'>    // Store the necessary data for a trove</span>
   49 |     | <span class='neutral'>    struct Trove {</span>
   50 |     | <span class='neutral'>        uint256 debt;</span>
   51 |     | <span class='neutral'>        uint256 coll;</span>
   52 |     | <span class='neutral'>        uint256 stake;</span>
   53 |     | <span class='neutral'>        Status status;</span>
   54 |     | <span class='neutral'>        uint64 arrayIndex;</span>
   55 |     | <span class='neutral'>        uint64 lastDebtUpdateTime;</span>
   56 |     | <span class='neutral'>        uint64 lastInterestRateAdjTime;</span>
   57 |     | <span class='neutral'>        uint256 annualInterestRate;</span>
   58 |     | <span class='neutral'>        address interestBatchManager;</span>
   59 |     | <span class='neutral'>        uint256 batchDebtShares;</span>
   60 |     | <span class='neutral'>    }</span>
   61 |     | <span class='neutral'></span>
   62 |     | <span class='unexecuted'>    mapping(uint256 =&gt; Trove) public Troves;</span>
   63 |     | <span class='neutral'></span>
   64 |     | <span class='neutral'>    // Store the necessary data for an interest batch manager. We treat each batch as a “big trove”.</span>
   65 |     | <span class='neutral'>    // Each trove has a share of the debt of the global batch. Collateral is stored per trove (as CRs are different)</span>
   66 |     | <span class='neutral'>    // Still the total amount of batch collateral is stored for informational purposes</span>
   67 |     | <span class='neutral'>    struct Batch {</span>
   68 |     | <span class='neutral'>        uint256 debt;</span>
   69 |     | <span class='neutral'>        uint256 coll;</span>
   70 |     | <span class='neutral'>        uint64 arrayIndex;</span>
   71 |     | <span class='neutral'>        uint64 lastDebtUpdateTime;</span>
   72 |     | <span class='neutral'>        uint64 lastInterestRateAdjTime;</span>
   73 |     | <span class='neutral'>        uint256 annualInterestRate;</span>
   74 |     | <span class='neutral'>        uint256 annualManagementFee;</span>
   75 |     | <span class='neutral'>        uint256 totalDebtShares;</span>
   76 |     | <span class='neutral'>    }</span>
   77 |     | <span class='neutral'></span>
   78 |     | <span class='neutral'>    mapping(address =&gt; Batch) internal batches;</span>
   79 |     | <span class='neutral'></span>
   80 |     | <span class='neutral'>    uint256 internal totalStakes;</span>
   81 |     | <span class='neutral'></span>
   82 |     | <span class='neutral'>    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation</span>
   83 |     | <span class='neutral'>    uint256 internal totalStakesSnapshot;</span>
   84 |     | <span class='neutral'></span>
   85 |     | <span class='neutral'>    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.</span>
   86 |     | <span class='neutral'>    uint256 internal totalCollateralSnapshot;</span>
   87 |     | <span class='neutral'></span>
   88 |     | <span class='neutral'>    /*</span>
   89 |     | <span class='neutral'>    * L_coll and L_boldDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:</span>
   90 |     | <span class='neutral'>    *</span>
   91 |     | <span class='neutral'>    * An Coll gain of ( stake * [L_coll - L_coll(0)] )</span>
   92 |     | <span class='neutral'>    * A boldDebt increase  of ( stake * [L_boldDebt - L_boldDebt(0)] )</span>
   93 |     | <span class='neutral'>    *</span>
   94 |     | <span class='neutral'>    * Where L_coll(0) and L_boldDebt(0) are snapshots of L_coll and L_boldDebt for the active Trove taken at the instant the stake was made</span>
   95 |     | <span class='neutral'>    */</span>
   96 |     | <span class='neutral'>    uint256 internal L_coll;</span>
   97 |     | <span class='neutral'>    uint256 internal L_boldDebt;</span>
   98 |     | <span class='neutral'></span>
   99 |     | <span class='neutral'>    // Map active troves to their RewardSnapshot</span>
  100 |     | <span class='unexecuted'>    mapping(uint256 =&gt; RewardSnapshot) public rewardSnapshots;</span>
  101 |     | <span class='neutral'></span>
  102 |     | <span class='neutral'>    // Object containing the Coll and Bold snapshots for a given active trove</span>
  103 |     | <span class='neutral'>    struct RewardSnapshot {</span>
  104 |     | <span class='neutral'>        uint256 coll;</span>
  105 |     | <span class='neutral'>        uint256 boldDebt;</span>
  106 |     | <span class='neutral'>    }</span>
  107 |     | <span class='neutral'></span>
  108 |     | <span class='neutral'>    // Array of all active trove addresses - used to compute an approximate hint off-chain, for the sorted list insertion</span>
  109 |     | <span class='neutral'>    uint256[] internal TroveIds;</span>
  110 |     | <span class='neutral'>    // Array of all batch managers - used to fetch them off-chain</span>
  111 |     | <span class='unexecuted'>    address[] public batchIds;</span>
  112 |     | <span class='neutral'></span>
  113 | *   | <span class='executed'>    uint256 public lastZombieTroveId;</span>
  114 |     | <span class='neutral'></span>
  115 |     | <span class='neutral'>    // Error trackers for the trove redistribution calculation</span>
  116 |     | <span class='neutral'>    uint256 internal lastCollError_Redistribution;</span>
  117 |     | <span class='neutral'>    uint256 internal lastBoldDebtError_Redistribution;</span>
  118 |     | <span class='neutral'></span>
  119 |     | <span class='neutral'>    // Timestamp at which branch was shut down. 0 if not shut down.</span>
  120 |     | <span class='unexecuted'>    uint256 public shutdownTime;</span>
  121 |     | <span class='neutral'></span>
  122 |     | <span class='neutral'>    /*</span>
  123 |     | <span class='neutral'>    * --- Variable container structs for liquidations ---</span>
  124 |     | <span class='neutral'>    *</span>
  125 |     | <span class='neutral'>    * These structs are used to hold, return and assign variables inside the liquidation functions,</span>
  126 |     | <span class='neutral'>    * in order to avoid the error: &quot;CompilerError: Stack too deep&quot;.</span>
  127 |     | <span class='neutral'>    **/</span>
  128 |     | <span class='neutral'></span>
  129 |     | <span class='neutral'>    struct LiquidationValues {</span>
  130 |     | <span class='neutral'>        uint256 collGasCompensation;</span>
  131 |     | <span class='neutral'>        uint256 debtToOffset;</span>
  132 |     | <span class='neutral'>        uint256 collToSendToSP;</span>
  133 |     | <span class='neutral'>        uint256 debtToRedistribute;</span>
  134 |     | <span class='neutral'>        uint256 collToRedistribute;</span>
  135 |     | <span class='neutral'>        uint256 collSurplus;</span>
  136 |     | <span class='neutral'>        uint256 ETHGasCompensation;</span>
  137 |     | <span class='neutral'>        uint256 oldWeightedRecordedDebt;</span>
  138 |     | <span class='neutral'>        uint256 newWeightedRecordedDebt;</span>
  139 |     | <span class='neutral'>    }</span>
  140 |     | <span class='neutral'></span>
  141 |     | <span class='neutral'>    // --- Variable container structs for redemptions ---</span>
  142 |     | <span class='neutral'></span>
  143 |     | <span class='neutral'>    struct SingleRedemptionValues {</span>
  144 |     | <span class='neutral'>        uint256 troveId;</span>
  145 |     | <span class='neutral'>        address batchAddress;</span>
  146 |     | <span class='neutral'>        uint256 boldLot;</span>
  147 |     | <span class='neutral'>        uint256 collLot;</span>
  148 |     | <span class='neutral'>        uint256 collFee;</span>
  149 |     | <span class='neutral'>        uint256 appliedRedistBoldDebtGain;</span>
  150 |     | <span class='neutral'>        uint256 oldWeightedRecordedDebt;</span>
  151 |     | <span class='neutral'>        uint256 newWeightedRecordedDebt;</span>
  152 |     | <span class='neutral'>        uint256 newStake;</span>
  153 |     | <span class='neutral'>        bool isZombieTrove;</span>
  154 |     | <span class='neutral'>        LatestTroveData trove;</span>
  155 |     | <span class='neutral'>        LatestBatchData batch;</span>
  156 |     | <span class='neutral'>    }</span>
  157 |     | <span class='neutral'></span>
  158 |     | <span class='neutral'>    // --- Errors ---</span>
  159 |     | <span class='neutral'></span>
  160 |     | <span class='neutral'>    error EmptyData();</span>
  161 |     | <span class='neutral'>    error NothingToLiquidate();</span>
  162 |     | <span class='neutral'>    error CallerNotBorrowerOperations();</span>
  163 |     | <span class='neutral'>    error CallerNotCollateralRegistry();</span>
  164 |     | <span class='neutral'>    error OnlyOneTroveLeft();</span>
  165 |     | <span class='neutral'>    error NotShutDown();</span>
  166 |     | <span class='neutral'>    error ZeroAmount();</span>
  167 |     | <span class='neutral'>    error NotEnoughBoldBalance();</span>
  168 |     | <span class='neutral'>    error MinCollNotReached(uint256 _coll);</span>
  169 |     | <span class='neutral'>    error BatchSharesRatioTooHigh();</span>
  170 |     | <span class='neutral'></span>
  171 |     | <span class='neutral'>    // --- Events ---</span>
  172 |     | <span class='neutral'></span>
  173 |     | <span class='neutral'>    event TroveNFTAddressChanged(address _newTroveNFTAddress);</span>
  174 |     | <span class='neutral'>    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);</span>
  175 |     | <span class='neutral'>    event BoldTokenAddressChanged(address _newBoldTokenAddress);</span>
  176 |     | <span class='neutral'>    event StabilityPoolAddressChanged(address _stabilityPoolAddress);</span>
  177 |     | <span class='neutral'>    event GasPoolAddressChanged(address _gasPoolAddress);</span>
  178 |     | <span class='neutral'>    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);</span>
  179 |     | <span class='neutral'>    event SortedTrovesAddressChanged(address _sortedTrovesAddress);</span>
  180 |     | <span class='neutral'>    event CollateralRegistryAddressChanged(address _collateralRegistryAddress);</span>
  181 |     | <span class='neutral'></span>
  182 | *   | <span class='executed'>    constructor(IAddressesRegistry _addressesRegistry) LiquityBase(_addressesRegistry) {</span>
  183 | *   | <span class='executed'>        CCR = _addressesRegistry.CCR();</span>
  184 | *   | <span class='executed'>        MCR = _addressesRegistry.MCR();</span>
  185 | *   | <span class='executed'>        SCR = _addressesRegistry.SCR();</span>
  186 | *   | <span class='executed'>        LIQUIDATION_PENALTY_SP = _addressesRegistry.LIQUIDATION_PENALTY_SP();</span>
  187 | *   | <span class='executed'>        LIQUIDATION_PENALTY_REDISTRIBUTION = _addressesRegistry.LIQUIDATION_PENALTY_REDISTRIBUTION();</span>
  188 |     | <span class='neutral'></span>
  189 | *   | <span class='executed'>        troveNFT = _addressesRegistry.troveNFT();</span>
  190 | *   | <span class='executed'>        borrowerOperations = _addressesRegistry.borrowerOperations();</span>
  191 | *   | <span class='executed'>        stabilityPool = _addressesRegistry.stabilityPool();</span>
  192 | *   | <span class='executed'>        gasPoolAddress = _addressesRegistry.gasPoolAddress();</span>
  193 | *   | <span class='executed'>        collSurplusPool = _addressesRegistry.collSurplusPool();</span>
  194 | *   | <span class='executed'>        boldToken = _addressesRegistry.boldToken();</span>
  195 | *   | <span class='executed'>        sortedTroves = _addressesRegistry.sortedTroves();</span>
  196 | *   | <span class='executed'>        WETH = _addressesRegistry.WETH();</span>
  197 | *   | <span class='executed'>        collateralRegistry = _addressesRegistry.collateralRegistry();</span>
  198 |     | <span class='neutral'></span>
  199 | *   | <span class='executed'>        emit TroveNFTAddressChanged(address(troveNFT));</span>
  200 | *   | <span class='executed'>        emit BorrowerOperationsAddressChanged(address(borrowerOperations));</span>
  201 | *   | <span class='executed'>        emit StabilityPoolAddressChanged(address(stabilityPool));</span>
  202 | *   | <span class='executed'>        emit GasPoolAddressChanged(gasPoolAddress);</span>
  203 | *   | <span class='executed'>        emit CollSurplusPoolAddressChanged(address(collSurplusPool));</span>
  204 | *   | <span class='executed'>        emit BoldTokenAddressChanged(address(boldToken));</span>
  205 | *   | <span class='executed'>        emit SortedTrovesAddressChanged(address(sortedTroves));</span>
  206 | *   | <span class='executed'>        emit CollateralRegistryAddressChanged(address(collateralRegistry));</span>
  207 |     | <span class='neutral'>    }</span>
  208 |     | <span class='neutral'></span>
  209 |     | <span class='neutral'>    // --- Getters ---</span>
  210 |     | <span class='neutral'></span>
  211 | *   | <span class='executed'>    function getTroveIdsCount() external view override returns (uint256) {</span>
  212 | *   | <span class='executed'>        return TroveIds.length;</span>
  213 |     | <span class='neutral'>    }</span>
  214 |     | <span class='neutral'></span>
  215 | *   | <span class='executed'>    function getTroveFromTroveIdsArray(uint256 _index) external view override returns (uint256) {</span>
  216 | *   | <span class='executed'>        return TroveIds[_index];</span>
  217 |     | <span class='neutral'>    }</span>
  218 |     | <span class='neutral'></span>
  219 |     | <span class='neutral'>    // --- Trove Liquidation functions ---</span>
  220 |     | <span class='neutral'></span>
  221 |     | <span class='neutral'>    // --- Inner single liquidation functions ---</span>
  222 |     | <span class='neutral'></span>
  223 |     | <span class='neutral'>    // Liquidate one trove</span>
  224 |     | <span class='unexecuted'>    function _liquidate(</span>
  225 |     | <span class='neutral'>        IDefaultPool _defaultPool,</span>
  226 |     | <span class='neutral'>        uint256 _troveId,</span>
  227 |     | <span class='neutral'>        uint256 _boldInStabPool,</span>
  228 |     | <span class='neutral'>        uint256 _price,</span>
  229 |     | <span class='neutral'>        LatestTroveData memory trove,</span>
  230 |     | <span class='neutral'>        LiquidationValues memory singleLiquidation</span>
  231 |     | <span class='unexecuted'>    ) internal {</span>
  232 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_troveId);</span>
  233 |     | <span class='neutral'></span>
  234 |     | <span class='unexecuted'>        _getLatestTroveData(_troveId, trove);</span>
  235 |     | <span class='unexecuted'>        address batchAddress = _getBatchManager(_troveId);</span>
  236 |     | <span class='unexecuted'>        bool isTroveInBatch = batchAddress != address(0);</span>
  237 |     | <span class='unexecuted'>        LatestBatchData memory batch;</span>
  238 |     | <span class='unexecuted'>        if (isTroveInBatch) _getLatestBatchData(batchAddress, batch);</span>
  239 |     | <span class='neutral'></span>
  240 |     | <span class='unexecuted'>        _movePendingTroveRewardsToActivePool(_defaultPool, trove.redistBoldDebtGain, trove.redistCollGain);</span>
  241 |     | <span class='neutral'></span>
  242 |     | <span class='unexecuted'>        singleLiquidation.collGasCompensation = _getCollGasCompensation(trove.entireColl);</span>
  243 |     | <span class='unexecuted'>        uint256 collToLiquidate = trove.entireColl - singleLiquidation.collGasCompensation;</span>
  244 |     | <span class='neutral'></span>
  245 |     | <span class='unexecuted'>        (</span>
  246 |     | <span class='unexecuted'>            singleLiquidation.debtToOffset,</span>
  247 |     | <span class='unexecuted'>            singleLiquidation.collToSendToSP,</span>
  248 |     | <span class='unexecuted'>            singleLiquidation.debtToRedistribute,</span>
  249 |     | <span class='unexecuted'>            singleLiquidation.collToRedistribute,</span>
  250 |     | <span class='unexecuted'>            singleLiquidation.collSurplus</span>
  251 |     | <span class='unexecuted'>        ) = _getOffsetAndRedistributionVals(trove.entireDebt, collToLiquidate, _boldInStabPool, _price);</span>
  252 |     | <span class='neutral'></span>
  253 |     | <span class='unexecuted'>        TroveChange memory troveChange;</span>
  254 |     | <span class='unexecuted'>        troveChange.collDecrease = trove.entireColl;</span>
  255 |     | <span class='unexecuted'>        troveChange.debtDecrease = trove.entireDebt;</span>
  256 |     | <span class='unexecuted'>        troveChange.appliedRedistCollGain = trove.redistCollGain;</span>
  257 |     | <span class='unexecuted'>        troveChange.appliedRedistBoldDebtGain = trove.redistBoldDebtGain;</span>
  258 |     | <span class='unexecuted'>        _closeTrove(</span>
  259 |     | <span class='unexecuted'>            _troveId,</span>
  260 |     | <span class='neutral'>            troveChange,</span>
  261 |     | <span class='unexecuted'>            batchAddress,</span>
  262 |     | <span class='unexecuted'>            batch.entireCollWithoutRedistribution,</span>
  263 |     | <span class='unexecuted'>            batch.entireDebtWithoutRedistribution,</span>
  264 |     | <span class='unexecuted'>            Status.closedByLiquidation</span>
  265 |     | <span class='neutral'>        );</span>
  266 |     | <span class='neutral'></span>
  267 |     | <span class='unexecuted'>        if (isTroveInBatch) {</span>
  268 |     | <span class='unexecuted'>            singleLiquidation.oldWeightedRecordedDebt =</span>
  269 |     | <span class='unexecuted'>                batch.weightedRecordedDebt + (trove.entireDebt - trove.redistBoldDebtGain) * batch.annualInterestRate;</span>
  270 |     | <span class='unexecuted'>            singleLiquidation.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;</span>
  271 |     | <span class='neutral'>            // Mint batch management fee</span>
  272 |     | <span class='unexecuted'>            troveChange.batchAccruedManagementFee = batch.accruedManagementFee;</span>
  273 |     | <span class='unexecuted'>            troveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee</span>
  274 |     | <span class='unexecuted'>                + (trove.entireDebt - trove.redistBoldDebtGain) * batch.annualManagementFee;</span>
  275 |     | <span class='unexecuted'>            troveChange.newWeightedRecordedBatchManagementFee =</span>
  276 |     | <span class='unexecuted'>                batch.entireDebtWithoutRedistribution * batch.annualManagementFee;</span>
  277 |     | <span class='unexecuted'>            activePool.mintBatchManagementFeeAndAccountForChange(troveChange, batchAddress);</span>
  278 |     | <span class='neutral'>        } else {</span>
  279 |     | <span class='unexecuted'>            singleLiquidation.oldWeightedRecordedDebt = trove.weightedRecordedDebt;</span>
  280 |     | <span class='neutral'>        }</span>
  281 |     | <span class='neutral'></span>
  282 |     | <span class='neutral'>        // Differencen between liquidation penalty and liquidation threshold</span>
  283 |     | <span class='unexecuted'>        if (singleLiquidation.collSurplus &gt; 0) {</span>
  284 |     | <span class='unexecuted'>            collSurplusPool.accountSurplus(owner, singleLiquidation.collSurplus);</span>
  285 |     | <span class='neutral'>        }</span>
  286 |     | <span class='neutral'></span>
  287 |     | <span class='neutral'>        // Wipe out state in BO</span>
  288 |     | <span class='unexecuted'>        borrowerOperations.onLiquidateTrove(_troveId);</span>
  289 |     | <span class='neutral'></span>
  290 |     | <span class='unexecuted'>        emit TroveUpdated({</span>
  291 |     | <span class='unexecuted'>            _troveId: _troveId,</span>
  292 |     | <span class='unexecuted'>            _debt: 0,</span>
  293 |     | <span class='unexecuted'>            _coll: 0,</span>
  294 |     | <span class='unexecuted'>            _stake: 0,</span>
  295 |     | <span class='unexecuted'>            _annualInterestRate: 0,</span>
  296 |     | <span class='unexecuted'>            _snapshotOfTotalCollRedist: 0,</span>
  297 |     | <span class='unexecuted'>            _snapshotOfTotalDebtRedist: 0</span>
  298 |     | <span class='neutral'>        });</span>
  299 |     | <span class='neutral'></span>
  300 |     | <span class='unexecuted'>        emit TroveOperation({</span>
  301 |     | <span class='unexecuted'>            _troveId: _troveId,</span>
  302 |     | <span class='unexecuted'>            _operation: Operation.liquidate,</span>
  303 |     | <span class='unexecuted'>            _annualInterestRate: 0,</span>
  304 |     | <span class='unexecuted'>            _debtIncreaseFromRedist: trove.redistBoldDebtGain,</span>
  305 |     | <span class='unexecuted'>            _debtIncreaseFromUpfrontFee: 0,</span>
  306 |     | <span class='unexecuted'>            _debtChangeFromOperation: -int256(trove.entireDebt),</span>
  307 |     | <span class='unexecuted'>            _collIncreaseFromRedist: trove.redistCollGain,</span>
  308 |     | <span class='unexecuted'>            _collChangeFromOperation: -int256(trove.entireColl)</span>
  309 |     | <span class='neutral'>        });</span>
  310 |     | <span class='neutral'></span>
  311 |     | <span class='unexecuted'>        if (isTroveInBatch) {</span>
  312 |     | <span class='unexecuted'>            emit BatchUpdated({</span>
  313 |     | <span class='neutral'>                _interestBatchManager: batchAddress,</span>
  314 |     | <span class='unexecuted'>                _operation: BatchOperation.exitBatch,</span>
  315 |     | <span class='unexecuted'>                _debt: batches[batchAddress].debt,</span>
  316 |     | <span class='unexecuted'>                _coll: batches[batchAddress].coll,</span>
  317 |     | <span class='unexecuted'>                _annualInterestRate: batch.annualInterestRate,</span>
  318 |     | <span class='unexecuted'>                _annualManagementFee: batch.annualManagementFee,</span>
  319 |     | <span class='unexecuted'>                _totalDebtShares: batches[batchAddress].totalDebtShares,</span>
  320 |     | <span class='neutral'>                _debtIncreaseFromUpfrontFee: 0</span>
  321 |     | <span class='neutral'>            });</span>
  322 |     | <span class='neutral'>        }</span>
  323 |     | <span class='neutral'>    }</span>
  324 |     | <span class='neutral'></span>
  325 |     | <span class='neutral'>    // Return the amount of Coll to be drawn from a trove&#39;s collateral and sent as gas compensation.</span>
  326 |     | <span class='unexecuted'>    function _getCollGasCompensation(uint256 _entireColl) internal pure returns (uint256) {</span>
  327 |     | <span class='unexecuted'>        return LiquityMath._min(_entireColl / COLL_GAS_COMPENSATION_DIVISOR, COLL_GAS_COMPENSATION_CAP);</span>
  328 |     | <span class='neutral'>    }</span>
  329 |     | <span class='neutral'></span>
  330 |     | <span class='neutral'>    /* In a full liquidation, returns the values for a trove&#39;s coll and debt to be offset, and coll and debt to be</span>
  331 |     | <span class='neutral'>    * redistributed to active troves.</span>
  332 |     | <span class='neutral'>    */</span>
  333 |     | <span class='unexecuted'>    function _getOffsetAndRedistributionVals(</span>
  334 |     | <span class='neutral'>        uint256 _entireTroveDebt,</span>
  335 |     | <span class='neutral'>        uint256 _collToLiquidate, // gas compensation is already subtracted</span>
  336 |     | <span class='neutral'>        uint256 _boldInStabPool,</span>
  337 |     | <span class='neutral'>        uint256 _price</span>
  338 |     | <span class='neutral'>    )</span>
  339 |     | <span class='neutral'>        internal</span>
  340 |     | <span class='neutral'>        view</span>
  341 |     | <span class='neutral'>        returns (</span>
  342 |     | <span class='unexecuted'>            uint256 debtToOffset,</span>
  343 |     | <span class='neutral'>            uint256 collToSendToSP,</span>
  344 |     | <span class='neutral'>            uint256 debtToRedistribute,</span>
  345 |     | <span class='neutral'>            uint256 collToRedistribute,</span>
  346 |     | <span class='neutral'>            uint256 collSurplus</span>
  347 |     | <span class='neutral'>        )</span>
  348 |     | <span class='unexecuted'>    {</span>
  349 |     | <span class='neutral'>        uint256 collSPPortion;</span>
  350 |     | <span class='neutral'>        /*</span>
  351 |     | <span class='neutral'>         * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder</span>
  352 |     | <span class='neutral'>         * between all active troves.</span>
  353 |     | <span class='neutral'>         *</span>
  354 |     | <span class='neutral'>         *  If the trove&#39;s debt is larger than the deposited Bold in the Stability Pool:</span>
  355 |     | <span class='neutral'>         *</span>
  356 |     | <span class='neutral'>         *  - Offset an amount of the trove&#39;s debt equal to the Bold in the Stability Pool</span>
  357 |     | <span class='neutral'>         *  - Send a fraction of the trove&#39;s collateral to the Stability Pool, equal to the fraction of its offset debt</span>
  358 |     | <span class='neutral'>         *</span>
  359 |     | <span class='neutral'>         */</span>
  360 |     | <span class='unexecuted'>        if (_boldInStabPool &gt; 0) {</span>
  361 |     | <span class='unexecuted'>            debtToOffset = LiquityMath._min(_entireTroveDebt, _boldInStabPool);</span>
  362 |     | <span class='unexecuted'>            collSPPortion = _collToLiquidate * debtToOffset / _entireTroveDebt;</span>
  363 |     | <span class='unexecuted'>            (collToSendToSP, collSurplus) =</span>
  364 |     | <span class='unexecuted'>                _getCollPenaltyAndSurplus(collSPPortion, debtToOffset, LIQUIDATION_PENALTY_SP, _price);</span>
  365 |     | <span class='neutral'>        }</span>
  366 |     | <span class='neutral'></span>
  367 |     | <span class='neutral'>        // Redistribution</span>
  368 |     | <span class='unexecuted'>        debtToRedistribute = _entireTroveDebt - debtToOffset;</span>
  369 |     | <span class='unexecuted'>        if (debtToRedistribute &gt; 0) {</span>
  370 |     | <span class='unexecuted'>            uint256 collRedistributionPortion = _collToLiquidate - collSPPortion;</span>
  371 |     | <span class='unexecuted'>            if (collRedistributionPortion &gt; 0) {</span>
  372 |     | <span class='unexecuted'>                (collToRedistribute, collSurplus) = _getCollPenaltyAndSurplus(</span>
  373 |     | <span class='unexecuted'>                    collRedistributionPortion + collSurplus, // Coll surplus from offset can be eaten up by red. penalty</span>
  374 |     | <span class='unexecuted'>                    debtToRedistribute,</span>
  375 |     | <span class='unexecuted'>                    LIQUIDATION_PENALTY_REDISTRIBUTION, // _penaltyRatio</span>
  376 |     | <span class='unexecuted'>                    _price</span>
  377 |     | <span class='neutral'>                );</span>
  378 |     | <span class='neutral'>            }</span>
  379 |     | <span class='neutral'>        }</span>
  380 |     | <span class='neutral'>        // assert(_collToLiquidate == collToSendToSP + collToRedistribute + collSurplus);</span>
  381 |     | <span class='neutral'>    }</span>
  382 |     | <span class='neutral'></span>
  383 |     | <span class='unexecuted'>    function _getCollPenaltyAndSurplus(</span>
  384 |     | <span class='neutral'>        uint256 _collToLiquidate,</span>
  385 |     | <span class='neutral'>        uint256 _debtToLiquidate,</span>
  386 |     | <span class='neutral'>        uint256 _penaltyRatio,</span>
  387 |     | <span class='neutral'>        uint256 _price</span>
  388 |     | <span class='unexecuted'>    ) internal pure returns (uint256 seizedColl, uint256 collSurplus) {</span>
  389 |     | <span class='unexecuted'>        uint256 maxSeizedColl = _debtToLiquidate * (DECIMAL_PRECISION + _penaltyRatio) / _price;</span>
  390 |     | <span class='unexecuted'>        if (_collToLiquidate &gt; maxSeizedColl) {</span>
  391 |     | <span class='unexecuted'>            seizedColl = maxSeizedColl;</span>
  392 |     | <span class='unexecuted'>            collSurplus = _collToLiquidate - maxSeizedColl;</span>
  393 |     | <span class='neutral'>        } else {</span>
  394 |     | <span class='unexecuted'>            seizedColl = _collToLiquidate;</span>
  395 |     | <span class='unexecuted'>            collSurplus = 0;</span>
  396 |     | <span class='neutral'>        }</span>
  397 |     | <span class='neutral'>    }</span>
  398 |     | <span class='neutral'></span>
  399 |     | <span class='neutral'>    /*</span>
  400 |     | <span class='neutral'>     * Attempt to liquidate a custom list of troves provided by the caller.</span>
  401 |     | <span class='neutral'>     */</span>
  402 | *   | <span class='executed'>    function batchLiquidateTroves(uint256[] memory _troveArray) public override {</span>
  403 | *   | <span class='executed'>        if (_troveArray.length == 0) {</span>
  404 | *   | <span class='executed'>            revert EmptyData();</span>
  405 |     | <span class='neutral'>        }</span>
  406 |     | <span class='neutral'></span>
  407 | *   | <span class='executed'>        IActivePool activePoolCached = activePool;</span>
  408 | *   | <span class='executed'>        IDefaultPool defaultPoolCached = defaultPool;</span>
  409 | *   | <span class='executed'>        IStabilityPool stabilityPoolCached = stabilityPool;</span>
  410 |     | <span class='neutral'></span>
  411 | *   | <span class='executed'>        TroveChange memory troveChange;</span>
  412 | *   | <span class='executed'>        LiquidationValues memory totals;</span>
  413 |     | <span class='neutral'></span>
  414 | *   | <span class='executed'>        (uint256 price,) = priceFeed.fetchPrice();</span>
  415 | *   | <span class='executed'>        uint256 boldInStabPool = stabilityPoolCached.getTotalBoldDeposits();</span>
  416 |     | <span class='neutral'></span>
  417 |     | <span class='neutral'>        // Perform the appropriate liquidation sequence - tally values and obtain their totals.</span>
  418 | *   | <span class='executed'>        _batchLiquidateTroves(defaultPoolCached, price, boldInStabPool, _troveArray, totals, troveChange);</span>
  419 |     | <span class='neutral'></span>
  420 | *   | <span class='executed'>        if (troveChange.debtDecrease == 0) {</span>
  421 | *   | <span class='executed'>            revert NothingToLiquidate();</span>
  422 |     | <span class='neutral'>        }</span>
  423 |     | <span class='neutral'></span>
  424 |     | <span class='unexecuted'>        activePoolCached.mintAggInterestAndAccountForTroveChange(troveChange, address(0));</span>
  425 |     | <span class='neutral'></span>
  426 |     | <span class='neutral'>        // Move liquidated Coll and Bold to the appropriate pools</span>
  427 |     | <span class='unexecuted'>        if (totals.debtToOffset &gt; 0 || totals.collToSendToSP &gt; 0) {</span>
  428 |     | <span class='unexecuted'>            stabilityPoolCached.offset(totals.debtToOffset, totals.collToSendToSP);</span>
  429 |     | <span class='neutral'>        }</span>
  430 |     | <span class='neutral'>        // we check amount is not zero inside</span>
  431 |     | <span class='unexecuted'>        _redistributeDebtAndColl(</span>
  432 |     | <span class='unexecuted'>            activePoolCached, defaultPoolCached, totals.debtToRedistribute, totals.collToRedistribute</span>
  433 |     | <span class='neutral'>        );</span>
  434 |     | <span class='unexecuted'>        if (totals.collSurplus &gt; 0) {</span>
  435 |     | <span class='unexecuted'>            activePoolCached.sendColl(address(collSurplusPool), totals.collSurplus);</span>
  436 |     | <span class='neutral'>        }</span>
  437 |     | <span class='neutral'></span>
  438 |     | <span class='neutral'>        // Update system snapshots</span>
  439 |     | <span class='unexecuted'>        _updateSystemSnapshots_excludeCollRemainder(activePoolCached, totals.collGasCompensation);</span>
  440 |     | <span class='neutral'></span>
  441 |     | <span class='unexecuted'>        emit Liquidation(</span>
  442 |     | <span class='unexecuted'>            totals.debtToOffset,</span>
  443 |     | <span class='unexecuted'>            totals.debtToRedistribute,</span>
  444 |     | <span class='unexecuted'>            totals.ETHGasCompensation,</span>
  445 |     | <span class='unexecuted'>            totals.collGasCompensation,</span>
  446 |     | <span class='unexecuted'>            totals.collToSendToSP,</span>
  447 |     | <span class='unexecuted'>            totals.collToRedistribute,</span>
  448 |     | <span class='unexecuted'>            totals.collSurplus,</span>
  449 |     | <span class='unexecuted'>            L_coll,</span>
  450 |     | <span class='unexecuted'>            L_boldDebt,</span>
  451 |     | <span class='unexecuted'>            price</span>
  452 |     | <span class='neutral'>        );</span>
  453 |     | <span class='neutral'></span>
  454 |     | <span class='neutral'>        // Send gas compensation to caller</span>
  455 | *   | <span class='executed'>        _sendGasCompensation(activePoolCached, msg.sender, totals.ETHGasCompensation, totals.collGasCompensation);</span>
  456 |     | <span class='neutral'>    }</span>
  457 |     | <span class='neutral'></span>
  458 | *   | <span class='executed'>    function _isActiveOrZombie(Status _status) internal pure returns (bool) {</span>
  459 | *   | <span class='executed'>        return _status == Status.active || _status == Status.zombie;</span>
  460 |     | <span class='neutral'>    }</span>
  461 |     | <span class='neutral'></span>
  462 | *   | <span class='executed'>    function _batchLiquidateTroves(</span>
  463 |     | <span class='neutral'>        IDefaultPool _defaultPool,</span>
  464 |     | <span class='neutral'>        uint256 _price,</span>
  465 |     | <span class='neutral'>        uint256 _boldInStabPool,</span>
  466 |     | <span class='neutral'>        uint256[] memory _troveArray,</span>
  467 |     | <span class='neutral'>        LiquidationValues memory totals,</span>
  468 |     | <span class='neutral'>        TroveChange memory troveChange</span>
  469 |     | <span class='neutral'>    ) internal {</span>
  470 | *   | <span class='executed'>        uint256 remainingBoldInStabPool = _boldInStabPool;</span>
  471 |     | <span class='neutral'></span>
  472 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; _troveArray.length; i++) {</span>
  473 | *   | <span class='executed'>            uint256 troveId = _troveArray[i];</span>
  474 |     | <span class='neutral'></span>
  475 |     | <span class='neutral'>            // Skip non-liquidatable troves</span>
  476 | *   | <span class='executed'>            if (!_isActiveOrZombie(Troves[troveId].status)) continue;</span>
  477 |     | <span class='neutral'></span>
  478 |     | <span class='unexecuted'>            uint256 ICR = getCurrentICR(troveId, _price);</span>
  479 |     | <span class='neutral'></span>
  480 |     | <span class='unexecuted'>            if (ICR &lt; MCR) {</span>
  481 |     | <span class='unexecuted'>                LiquidationValues memory singleLiquidation;</span>
  482 |     | <span class='unexecuted'>                LatestTroveData memory trove;</span>
  483 |     | <span class='neutral'></span>
  484 |     | <span class='unexecuted'>                _liquidate(_defaultPool, troveId, remainingBoldInStabPool, _price, trove, singleLiquidation);</span>
  485 |     | <span class='unexecuted'>                remainingBoldInStabPool -= singleLiquidation.debtToOffset;</span>
  486 |     | <span class='neutral'></span>
  487 |     | <span class='neutral'>                // Add liquidation values to their respective running totals</span>
  488 |     | <span class='unexecuted'>                _addLiquidationValuesToTotals(trove, singleLiquidation, totals, troveChange);</span>
  489 |     | <span class='neutral'>            }</span>
  490 |     | <span class='neutral'>        }</span>
  491 |     | <span class='neutral'>    }</span>
  492 |     | <span class='neutral'></span>
  493 |     | <span class='neutral'>    // --- Liquidation helper functions ---</span>
  494 |     | <span class='neutral'></span>
  495 |     | <span class='neutral'>    // Adds all values from `singleLiquidation` to their respective totals in `totals` in-place</span>
  496 |     | <span class='unexecuted'>    function _addLiquidationValuesToTotals(</span>
  497 |     | <span class='neutral'>        LatestTroveData memory _trove,</span>
  498 |     | <span class='neutral'>        LiquidationValues memory _singleLiquidation,</span>
  499 |     | <span class='neutral'>        LiquidationValues memory totals,</span>
  500 |     | <span class='neutral'>        TroveChange memory troveChange</span>
  501 |     | <span class='neutral'>    ) internal pure {</span>
  502 |     | <span class='neutral'>        // Tally all the values with their respective running totals</span>
  503 |     | <span class='unexecuted'>        totals.collGasCompensation += _singleLiquidation.collGasCompensation;</span>
  504 |     | <span class='unexecuted'>        totals.ETHGasCompensation += ETH_GAS_COMPENSATION;</span>
  505 |     | <span class='unexecuted'>        troveChange.debtDecrease += _trove.entireDebt;</span>
  506 |     | <span class='unexecuted'>        troveChange.collDecrease += _trove.entireColl;</span>
  507 |     | <span class='unexecuted'>        troveChange.appliedRedistBoldDebtGain += _trove.redistBoldDebtGain;</span>
  508 |     | <span class='unexecuted'>        troveChange.oldWeightedRecordedDebt += _singleLiquidation.oldWeightedRecordedDebt;</span>
  509 |     | <span class='unexecuted'>        troveChange.newWeightedRecordedDebt += _singleLiquidation.newWeightedRecordedDebt;</span>
  510 |     | <span class='unexecuted'>        totals.debtToOffset += _singleLiquidation.debtToOffset;</span>
  511 |     | <span class='unexecuted'>        totals.collToSendToSP += _singleLiquidation.collToSendToSP;</span>
  512 |     | <span class='unexecuted'>        totals.debtToRedistribute += _singleLiquidation.debtToRedistribute;</span>
  513 |     | <span class='unexecuted'>        totals.collToRedistribute += _singleLiquidation.collToRedistribute;</span>
  514 |     | <span class='unexecuted'>        totals.collSurplus += _singleLiquidation.collSurplus;</span>
  515 |     | <span class='neutral'>    }</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='unexecuted'>    function _sendGasCompensation(IActivePool _activePool, address _liquidator, uint256 _eth, uint256 _coll) internal {</span>
  518 |     | <span class='unexecuted'>        if (_eth &gt; 0) {</span>
  519 |     | <span class='unexecuted'>            WETH.transferFrom(gasPoolAddress, _liquidator, _eth);</span>
  520 |     | <span class='neutral'>        }</span>
  521 |     | <span class='neutral'></span>
  522 |     | <span class='unexecuted'>        if (_coll &gt; 0) {</span>
  523 |     | <span class='unexecuted'>            _activePool.sendColl(_liquidator, _coll);</span>
  524 |     | <span class='neutral'>        }</span>
  525 |     | <span class='neutral'>    }</span>
  526 |     | <span class='neutral'></span>
  527 |     | <span class='neutral'>    // Move a Trove&#39;s pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool</span>
  528 | *   | <span class='executed'>    function _movePendingTroveRewardsToActivePool(IDefaultPool _defaultPool, uint256 _bold, uint256 _coll) internal {</span>
  529 | *   | <span class='executed'>        if (_bold &gt; 0) {</span>
  530 |     | <span class='unexecuted'>            _defaultPool.decreaseBoldDebt(_bold);</span>
  531 |     | <span class='neutral'>        }</span>
  532 |     | <span class='neutral'></span>
  533 | *   | <span class='executed'>        if (_coll &gt; 0) {</span>
  534 |     | <span class='unexecuted'>            _defaultPool.sendCollToActivePool(_coll);</span>
  535 |     | <span class='neutral'>        }</span>
  536 |     | <span class='neutral'>    }</span>
  537 |     | <span class='neutral'></span>
  538 |     | <span class='neutral'>    // --- Redemption functions ---</span>
  539 |     | <span class='neutral'></span>
  540 | *   | <span class='executed'>    function _applySingleRedemption(</span>
  541 |     | <span class='neutral'>        IDefaultPool _defaultPool,</span>
  542 |     | <span class='neutral'>        SingleRedemptionValues memory _singleRedemption,</span>
  543 |     | <span class='neutral'>        bool _isTroveInBatch</span>
  544 | *   | <span class='executed'>    ) internal returns (uint256) {</span>
  545 |     | <span class='neutral'>        // Decrease the debt and collateral of the current Trove according to the Bold lot and corresponding ETH to send</span>
  546 | *   | <span class='executed'>        uint256 newDebt = _singleRedemption.trove.entireDebt - _singleRedemption.boldLot;</span>
  547 | *   | <span class='executed'>        uint256 newColl = _singleRedemption.trove.entireColl - _singleRedemption.collLot;</span>
  548 |     | <span class='neutral'></span>
  549 | *   | <span class='executed'>        _singleRedemption.appliedRedistBoldDebtGain = _singleRedemption.trove.redistBoldDebtGain;</span>
  550 |     | <span class='neutral'></span>
  551 | *   | <span class='executed'>        if (_isTroveInBatch) {</span>
  552 | *   | <span class='executed'>            _getLatestBatchData(_singleRedemption.batchAddress, _singleRedemption.batch);</span>
  553 |     | <span class='neutral'>            // We know boldLot &lt;= trove entire debt, so this subtraction is safe</span>
  554 | *   | <span class='executed'>            uint256 newAmountForWeightedDebt = _singleRedemption.batch.entireDebtWithoutRedistribution</span>
  555 | *   | <span class='executed'>                + _singleRedemption.trove.redistBoldDebtGain - _singleRedemption.boldLot;</span>
  556 | *   | <span class='executed'>            _singleRedemption.oldWeightedRecordedDebt = _singleRedemption.batch.weightedRecordedDebt;</span>
  557 | *   | <span class='executed'>            _singleRedemption.newWeightedRecordedDebt =</span>
  558 | *   | <span class='executed'>                newAmountForWeightedDebt * _singleRedemption.batch.annualInterestRate;</span>
  559 |     | <span class='neutral'></span>
  560 | *   | <span class='executed'>            TroveChange memory troveChange;</span>
  561 | *   | <span class='executed'>            troveChange.debtDecrease = _singleRedemption.boldLot;</span>
  562 | *   | <span class='executed'>            troveChange.collDecrease = _singleRedemption.collLot;</span>
  563 | *   | <span class='executed'>            troveChange.appliedRedistBoldDebtGain = _singleRedemption.trove.redistBoldDebtGain;</span>
  564 | *   | <span class='executed'>            troveChange.appliedRedistCollGain = _singleRedemption.trove.redistCollGain;</span>
  565 |     | <span class='neutral'>            // batchAccruedManagementFee is handled in the outer function</span>
  566 | *   | <span class='executed'>            troveChange.oldWeightedRecordedBatchManagementFee =</span>
  567 | *   | <span class='executed'>                _singleRedemption.batch.weightedRecordedBatchManagementFee;</span>
  568 | *   | <span class='executed'>            troveChange.newWeightedRecordedBatchManagementFee =</span>
  569 | *   | <span class='executed'>                newAmountForWeightedDebt * _singleRedemption.batch.annualManagementFee;</span>
  570 |     | <span class='neutral'></span>
  571 | *   | <span class='executed'>            activePool.mintBatchManagementFeeAndAccountForChange(troveChange, _singleRedemption.batchAddress);</span>
  572 |     | <span class='neutral'></span>
  573 | *   | <span class='executed'>            Troves[_singleRedemption.troveId].coll = newColl;</span>
  574 |     | <span class='neutral'>            // interest and fee were updated in the outer function</span>
  575 |     | <span class='neutral'>            // This call could revert due to BatchSharesRatioTooHigh if trove.redistCollGain &gt; boldLot</span>
  576 |     | <span class='neutral'>            // so we skip that check to avoid blocking redemptions</span>
  577 | *   | <span class='executed'>            _updateBatchShares(</span>
  578 | *   | <span class='executed'>                _singleRedemption.troveId,</span>
  579 | *   | <span class='executed'>                _singleRedemption.batchAddress,</span>
  580 | *   | <span class='executed'>                troveChange,</span>
  581 | *   | <span class='executed'>                newDebt,</span>
  582 | *   | <span class='executed'>                _singleRedemption.batch.entireCollWithoutRedistribution,</span>
  583 | *   | <span class='executed'>                _singleRedemption.batch.entireDebtWithoutRedistribution,</span>
  584 |     | <span class='neutral'>                false // _checkBatchSharesRatio</span>
  585 |     | <span class='neutral'>            );</span>
  586 |     | <span class='neutral'>        } else {</span>
  587 | *   | <span class='executed'>            _singleRedemption.oldWeightedRecordedDebt = _singleRedemption.trove.weightedRecordedDebt;</span>
  588 | *   | <span class='executed'>            _singleRedemption.newWeightedRecordedDebt = newDebt * _singleRedemption.trove.annualInterestRate;</span>
  589 | *   | <span class='executed'>            Troves[_singleRedemption.troveId].debt = newDebt;</span>
  590 | *   | <span class='executed'>            Troves[_singleRedemption.troveId].coll = newColl;</span>
  591 | *   | <span class='executed'>            Troves[_singleRedemption.troveId].lastDebtUpdateTime = uint64(block.timestamp);</span>
  592 |     | <span class='neutral'>        }</span>
  593 |     | <span class='neutral'></span>
  594 | *   | <span class='executed'>        _singleRedemption.newStake = _updateStakeAndTotalStakes(_singleRedemption.troveId, newColl);</span>
  595 | *   | <span class='executed'>        _movePendingTroveRewardsToActivePool(</span>
  596 | *   | <span class='executed'>            _defaultPool, _singleRedemption.trove.redistBoldDebtGain, _singleRedemption.trove.redistCollGain</span>
  597 |     | <span class='neutral'>        );</span>
  598 | *   | <span class='executed'>        _updateTroveRewardSnapshots(_singleRedemption.troveId);</span>
  599 |     | <span class='neutral'></span>
  600 | *   | <span class='executed'>        if (_isTroveInBatch) {</span>
  601 | *   | <span class='executed'>            emit BatchedTroveUpdated({</span>
  602 | *   | <span class='executed'>                _troveId: _singleRedemption.troveId,</span>
  603 | *   | <span class='executed'>                _interestBatchManager: _singleRedemption.batchAddress,</span>
  604 | *   | <span class='executed'>                _batchDebtShares: Troves[_singleRedemption.troveId].batchDebtShares,</span>
  605 | *   | <span class='executed'>                _coll: newColl,</span>
  606 | *   | <span class='executed'>                _stake: _singleRedemption.newStake,</span>
  607 | *   | <span class='executed'>                _snapshotOfTotalCollRedist: L_coll,</span>
  608 | *   | <span class='executed'>                _snapshotOfTotalDebtRedist: L_boldDebt</span>
  609 |     | <span class='neutral'>            });</span>
  610 |     | <span class='neutral'>        } else {</span>
  611 | *   | <span class='executed'>            emit TroveUpdated({</span>
  612 | *   | <span class='executed'>                _troveId: _singleRedemption.troveId,</span>
  613 | *   | <span class='executed'>                _debt: newDebt,</span>
  614 | *   | <span class='executed'>                _coll: newColl,</span>
  615 | *   | <span class='executed'>                _stake: _singleRedemption.newStake,</span>
  616 | *   | <span class='executed'>                _annualInterestRate: _singleRedemption.trove.annualInterestRate,</span>
  617 | *   | <span class='executed'>                _snapshotOfTotalCollRedist: L_coll,</span>
  618 | *   | <span class='executed'>                _snapshotOfTotalDebtRedist: L_boldDebt</span>
  619 |     | <span class='neutral'>            });</span>
  620 |     | <span class='neutral'>        }</span>
  621 |     | <span class='neutral'></span>
  622 | *   | <span class='executed'>        emit TroveOperation({</span>
  623 | *   | <span class='executed'>            _troveId: _singleRedemption.troveId,</span>
  624 | *   | <span class='executed'>            _operation: Operation.redeemCollateral,</span>
  625 | *   | <span class='executed'>            _annualInterestRate: _singleRedemption.trove.annualInterestRate,</span>
  626 | *   | <span class='executed'>            _debtIncreaseFromRedist: _singleRedemption.trove.redistBoldDebtGain,</span>
  627 | *   | <span class='executed'>            _debtIncreaseFromUpfrontFee: 0,</span>
  628 | *   | <span class='executed'>            _debtChangeFromOperation: -int256(_singleRedemption.boldLot),</span>
  629 | *   | <span class='executed'>            _collIncreaseFromRedist: _singleRedemption.trove.redistCollGain,</span>
  630 | *   | <span class='executed'>            _collChangeFromOperation: -int256(_singleRedemption.collLot)</span>
  631 |     | <span class='neutral'>        });</span>
  632 |     | <span class='neutral'></span>
  633 | *   | <span class='executed'>        if (_isTroveInBatch) {</span>
  634 | *   | <span class='executed'>            emit BatchUpdated({</span>
  635 | *   | <span class='executed'>                _interestBatchManager: _singleRedemption.batchAddress,</span>
  636 | *   | <span class='executed'>                _operation: BatchOperation.troveChange,</span>
  637 | *   | <span class='executed'>                _debt: batches[_singleRedemption.batchAddress].debt,</span>
  638 | *   | <span class='executed'>                _coll: batches[_singleRedemption.batchAddress].coll,</span>
  639 | *   | <span class='executed'>                _annualInterestRate: _singleRedemption.batch.annualInterestRate,</span>
  640 | *   | <span class='executed'>                _annualManagementFee: _singleRedemption.batch.annualManagementFee,</span>
  641 | *   | <span class='executed'>                _totalDebtShares: batches[_singleRedemption.batchAddress].totalDebtShares,</span>
  642 |     | <span class='neutral'>                _debtIncreaseFromUpfrontFee: 0</span>
  643 |     | <span class='neutral'>            });</span>
  644 |     | <span class='neutral'>        }</span>
  645 |     | <span class='neutral'></span>
  646 | *   | <span class='executed'>        emit RedemptionFeePaidToTrove(_singleRedemption.troveId, _singleRedemption.collFee);</span>
  647 |     | <span class='neutral'></span>
  648 | *   | <span class='executed'>        return newDebt;</span>
  649 |     | <span class='neutral'>    }</span>
  650 |     | <span class='neutral'></span>
  651 |     | <span class='neutral'>    // Redeem as much collateral as possible from _borrower&#39;s Trove in exchange for Bold up to _maxBoldamount</span>
  652 | *   | <span class='executed'>    function _redeemCollateralFromTrove(</span>
  653 |     | <span class='neutral'>        IDefaultPool _defaultPool,</span>
  654 |     | <span class='neutral'>        SingleRedemptionValues memory _singleRedemption,</span>
  655 |     | <span class='neutral'>        uint256 _maxBoldamount,</span>
  656 |     | <span class='neutral'>        uint256 _price,</span>
  657 |     | <span class='neutral'>        uint256 _redemptionRate</span>
  658 |     | <span class='unexecuted'>    ) internal {</span>
  659 | *   | <span class='executed'>        _getLatestTroveData(_singleRedemption.troveId, _singleRedemption.trove);</span>
  660 |     | <span class='neutral'></span>
  661 |     | <span class='neutral'>        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove</span>
  662 | *   | <span class='executed'>        _singleRedemption.boldLot = LiquityMath._min(_maxBoldamount, _singleRedemption.trove.entireDebt);</span>
  663 |     | <span class='neutral'></span>
  664 |     | <span class='neutral'>        // Get the amount of Coll equal in USD value to the boldLot redeemed</span>
  665 | *   | <span class='executed'>        uint256 correspondingColl = _singleRedemption.boldLot * DECIMAL_PRECISION / _price;</span>
  666 |     | <span class='neutral'>        // Calculate the collFee separately (for events)</span>
  667 | *   | <span class='executed'>        _singleRedemption.collFee = correspondingColl * _redemptionRate / DECIMAL_PRECISION;</span>
  668 |     | <span class='neutral'>        // Get the final collLot to send to redeemer, leaving the fee in the Trove</span>
  669 | *   | <span class='executed'>        _singleRedemption.collLot = correspondingColl - _singleRedemption.collFee;</span>
  670 |     | <span class='neutral'></span>
  671 | *   | <span class='executed'>        bool isTroveInBatch = _singleRedemption.batchAddress != address(0);</span>
  672 | *   | <span class='executed'>        uint256 newDebt = _applySingleRedemption(_defaultPool, _singleRedemption, isTroveInBatch);</span>
  673 |     | <span class='neutral'></span>
  674 |     | <span class='neutral'>        // Make Trove zombie if it&#39;s tiny (and it wasn’t already), in order to prevent griefing future (normal, sequential) redemptions</span>
  675 | *   | <span class='executed'>        if (newDebt &lt; MIN_DEBT) {</span>
  676 | *   | <span class='executed'>            if (!_singleRedemption.isZombieTrove) {</span>
  677 | *   | <span class='executed'>                Troves[_singleRedemption.troveId].status = Status.zombie;</span>
  678 | *   | <span class='executed'>                if (isTroveInBatch) {</span>
  679 | *   | <span class='executed'>                    sortedTroves.removeFromBatch(_singleRedemption.troveId);</span>
  680 |     | <span class='neutral'>                } else {</span>
  681 | *   | <span class='executed'>                    sortedTroves.remove(_singleRedemption.troveId);</span>
  682 |     | <span class='neutral'>                }</span>
  683 |     | <span class='neutral'>                // If it’s a partial redemption, let’s store a pointer to it so it’s used first in the next one</span>
  684 | *   | <span class='executed'>                if (newDebt &gt; 0) {</span>
  685 | *   | <span class='executed'>                    lastZombieTroveId = _singleRedemption.troveId;</span>
  686 |     | <span class='neutral'>                }</span>
  687 |     | <span class='unexecuted'>            } else if (newDebt == 0) {</span>
  688 |     | <span class='neutral'>                // Reset last zombie trove pointer if the previous one was fully redeemed now</span>
  689 |     | <span class='unexecuted'>                lastZombieTroveId = 0;</span>
  690 |     | <span class='neutral'>            }</span>
  691 |     | <span class='neutral'>        }</span>
  692 |     | <span class='neutral'>        // Note: technically, it could happen that the Trove pointed to by `lastZombieTroveId` ends up with</span>
  693 |     | <span class='neutral'>        // newDebt &gt;= MIN_DEBT thanks to BOLD debt redistribution, which means it _could_ be made active again,</span>
  694 |     | <span class='neutral'>        // however we don&#39;t do that here, as it would require hints for re-insertion into `SortedTroves`.</span>
  695 |     | <span class='neutral'>    }</span>
  696 |     | <span class='neutral'></span>
  697 | *   | <span class='executed'>    function _updateBatchInterestPriorToRedemption(IActivePool _activePool, address _batchAddress) internal {</span>
  698 | *   | <span class='executed'>        LatestBatchData memory batch;</span>
  699 | *   | <span class='executed'>        _getLatestBatchData(_batchAddress, batch);</span>
  700 | *   | <span class='executed'>        batches[_batchAddress].debt = batch.entireDebtWithoutRedistribution;</span>
  701 | *   | <span class='executed'>        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);</span>
  702 |     | <span class='neutral'>        // As we are updating the batch, we update the ActivePool weighted sum too</span>
  703 | *   | <span class='executed'>        TroveChange memory batchTroveChange;</span>
  704 | *   | <span class='executed'>        batchTroveChange.oldWeightedRecordedDebt = batch.weightedRecordedDebt;</span>
  705 | *   | <span class='executed'>        batchTroveChange.newWeightedRecordedDebt = batch.entireDebtWithoutRedistribution * batch.annualInterestRate;</span>
  706 | *   | <span class='executed'>        batchTroveChange.batchAccruedManagementFee = batch.accruedManagementFee;</span>
  707 | *   | <span class='executed'>        batchTroveChange.oldWeightedRecordedBatchManagementFee = batch.weightedRecordedBatchManagementFee;</span>
  708 | *   | <span class='executed'>        batchTroveChange.newWeightedRecordedBatchManagementFee =</span>
  709 | *   | <span class='executed'>            batch.entireDebtWithoutRedistribution * batch.annualManagementFee;</span>
  710 |     | <span class='neutral'></span>
  711 | *   | <span class='executed'>        _activePool.mintAggInterestAndAccountForTroveChange(batchTroveChange, _batchAddress);</span>
  712 |     | <span class='neutral'>    }</span>
  713 |     | <span class='neutral'></span>
  714 |     | <span class='neutral'>    /* Send _boldamount Bold to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption</span>
  715 |     | <span class='neutral'>    * request.  Applies redistribution gains to a Trove before reducing its debt and coll.</span>
  716 |     | <span class='neutral'>    *</span>
  717 |     | <span class='neutral'>    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by</span>
  718 |     | <span class='neutral'>    * splitting the total _amount in appropriate chunks and calling the function multiple times.</span>
  719 |     | <span class='neutral'>    *</span>
  720 |     | <span class='neutral'>    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to</span>
  721 |     | <span class='neutral'>    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”</span>
  722 |     | <span class='neutral'>    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode</span>
  723 |     | <span class='neutral'>    * costs can vary.</span>
  724 |     | <span class='neutral'>    *</span>
  725 |     | <span class='neutral'>    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, and therefore in “zombie” state</span>
  726 |     | <span class='neutral'>    */</span>
  727 | *   | <span class='executed'>    function redeemCollateral(</span>
  728 |     | <span class='neutral'>        address _redeemer,</span>
  729 |     | <span class='neutral'>        uint256 _boldamount,</span>
  730 |     | <span class='neutral'>        uint256 _price,</span>
  731 |     | <span class='neutral'>        uint256 _redemptionRate,</span>
  732 |     | <span class='neutral'>        uint256 _maxIterations</span>
  733 | *   | <span class='executed'>    ) external override returns (uint256 _redemeedAmount) {</span>
  734 | *   | <span class='executed'>        _requireCallerIsCollateralRegistry();</span>
  735 |     | <span class='neutral'></span>
  736 | *   | <span class='executed'>        IActivePool activePoolCached = activePool;</span>
  737 | *   | <span class='executed'>        ISortedTroves sortedTrovesCached = sortedTroves;</span>
  738 |     | <span class='neutral'></span>
  739 | *   | <span class='executed'>        TroveChange memory totalsTroveChange;</span>
  740 | *   | <span class='executed'>        uint256 totalCollFee;</span>
  741 |     | <span class='neutral'></span>
  742 | *   | <span class='executed'>        uint256 remainingBold = _boldamount;</span>
  743 |     | <span class='neutral'></span>
  744 | *   | <span class='executed'>        SingleRedemptionValues memory singleRedemption;</span>
  745 |     | <span class='neutral'>        // Let’s check if there’s a pending zombie trove from previous redemption</span>
  746 | *   | <span class='executed'>        if (lastZombieTroveId != 0) {</span>
  747 |     | <span class='unexecuted'>            singleRedemption.troveId = lastZombieTroveId;</span>
  748 |     | <span class='unexecuted'>            singleRedemption.isZombieTrove = true;</span>
  749 |     | <span class='neutral'>        } else {</span>
  750 | *   | <span class='executed'>            singleRedemption.troveId = sortedTrovesCached.getLast();</span>
  751 |     | <span class='neutral'>        }</span>
  752 | *   | <span class='executed'>        address lastBatchUpdatedInterest = address(0);</span>
  753 |     | <span class='neutral'></span>
  754 |     | <span class='neutral'>        // Loop through the Troves starting from the one with lowest interest rate until _amount of Bold is exchanged for collateral</span>
  755 | *   | <span class='executed'>        if (_maxIterations == 0) _maxIterations = type(uint256).max;</span>
  756 | *   | <span class='executed'>        while (singleRedemption.troveId != 0 &amp;&amp; remainingBold &gt; 0 &amp;&amp; _maxIterations &gt; 0) {</span>
  757 | *   | <span class='executed'>            _maxIterations--;</span>
  758 |     | <span class='neutral'>            // Save the uint256 of the Trove preceding the current one</span>
  759 | *   | <span class='executed'>            uint256 nextUserToCheck;</span>
  760 | *   | <span class='executed'>            if (singleRedemption.isZombieTrove) {</span>
  761 |     | <span class='unexecuted'>                nextUserToCheck = sortedTrovesCached.getLast();</span>
  762 |     | <span class='neutral'>            } else {</span>
  763 | *   | <span class='executed'>                nextUserToCheck = sortedTrovesCached.getPrev(singleRedemption.troveId);</span>
  764 |     | <span class='neutral'>            }</span>
  765 |     | <span class='neutral'></span>
  766 |     | <span class='neutral'>            // Skip if ICR &lt; 100%, to make sure that redemptions don’t decrease the CR of hit Troves</span>
  767 | *   | <span class='executed'>            if (getCurrentICR(singleRedemption.troveId, _price) &lt; _100pct) {</span>
  768 |     | <span class='unexecuted'>                singleRedemption.troveId = nextUserToCheck;</span>
  769 |     | <span class='unexecuted'>                singleRedemption.isZombieTrove = false;</span>
  770 |     | <span class='unexecuted'>                continue;</span>
  771 |     | <span class='neutral'>            }</span>
  772 |     | <span class='neutral'></span>
  773 |     | <span class='neutral'>            // If it’s in a batch, we need to update interest first</span>
  774 |     | <span class='neutral'>            // We do it here outside, to avoid repeating for each trove in the same batch</span>
  775 | *   | <span class='executed'>            singleRedemption.batchAddress = _getBatchManager(singleRedemption.troveId);</span>
  776 | *   | <span class='executed'>            if (</span>
  777 | *   | <span class='executed'>                singleRedemption.batchAddress != address(0) &amp;&amp; singleRedemption.batchAddress != lastBatchUpdatedInterest</span>
  778 |     | <span class='neutral'>            ) {</span>
  779 | *   | <span class='executed'>                _updateBatchInterestPriorToRedemption(activePoolCached, singleRedemption.batchAddress);</span>
  780 | *   | <span class='executed'>                lastBatchUpdatedInterest = singleRedemption.batchAddress;</span>
  781 |     | <span class='neutral'>            }</span>
  782 |     | <span class='neutral'></span>
  783 | *   | <span class='executed'>            _redeemCollateralFromTrove(defaultPool, singleRedemption, remainingBold, _price, _redemptionRate);</span>
  784 |     | <span class='neutral'></span>
  785 | *   | <span class='executed'>            totalsTroveChange.collDecrease += singleRedemption.collLot;</span>
  786 | *   | <span class='executed'>            totalsTroveChange.debtDecrease += singleRedemption.boldLot;</span>
  787 | *   | <span class='executed'>            totalsTroveChange.appliedRedistBoldDebtGain += singleRedemption.appliedRedistBoldDebtGain;</span>
  788 |     | <span class='neutral'>            // For recorded and weighted recorded debt totals, we need to capture the increases and decreases,</span>
  789 |     | <span class='neutral'>            // since the net debt change for a given Trove could be positive or negative: redemptions decrease a Trove&#39;s recorded</span>
  790 |     | <span class='neutral'>            // (and weighted recorded) debt, but the accrued interest increases it.</span>
  791 | *   | <span class='executed'>            totalsTroveChange.newWeightedRecordedDebt += singleRedemption.newWeightedRecordedDebt;</span>
  792 | *   | <span class='executed'>            totalsTroveChange.oldWeightedRecordedDebt += singleRedemption.oldWeightedRecordedDebt;</span>
  793 | *   | <span class='executed'>            totalCollFee += singleRedemption.collFee;</span>
  794 |     | <span class='neutral'></span>
  795 | *   | <span class='executed'>            remainingBold -= singleRedemption.boldLot;</span>
  796 | *   | <span class='executed'>            singleRedemption.troveId = nextUserToCheck;</span>
  797 | *   | <span class='executed'>            singleRedemption.isZombieTrove = false;</span>
  798 |     | <span class='neutral'>        }</span>
  799 |     | <span class='neutral'></span>
  800 |     | <span class='neutral'>        // We are removing this condition to prevent blocking redemptions</span>
  801 |     | <span class='neutral'>        //require(totals.totalCollDrawn &gt; 0, &quot;TroveManager: Unable to redeem any amount&quot;);</span>
  802 |     | <span class='neutral'></span>
  803 | *   | <span class='executed'>        emit Redemption(</span>
  804 | *   | <span class='executed'>            _boldamount, totalsTroveChange.debtDecrease, totalsTroveChange.collDecrease, totalCollFee, _price</span>
  805 |     | <span class='neutral'>        );</span>
  806 |     | <span class='neutral'></span>
  807 | *   | <span class='executed'>        activePoolCached.mintAggInterestAndAccountForTroveChange(totalsTroveChange, address(0));</span>
  808 |     | <span class='neutral'></span>
  809 |     | <span class='neutral'>        // Send the redeemed Coll to sender</span>
  810 | *   | <span class='executed'>        activePoolCached.sendColl(_redeemer, totalsTroveChange.collDecrease);</span>
  811 |     | <span class='neutral'>        // We’ll burn all the Bold together out in the CollateralRegistry, to save gas</span>
  812 |     | <span class='neutral'></span>
  813 | *   | <span class='executed'>        return totalsTroveChange.debtDecrease;</span>
  814 |     | <span class='neutral'>    }</span>
  815 |     | <span class='neutral'></span>
  816 |     | <span class='neutral'>    // Redeem as much collateral as possible from _borrower&#39;s Trove in exchange for Bold up to _maxBoldamount</span>
  817 |     | <span class='unexecuted'>    function _urgentRedeemCollateralFromTrove(</span>
  818 |     | <span class='neutral'>        IDefaultPool _defaultPool,</span>
  819 |     | <span class='neutral'>        uint256 _maxBoldamount,</span>
  820 |     | <span class='neutral'>        uint256 _price,</span>
  821 |     | <span class='neutral'>        SingleRedemptionValues memory _singleRedemption</span>
  822 |     | <span class='unexecuted'>    ) internal {</span>
  823 |     | <span class='neutral'>        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve</span>
  824 |     | <span class='unexecuted'>        _singleRedemption.boldLot = LiquityMath._min(_maxBoldamount, _singleRedemption.trove.entireDebt);</span>
  825 |     | <span class='neutral'></span>
  826 |     | <span class='neutral'>        // Get the amount of ETH equal in USD value to the BOLD lot redeemed</span>
  827 |     | <span class='unexecuted'>        _singleRedemption.collLot = _singleRedemption.boldLot * (DECIMAL_PRECISION + URGENT_REDEMPTION_BONUS) / _price;</span>
  828 |     | <span class='neutral'>        // As here we can redeem when CR &lt; 101% (accounting for 1% bonus), we need to cap by collateral too</span>
  829 |     | <span class='unexecuted'>        if (_singleRedemption.collLot &gt; _singleRedemption.trove.entireColl) {</span>
  830 |     | <span class='unexecuted'>            _singleRedemption.collLot = _singleRedemption.trove.entireColl;</span>
  831 |     | <span class='unexecuted'>            _singleRedemption.boldLot =</span>
  832 |     | <span class='unexecuted'>                _singleRedemption.trove.entireColl * _price / (DECIMAL_PRECISION + URGENT_REDEMPTION_BONUS);</span>
  833 |     | <span class='neutral'>        }</span>
  834 |     | <span class='neutral'></span>
  835 |     | <span class='unexecuted'>        bool isTroveInBatch = _singleRedemption.batchAddress != address(0);</span>
  836 |     | <span class='unexecuted'>        _applySingleRedemption(_defaultPool, _singleRedemption, isTroveInBatch);</span>
  837 |     | <span class='neutral'></span>
  838 |     | <span class='neutral'>        // No need to make this Trove zombie if it has tiny debt, since:</span>
  839 |     | <span class='neutral'>        // - This collateral branch has shut down and urgent redemptions are enabled</span>
  840 |     | <span class='neutral'>        // - Urgent redemptions aren&#39;t sequential, so they can&#39;t be griefed by tiny Troves.</span>
  841 |     | <span class='neutral'>    }</span>
  842 |     | <span class='neutral'></span>
  843 | *   | <span class='executed'>    function urgentRedemption(uint256 _boldAmount, uint256[] calldata _troveIds, uint256 _minCollateral) external {</span>
  844 | *   | <span class='executed'>        _requireIsShutDown();</span>
  845 | *   | <span class='executed'>        _requireAmountGreaterThanZero(_boldAmount);</span>
  846 | *   | <span class='executed'>        _requireBoldBalanceCoversRedemption(boldToken, msg.sender, _boldAmount);</span>
  847 |     | <span class='neutral'></span>
  848 | *   | <span class='executed'>        IActivePool activePoolCached = activePool;</span>
  849 | *   | <span class='executed'>        TroveChange memory totalsTroveChange;</span>
  850 |     | <span class='neutral'></span>
  851 |     | <span class='neutral'>        // Use the standard fetchPrice here, since if branch has shut down we don&#39;t worry about small redemption arbs</span>
  852 | *   | <span class='executed'>        (uint256 price,) = priceFeed.fetchPrice();</span>
  853 |     | <span class='neutral'></span>
  854 | *   | <span class='executed'>        uint256 remainingBold = _boldAmount;</span>
  855 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; _troveIds.length; i++) {</span>
  856 | *   | <span class='executed'>            if (remainingBold == 0) break;</span>
  857 |     | <span class='neutral'></span>
  858 | *   | <span class='executed'>            SingleRedemptionValues memory singleRedemption;</span>
  859 | *   | <span class='executed'>            singleRedemption.troveId = _troveIds[i];</span>
  860 | *   | <span class='executed'>            _getLatestTroveData(singleRedemption.troveId, singleRedemption.trove);</span>
  861 |     | <span class='neutral'></span>
  862 | *   | <span class='executed'>            if (!_isActiveOrZombie(Troves[singleRedemption.troveId].status) || singleRedemption.trove.entireDebt == 0) {</span>
  863 | *   | <span class='executed'>                continue;</span>
  864 |     | <span class='neutral'>            }</span>
  865 |     | <span class='neutral'></span>
  866 |     | <span class='neutral'>            // If it’s in a batch, we need to update interest first</span>
  867 |     | <span class='neutral'>            // As we don’t have them ordered now, we cannot avoid repeating for each trove in the same batch</span>
  868 |     | <span class='unexecuted'>            singleRedemption.batchAddress = _getBatchManager(singleRedemption.troveId);</span>
  869 |     | <span class='unexecuted'>            if (singleRedemption.batchAddress != address(0)) {</span>
  870 |     | <span class='unexecuted'>                _updateBatchInterestPriorToRedemption(activePoolCached, singleRedemption.batchAddress);</span>
  871 |     | <span class='neutral'>            }</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='unexecuted'>            _urgentRedeemCollateralFromTrove(defaultPool, remainingBold, price, singleRedemption);</span>
  874 |     | <span class='neutral'></span>
  875 |     | <span class='unexecuted'>            totalsTroveChange.collDecrease += singleRedemption.collLot;</span>
  876 |     | <span class='unexecuted'>            totalsTroveChange.debtDecrease += singleRedemption.boldLot;</span>
  877 |     | <span class='unexecuted'>            totalsTroveChange.appliedRedistBoldDebtGain += singleRedemption.appliedRedistBoldDebtGain;</span>
  878 |     | <span class='neutral'>            // For recorded and weighted recorded debt totals, we need to capture the increases and decreases,</span>
  879 |     | <span class='neutral'>            // since the net debt change for a given Trove could be positive or negative: redemptions decrease a Trove&#39;s recorded</span>
  880 |     | <span class='neutral'>            // (and weighted recorded) debt, but the accrued interest increases it.</span>
  881 |     | <span class='unexecuted'>            totalsTroveChange.newWeightedRecordedDebt += singleRedemption.newWeightedRecordedDebt;</span>
  882 |     | <span class='unexecuted'>            totalsTroveChange.oldWeightedRecordedDebt += singleRedemption.oldWeightedRecordedDebt;</span>
  883 |     | <span class='neutral'></span>
  884 |     | <span class='unexecuted'>            remainingBold -= singleRedemption.boldLot;</span>
  885 |     | <span class='neutral'>        }</span>
  886 |     | <span class='neutral'></span>
  887 | *   | <span class='executed'>        if (totalsTroveChange.collDecrease &lt; _minCollateral) {</span>
  888 | *   | <span class='executed'>            revert MinCollNotReached(totalsTroveChange.collDecrease);</span>
  889 |     | <span class='neutral'>        }</span>
  890 |     | <span class='neutral'></span>
  891 | *   | <span class='executed'>        emit Redemption(_boldAmount, totalsTroveChange.debtDecrease, totalsTroveChange.collDecrease, 0, price);</span>
  892 |     | <span class='neutral'></span>
  893 |     | <span class='neutral'>        // Since this branch is shut down, this will mint 0 interest.</span>
  894 |     | <span class='neutral'>        // We call this only to update the aggregate debt and weighted debt trackers.</span>
  895 | *   | <span class='executed'>        activePoolCached.mintAggInterestAndAccountForTroveChange(totalsTroveChange, address(0));</span>
  896 |     | <span class='neutral'></span>
  897 |     | <span class='neutral'>        // Send the redeemed coll to caller</span>
  898 | *   | <span class='executed'>        activePoolCached.sendColl(msg.sender, totalsTroveChange.collDecrease);</span>
  899 |     | <span class='neutral'>        // Burn bold</span>
  900 | *   | <span class='executed'>        boldToken.burn(msg.sender, totalsTroveChange.debtDecrease);</span>
  901 |     | <span class='neutral'>    }</span>
  902 |     | <span class='neutral'></span>
  903 | *   | <span class='executed'>    function shutdown() external {</span>
  904 | *   | <span class='executed'>        _requireCallerIsBorrowerOperations();</span>
  905 | *   | <span class='executed'>        shutdownTime = block.timestamp;</span>
  906 | *   | <span class='executed'>        activePool.setShutdownFlag();</span>
  907 |     | <span class='neutral'>    }</span>
  908 |     | <span class='neutral'></span>
  909 |     | <span class='neutral'>    // --- Helper functions ---</span>
  910 |     | <span class='neutral'></span>
  911 |     | <span class='neutral'>    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove&#39;s pending coll and debt rewards from redistributions into account.</span>
  912 | *   | <span class='executed'>    function getCurrentICR(uint256 _troveId, uint256 _price) public view override returns (uint256) {</span>
  913 | *   | <span class='executed'>        LatestTroveData memory trove;</span>
  914 | *   | <span class='executed'>        _getLatestTroveData(_troveId, trove);</span>
  915 | *   | <span class='executed'>        return LiquityMath._computeCR(trove.entireColl, trove.entireDebt, _price);</span>
  916 |     | <span class='neutral'>    }</span>
  917 |     | <span class='neutral'></span>
  918 | *   | <span class='executed'>    function _updateTroveRewardSnapshots(uint256 _troveId) internal {</span>
  919 | *   | <span class='executed'>        rewardSnapshots[_troveId].coll = L_coll;</span>
  920 | *   | <span class='executed'>        rewardSnapshots[_troveId].boldDebt = L_boldDebt;</span>
  921 |     | <span class='neutral'>    }</span>
  922 |     | <span class='neutral'></span>
  923 |     | <span class='neutral'>    // Return the Troves entire debt and coll, including redistribution gains from redistributions.</span>
  924 | *   | <span class='executed'>    function _getLatestTroveData(uint256 _troveId, LatestTroveData memory trove) internal view {</span>
  925 |     | <span class='neutral'>        // If trove belongs to a batch, we fetch the batch and apply its share to obtained values</span>
  926 | *   | <span class='executed'>        address batchAddress = _getBatchManager(_troveId);</span>
  927 | *   | <span class='executed'>        if (batchAddress != address(0)) {</span>
  928 | *   | <span class='executed'>            LatestBatchData memory batch;</span>
  929 | *   | <span class='executed'>            _getLatestBatchData(batchAddress, batch);</span>
  930 | *   | <span class='executed'>            _getLatestTroveDataFromBatch(_troveId, batchAddress, trove, batch);</span>
  931 |     | <span class='neutral'>            return;</span>
  932 |     | <span class='neutral'>        }</span>
  933 |     | <span class='neutral'></span>
  934 | *   | <span class='executed'>        uint256 stake = Troves[_troveId].stake;</span>
  935 | *   | <span class='executed'>        trove.redistBoldDebtGain = stake * (L_boldDebt - rewardSnapshots[_troveId].boldDebt) / DECIMAL_PRECISION;</span>
  936 | *   | <span class='executed'>        trove.redistCollGain = stake * (L_coll - rewardSnapshots[_troveId].coll) / DECIMAL_PRECISION;</span>
  937 |     | <span class='neutral'></span>
  938 | *   | <span class='executed'>        trove.recordedDebt = Troves[_troveId].debt;</span>
  939 | *   | <span class='executed'>        trove.annualInterestRate = Troves[_troveId].annualInterestRate;</span>
  940 | *   | <span class='executed'>        trove.weightedRecordedDebt = trove.recordedDebt * trove.annualInterestRate;</span>
  941 |     | <span class='neutral'></span>
  942 | *   | <span class='executed'>        uint256 period = _getInterestPeriod(Troves[_troveId].lastDebtUpdateTime);</span>
  943 | *   | <span class='executed'>        trove.accruedInterest = _calcInterest(trove.weightedRecordedDebt, period);</span>
  944 |     | <span class='neutral'></span>
  945 | *   | <span class='executed'>        trove.entireDebt = trove.recordedDebt + trove.redistBoldDebtGain + trove.accruedInterest;</span>
  946 | *   | <span class='executed'>        trove.entireColl = Troves[_troveId].coll + trove.redistCollGain;</span>
  947 | *   | <span class='executed'>        trove.lastInterestRateAdjTime = Troves[_troveId].lastInterestRateAdjTime;</span>
  948 |     | <span class='neutral'>    }</span>
  949 |     | <span class='neutral'></span>
  950 | *   | <span class='executed'>    function _getLatestTroveDataFromBatch(</span>
  951 |     | <span class='neutral'>        uint256 _troveId,</span>
  952 |     | <span class='neutral'>        address _batchAddress,</span>
  953 |     | <span class='neutral'>        LatestTroveData memory _latestTroveData,</span>
  954 |     | <span class='neutral'>        LatestBatchData memory _latestBatchData</span>
  955 |     | <span class='neutral'>    ) internal view {</span>
  956 | *   | <span class='executed'>        Trove memory trove = Troves[_troveId];</span>
  957 | *   | <span class='executed'>        uint256 batchDebtShares = trove.batchDebtShares;</span>
  958 | *   | <span class='executed'>        uint256 totalDebtShares = batches[_batchAddress].totalDebtShares;</span>
  959 |     | <span class='neutral'></span>
  960 | *   | <span class='executed'>        uint256 stake = trove.stake;</span>
  961 | *   | <span class='executed'>        _latestTroveData.redistBoldDebtGain =</span>
  962 | *   | <span class='executed'>            stake * (L_boldDebt - rewardSnapshots[_troveId].boldDebt) / DECIMAL_PRECISION;</span>
  963 | *   | <span class='executed'>        _latestTroveData.redistCollGain = stake * (L_coll - rewardSnapshots[_troveId].coll) / DECIMAL_PRECISION;</span>
  964 |     | <span class='neutral'></span>
  965 | *   | <span class='executed'>        if (totalDebtShares &gt; 0) {</span>
  966 | *   | <span class='executed'>            _latestTroveData.recordedDebt = _latestBatchData.recordedDebt * batchDebtShares / totalDebtShares;</span>
  967 | *   | <span class='executed'>            _latestTroveData.weightedRecordedDebt = _latestTroveData.recordedDebt * _latestBatchData.annualInterestRate;</span>
  968 | *   | <span class='executed'>            _latestTroveData.accruedInterest = _latestBatchData.accruedInterest * batchDebtShares / totalDebtShares;</span>
  969 | *   | <span class='executed'>            _latestTroveData.accruedBatchManagementFee =</span>
  970 | *   | <span class='executed'>                _latestBatchData.accruedManagementFee * batchDebtShares / totalDebtShares;</span>
  971 |     | <span class='neutral'>        }</span>
  972 | *   | <span class='executed'>        _latestTroveData.annualInterestRate = _latestBatchData.annualInterestRate;</span>
  973 |     | <span class='neutral'></span>
  974 |     | <span class='neutral'>        // We can’t do pro-rata batch entireDebt, because redist gains are proportional to coll, not to debt</span>
  975 | *   | <span class='executed'>        _latestTroveData.entireDebt = _latestTroveData.recordedDebt + _latestTroveData.redistBoldDebtGain</span>
  976 | *   | <span class='executed'>            + _latestTroveData.accruedInterest + _latestTroveData.accruedBatchManagementFee;</span>
  977 | *   | <span class='executed'>        _latestTroveData.entireColl = trove.coll + _latestTroveData.redistCollGain;</span>
  978 | *   | <span class='executed'>        _latestTroveData.lastInterestRateAdjTime =</span>
  979 | *   | <span class='executed'>            LiquityMath._max(_latestBatchData.lastInterestRateAdjTime, trove.lastInterestRateAdjTime);</span>
  980 |     | <span class='neutral'>    }</span>
  981 |     | <span class='neutral'></span>
  982 | *   | <span class='executed'>    function getLatestTroveData(uint256 _troveId) external view returns (LatestTroveData memory trove) {</span>
  983 | *   | <span class='executed'>        _getLatestTroveData(_troveId, trove);</span>
  984 |     | <span class='neutral'>    }</span>
  985 |     | <span class='neutral'></span>
  986 | *   | <span class='executed'>    function getTroveAnnualInterestRate(uint256 _troveId) external view returns (uint256) {</span>
  987 | *   | <span class='executed'>        Trove memory trove = Troves[_troveId];</span>
  988 | *   | <span class='executed'>        address batchAddress = _getBatchManager(trove);</span>
  989 | *   | <span class='executed'>        if (batchAddress != address(0)) {</span>
  990 | *   | <span class='executed'>            return batches[batchAddress].annualInterestRate;</span>
  991 |     | <span class='neutral'>        }</span>
  992 | *   | <span class='executed'>        return trove.annualInterestRate;</span>
  993 |     | <span class='neutral'>    }</span>
  994 |     | <span class='neutral'></span>
  995 | *   | <span class='executed'>    function _getBatchManager(uint256 _troveId) internal view returns (address) {</span>
  996 | *   | <span class='executed'>        return Troves[_troveId].interestBatchManager;</span>
  997 |     | <span class='neutral'>    }</span>
  998 |     | <span class='neutral'></span>
  999 | *   | <span class='executed'>    function _getBatchManager(Trove memory trove) internal pure returns (address) {</span>
 1000 | *   | <span class='executed'>        return trove.interestBatchManager;</span>
 1001 |     | <span class='neutral'>    }</span>
 1002 |     | <span class='neutral'></span>
 1003 |     | <span class='neutral'>    // Return the Batch entire debt and coll, including redistribution gains from redistributions.</span>
 1004 | *   | <span class='executed'>    function _getLatestBatchData(address _batchAddress, LatestBatchData memory latestBatchData) internal view {</span>
 1005 | *   | <span class='executed'>        Batch memory batch = batches[_batchAddress];</span>
 1006 |     | <span class='neutral'></span>
 1007 | *   | <span class='executed'>        latestBatchData.recordedDebt = batch.debt;</span>
 1008 | *   | <span class='executed'>        latestBatchData.annualInterestRate = batch.annualInterestRate;</span>
 1009 | *   | <span class='executed'>        latestBatchData.weightedRecordedDebt = latestBatchData.recordedDebt * latestBatchData.annualInterestRate;</span>
 1010 | *   | <span class='executed'>        uint256 period = _getInterestPeriod(batch.lastDebtUpdateTime);</span>
 1011 | *   | <span class='executed'>        latestBatchData.accruedInterest = _calcInterest(latestBatchData.weightedRecordedDebt, period);</span>
 1012 | *   | <span class='executed'>        latestBatchData.annualManagementFee = batch.annualManagementFee;</span>
 1013 | *   | <span class='executed'>        latestBatchData.weightedRecordedBatchManagementFee =</span>
 1014 | *   | <span class='executed'>            latestBatchData.recordedDebt * latestBatchData.annualManagementFee;</span>
 1015 | *   | <span class='executed'>        latestBatchData.accruedManagementFee = _calcInterest(latestBatchData.weightedRecordedBatchManagementFee, period);</span>
 1016 |     | <span class='neutral'></span>
 1017 | *   | <span class='executed'>        latestBatchData.entireDebtWithoutRedistribution =</span>
 1018 | *   | <span class='executed'>            latestBatchData.recordedDebt + latestBatchData.accruedInterest + latestBatchData.accruedManagementFee;</span>
 1019 | *   | <span class='executed'>        latestBatchData.entireCollWithoutRedistribution = batch.coll;</span>
 1020 | *   | <span class='executed'>        latestBatchData.lastDebtUpdateTime = batch.lastDebtUpdateTime;</span>
 1021 | *   | <span class='executed'>        latestBatchData.lastInterestRateAdjTime = batch.lastInterestRateAdjTime;</span>
 1022 |     | <span class='neutral'>    }</span>
 1023 |     | <span class='neutral'></span>
 1024 | *   | <span class='executed'>    function getLatestBatchData(address _batchAddress) external view returns (LatestBatchData memory batch) {</span>
 1025 | *   | <span class='executed'>        _getLatestBatchData(_batchAddress, batch);</span>
 1026 |     | <span class='neutral'>    }</span>
 1027 |     | <span class='neutral'></span>
 1028 |     | <span class='neutral'>    // Update borrower&#39;s stake based on their latest collateral value</span>
 1029 | *   | <span class='executed'>    function _updateStakeAndTotalStakes(uint256 _troveId, uint256 _coll) internal returns (uint256 newStake) {</span>
 1030 | *   | <span class='executed'>        newStake = _computeNewStake(_coll);</span>
 1031 | *   | <span class='executed'>        uint256 oldStake = Troves[_troveId].stake;</span>
 1032 | *   | <span class='executed'>        Troves[_troveId].stake = newStake;</span>
 1033 |     | <span class='neutral'></span>
 1034 | *   | <span class='executed'>        totalStakes = totalStakes - oldStake + newStake;</span>
 1035 |     | <span class='neutral'>    }</span>
 1036 |     | <span class='neutral'></span>
 1037 |     | <span class='neutral'>    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation</span>
 1038 | *   | <span class='executed'>    function _computeNewStake(uint256 _coll) internal view returns (uint256) {</span>
 1039 | *   | <span class='executed'>        uint256 stake;</span>
 1040 | *   | <span class='executed'>        if (totalCollateralSnapshot == 0) {</span>
 1041 | *   | <span class='executed'>            stake = _coll;</span>
 1042 |     | <span class='neutral'>        } else {</span>
 1043 |     | <span class='neutral'>            /*</span>
 1044 |     | <span class='neutral'>            * The following assert() holds true because:</span>
 1045 |     | <span class='neutral'>            * - The system always contains &gt;= 1 trove</span>
 1046 |     | <span class='neutral'>            * - When we close or liquidate a trove, we redistribute the redistribution gains, so if all troves were closed/liquidated,</span>
 1047 |     | <span class='neutral'>            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.</span>
 1048 |     | <span class='neutral'>            */</span>
 1049 |     | <span class='neutral'>            // assert(totalStakesSnapshot &gt; 0);</span>
 1050 | *   | <span class='executed'>            stake = _coll * totalStakesSnapshot / totalCollateralSnapshot;</span>
 1051 |     | <span class='neutral'>        }</span>
 1052 | *   | <span class='executed'>        return stake;</span>
 1053 |     | <span class='neutral'>    }</span>
 1054 |     | <span class='neutral'></span>
 1055 |     | <span class='unexecuted'>    function _redistributeDebtAndColl(</span>
 1056 |     | <span class='neutral'>        IActivePool _activePool,</span>
 1057 |     | <span class='neutral'>        IDefaultPool _defaultPool,</span>
 1058 |     | <span class='neutral'>        uint256 _debtToRedistribute,</span>
 1059 |     | <span class='neutral'>        uint256 _collToRedistribute</span>
 1060 |     | <span class='neutral'>    ) internal {</span>
 1061 |     | <span class='unexecuted'>        if (_debtToRedistribute == 0) return; // Otherwise _collToRedistribute &gt; 0 too</span>
 1062 |     | <span class='neutral'></span>
 1063 |     | <span class='neutral'>        /*</span>
 1064 |     | <span class='neutral'>        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a &quot;feedback&quot;</span>
 1065 |     | <span class='neutral'>        * error correction, to keep the cumulative error low in the running totals L_coll and L_boldDebt:</span>
 1066 |     | <span class='neutral'>        *</span>
 1067 |     | <span class='neutral'>        * 1) Form numerators which compensate for the floor division errors that occurred the last time this</span>
 1068 |     | <span class='neutral'>        * function was called.</span>
 1069 |     | <span class='neutral'>        * 2) Calculate &quot;per-unit-staked&quot; ratios.</span>
 1070 |     | <span class='neutral'>        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.</span>
 1071 |     | <span class='neutral'>        * 4) Store these errors for use in the next correction when this function is called.</span>
 1072 |     | <span class='neutral'>        * 5) Note: static analysis tools complain about this &quot;division before multiplication&quot;, however, it is intended.</span>
 1073 |     | <span class='neutral'>        */</span>
 1074 |     | <span class='unexecuted'>        uint256 collNumerator = _collToRedistribute * DECIMAL_PRECISION + lastCollError_Redistribution;</span>
 1075 |     | <span class='unexecuted'>        uint256 boldDebtNumerator = _debtToRedistribute * DECIMAL_PRECISION + lastBoldDebtError_Redistribution;</span>
 1076 |     | <span class='neutral'></span>
 1077 |     | <span class='neutral'>        // Get the per-unit-staked terms</span>
 1078 |     | <span class='unexecuted'>        uint256 collRewardPerUnitStaked = collNumerator / totalStakes;</span>
 1079 |     | <span class='unexecuted'>        uint256 boldDebtRewardPerUnitStaked = boldDebtNumerator / totalStakes;</span>
 1080 |     | <span class='neutral'></span>
 1081 |     | <span class='unexecuted'>        lastCollError_Redistribution = collNumerator - collRewardPerUnitStaked * totalStakes;</span>
 1082 |     | <span class='unexecuted'>        lastBoldDebtError_Redistribution = boldDebtNumerator - boldDebtRewardPerUnitStaked * totalStakes;</span>
 1083 |     | <span class='neutral'></span>
 1084 |     | <span class='neutral'>        // Add per-unit-staked terms to the running totals</span>
 1085 |     | <span class='unexecuted'>        L_coll = L_coll + collRewardPerUnitStaked;</span>
 1086 |     | <span class='unexecuted'>        L_boldDebt = L_boldDebt + boldDebtRewardPerUnitStaked;</span>
 1087 |     | <span class='neutral'></span>
 1088 |     | <span class='unexecuted'>        _defaultPool.increaseBoldDebt(_debtToRedistribute);</span>
 1089 |     | <span class='unexecuted'>        _activePool.sendCollToDefaultPool(_collToRedistribute);</span>
 1090 |     | <span class='neutral'>    }</span>
 1091 |     | <span class='neutral'></span>
 1092 |     | <span class='neutral'>    /*</span>
 1093 |     | <span class='neutral'>    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.</span>
 1094 |     | <span class='neutral'>    * Used in a liquidation sequence.</span>
 1095 |     | <span class='neutral'>    */</span>
 1096 |     | <span class='unexecuted'>    function _updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, uint256 _collRemainder) internal {</span>
 1097 |     | <span class='unexecuted'>        totalStakesSnapshot = totalStakes;</span>
 1098 |     | <span class='neutral'></span>
 1099 |     | <span class='unexecuted'>        uint256 activeColl = _activePool.getCollBalance();</span>
 1100 |     | <span class='unexecuted'>        uint256 liquidatedColl = defaultPool.getCollBalance();</span>
 1101 |     | <span class='unexecuted'>        totalCollateralSnapshot = activeColl - _collRemainder + liquidatedColl;</span>
 1102 |     | <span class='neutral'>    }</span>
 1103 |     | <span class='neutral'></span>
 1104 |     | <span class='neutral'>    /*</span>
 1105 |     | <span class='neutral'>    * Remove a Trove owner from the TroveIds array, not preserving array order. Removing owner &#39;B&#39; does the following:</span>
 1106 |     | <span class='neutral'>    * [A B C D E] =&gt; [A E C D], and updates E&#39;s Trove struct to point to its new array index.</span>
 1107 |     | <span class='neutral'>    */</span>
 1108 |     | <span class='unexecuted'>    function _removeTroveId(uint256 _troveId, uint256 TroveIdsArrayLength) internal {</span>
 1109 |     | <span class='unexecuted'>        uint64 index = Troves[_troveId].arrayIndex;</span>
 1110 |     | <span class='unexecuted'>        uint256 idxLast = TroveIdsArrayLength - 1;</span>
 1111 |     | <span class='neutral'></span>
 1112 |     | <span class='neutral'>        // assert(index &lt;= idxLast);</span>
 1113 |     | <span class='neutral'></span>
 1114 |     | <span class='unexecuted'>        uint256 idToMove = TroveIds[idxLast];</span>
 1115 |     | <span class='neutral'></span>
 1116 |     | <span class='unexecuted'>        TroveIds[index] = idToMove;</span>
 1117 |     | <span class='unexecuted'>        Troves[idToMove].arrayIndex = index;</span>
 1118 |     | <span class='neutral'></span>
 1119 |     | <span class='unexecuted'>        TroveIds.pop();</span>
 1120 |     | <span class='neutral'>    }</span>
 1121 |     | <span class='neutral'></span>
 1122 | *   | <span class='executed'>    function getTroveStatus(uint256 _troveId) external view override returns (Status) {</span>
 1123 | *   | <span class='executed'>        return Troves[_troveId].status;</span>
 1124 |     | <span class='neutral'>    }</span>
 1125 |     | <span class='neutral'></span>
 1126 |     | <span class='neutral'>    // --- Interest rate calculations ---</span>
 1127 |     | <span class='neutral'></span>
 1128 | *   | <span class='executed'>    function _getInterestPeriod(uint256 _lastDebtUpdateTime) internal view returns (uint256) {</span>
 1129 | *   | <span class='executed'>        if (shutdownTime == 0) {</span>
 1130 |     | <span class='neutral'>            // If branch is not shut down, interest is earned up to now.</span>
 1131 | *   | <span class='executed'>            return block.timestamp - _lastDebtUpdateTime;</span>
 1132 | *   | <span class='executed'>        } else if (shutdownTime &gt; 0 &amp;&amp; _lastDebtUpdateTime &lt; shutdownTime) {</span>
 1133 |     | <span class='neutral'>            // If branch is shut down and the Trove was not updated since shut down, interest is earned up to the shutdown time.</span>
 1134 | *   | <span class='executed'>            return shutdownTime - _lastDebtUpdateTime;</span>
 1135 |     | <span class='neutral'>        } else {</span>
 1136 |     | <span class='neutral'>            // if (shutdownTime &gt; 0 &amp;&amp; _lastDebtUpdateTime &gt;= shutdownTime)</span>
 1137 |     | <span class='neutral'>            // If branch is shut down and the Trove was updated after shutdown, no interest is earned since.</span>
 1138 |     | <span class='unexecuted'>            return 0;</span>
 1139 |     | <span class='neutral'>        }</span>
 1140 |     | <span class='neutral'>    }</span>
 1141 |     | <span class='neutral'></span>
 1142 |     | <span class='neutral'>    // --- &#39;require&#39; wrapper functions ---</span>
 1143 |     | <span class='neutral'></span>
 1144 | *   | <span class='executed'>    function _requireCallerIsBorrowerOperations() internal view {</span>
 1145 | *   | <span class='executed'>        if (msg.sender != address(borrowerOperations)) {</span>
 1146 |     | <span class='unexecuted'>            revert CallerNotBorrowerOperations();</span>
 1147 |     | <span class='neutral'>        }</span>
 1148 |     | <span class='neutral'>    }</span>
 1149 |     | <span class='neutral'></span>
 1150 | *   | <span class='executed'>    function _requireCallerIsCollateralRegistry() internal view {</span>
 1151 | *   | <span class='executed'>        if (msg.sender != address(collateralRegistry)) {</span>
 1152 |     | <span class='unexecuted'>            revert CallerNotCollateralRegistry();</span>
 1153 |     | <span class='neutral'>        }</span>
 1154 |     | <span class='neutral'>    }</span>
 1155 |     | <span class='neutral'></span>
 1156 |     | <span class='unexecuted'>    function _requireMoreThanOneTroveInSystem(uint256 TroveIdsArrayLength) internal pure {</span>
 1157 |     | <span class='unexecuted'>        if (TroveIdsArrayLength == 1) {</span>
 1158 |     | <span class='unexecuted'>            revert OnlyOneTroveLeft();</span>
 1159 |     | <span class='neutral'>        }</span>
 1160 |     | <span class='neutral'>    }</span>
 1161 |     | <span class='neutral'></span>
 1162 | *   | <span class='executed'>    function _requireIsShutDown() internal view {</span>
 1163 | *   | <span class='executed'>        if (shutdownTime == 0) {</span>
 1164 | *   | <span class='executed'>            revert NotShutDown();</span>
 1165 |     | <span class='neutral'>        }</span>
 1166 |     | <span class='neutral'>    }</span>
 1167 |     | <span class='neutral'></span>
 1168 | *   | <span class='executed'>    function _requireAmountGreaterThanZero(uint256 _amount) internal pure {</span>
 1169 | *   | <span class='executed'>        if (_amount == 0) {</span>
 1170 | *   | <span class='executed'>            revert ZeroAmount();</span>
 1171 |     | <span class='neutral'>        }</span>
 1172 |     | <span class='neutral'>    }</span>
 1173 |     | <span class='neutral'></span>
 1174 | *   | <span class='executed'>    function _requireBoldBalanceCoversRedemption(IBoldToken _boldToken, address _redeemer, uint256 _amount)</span>
 1175 |     | <span class='neutral'>        internal</span>
 1176 |     | <span class='neutral'>        view</span>
 1177 |     | <span class='neutral'>    {</span>
 1178 | *   | <span class='executed'>        uint256 boldBalance = _boldToken.balanceOf(_redeemer);</span>
 1179 | *   | <span class='executed'>        if (boldBalance &lt; _amount) {</span>
 1180 | *   | <span class='executed'>            revert NotEnoughBoldBalance();</span>
 1181 |     | <span class='neutral'>        }</span>
 1182 |     | <span class='neutral'>    }</span>
 1183 |     | <span class='neutral'></span>
 1184 |     | <span class='neutral'>    // --- Trove property getters ---</span>
 1185 |     | <span class='neutral'></span>
 1186 | *   | <span class='executed'>    function getUnbackedPortionPriceAndRedeemability() external returns (uint256, uint256, bool) {</span>
 1187 | *   | <span class='executed'>        uint256 totalDebt = getEntireSystemDebt();</span>
 1188 | *   | <span class='executed'>        uint256 spSize = stabilityPool.getTotalBoldDeposits();</span>
 1189 | *   | <span class='executed'>        uint256 unbackedPortion = totalDebt &gt; spSize ? totalDebt - spSize : 0;</span>
 1190 |     | <span class='neutral'></span>
 1191 | *   | <span class='executed'>        (uint256 price,) = priceFeed.fetchRedemptionPrice();</span>
 1192 |     | <span class='neutral'>        // It&#39;s redeemable if the TCR is above the shutdown threshold, and branch has not been shut down</span>
 1193 | *   | <span class='executed'>        bool redeemable = _getTCR(price) &gt;= SCR &amp;&amp; shutdownTime == 0;</span>
 1194 |     | <span class='neutral'></span>
 1195 | *   | <span class='executed'>        return (unbackedPortion, price, redeemable);</span>
 1196 |     | <span class='neutral'>    }</span>
 1197 |     | <span class='neutral'></span>
 1198 |     | <span class='neutral'>    // --- Trove property setters, called by BorrowerOperations ---</span>
 1199 |     | <span class='neutral'></span>
 1200 | *   | <span class='executed'>    function onOpenTrove(address _owner, uint256 _troveId, TroveChange memory _troveChange, uint256 _annualInterestRate)</span>
 1201 |     | <span class='neutral'>        external</span>
 1202 | *   | <span class='executed'>    {</span>
 1203 | *   | <span class='executed'>        _requireCallerIsBorrowerOperations();</span>
 1204 |     | <span class='neutral'></span>
 1205 | *   | <span class='executed'>        uint256 newStake = _computeNewStake(_troveChange.collIncrease);</span>
 1206 |     | <span class='neutral'></span>
 1207 |     | <span class='neutral'>        // Trove memory newTrove;</span>
 1208 | *   | <span class='executed'>        Troves[_troveId].debt = _troveChange.debtIncrease + _troveChange.upfrontFee;</span>
 1209 | *   | <span class='executed'>        Troves[_troveId].coll = _troveChange.collIncrease;</span>
 1210 | *   | <span class='executed'>        Troves[_troveId].stake = newStake;</span>
 1211 | *   | <span class='executed'>        Troves[_troveId].status = Status.active;</span>
 1212 | *   | <span class='executed'>        Troves[_troveId].arrayIndex = uint64(TroveIds.length);</span>
 1213 | *   | <span class='executed'>        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);</span>
 1214 | *   | <span class='executed'>        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);</span>
 1215 | *   | <span class='executed'>        Troves[_troveId].annualInterestRate = _annualInterestRate;</span>
 1216 |     | <span class='neutral'></span>
 1217 |     | <span class='neutral'>        // Push the trove&#39;s id to the Trove list</span>
 1218 | *   | <span class='executed'>        TroveIds.push(_troveId);</span>
 1219 |     | <span class='neutral'></span>
 1220 | *   | <span class='executed'>        uint256 newTotalStakes = totalStakes + newStake;</span>
 1221 | *   | <span class='executed'>        totalStakes = newTotalStakes;</span>
 1222 |     | <span class='neutral'></span>
 1223 |     | <span class='neutral'>        // mint ERC721</span>
 1224 | *   | <span class='executed'>        troveNFT.mint(_owner, _troveId);</span>
 1225 |     | <span class='neutral'></span>
 1226 | *   | <span class='executed'>        _updateTroveRewardSnapshots(_troveId);</span>
 1227 |     | <span class='neutral'></span>
 1228 | *   | <span class='executed'>        emit TroveUpdated({</span>
 1229 | *   | <span class='executed'>            _troveId: _troveId,</span>
 1230 | *   | <span class='executed'>            _debt: _troveChange.debtIncrease + _troveChange.upfrontFee,</span>
 1231 | *   | <span class='executed'>            _coll: _troveChange.collIncrease,</span>
 1232 | *   | <span class='executed'>            _stake: newStake,</span>
 1233 | *   | <span class='executed'>            _annualInterestRate: _annualInterestRate,</span>
 1234 | *   | <span class='executed'>            _snapshotOfTotalCollRedist: L_coll,</span>
 1235 | *   | <span class='executed'>            _snapshotOfTotalDebtRedist: L_boldDebt</span>
 1236 |     | <span class='neutral'>        });</span>
 1237 |     | <span class='neutral'></span>
 1238 | *   | <span class='executed'>        emit TroveOperation({</span>
 1239 | *   | <span class='executed'>            _troveId: _troveId,</span>
 1240 | *   | <span class='executed'>            _operation: Operation.openTrove,</span>
 1241 | *   | <span class='executed'>            _annualInterestRate: _annualInterestRate,</span>
 1242 | *   | <span class='executed'>            _debtIncreaseFromRedist: 0,</span>
 1243 | *   | <span class='executed'>            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,</span>
 1244 | *   | <span class='executed'>            _debtChangeFromOperation: int256(_troveChange.debtIncrease),</span>
 1245 | *   | <span class='executed'>            _collIncreaseFromRedist: 0,</span>
 1246 | *   | <span class='executed'>            _collChangeFromOperation: int256(_troveChange.collIncrease)</span>
 1247 |     | <span class='neutral'>        });</span>
 1248 |     | <span class='neutral'>    }</span>
 1249 |     | <span class='neutral'></span>
 1250 | *   | <span class='executed'>    function onOpenTroveAndJoinBatch(</span>
 1251 |     | <span class='neutral'>        address _owner,</span>
 1252 |     | <span class='neutral'>        uint256 _troveId,</span>
 1253 |     | <span class='neutral'>        TroveChange memory _troveChange,</span>
 1254 |     | <span class='neutral'>        address _batchAddress,</span>
 1255 |     | <span class='neutral'>        uint256 _batchColl,</span>
 1256 |     | <span class='neutral'>        uint256 _batchDebt</span>
 1257 | *   | <span class='executed'>    ) external {</span>
 1258 | *   | <span class='executed'>        _requireCallerIsBorrowerOperations();</span>
 1259 |     | <span class='neutral'>        // assert(batchIds[batches[_batchAddress].arrayIndex] == _batchAddress);</span>
 1260 |     | <span class='neutral'></span>
 1261 | *   | <span class='executed'>        uint256 newStake = _computeNewStake(_troveChange.collIncrease);</span>
 1262 |     | <span class='neutral'></span>
 1263 |     | <span class='neutral'>        // Trove memory newTrove;</span>
 1264 | *   | <span class='executed'>        Troves[_troveId].coll = _troveChange.collIncrease;</span>
 1265 | *   | <span class='executed'>        Troves[_troveId].stake = newStake;</span>
 1266 | *   | <span class='executed'>        Troves[_troveId].status = Status.active;</span>
 1267 | *   | <span class='executed'>        Troves[_troveId].arrayIndex = uint64(TroveIds.length);</span>
 1268 | *   | <span class='executed'>        Troves[_troveId].interestBatchManager = _batchAddress;</span>
 1269 | *   | <span class='executed'>        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);</span>
 1270 |     | <span class='neutral'></span>
 1271 |     | <span class='neutral'>        _updateTroveRewardSnapshots(_troveId);</span>
 1272 |     | <span class='neutral'></span>
 1273 |     | <span class='neutral'>        // Push the trove&#39;s id to the Trove list</span>
 1274 | *   | <span class='executed'>        TroveIds.push(_troveId);</span>
 1275 |     | <span class='neutral'></span>
 1276 | *   | <span class='executed'>        assert(_troveChange.debtIncrease &gt; 0); // TODO: remove before deployment</span>
 1277 | *   | <span class='executed'>        _updateBatchShares(</span>
 1278 | *   | <span class='executed'>            _troveId, _batchAddress, _troveChange, _troveChange.debtIncrease, _batchColl, _batchDebt, true</span>
 1279 |     | <span class='neutral'>        );</span>
 1280 |     | <span class='neutral'></span>
 1281 | *   | <span class='executed'>        uint256 newTotalStakes = totalStakes + newStake;</span>
 1282 | *   | <span class='executed'>        totalStakes = newTotalStakes;</span>
 1283 |     | <span class='neutral'></span>
 1284 |     | <span class='neutral'>        // mint ERC721</span>
 1285 | *   | <span class='executed'>        troveNFT.mint(_owner, _troveId);</span>
 1286 |     | <span class='neutral'></span>
 1287 | *   | <span class='executed'>        emit BatchedTroveUpdated({</span>
 1288 | *   | <span class='executed'>            _troveId: _troveId,</span>
 1289 | *   | <span class='executed'>            _interestBatchManager: _batchAddress,</span>
 1290 | *   | <span class='executed'>            _batchDebtShares: Troves[_troveId].batchDebtShares,</span>
 1291 | *   | <span class='executed'>            _coll: _troveChange.collIncrease,</span>
 1292 | *   | <span class='executed'>            _stake: newStake,</span>
 1293 | *   | <span class='executed'>            _snapshotOfTotalCollRedist: L_coll,</span>
 1294 | *   | <span class='executed'>            _snapshotOfTotalDebtRedist: L_boldDebt</span>
 1295 |     | <span class='neutral'>        });</span>
 1296 |     | <span class='neutral'></span>
 1297 | *   | <span class='executed'>        emit TroveOperation({</span>
 1298 | *   | <span class='executed'>            _troveId: _troveId,</span>
 1299 | *   | <span class='executed'>            _operation: Operation.openTroveAndJoinBatch,</span>
 1300 | *   | <span class='executed'>            _annualInterestRate: batches[_batchAddress].annualInterestRate,</span>
 1301 |     | <span class='neutral'>            _debtIncreaseFromRedist: 0,</span>
 1302 | *   | <span class='executed'>            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,</span>
 1303 | *   | <span class='executed'>            _debtChangeFromOperation: int256(_troveChange.debtIncrease),</span>
 1304 |     | <span class='neutral'>            _collIncreaseFromRedist: 0,</span>
 1305 | *   | <span class='executed'>            _collChangeFromOperation: int256(_troveChange.collIncrease)</span>
 1306 |     | <span class='neutral'>        });</span>
 1307 |     | <span class='neutral'></span>
 1308 | *   | <span class='executed'>        emit BatchUpdated({</span>
 1309 |     | <span class='neutral'>            _interestBatchManager: _batchAddress,</span>
 1310 | *   | <span class='executed'>            _operation: BatchOperation.joinBatch,</span>
 1311 | *   | <span class='executed'>            _debt: batches[_batchAddress].debt,</span>
 1312 | *   | <span class='executed'>            _coll: batches[_batchAddress].coll,</span>
 1313 | *   | <span class='executed'>            _annualInterestRate: batches[_batchAddress].annualInterestRate,</span>
 1314 | *   | <span class='executed'>            _annualManagementFee: batches[_batchAddress].annualManagementFee,</span>
 1315 | *   | <span class='executed'>            _totalDebtShares: batches[_batchAddress].totalDebtShares,</span>
 1316 |     | <span class='neutral'>            // Although the Trove joining the batch pays an upfront fee,</span>
 1317 |     | <span class='neutral'>            // it is an individual fee, so we don&#39;t include it here</span>
 1318 |     | <span class='neutral'>            _debtIncreaseFromUpfrontFee: 0</span>
 1319 |     | <span class='neutral'>        });</span>
 1320 |     | <span class='neutral'>    }</span>
 1321 |     | <span class='neutral'></span>
 1322 | *   | <span class='executed'>    function setTroveStatusToActive(uint256 _troveId) external {</span>
 1323 | *   | <span class='executed'>        _requireCallerIsBorrowerOperations();</span>
 1324 | *   | <span class='executed'>        Troves[_troveId].status = Status.active;</span>
 1325 | *   | <span class='executed'>        if (lastZombieTroveId == _troveId) {</span>
 1326 | *   | <span class='executed'>            lastZombieTroveId = 0;</span>
 1327 |     | <span class='neutral'>        }</span>
 1328 |     | <span class='neutral'>    }</span>
 1329 |     | <span class='neutral'></span>
 1330 | *   | <span class='executed'>    function onAdjustTroveInterestRate(</span>
 1331 |     | <span class='neutral'>        uint256 _troveId,</span>
 1332 |     | <span class='neutral'>        uint256 _newColl,</span>
 1333 |     | <span class='neutral'>        uint256 _newDebt,</span>
 1334 |     | <span class='neutral'>        uint256 _newAnnualInterestRate,</span>
 1335 |     | <span class='neutral'>        TroveChange calldata _troveChange</span>
 1336 |     | <span class='neutral'>    ) external {</span>
 1337 | *   | <span class='executed'>        _requireCallerIsBorrowerOperations();</span>
 1338 |     | <span class='neutral'></span>
 1339 | *   | <span class='executed'>        Troves[_troveId].coll = _newColl;</span>
 1340 | *   | <span class='executed'>        Troves[_troveId].debt = _newDebt;</span>
 1341 | *   | <span class='executed'>        Troves[_troveId].annualInterestRate = _newAnnualInterestRate;</span>
 1342 | *   | <span class='executed'>        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);</span>
 1343 | *   | <span class='executed'>        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);</span>
 1344 |     | <span class='neutral'></span>
 1345 | *   | <span class='executed'>        _movePendingTroveRewardsToActivePool(</span>
 1346 | *   | <span class='executed'>            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain</span>
 1347 |     | <span class='neutral'>        );</span>
 1348 |     | <span class='neutral'></span>
 1349 |     | <span class='neutral'>        _updateTroveRewardSnapshots(_troveId);</span>
 1350 |     | <span class='neutral'></span>
 1351 | *   | <span class='executed'>        emit TroveUpdated({</span>
 1352 | *   | <span class='executed'>            _troveId: _troveId,</span>
 1353 | *   | <span class='executed'>            _debt: _newDebt,</span>
 1354 | *   | <span class='executed'>            _coll: _newColl,</span>
 1355 | *   | <span class='executed'>            _stake: Troves[_troveId].stake,</span>
 1356 | *   | <span class='executed'>            _annualInterestRate: _newAnnualInterestRate,</span>
 1357 | *   | <span class='executed'>            _snapshotOfTotalCollRedist: L_coll,</span>
 1358 | *   | <span class='executed'>            _snapshotOfTotalDebtRedist: L_boldDebt</span>
 1359 |     | <span class='neutral'>        });</span>
 1360 |     | <span class='neutral'></span>
 1361 | *   | <span class='executed'>        emit TroveOperation({</span>
 1362 | *   | <span class='executed'>            _troveId: _troveId,</span>
 1363 | *   | <span class='executed'>            _operation: Operation.adjustTroveInterestRate,</span>
 1364 | *   | <span class='executed'>            _annualInterestRate: _newAnnualInterestRate,</span>
 1365 | *   | <span class='executed'>            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,</span>
 1366 | *   | <span class='executed'>            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,</span>
 1367 | *   | <span class='executed'>            _debtChangeFromOperation: 0,</span>
 1368 | *   | <span class='executed'>            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,</span>
 1369 | *   | <span class='executed'>            _collChangeFromOperation: 0</span>
 1370 |     | <span class='neutral'>        });</span>
 1371 |     | <span class='neutral'>    }</span>
 1372 |     | <span class='neutral'></span>
 1373 | *   | <span class='executed'>    function onAdjustTrove(uint256 _troveId, uint256 _newColl, uint256 _newDebt, TroveChange calldata _troveChange)</span>
 1374 |     | <span class='neutral'>        external</span>
 1375 |     | <span class='neutral'>    {</span>
 1376 | *   | <span class='executed'>        _requireCallerIsBorrowerOperations();</span>
 1377 |     | <span class='neutral'></span>
 1378 | *   | <span class='executed'>        Troves[_troveId].coll = _newColl;</span>
 1379 | *   | <span class='executed'>        Troves[_troveId].debt = _newDebt;</span>
 1380 | *   | <span class='executed'>        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);</span>
 1381 |     | <span class='neutral'></span>
 1382 | *   | <span class='executed'>        _movePendingTroveRewardsToActivePool(</span>
 1383 | *   | <span class='executed'>            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain</span>
 1384 |     | <span class='neutral'>        );</span>
 1385 |     | <span class='neutral'></span>
 1386 | *   | <span class='executed'>        uint256 newStake = _updateStakeAndTotalStakes(_troveId, _newColl);</span>
 1387 |     | <span class='neutral'>        _updateTroveRewardSnapshots(_troveId);</span>
 1388 |     | <span class='neutral'></span>
 1389 | *   | <span class='executed'>        emit TroveUpdated({</span>
 1390 | *   | <span class='executed'>            _troveId: _troveId,</span>
 1391 | *   | <span class='executed'>            _debt: _newDebt,</span>
 1392 | *   | <span class='executed'>            _coll: _newColl,</span>
 1393 | *   | <span class='executed'>            _stake: newStake,</span>
 1394 | *   | <span class='executed'>            _annualInterestRate: Troves[_troveId].annualInterestRate,</span>
 1395 | *   | <span class='executed'>            _snapshotOfTotalCollRedist: L_coll,</span>
 1396 | *   | <span class='executed'>            _snapshotOfTotalDebtRedist: L_boldDebt</span>
 1397 |     | <span class='neutral'>        });</span>
 1398 |     | <span class='neutral'></span>
 1399 | *   | <span class='executed'>        emit TroveOperation({</span>
 1400 | *   | <span class='executed'>            _troveId: _troveId,</span>
 1401 | *   | <span class='executed'>            _operation: Operation.adjustTrove,</span>
 1402 | *   | <span class='executed'>            _annualInterestRate: Troves[_troveId].annualInterestRate,</span>
 1403 | *   | <span class='executed'>            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,</span>
 1404 | *   | <span class='executed'>            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,</span>
 1405 | *   | <span class='executed'>            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),</span>
 1406 | *   | <span class='executed'>            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,</span>
 1407 | *   | <span class='executed'>            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)</span>
 1408 |     | <span class='neutral'>        });</span>
 1409 |     | <span class='neutral'>    }</span>
 1410 |     | <span class='neutral'></span>
 1411 |     | <span class='unexecuted'>    function onCloseTrove(</span>
 1412 |     | <span class='neutral'>        uint256 _troveId,</span>
 1413 |     | <span class='neutral'>        TroveChange memory _troveChange, // decrease vars: entire, with interest, batch fee and redistribution</span>
 1414 |     | <span class='neutral'>        address _batchAddress,</span>
 1415 |     | <span class='neutral'>        uint256 _newBatchColl,</span>
 1416 |     | <span class='neutral'>        uint256 _newBatchDebt // entire, with interest and batch fee</span>
 1417 |     | <span class='neutral'>    ) external override {</span>
 1418 |     | <span class='unexecuted'>        _requireCallerIsBorrowerOperations();</span>
 1419 |     | <span class='unexecuted'>        _closeTrove(_troveId, _troveChange, _batchAddress, _newBatchColl, _newBatchDebt, Status.closedByOwner);</span>
 1420 |     | <span class='unexecuted'>        _movePendingTroveRewardsToActivePool(</span>
 1421 |     | <span class='unexecuted'>            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain</span>
 1422 |     | <span class='neutral'>        );</span>
 1423 |     | <span class='neutral'></span>
 1424 |     | <span class='unexecuted'>        emit TroveUpdated({</span>
 1425 |     | <span class='unexecuted'>            _troveId: _troveId,</span>
 1426 |     | <span class='unexecuted'>            _debt: 0,</span>
 1427 |     | <span class='unexecuted'>            _coll: 0,</span>
 1428 |     | <span class='unexecuted'>            _stake: 0,</span>
 1429 |     | <span class='unexecuted'>            _annualInterestRate: 0,</span>
 1430 |     | <span class='unexecuted'>            _snapshotOfTotalCollRedist: 0,</span>
 1431 |     | <span class='unexecuted'>            _snapshotOfTotalDebtRedist: 0</span>
 1432 |     | <span class='neutral'>        });</span>
 1433 |     | <span class='neutral'></span>
 1434 |     | <span class='unexecuted'>        emit TroveOperation({</span>
 1435 |     | <span class='unexecuted'>            _troveId: _troveId,</span>
 1436 |     | <span class='unexecuted'>            _operation: Operation.closeTrove,</span>
 1437 |     | <span class='unexecuted'>            _annualInterestRate: 0,</span>
 1438 |     | <span class='unexecuted'>            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,</span>
 1439 |     | <span class='unexecuted'>            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,</span>
 1440 |     | <span class='unexecuted'>            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),</span>
 1441 |     | <span class='unexecuted'>            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,</span>
 1442 |     | <span class='unexecuted'>            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)</span>
 1443 |     | <span class='neutral'>        });</span>
 1444 |     | <span class='neutral'></span>
 1445 |     | <span class='unexecuted'>        if (_batchAddress != address(0)) {</span>
 1446 |     | <span class='unexecuted'>            emit BatchUpdated({</span>
 1447 |     | <span class='neutral'>                _interestBatchManager: _batchAddress,</span>
 1448 |     | <span class='unexecuted'>                _operation: BatchOperation.exitBatch,</span>
 1449 |     | <span class='unexecuted'>                _debt: batches[_batchAddress].debt,</span>
 1450 |     | <span class='unexecuted'>                _coll: batches[_batchAddress].coll,</span>
 1451 |     | <span class='unexecuted'>                _annualInterestRate: batches[_batchAddress].annualInterestRate,</span>
 1452 |     | <span class='unexecuted'>                _annualManagementFee: batches[_batchAddress].annualManagementFee,</span>
 1453 |     | <span class='unexecuted'>                _totalDebtShares: batches[_batchAddress].totalDebtShares,</span>
 1454 |     | <span class='neutral'>                _debtIncreaseFromUpfrontFee: 0</span>
 1455 |     | <span class='neutral'>            });</span>
 1456 |     | <span class='neutral'>        }</span>
 1457 |     | <span class='neutral'>    }</span>
 1458 |     | <span class='neutral'></span>
 1459 |     | <span class='unexecuted'>    function _closeTrove(</span>
 1460 |     | <span class='neutral'>        uint256 _troveId,</span>
 1461 |     | <span class='neutral'>        TroveChange memory _troveChange, // decrease vars: entire, with interest, batch fee and redistribution</span>
 1462 |     | <span class='neutral'>        address _batchAddress,</span>
 1463 |     | <span class='neutral'>        uint256 _newBatchColl,</span>
 1464 |     | <span class='neutral'>        uint256 _newBatchDebt, // entire, with interest and batch fee</span>
 1465 |     | <span class='neutral'>        Status closedStatus</span>
 1466 |     | <span class='neutral'>    ) internal {</span>
 1467 |     | <span class='neutral'>        // assert(closedStatus == Status.closedByLiquidation || closedStatus == Status.closedByOwner);</span>
 1468 |     | <span class='neutral'></span>
 1469 |     | <span class='unexecuted'>        uint256 TroveIdsArrayLength = TroveIds.length;</span>
 1470 |     | <span class='unexecuted'>        _requireMoreThanOneTroveInSystem(TroveIdsArrayLength);</span>
 1471 |     | <span class='neutral'></span>
 1472 |     | <span class='unexecuted'>        _removeTroveId(_troveId, TroveIdsArrayLength);</span>
 1473 |     | <span class='neutral'></span>
 1474 |     | <span class='unexecuted'>        Trove memory trove = Troves[_troveId];</span>
 1475 |     | <span class='neutral'></span>
 1476 |     | <span class='neutral'>        // If trove belongs to a batch, remove from it</span>
 1477 |     | <span class='unexecuted'>        if (_batchAddress != address(0)) {</span>
 1478 |     | <span class='unexecuted'>            if (trove.status == Status.active) {</span>
 1479 |     | <span class='unexecuted'>                sortedTroves.removeFromBatch(_troveId);</span>
 1480 |     | <span class='unexecuted'>            } else if (trove.status == Status.zombie &amp;&amp; lastZombieTroveId == _troveId) {</span>
 1481 |     | <span class='unexecuted'>                lastZombieTroveId = 0;</span>
 1482 |     | <span class='neutral'>            }</span>
 1483 |     | <span class='neutral'></span>
 1484 |     | <span class='unexecuted'>            _removeTroveSharesFromBatch(</span>
 1485 |     | <span class='unexecuted'>                _troveId,</span>
 1486 |     | <span class='unexecuted'>                _troveChange.collDecrease,</span>
 1487 |     | <span class='unexecuted'>                _troveChange.debtDecrease,</span>
 1488 |     | <span class='unexecuted'>                _troveChange,</span>
 1489 |     | <span class='unexecuted'>                _batchAddress,</span>
 1490 |     | <span class='unexecuted'>                _newBatchColl,</span>
 1491 |     | <span class='unexecuted'>                _newBatchDebt</span>
 1492 |     | <span class='neutral'>            );</span>
 1493 |     | <span class='neutral'>        } else {</span>
 1494 |     | <span class='unexecuted'>            if (trove.status == Status.active) {</span>
 1495 |     | <span class='unexecuted'>                sortedTroves.remove(_troveId);</span>
 1496 |     | <span class='unexecuted'>            } else if (trove.status == Status.zombie &amp;&amp; lastZombieTroveId == _troveId) {</span>
 1497 |     | <span class='unexecuted'>                lastZombieTroveId = 0;</span>
 1498 |     | <span class='neutral'>            }</span>
 1499 |     | <span class='neutral'>        }</span>
 1500 |     | <span class='neutral'></span>
 1501 |     | <span class='unexecuted'>        uint256 newTotalStakes = totalStakes - trove.stake;</span>
 1502 |     | <span class='unexecuted'>        totalStakes = newTotalStakes;</span>
 1503 |     | <span class='neutral'></span>
 1504 |     | <span class='neutral'>        // Zero Trove properties</span>
 1505 |     | <span class='unexecuted'>        delete Troves[_troveId];</span>
 1506 |     | <span class='unexecuted'>        Troves[_troveId].status = closedStatus;</span>
 1507 |     | <span class='neutral'></span>
 1508 |     | <span class='neutral'>        // Zero Trove snapshots</span>
 1509 |     | <span class='unexecuted'>        delete rewardSnapshots[_troveId];</span>
 1510 |     | <span class='neutral'></span>
 1511 |     | <span class='neutral'>        // burn ERC721</span>
 1512 |     | <span class='unexecuted'>        troveNFT.burn(_troveId);</span>
 1513 |     | <span class='neutral'>    }</span>
 1514 |     | <span class='neutral'></span>
 1515 | *   | <span class='executed'>    function onAdjustTroveInsideBatch(</span>
 1516 |     | <span class='neutral'>        uint256 _troveId,</span>
 1517 |     | <span class='neutral'>        uint256 _newTroveColl, // entire, with redistribution and trove change</span>
 1518 |     | <span class='neutral'>        uint256 _newTroveDebt, // entire, with redistribution and trove change</span>
 1519 |     | <span class='neutral'>        TroveChange memory _troveChange,</span>
 1520 |     | <span class='neutral'>        address _batchAddress,</span>
 1521 |     | <span class='neutral'>        uint256 _newBatchColl, // without trove change</span>
 1522 |     | <span class='neutral'>        uint256 _newBatchDebt // entire (with interest, batch fee), but without trove change nor upfront fee nor redistribution</span>
 1523 |     | <span class='neutral'>    ) external {</span>
 1524 | *   | <span class='executed'>        _requireCallerIsBorrowerOperations();</span>
 1525 |     | <span class='neutral'></span>
 1526 |     | <span class='neutral'>        // Trove</span>
 1527 | *   | <span class='executed'>        Troves[_troveId].coll = _newTroveColl;</span>
 1528 |     | <span class='neutral'>        _updateTroveRewardSnapshots(_troveId);</span>
 1529 | *   | <span class='executed'>        uint256 newStake = _updateStakeAndTotalStakes(_troveId, _newTroveColl);</span>
 1530 |     | <span class='neutral'></span>
 1531 |     | <span class='neutral'>        // Batch</span>
 1532 | *   | <span class='executed'>        assert(_newTroveDebt &gt; 0); // TODO: remove before deployment</span>
 1533 | *   | <span class='executed'>        _updateBatchShares(_troveId, _batchAddress, _troveChange, _newTroveDebt, _newBatchColl, _newBatchDebt, true);</span>
 1534 |     | <span class='neutral'></span>
 1535 | *   | <span class='executed'>        _movePendingTroveRewardsToActivePool(</span>
 1536 | *   | <span class='executed'>            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain</span>
 1537 |     | <span class='neutral'>        );</span>
 1538 |     | <span class='neutral'></span>
 1539 | *   | <span class='executed'>        emit BatchedTroveUpdated({</span>
 1540 | *   | <span class='executed'>            _troveId: _troveId,</span>
 1541 | *   | <span class='executed'>            _interestBatchManager: _batchAddress,</span>
 1542 | *   | <span class='executed'>            _batchDebtShares: Troves[_troveId].batchDebtShares,</span>
 1543 | *   | <span class='executed'>            _coll: _newTroveColl,</span>
 1544 | *   | <span class='executed'>            _stake: newStake,</span>
 1545 | *   | <span class='executed'>            _snapshotOfTotalCollRedist: L_coll,</span>
 1546 | *   | <span class='executed'>            _snapshotOfTotalDebtRedist: L_boldDebt</span>
 1547 |     | <span class='neutral'>        });</span>
 1548 |     | <span class='neutral'></span>
 1549 | *   | <span class='executed'>        emit TroveOperation({</span>
 1550 | *   | <span class='executed'>            _troveId: _troveId,</span>
 1551 | *   | <span class='executed'>            _operation: Operation.adjustTrove,</span>
 1552 | *   | <span class='executed'>            _annualInterestRate: batches[_batchAddress].annualInterestRate,</span>
 1553 | *   | <span class='executed'>            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,</span>
 1554 | *   | <span class='executed'>            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,</span>
 1555 | *   | <span class='executed'>            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),</span>
 1556 | *   | <span class='executed'>            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,</span>
 1557 | *   | <span class='executed'>            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)</span>
 1558 |     | <span class='neutral'>        });</span>
 1559 |     | <span class='neutral'></span>
 1560 | *   | <span class='executed'>        emit BatchUpdated({</span>
 1561 |     | <span class='neutral'>            _interestBatchManager: _batchAddress,</span>
 1562 | *   | <span class='executed'>            _operation: BatchOperation.troveChange,</span>
 1563 | *   | <span class='executed'>            _debt: batches[_batchAddress].debt,</span>
 1564 | *   | <span class='executed'>            _coll: batches[_batchAddress].coll,</span>
 1565 | *   | <span class='executed'>            _annualInterestRate: batches[_batchAddress].annualInterestRate,</span>
 1566 | *   | <span class='executed'>            _annualManagementFee: batches[_batchAddress].annualManagementFee,</span>
 1567 | *   | <span class='executed'>            _totalDebtShares: batches[_batchAddress].totalDebtShares,</span>
 1568 |     | <span class='neutral'>            // Although the Trove being adjusted may pay an upfront fee,</span>
 1569 |     | <span class='neutral'>            // it is an individual fee, so we don&#39;t include it here</span>
 1570 |     | <span class='neutral'>            _debtIncreaseFromUpfrontFee: 0</span>
 1571 |     | <span class='neutral'>        });</span>
 1572 |     | <span class='neutral'>    }</span>
 1573 |     | <span class='neutral'></span>
 1574 | *   | <span class='executed'>    function onApplyTroveInterest(</span>
 1575 |     | <span class='neutral'>        uint256 _troveId,</span>
 1576 |     | <span class='neutral'>        uint256 _newTroveColl,</span>
 1577 |     | <span class='neutral'>        uint256 _newTroveDebt,</span>
 1578 |     | <span class='neutral'>        address _batchAddress,</span>
 1579 |     | <span class='neutral'>        uint256 _newBatchColl,</span>
 1580 |     | <span class='neutral'>        uint256 _newBatchDebt,</span>
 1581 |     | <span class='neutral'>        TroveChange calldata _troveChange</span>
 1582 |     | <span class='neutral'>    ) external {</span>
 1583 | *   | <span class='executed'>        _requireCallerIsBorrowerOperations();</span>
 1584 |     | <span class='neutral'></span>
 1585 | *   | <span class='executed'>        Troves[_troveId].coll = _newTroveColl;</span>
 1586 |     | <span class='neutral'></span>
 1587 | *   | <span class='executed'>        if (_batchAddress != address(0)) {</span>
 1588 | *   | <span class='executed'>            assert(_newTroveDebt &gt; 0); // TODO: remove before deployment</span>
 1589 | *   | <span class='executed'>            _updateBatchShares(_troveId, _batchAddress, _troveChange, _newTroveDebt, _newBatchColl, _newBatchDebt, true);</span>
 1590 |     | <span class='neutral'></span>
 1591 | *   | <span class='executed'>            emit BatchUpdated({</span>
 1592 |     | <span class='neutral'>                _interestBatchManager: _batchAddress,</span>
 1593 | *   | <span class='executed'>                _operation: BatchOperation.applyBatchInterestAndFee,</span>
 1594 | *   | <span class='executed'>                _debt: _newBatchDebt,</span>
 1595 | *   | <span class='executed'>                _coll: _newBatchColl,</span>
 1596 | *   | <span class='executed'>                _annualInterestRate: batches[_batchAddress].annualInterestRate,</span>
 1597 | *   | <span class='executed'>                _annualManagementFee: batches[_batchAddress].annualManagementFee,</span>
 1598 | *   | <span class='executed'>                _totalDebtShares: batches[_batchAddress].totalDebtShares,</span>
 1599 |     | <span class='neutral'>                _debtIncreaseFromUpfrontFee: 0</span>
 1600 |     | <span class='neutral'>            });</span>
 1601 |     | <span class='neutral'>        } else {</span>
 1602 | *   | <span class='executed'>            Troves[_troveId].debt = _newTroveDebt;</span>
 1603 | *   | <span class='executed'>            Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);</span>
 1604 |     | <span class='neutral'>        }</span>
 1605 |     | <span class='neutral'></span>
 1606 | *   | <span class='executed'>        _movePendingTroveRewardsToActivePool(</span>
 1607 | *   | <span class='executed'>            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain</span>
 1608 |     | <span class='neutral'>        );</span>
 1609 |     | <span class='neutral'></span>
 1610 |     | <span class='neutral'>        _updateTroveRewardSnapshots(_troveId);</span>
 1611 |     | <span class='neutral'></span>
 1612 | *   | <span class='executed'>        emit TroveUpdated({</span>
 1613 |     | <span class='neutral'>            _troveId: _troveId,</span>
 1614 | *   | <span class='executed'>            _debt: _newTroveDebt,</span>
 1615 | *   | <span class='executed'>            _coll: _newTroveColl,</span>
 1616 | *   | <span class='executed'>            _stake: Troves[_troveId].stake,</span>
 1617 | *   | <span class='executed'>            _annualInterestRate: Troves[_troveId].annualInterestRate,</span>
 1618 | *   | <span class='executed'>            _snapshotOfTotalCollRedist: L_coll,</span>
 1619 |     | <span class='neutral'>            _snapshotOfTotalDebtRedist: L_boldDebt</span>
 1620 |     | <span class='neutral'>        });</span>
 1621 |     | <span class='neutral'></span>
 1622 | *   | <span class='executed'>        emit TroveOperation({</span>
 1623 | *   | <span class='executed'>            _troveId: _troveId,</span>
 1624 | *   | <span class='executed'>            _operation: Operation.applyPendingDebt,</span>
 1625 | *   | <span class='executed'>            _annualInterestRate: Troves[_troveId].annualInterestRate,</span>
 1626 | *   | <span class='executed'>            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,</span>
 1627 | *   | <span class='executed'>            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,</span>
 1628 | *   | <span class='executed'>            _debtChangeFromOperation: int256(_troveChange.debtIncrease) - int256(_troveChange.debtDecrease),</span>
 1629 | *   | <span class='executed'>            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,</span>
 1630 | *   | <span class='executed'>            _collChangeFromOperation: int256(_troveChange.collIncrease) - int256(_troveChange.collDecrease)</span>
 1631 |     | <span class='neutral'>        });</span>
 1632 |     | <span class='neutral'>    }</span>
 1633 |     | <span class='neutral'></span>
 1634 | *   | <span class='executed'>    function onRegisterBatchManager(address _account, uint256 _annualInterestRate, uint256 _annualManagementFee)</span>
 1635 |     | <span class='neutral'>        external</span>
 1636 |     | <span class='neutral'>    {</span>
 1637 | *   | <span class='executed'>        _requireCallerIsBorrowerOperations();</span>
 1638 |     | <span class='neutral'></span>
 1639 | *   | <span class='executed'>        batches[_account].arrayIndex = uint64(batchIds.length);</span>
 1640 | *   | <span class='executed'>        batches[_account].annualInterestRate = _annualInterestRate;</span>
 1641 | *   | <span class='executed'>        batches[_account].annualManagementFee = _annualManagementFee;</span>
 1642 | *   | <span class='executed'>        batches[_account].lastInterestRateAdjTime = uint64(block.timestamp);</span>
 1643 |     | <span class='neutral'></span>
 1644 | *   | <span class='executed'>        batchIds.push(_account);</span>
 1645 |     | <span class='neutral'></span>
 1646 | *   | <span class='executed'>        emit BatchUpdated({</span>
 1647 |     | <span class='neutral'>            _interestBatchManager: _account,</span>
 1648 |     | <span class='neutral'>            _operation: BatchOperation.registerBatchManager,</span>
 1649 |     | <span class='neutral'>            _debt: 0,</span>
 1650 |     | <span class='neutral'>            _coll: 0,</span>
 1651 |     | <span class='neutral'>            _annualInterestRate: _annualInterestRate,</span>
 1652 |     | <span class='neutral'>            _annualManagementFee: _annualManagementFee,</span>
 1653 |     | <span class='neutral'>            _totalDebtShares: 0,</span>
 1654 |     | <span class='neutral'>            _debtIncreaseFromUpfrontFee: 0</span>
 1655 |     | <span class='neutral'>        });</span>
 1656 |     | <span class='neutral'>    }</span>
 1657 |     | <span class='neutral'></span>
 1658 | *   | <span class='executed'>    function onLowerBatchManagerAnnualFee(</span>
 1659 |     | <span class='neutral'>        address _batchAddress,</span>
 1660 |     | <span class='neutral'>        uint256 _newColl,</span>
 1661 |     | <span class='neutral'>        uint256 _newDebt,</span>
 1662 |     | <span class='neutral'>        uint256 _newAnnualManagementFee</span>
 1663 |     | <span class='neutral'>    ) external {</span>
 1664 | *   | <span class='executed'>        _requireCallerIsBorrowerOperations();</span>
 1665 |     | <span class='neutral'></span>
 1666 | *   | <span class='executed'>        batches[_batchAddress].coll = _newColl;</span>
 1667 | *   | <span class='executed'>        batches[_batchAddress].debt = _newDebt;</span>
 1668 | *   | <span class='executed'>        batches[_batchAddress].annualManagementFee = _newAnnualManagementFee;</span>
 1669 | *   | <span class='executed'>        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);</span>
 1670 |     | <span class='neutral'></span>
 1671 | *   | <span class='executed'>        emit BatchUpdated({</span>
 1672 |     | <span class='neutral'>            _interestBatchManager: _batchAddress,</span>
 1673 |     | <span class='neutral'>            _operation: BatchOperation.lowerBatchManagerAnnualFee,</span>
 1674 |     | <span class='neutral'>            _debt: _newDebt,</span>
 1675 |     | <span class='neutral'>            _coll: _newColl,</span>
 1676 | *   | <span class='executed'>            _annualInterestRate: batches[_batchAddress].annualInterestRate,</span>
 1677 |     | <span class='neutral'>            _annualManagementFee: _newAnnualManagementFee,</span>
 1678 | *   | <span class='executed'>            _totalDebtShares: batches[_batchAddress].totalDebtShares,</span>
 1679 |     | <span class='neutral'>            _debtIncreaseFromUpfrontFee: 0</span>
 1680 |     | <span class='neutral'>        });</span>
 1681 |     | <span class='neutral'>    }</span>
 1682 |     | <span class='neutral'></span>
 1683 |     | <span class='unexecuted'>    function onSetBatchManagerAnnualInterestRate(</span>
 1684 |     | <span class='neutral'>        address _batchAddress,</span>
 1685 |     | <span class='neutral'>        uint256 _newColl,</span>
 1686 |     | <span class='neutral'>        uint256 _newDebt,</span>
 1687 |     | <span class='neutral'>        uint256 _newAnnualInterestRate,</span>
 1688 |     | <span class='neutral'>        uint256 _upfrontFee</span>
 1689 |     | <span class='neutral'>    ) external {</span>
 1690 |     | <span class='unexecuted'>        _requireCallerIsBorrowerOperations();</span>
 1691 |     | <span class='neutral'></span>
 1692 |     | <span class='unexecuted'>        batches[_batchAddress].coll = _newColl;</span>
 1693 |     | <span class='unexecuted'>        batches[_batchAddress].debt = _newDebt;</span>
 1694 |     | <span class='unexecuted'>        batches[_batchAddress].annualInterestRate = _newAnnualInterestRate;</span>
 1695 |     | <span class='unexecuted'>        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);</span>
 1696 |     | <span class='unexecuted'>        batches[_batchAddress].lastInterestRateAdjTime = uint64(block.timestamp);</span>
 1697 |     | <span class='neutral'></span>
 1698 |     | <span class='unexecuted'>        emit BatchUpdated({</span>
 1699 |     | <span class='neutral'>            _interestBatchManager: _batchAddress,</span>
 1700 |     | <span class='neutral'>            _operation: BatchOperation.setBatchManagerAnnualInterestRate,</span>
 1701 |     | <span class='neutral'>            _debt: _newDebt,</span>
 1702 |     | <span class='neutral'>            _coll: _newColl,</span>
 1703 |     | <span class='neutral'>            _annualInterestRate: _newAnnualInterestRate,</span>
 1704 |     | <span class='unexecuted'>            _annualManagementFee: batches[_batchAddress].annualManagementFee,</span>
 1705 |     | <span class='unexecuted'>            _totalDebtShares: batches[_batchAddress].totalDebtShares,</span>
 1706 |     | <span class='unexecuted'>            _debtIncreaseFromUpfrontFee: _upfrontFee</span>
 1707 |     | <span class='neutral'>        });</span>
 1708 |     | <span class='neutral'>    }</span>
 1709 |     | <span class='neutral'></span>
 1710 |     | <span class='unexecuted'>    function onSetInterestBatchManager(OnSetInterestBatchManagerParams calldata _params) external {</span>
 1711 |     | <span class='unexecuted'>        _requireCallerIsBorrowerOperations();</span>
 1712 |     | <span class='unexecuted'>        TroveChange memory _troveChange = _params.troveChange;</span>
 1713 |     | <span class='neutral'></span>
 1714 |     | <span class='neutral'>        // assert(batchIds[batches[_params.newBatchAddress].arrayIndex] == _params.newBatchAddress);</span>
 1715 |     | <span class='neutral'></span>
 1716 |     | <span class='unexecuted'>        _updateTroveRewardSnapshots(_params.troveId);</span>
 1717 |     | <span class='neutral'></span>
 1718 |     | <span class='neutral'>        // Clean Trove state</span>
 1719 |     | <span class='unexecuted'>        Troves[_params.troveId].debt = 0;</span>
 1720 |     | <span class='unexecuted'>        Troves[_params.troveId].annualInterestRate = 0;</span>
 1721 |     | <span class='unexecuted'>        Troves[_params.troveId].lastDebtUpdateTime = 0;</span>
 1722 |     | <span class='unexecuted'>        Troves[_params.troveId].coll = _params.troveColl;</span>
 1723 |     | <span class='neutral'></span>
 1724 |     | <span class='unexecuted'>        Troves[_params.troveId].interestBatchManager = _params.newBatchAddress;</span>
 1725 |     | <span class='unexecuted'>        Troves[_params.troveId].lastInterestRateAdjTime = uint64(block.timestamp);</span>
 1726 |     | <span class='neutral'></span>
 1727 |     | <span class='unexecuted'>        _troveChange.collIncrease = _params.troveColl - _troveChange.appliedRedistCollGain;</span>
 1728 |     | <span class='unexecuted'>        _troveChange.debtIncrease = _params.troveDebt - _troveChange.appliedRedistBoldDebtGain - _troveChange.upfrontFee;</span>
 1729 |     | <span class='unexecuted'>        assert(_params.troveDebt &gt; 0); // TODO: remove before deployment</span>
 1730 |     | <span class='unexecuted'>        _updateBatchShares(</span>
 1731 |     | <span class='unexecuted'>            _params.troveId,</span>
 1732 |     | <span class='unexecuted'>            _params.newBatchAddress,</span>
 1733 |     | <span class='unexecuted'>            _troveChange,</span>
 1734 |     | <span class='unexecuted'>            _params.troveDebt,</span>
 1735 |     | <span class='unexecuted'>            _params.newBatchColl,</span>
 1736 |     | <span class='unexecuted'>            _params.newBatchDebt,</span>
 1737 |     | <span class='unexecuted'>            true</span>
 1738 |     | <span class='neutral'>        );</span>
 1739 |     | <span class='neutral'></span>
 1740 |     | <span class='unexecuted'>        _movePendingTroveRewardsToActivePool(</span>
 1741 |     | <span class='unexecuted'>            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain</span>
 1742 |     | <span class='neutral'>        );</span>
 1743 |     | <span class='neutral'></span>
 1744 |     | <span class='unexecuted'>        emit BatchedTroveUpdated({</span>
 1745 |     | <span class='unexecuted'>            _troveId: _params.troveId,</span>
 1746 |     | <span class='unexecuted'>            _interestBatchManager: _params.newBatchAddress,</span>
 1747 |     | <span class='unexecuted'>            _batchDebtShares: Troves[_params.troveId].batchDebtShares,</span>
 1748 |     | <span class='unexecuted'>            _coll: _params.troveColl,</span>
 1749 |     | <span class='unexecuted'>            _stake: Troves[_params.troveId].stake,</span>
 1750 |     | <span class='unexecuted'>            _snapshotOfTotalCollRedist: L_coll,</span>
 1751 |     | <span class='unexecuted'>            _snapshotOfTotalDebtRedist: L_boldDebt</span>
 1752 |     | <span class='neutral'>        });</span>
 1753 |     | <span class='neutral'></span>
 1754 |     | <span class='unexecuted'>        emit TroveOperation({</span>
 1755 |     | <span class='unexecuted'>            _troveId: _params.troveId,</span>
 1756 |     | <span class='unexecuted'>            _operation: Operation.setInterestBatchManager,</span>
 1757 |     | <span class='unexecuted'>            _annualInterestRate: batches[_params.newBatchAddress].annualInterestRate,</span>
 1758 |     | <span class='unexecuted'>            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,</span>
 1759 |     | <span class='unexecuted'>            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,</span>
 1760 |     | <span class='unexecuted'>            _debtChangeFromOperation: 0,</span>
 1761 |     | <span class='unexecuted'>            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,</span>
 1762 |     | <span class='unexecuted'>            _collChangeFromOperation: 0</span>
 1763 |     | <span class='neutral'>        });</span>
 1764 |     | <span class='neutral'></span>
 1765 |     | <span class='unexecuted'>        emit BatchUpdated({</span>
 1766 |     | <span class='unexecuted'>            _interestBatchManager: _params.newBatchAddress,</span>
 1767 |     | <span class='unexecuted'>            _operation: BatchOperation.joinBatch,</span>
 1768 |     | <span class='unexecuted'>            _debt: batches[_params.newBatchAddress].debt,</span>
 1769 |     | <span class='unexecuted'>            _coll: batches[_params.newBatchAddress].coll,</span>
 1770 |     | <span class='unexecuted'>            _annualInterestRate: batches[_params.newBatchAddress].annualInterestRate,</span>
 1771 |     | <span class='unexecuted'>            _annualManagementFee: batches[_params.newBatchAddress].annualManagementFee,</span>
 1772 |     | <span class='unexecuted'>            _totalDebtShares: batches[_params.newBatchAddress].totalDebtShares,</span>
 1773 |     | <span class='neutral'>            // Although the Trove joining the batch may pay an upfront fee,</span>
 1774 |     | <span class='neutral'>            // it is an individual fee, so we don&#39;t include it here</span>
 1775 |     | <span class='unexecuted'>            _debtIncreaseFromUpfrontFee: 0</span>
 1776 |     | <span class='neutral'>        });</span>
 1777 |     | <span class='neutral'>    }</span>
 1778 |     | <span class='neutral'></span>
 1779 |     | <span class='neutral'>    // This function will revert if there’s a total debt increase and the ratio debt / shares has exceeded the max</span>
 1780 | *   | <span class='executed'>    function _updateBatchShares(</span>
 1781 |     | <span class='neutral'>        uint256 _troveId,</span>
 1782 |     | <span class='neutral'>        address _batchAddress,</span>
 1783 |     | <span class='neutral'>        TroveChange memory _troveChange,</span>
 1784 |     | <span class='neutral'>        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution</span>
 1785 |     | <span class='neutral'>        uint256 _batchColl, // without trove change</span>
 1786 |     | <span class='neutral'>        uint256 _batchDebt, // entire (with interest, batch fee), but without trove change, nor upfront fee nor redist</span>
 1787 |     | <span class='neutral'>        bool _checkBatchSharesRatio // whether we do the check on the resulting ratio inside the func call</span>
 1788 | *   | <span class='executed'>    ) internal {</span>
 1789 |     | <span class='neutral'>        // Debt</span>
 1790 | *   | <span class='executed'>        uint256 currentBatchDebtShares = batches[_batchAddress].totalDebtShares;</span>
 1791 |     | <span class='neutral'>        uint256 batchDebtSharesDelta;</span>
 1792 | *   | <span class='executed'>        uint256 debtIncrease =</span>
 1793 | *   | <span class='executed'>            _troveChange.debtIncrease + _troveChange.upfrontFee + _troveChange.appliedRedistBoldDebtGain;</span>
 1794 | *   | <span class='executed'>        uint256 debtDecrease;</span>
 1795 | *   | <span class='executed'>        if (debtIncrease &gt; _troveChange.debtDecrease) {</span>
 1796 | *   | <span class='executed'>            debtIncrease -= _troveChange.debtDecrease;</span>
 1797 |     | <span class='neutral'>        } else {</span>
 1798 | *   | <span class='executed'>            debtDecrease = _troveChange.debtDecrease - debtIncrease;</span>
 1799 | *   | <span class='executed'>            debtIncrease = 0;</span>
 1800 |     | <span class='neutral'>        }</span>
 1801 |     | <span class='neutral'></span>
 1802 | *   | <span class='executed'>        if (debtIncrease == 0 &amp;&amp; debtDecrease == 0) {</span>
 1803 | *   | <span class='executed'>            batches[_batchAddress].debt = _batchDebt;</span>
 1804 |     | <span class='neutral'>        } else {</span>
 1805 | *   | <span class='executed'>            if (debtIncrease &gt; 0) {</span>
 1806 |     | <span class='neutral'>                // Add debt</span>
 1807 | *   | <span class='executed'>                if (_batchDebt == 0) {</span>
 1808 | *   | <span class='executed'>                    batchDebtSharesDelta = debtIncrease;</span>
 1809 |     | <span class='neutral'>                } else {</span>
 1810 |     | <span class='neutral'>                    // To avoid rebasing issues, let’s make sure the ratio debt / shares is not too high</span>
 1811 | *   | <span class='executed'>                    _requireBelowMaxSharesRatio(currentBatchDebtShares, _batchDebt, _checkBatchSharesRatio);</span>
 1812 |     | <span class='neutral'></span>
 1813 | *   | <span class='executed'>                    batchDebtSharesDelta = currentBatchDebtShares * debtIncrease / _batchDebt;</span>
 1814 |     | <span class='neutral'>                }</span>
 1815 |     | <span class='neutral'></span>
 1816 | *   | <span class='executed'>                Troves[_troveId].batchDebtShares += batchDebtSharesDelta;</span>
 1817 | *   | <span class='executed'>                batches[_batchAddress].debt = _batchDebt + debtIncrease;</span>
 1818 | *   | <span class='executed'>                batches[_batchAddress].totalDebtShares = currentBatchDebtShares + batchDebtSharesDelta;</span>
 1819 | *   | <span class='executed'>            } else if (debtDecrease &gt; 0) {</span>
 1820 |     | <span class='neutral'>                // Subtract debt</span>
 1821 |     | <span class='neutral'>                // We make sure that if final trove debt is zero, shares are too (avoiding rounding issues)</span>
 1822 |     | <span class='neutral'>                // This can only happen from redemptions, as otherwise we would be using _removeTroveSharesFromBatch</span>
 1823 |     | <span class='neutral'>                // In redemptions we don’t do that because we don’t want to kick the trove out of the batch (it’d be bad UX)</span>
 1824 | *   | <span class='executed'>                if (_newTroveDebt == 0) {</span>
 1825 |     | <span class='unexecuted'>                    batches[_batchAddress].debt = _batchDebt - debtDecrease;</span>
 1826 |     | <span class='unexecuted'>                    batches[_batchAddress].totalDebtShares = currentBatchDebtShares - Troves[_troveId].batchDebtShares;</span>
 1827 |     | <span class='unexecuted'>                    Troves[_troveId].batchDebtShares = 0;</span>
 1828 |     | <span class='neutral'>                } else {</span>
 1829 | *   | <span class='executed'>                    batchDebtSharesDelta = currentBatchDebtShares * debtDecrease / _batchDebt;</span>
 1830 |     | <span class='neutral'></span>
 1831 | *   | <span class='executed'>                    Troves[_troveId].batchDebtShares -= batchDebtSharesDelta;</span>
 1832 | *   | <span class='executed'>                    batches[_batchAddress].debt = _batchDebt - debtDecrease;</span>
 1833 | *   | <span class='executed'>                    batches[_batchAddress].totalDebtShares = currentBatchDebtShares - batchDebtSharesDelta;</span>
 1834 |     | <span class='neutral'>                }</span>
 1835 |     | <span class='neutral'>            }</span>
 1836 |     | <span class='neutral'>        }</span>
 1837 |     | <span class='neutral'>        // Update debt checkpoint</span>
 1838 | *   | <span class='executed'>        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);</span>
 1839 |     | <span class='neutral'></span>
 1840 |     | <span class='neutral'>        // Collateral</span>
 1841 | *   | <span class='executed'>        uint256 collIncrease = _troveChange.collIncrease + _troveChange.appliedRedistCollGain;</span>
 1842 | *   | <span class='executed'>        uint256 collDecrease;</span>
 1843 | *   | <span class='executed'>        if (collIncrease &gt; _troveChange.collDecrease) {</span>
 1844 | *   | <span class='executed'>            collIncrease -= _troveChange.collDecrease;</span>
 1845 |     | <span class='neutral'>        } else {</span>
 1846 | *   | <span class='executed'>            collDecrease = _troveChange.collDecrease - collIncrease;</span>
 1847 | *   | <span class='executed'>            collIncrease = 0;</span>
 1848 |     | <span class='neutral'>        }</span>
 1849 |     | <span class='neutral'></span>
 1850 | *   | <span class='executed'>        if (collIncrease == 0 &amp;&amp; collDecrease == 0) {</span>
 1851 | *   | <span class='executed'>            batches[_batchAddress].coll = _batchColl;</span>
 1852 |     | <span class='neutral'>        } else {</span>
 1853 | *   | <span class='executed'>            if (collIncrease &gt; 0) {</span>
 1854 |     | <span class='neutral'>                // Add coll</span>
 1855 | *   | <span class='executed'>                batches[_batchAddress].coll = _batchColl + collIncrease;</span>
 1856 | *   | <span class='executed'>            } else if (collDecrease &gt; 0) {</span>
 1857 |     | <span class='neutral'>                // Subtract coll</span>
 1858 | *   | <span class='executed'>                batches[_batchAddress].coll = _batchColl - collDecrease;</span>
 1859 |     | <span class='neutral'>            }</span>
 1860 |     | <span class='neutral'>        }</span>
 1861 |     | <span class='neutral'>    }</span>
 1862 |     | <span class='neutral'></span>
 1863 |     | <span class='neutral'>    // For the debt / shares ratio to increase by a factor 1e9</span>
 1864 |     | <span class='neutral'>    // at a average annual debt increase (compounded interest + fees) of 10%, it would take more than 217 years (log(1e9)/log(1.1))</span>
 1865 |     | <span class='neutral'>    // at a average annual debt increase (compounded interest + fees) of 50%, it would take more than 51 years (log(1e9)/log(1.5))</span>
 1866 |     | <span class='neutral'>    // When that happens, no more debt can be manually added to the batch, so batch should be migrated to a new one</span>
 1867 | *   | <span class='executed'>    function _requireBelowMaxSharesRatio(</span>
 1868 |     | <span class='neutral'>        uint256 _currentBatchDebtShares,</span>
 1869 |     | <span class='neutral'>        uint256 _batchDebt,</span>
 1870 |     | <span class='neutral'>        bool _checkBatchSharesRatio</span>
 1871 |     | <span class='neutral'>    ) internal pure {</span>
 1872 |     | <span class='neutral'>        // debt / shares should be below MAX_BATCH_SHARES_RATIO</span>
 1873 | *   | <span class='executed'>        if (_currentBatchDebtShares * MAX_BATCH_SHARES_RATIO &lt; _batchDebt &amp;&amp; _checkBatchSharesRatio) {</span>
 1874 |     | <span class='unexecuted'>            revert BatchSharesRatioTooHigh();</span>
 1875 |     | <span class='neutral'>        }</span>
 1876 |     | <span class='neutral'>    }</span>
 1877 |     | <span class='neutral'></span>
 1878 | *   | <span class='executed'>    function onRemoveFromBatch(</span>
 1879 |     | <span class='neutral'>        uint256 _troveId,</span>
 1880 |     | <span class='neutral'>        uint256 _newTroveColl, // entire, with redistribution</span>
 1881 |     | <span class='neutral'>        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution</span>
 1882 |     | <span class='neutral'>        TroveChange memory _troveChange,</span>
 1883 |     | <span class='neutral'>        address _batchAddress,</span>
 1884 |     | <span class='neutral'>        uint256 _newBatchColl,</span>
 1885 |     | <span class='neutral'>        uint256 _newBatchDebt, // entire, with interest and batch fee</span>
 1886 |     | <span class='neutral'>        uint256 _newAnnualInterestRate</span>
 1887 |     | <span class='neutral'>    ) external {</span>
 1888 | *   | <span class='executed'>        _requireCallerIsBorrowerOperations();</span>
 1889 |     | <span class='neutral'>        // assert(batchIds[batches[_batchAddress].arrayIndex] == _batchAddress);</span>
 1890 |     | <span class='neutral'></span>
 1891 |     | <span class='neutral'>        // Subtract from batch</span>
 1892 | *   | <span class='executed'>        _removeTroveSharesFromBatch(</span>
 1893 | *   | <span class='executed'>            _troveId, _newTroveColl, _newTroveDebt, _troveChange, _batchAddress, _newBatchColl, _newBatchDebt</span>
 1894 |     | <span class='neutral'>        );</span>
 1895 |     | <span class='neutral'></span>
 1896 |     | <span class='neutral'>        // Restore Trove state</span>
 1897 | *   | <span class='executed'>        Troves[_troveId].debt = _newTroveDebt;</span>
 1898 | *   | <span class='executed'>        Troves[_troveId].coll = _newTroveColl;</span>
 1899 | *   | <span class='executed'>        Troves[_troveId].lastDebtUpdateTime = uint64(block.timestamp);</span>
 1900 | *   | <span class='executed'>        Troves[_troveId].annualInterestRate = _newAnnualInterestRate;</span>
 1901 | *   | <span class='executed'>        Troves[_troveId].lastInterestRateAdjTime = uint64(block.timestamp);</span>
 1902 |     | <span class='neutral'></span>
 1903 |     | <span class='neutral'>        _updateTroveRewardSnapshots(_troveId);</span>
 1904 | *   | <span class='executed'>        _movePendingTroveRewardsToActivePool(</span>
 1905 | *   | <span class='executed'>            defaultPool, _troveChange.appliedRedistBoldDebtGain, _troveChange.appliedRedistCollGain</span>
 1906 |     | <span class='neutral'>        );</span>
 1907 |     | <span class='neutral'></span>
 1908 | *   | <span class='executed'>        emit TroveUpdated({</span>
 1909 | *   | <span class='executed'>            _troveId: _troveId,</span>
 1910 | *   | <span class='executed'>            _debt: _newTroveDebt,</span>
 1911 | *   | <span class='executed'>            _coll: _newTroveColl,</span>
 1912 | *   | <span class='executed'>            _stake: Troves[_troveId].stake,</span>
 1913 | *   | <span class='executed'>            _annualInterestRate: _newAnnualInterestRate,</span>
 1914 | *   | <span class='executed'>            _snapshotOfTotalCollRedist: L_coll,</span>
 1915 | *   | <span class='executed'>            _snapshotOfTotalDebtRedist: L_boldDebt</span>
 1916 |     | <span class='neutral'>        });</span>
 1917 |     | <span class='neutral'></span>
 1918 | *   | <span class='executed'>        emit TroveOperation({</span>
 1919 | *   | <span class='executed'>            _troveId: _troveId,</span>
 1920 | *   | <span class='executed'>            _operation: Operation.removeFromBatch,</span>
 1921 | *   | <span class='executed'>            _annualInterestRate: _newAnnualInterestRate,</span>
 1922 | *   | <span class='executed'>            _debtIncreaseFromRedist: _troveChange.appliedRedistBoldDebtGain,</span>
 1923 | *   | <span class='executed'>            _debtIncreaseFromUpfrontFee: _troveChange.upfrontFee,</span>
 1924 |     | <span class='neutral'>            _debtChangeFromOperation: 0,</span>
 1925 | *   | <span class='executed'>            _collIncreaseFromRedist: _troveChange.appliedRedistCollGain,</span>
 1926 |     | <span class='neutral'>            _collChangeFromOperation: 0</span>
 1927 |     | <span class='neutral'>        });</span>
 1928 |     | <span class='neutral'></span>
 1929 | *   | <span class='executed'>        emit BatchUpdated({</span>
 1930 |     | <span class='neutral'>            _interestBatchManager: _batchAddress,</span>
 1931 | *   | <span class='executed'>            _operation: BatchOperation.exitBatch,</span>
 1932 | *   | <span class='executed'>            _debt: batches[_batchAddress].debt,</span>
 1933 | *   | <span class='executed'>            _coll: batches[_batchAddress].coll,</span>
 1934 | *   | <span class='executed'>            _annualInterestRate: batches[_batchAddress].annualInterestRate,</span>
 1935 | *   | <span class='executed'>            _annualManagementFee: batches[_batchAddress].annualManagementFee,</span>
 1936 | *   | <span class='executed'>            _totalDebtShares: batches[_batchAddress].totalDebtShares,</span>
 1937 |     | <span class='neutral'>            // Although the Trove leaving the batch may pay an upfront fee,</span>
 1938 |     | <span class='neutral'>            // it is an individual fee, so we don&#39;t include it here</span>
 1939 |     | <span class='neutral'>            _debtIncreaseFromUpfrontFee: 0</span>
 1940 |     | <span class='neutral'>        });</span>
 1941 |     | <span class='neutral'>    }</span>
 1942 |     | <span class='neutral'></span>
 1943 | *   | <span class='executed'>    function _removeTroveSharesFromBatch(</span>
 1944 |     | <span class='neutral'>        uint256 _troveId,</span>
 1945 |     | <span class='neutral'>        uint256 _newTroveColl, // entire, with redistribution</span>
 1946 |     | <span class='neutral'>        uint256 _newTroveDebt, // entire, with interest, batch fee and redistribution</span>
 1947 |     | <span class='neutral'>        TroveChange memory _troveChange,</span>
 1948 |     | <span class='neutral'>        address _batchAddress,</span>
 1949 |     | <span class='neutral'>        uint256 _newBatchColl, // without trove change</span>
 1950 |     | <span class='neutral'>        uint256 _newBatchDebt // entire (with interest and batch fee), but without trove change</span>
 1951 |     | <span class='neutral'>    ) internal {</span>
 1952 |     | <span class='neutral'>        // As we are removing:</span>
 1953 |     | <span class='neutral'>        // assert(_newBatchDebt &gt; 0 || _newBatchColl &gt; 0);</span>
 1954 |     | <span class='neutral'></span>
 1955 | *   | <span class='executed'>        Trove memory trove = Troves[_troveId];</span>
 1956 |     | <span class='neutral'></span>
 1957 |     | <span class='neutral'>        // We don’t need to increase the shares corresponding to redistribution first, because they would be subtracted immediately after</span>
 1958 |     | <span class='neutral'>        // We don’t need to account for interest nor batch fee because it’s proportional to debt shares</span>
 1959 | *   | <span class='executed'>        uint256 batchDebtDecrease = _newTroveDebt - _troveChange.upfrontFee - _troveChange.appliedRedistBoldDebtGain;</span>
 1960 | *   | <span class='executed'>        uint256 batchCollDecrease = _newTroveColl - _troveChange.appliedRedistCollGain;</span>
 1961 |     | <span class='neutral'></span>
 1962 | *   | <span class='executed'>        batches[_batchAddress].totalDebtShares -= trove.batchDebtShares;</span>
 1963 | *   | <span class='executed'>        batches[_batchAddress].debt = _newBatchDebt - batchDebtDecrease;</span>
 1964 | *   | <span class='executed'>        batches[_batchAddress].coll = _newBatchColl - batchCollDecrease;</span>
 1965 | *   | <span class='executed'>        batches[_batchAddress].lastDebtUpdateTime = uint64(block.timestamp);</span>
 1966 |     | <span class='neutral'></span>
 1967 | *   | <span class='executed'>        Troves[_troveId].interestBatchManager = address(0);</span>
 1968 | *   | <span class='executed'>        Troves[_troveId].batchDebtShares = 0;</span>
 1969 |     | <span class='neutral'>    }</span>
 1970 |     | <span class='neutral'>}</span>
 1971 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/TroveNFT.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC721/ERC721.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>import &quot;./Interfaces/ITroveNFT.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;./Interfaces/IAddressesRegistry.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>import {IMetadataNFT} from &quot;./NFTMetadata/MetadataNFT.sol&quot;;</span>
 12 |     | <span class='neutral'>import {ITroveManager} from &quot;./Interfaces/ITroveManager.sol&quot;;</span>
 13 |     | <span class='neutral'></span>
 14 | *   | <span class='executed'>contract TroveNFT is ERC721, ITroveNFT {</span>
 15 |     | <span class='unexecuted'>    ITroveManager public immutable troveManager;</span>
 16 |     | <span class='neutral'>    IERC20Metadata internal immutable collToken;</span>
 17 |     | <span class='neutral'>    IBoldToken internal immutable boldToken;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    IMetadataNFT public immutable metadataNFT;</span>
 20 |     | <span class='neutral'></span>
 21 | *   | <span class='executed'>    constructor(IAddressesRegistry _addressesRegistry)</span>
 22 |     | <span class='neutral'>        ERC721(</span>
 23 | *   | <span class='executed'>            string.concat(&quot;Liquity v2 Trove - &quot;, _addressesRegistry.collToken().name()),</span>
 24 | *   | <span class='executed'>            string.concat(&quot;Lv2T_&quot;, _addressesRegistry.collToken().symbol())</span>
 25 |     | <span class='neutral'>        )</span>
 26 |     | <span class='neutral'>    {</span>
 27 | *   | <span class='executed'>        troveManager = _addressesRegistry.troveManager();</span>
 28 | *   | <span class='executed'>        collToken = _addressesRegistry.collToken();</span>
 29 | *   | <span class='executed'>        metadataNFT = _addressesRegistry.metadataNFT();</span>
 30 | *   | <span class='executed'>        boldToken = _addressesRegistry.boldToken();</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='unexecuted'>    function tokenURI(uint256 _tokenId) public view override(ERC721, IERC721Metadata) returns (string memory) {</span>
 34 |     | <span class='unexecuted'>        LatestTroveData memory latestTroveData = troveManager.getLatestTroveData(_tokenId);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>        IMetadataNFT.TroveData memory troveData = IMetadataNFT.TroveData({</span>
 37 |     | <span class='unexecuted'>            _tokenId: _tokenId,</span>
 38 |     | <span class='unexecuted'>            _owner: ownerOf(_tokenId),</span>
 39 |     | <span class='unexecuted'>            _collToken: address(collToken),</span>
 40 |     | <span class='unexecuted'>            _boldToken: address(boldToken),</span>
 41 |     | <span class='unexecuted'>            _collAmount: latestTroveData.entireColl,</span>
 42 |     | <span class='unexecuted'>            _debtAmount: latestTroveData.entireDebt,</span>
 43 |     | <span class='unexecuted'>            _interestRate: latestTroveData.annualInterestRate,</span>
 44 |     | <span class='unexecuted'>            _status: troveManager.getTroveStatus(_tokenId)</span>
 45 |     | <span class='neutral'>        });</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>        return metadataNFT.uri(troveData);</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'></span>
 50 | *   | <span class='executed'>    function mint(address _owner, uint256 _troveId) external override {</span>
 51 | *   | <span class='executed'>        _requireCallerIsTroveManager();</span>
 52 | *   | <span class='executed'>        _mint(_owner, _troveId);</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>    function burn(uint256 _troveId) external override {</span>
 56 |     | <span class='unexecuted'>        _requireCallerIsTroveManager();</span>
 57 |     | <span class='unexecuted'>        _burn(_troveId);</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'></span>
 60 | *   | <span class='executed'>    function _requireCallerIsTroveManager() internal view {</span>
 61 | *   | <span class='executed'>        require(msg.sender == address(troveManager), &quot;TroveNFT: Caller is not the TroveManager contract&quot;);</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'>}</span>
 64 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Types/BatchId.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>type BatchId is address;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>using {equals as ==, notEquals as !=, isZero, isNotZero} for BatchId global;</span>
  8 |     | <span class='neutral'></span>
  9 | *   | <span class='executed'>function equals(BatchId a, BatchId b) pure returns (bool) {</span>
 10 | *   | <span class='executed'>    return BatchId.unwrap(a) == BatchId.unwrap(b);</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>function notEquals(BatchId a, BatchId b) pure returns (bool) {</span>
 14 | *   | <span class='executed'>    return !(a == b);</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>
 17 | *   | <span class='executed'>function isZero(BatchId x) pure returns (bool) {</span>
 18 | *   | <span class='executed'>    return x == BATCH_ID_ZERO;</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>
 21 | *   | <span class='executed'>function isNotZero(BatchId x) pure returns (bool) {</span>
 22 | *   | <span class='executed'>    return !x.isZero();</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>BatchId constant BATCH_ID_ZERO = BatchId.wrap(address(0));</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Types/LatestBatchData.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>struct LatestBatchData {</span>
  6 |     | <span class='neutral'>    uint256 entireDebtWithoutRedistribution;</span>
  7 |     | <span class='neutral'>    uint256 entireCollWithoutRedistribution;</span>
  8 |     | <span class='neutral'>    uint256 accruedInterest;</span>
  9 |     | <span class='neutral'>    uint256 recordedDebt;</span>
 10 |     | <span class='neutral'>    uint256 annualInterestRate;</span>
 11 |     | <span class='neutral'>    uint256 weightedRecordedDebt;</span>
 12 |     | <span class='neutral'>    uint256 annualManagementFee;</span>
 13 |     | <span class='neutral'>    uint256 accruedManagementFee;</span>
 14 |     | <span class='neutral'>    uint256 weightedRecordedBatchManagementFee;</span>
 15 |     | <span class='neutral'>    uint256 lastDebtUpdateTime;</span>
 16 |     | <span class='neutral'>    uint256 lastInterestRateAdjTime;</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Types/LatestTroveData.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>struct LatestTroveData {</span>
  6 |     | <span class='neutral'>    uint256 entireDebt;</span>
  7 |     | <span class='neutral'>    uint256 entireColl;</span>
  8 |     | <span class='neutral'>    uint256 redistBoldDebtGain;</span>
  9 |     | <span class='neutral'>    uint256 redistCollGain;</span>
 10 |     | <span class='neutral'>    uint256 accruedInterest;</span>
 11 |     | <span class='neutral'>    uint256 recordedDebt;</span>
 12 |     | <span class='neutral'>    uint256 annualInterestRate;</span>
 13 |     | <span class='neutral'>    uint256 weightedRecordedDebt;</span>
 14 |     | <span class='neutral'>    uint256 accruedBatchManagementFee;</span>
 15 |     | <span class='neutral'>    uint256 lastInterestRateAdjTime;</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Types/TroveChange.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>struct TroveChange {</span>
  6 |     | <span class='neutral'>    uint256 appliedRedistBoldDebtGain;</span>
  7 |     | <span class='neutral'>    uint256 appliedRedistCollGain;</span>
  8 |     | <span class='neutral'>    uint256 collIncrease;</span>
  9 |     | <span class='neutral'>    uint256 collDecrease;</span>
 10 |     | <span class='neutral'>    uint256 debtIncrease;</span>
 11 |     | <span class='neutral'>    uint256 debtDecrease;</span>
 12 |     | <span class='neutral'>    uint256 newWeightedRecordedDebt;</span>
 13 |     | <span class='neutral'>    uint256 oldWeightedRecordedDebt;</span>
 14 |     | <span class='neutral'>    uint256 upfrontFee;</span>
 15 |     | <span class='neutral'>    uint256 batchAccruedManagementFee;</span>
 16 |     | <span class='neutral'>    uint256 newWeightedRecordedBatchManagementFee;</span>
 17 |     | <span class='neutral'>    uint256 oldWeightedRecordedBatchManagementFee;</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Types/TroveId.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {ROOT_NODE_ID} from &quot;../SortedTroves.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>type TroveId is uint256;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>using {equals as ==, notEquals as !=, isEndOfList, isNotEndOfList} for TroveId global;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>function equals(TroveId a, TroveId b) pure returns (bool) {</span>
 12 |     | <span class='neutral'>    return TroveId.unwrap(a) == TroveId.unwrap(b);</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>function notEquals(TroveId a, TroveId b) pure returns (bool) {</span>
 16 |     | <span class='neutral'>    return !(a == b);</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>function isEndOfList(TroveId x) pure returns (bool) {</span>
 20 |     | <span class='neutral'>    return x == TROVE_ID_END_OF_LIST;</span>
 21 |     | <span class='neutral'>}</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>function isNotEndOfList(TroveId x) pure returns (bool) {</span>
 24 |     | <span class='neutral'>    return !x.isEndOfList();</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>TroveId constant TROVE_ID_ZERO = TroveId.wrap(0);</span>
 28 |     | <span class='neutral'>TroveId constant TROVE_ID_END_OF_LIST = TroveId.wrap(ROOT_NODE_ID);</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/BaseZapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;../Interfaces/IWETH.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../Interfaces/IAddressesRegistry.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../Interfaces/IBorrowerOperations.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../Dependencies/AddRemoveManagers.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;./LeftoversSweep.sol&quot;;</span>
 10 |     | <span class='neutral'>import &quot;./Interfaces/IFlashLoanProvider.sol&quot;;</span>
 11 |     | <span class='neutral'>import &quot;./Interfaces/IFlashLoanReceiver.sol&quot;;</span>
 12 |     | <span class='neutral'>import &quot;./Interfaces/IExchange.sol&quot;;</span>
 13 |     | <span class='neutral'>import &quot;./Interfaces/IZapper.sol&quot;;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>abstract contract BaseZapper is AddRemoveManagers, LeftoversSweep, IFlashLoanReceiver, IZapper {</span>
 16 |     | <span class='unexecuted'>    IBorrowerOperations public immutable borrowerOperations; // LST branch (i.e., not WETH as collateral)</span>
 17 |     | <span class='unexecuted'>    ITroveManager public immutable troveManager;</span>
 18 |     | <span class='unexecuted'>    IWETH public immutable WETH;</span>
 19 |     | <span class='unexecuted'>    IBoldToken public immutable boldToken;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    IFlashLoanProvider public immutable flashLoanProvider;</span>
 22 |     | <span class='unexecuted'>    IExchange public immutable exchange;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    constructor(IAddressesRegistry _addressesRegistry, IFlashLoanProvider _flashLoanProvider, IExchange _exchange)</span>
 25 |     | <span class='unexecuted'>        AddRemoveManagers(_addressesRegistry)</span>
 26 |     | <span class='neutral'>    {</span>
 27 |     | <span class='unexecuted'>        borrowerOperations = _addressesRegistry.borrowerOperations();</span>
 28 |     | <span class='unexecuted'>        troveManager = _addressesRegistry.troveManager();</span>
 29 |     | <span class='unexecuted'>        boldToken = _addressesRegistry.boldToken();</span>
 30 |     | <span class='unexecuted'>        WETH = _addressesRegistry.WETH();</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>        flashLoanProvider = _flashLoanProvider;</span>
 33 |     | <span class='unexecuted'>        exchange = _exchange;</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>    function _checkAdjustTroveManagers(</span>
 37 |     | <span class='neutral'>        uint256 _troveId,</span>
 38 |     | <span class='neutral'>        uint256 _collChange,</span>
 39 |     | <span class='neutral'>        bool _isCollIncrease,</span>
 40 |     | <span class='neutral'>        uint256 _boldChange,</span>
 41 |     | <span class='neutral'>        bool _isDebtIncrease</span>
 42 |     | <span class='unexecuted'>    ) internal view returns (address) {</span>
 43 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_troveId);</span>
 44 |     | <span class='neutral'>        address receiver = owner;</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>        if ((!_isCollIncrease &amp;&amp; _collChange &gt; 0) || _isDebtIncrease) {</span>
 47 |     | <span class='unexecuted'>            receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);</span>
 48 |     | <span class='neutral'>        }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='unexecuted'>        if (_isCollIncrease || (!_isDebtIncrease &amp;&amp; _boldChange &gt; 0)) {</span>
 51 |     | <span class='unexecuted'>            _requireSenderIsOwnerOrAddManager(_troveId, owner);</span>
 52 |     | <span class='neutral'>        }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>        return receiver;</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'>}</span>
 57 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/GasCompZapper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;./BaseZapper.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../Dependencies/Constants.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>contract GasCompZapper is BaseZapper {</span>
  11 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>    IERC20 public immutable collToken;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>    constructor(IAddressesRegistry _addressesRegistry, IFlashLoanProvider _flashLoanProvider, IExchange _exchange)</span>
  16 |     | <span class='unexecuted'>        BaseZapper(_addressesRegistry, _flashLoanProvider, _exchange)</span>
  17 |     | <span class='neutral'>    {</span>
  18 |     | <span class='unexecuted'>        collToken = _addressesRegistry.collToken();</span>
  19 |     | <span class='unexecuted'>        require(address(WETH) != address(collToken), &quot;GCZ: Wrong coll branch&quot;);</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>        // Approve WETH to BorrowerOperations</span>
  22 |     | <span class='unexecuted'>        WETH.approve(address(borrowerOperations), type(uint256).max);</span>
  23 |     | <span class='neutral'>        // Approve coll to BorrowerOperations</span>
  24 |     | <span class='unexecuted'>        collToken.approve(address(borrowerOperations), type(uint256).max);</span>
  25 |     | <span class='neutral'>        // Approve Coll to exchange module (for closeTroveFromCollateral)</span>
  26 |     | <span class='unexecuted'>        collToken.approve(address(_exchange), type(uint256).max);</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    function openTroveWithRawETH(OpenTroveParams calldata _params) external payable returns (uint256) {</span>
  30 |     | <span class='unexecuted'>        require(msg.value == ETH_GAS_COMPENSATION, &quot;GCZ: Wrong ETH&quot;);</span>
  31 |     | <span class='unexecuted'>        require(</span>
  32 |     | <span class='unexecuted'>            _params.batchManager == address(0) || _params.annualInterestRate == 0,</span>
  33 |     | <span class='neutral'>            &quot;GCZ: Cannot choose interest if joining a batch&quot;</span>
  34 |     | <span class='neutral'>        );</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>        // Convert ETH to WETH</span>
  37 |     | <span class='unexecuted'>        WETH.deposit{value: msg.value}();</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>        // Pull coll</span>
  40 |     | <span class='unexecuted'>        collToken.safeTransferFrom(msg.sender, address(this), _params.collAmount);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>        uint256 troveId;</span>
  43 |     | <span class='unexecuted'>        if (_params.batchManager == address(0)) {</span>
  44 |     | <span class='unexecuted'>            troveId = borrowerOperations.openTrove(</span>
  45 |     | <span class='unexecuted'>                _params.owner,</span>
  46 |     | <span class='unexecuted'>                _params.ownerIndex,</span>
  47 |     | <span class='unexecuted'>                _params.collAmount,</span>
  48 |     | <span class='unexecuted'>                _params.boldAmount,</span>
  49 |     | <span class='unexecuted'>                _params.upperHint,</span>
  50 |     | <span class='unexecuted'>                _params.lowerHint,</span>
  51 |     | <span class='unexecuted'>                _params.annualInterestRate,</span>
  52 |     | <span class='unexecuted'>                _params.maxUpfrontFee,</span>
  53 |     | <span class='neutral'>                // Add this contract as add/receive manager to be able to fully adjust trove,</span>
  54 |     | <span class='neutral'>                // while keeping the same management functionality</span>
  55 |     | <span class='unexecuted'>                address(this), // add manager</span>
  56 |     | <span class='unexecuted'>                address(this), // remove manager</span>
  57 |     | <span class='unexecuted'>                address(this) // receiver for remove manager</span>
  58 |     | <span class='neutral'>            );</span>
  59 |     | <span class='unexecuted'>        } else {</span>
  60 |     | <span class='unexecuted'>            IBorrowerOperations.OpenTroveAndJoinInterestBatchManagerParams memory</span>
  61 |     | <span class='unexecuted'>                openTroveAndJoinInterestBatchManagerParams = IBorrowerOperations</span>
  62 |     | <span class='neutral'>                    .OpenTroveAndJoinInterestBatchManagerParams({</span>
  63 |     | <span class='unexecuted'>                    owner: _params.owner,</span>
  64 |     | <span class='unexecuted'>                    ownerIndex: _params.ownerIndex,</span>
  65 |     | <span class='unexecuted'>                    collAmount: _params.collAmount,</span>
  66 |     | <span class='unexecuted'>                    boldAmount: _params.boldAmount,</span>
  67 |     | <span class='unexecuted'>                    upperHint: _params.upperHint,</span>
  68 |     | <span class='unexecuted'>                    lowerHint: _params.lowerHint,</span>
  69 |     | <span class='unexecuted'>                    interestBatchManager: _params.batchManager,</span>
  70 |     | <span class='unexecuted'>                    maxUpfrontFee: _params.maxUpfrontFee,</span>
  71 |     | <span class='neutral'>                    // Add this contract as add/receive manager to be able to fully adjust trove,</span>
  72 |     | <span class='neutral'>                    // while keeping the same management functionality</span>
  73 |     | <span class='unexecuted'>                    addManager: address(this), // add manager</span>
  74 |     | <span class='neutral'>                    removeManager: address(this), // remove manager</span>
  75 |     | <span class='neutral'>                    receiver: address(this) // receiver for remove manager</span>
  76 |     | <span class='neutral'>                });</span>
  77 |     | <span class='unexecuted'>            troveId =</span>
  78 |     | <span class='unexecuted'>                borrowerOperations.openTroveAndJoinInterestBatchManager(openTroveAndJoinInterestBatchManagerParams);</span>
  79 |     | <span class='neutral'>        }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>        boldToken.transfer(msg.sender, _params.boldAmount);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>        // Set add/remove managers</span>
  84 |     | <span class='unexecuted'>        _setAddManager(troveId, _params.addManager);</span>
  85 |     | <span class='unexecuted'>        _setRemoveManagerAndReceiver(troveId, _params.removeManager, _params.receiver);</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>        return troveId;</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>    function addColl(uint256 _troveId, uint256 _amount) external {</span>
  91 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_troveId);</span>
  92 |     | <span class='unexecuted'>        _requireSenderIsOwnerOrAddManager(_troveId, owner);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        IBorrowerOperations borrowerOperationsCached = borrowerOperations;</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>        // Pull coll</span>
  97 |     | <span class='unexecuted'>        collToken.safeTransferFrom(msg.sender, address(this), _amount);</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>        borrowerOperationsCached.addColl(_troveId, _amount);</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>    function withdrawColl(uint256 _troveId, uint256 _amount) external {</span>
 103 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_troveId);</span>
 104 |     | <span class='unexecuted'>        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>        borrowerOperations.withdrawColl(_troveId, _amount);</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>        // Send coll left</span>
 109 |     | <span class='unexecuted'>        collToken.safeTransfer(receiver, _amount);</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>    function withdrawBold(uint256 _troveId, uint256 _boldAmount, uint256 _maxUpfrontFee) external {</span>
 113 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_troveId);</span>
 114 |     | <span class='unexecuted'>        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>        borrowerOperations.withdrawBold(_troveId, _boldAmount, _maxUpfrontFee);</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>        // Send Bold</span>
 119 |     | <span class='unexecuted'>        boldToken.transfer(receiver, _boldAmount);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>    function repayBold(uint256 _troveId, uint256 _boldAmount) external {</span>
 123 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_troveId);</span>
 124 |     | <span class='unexecuted'>        _requireSenderIsOwnerOrAddManager(_troveId, owner);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>        // Set initial balances to make sure there are not lefovers</span>
 127 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
 128 |     | <span class='unexecuted'>        _setInitialTokensAndBalances(collToken, boldToken, initialBalances);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>        // Pull Bold</span>
 131 |     | <span class='unexecuted'>        boldToken.transferFrom(msg.sender, address(this), _boldAmount);</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>        borrowerOperations.repayBold(_troveId, _boldAmount);</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>        // return leftovers to user</span>
 136 |     | <span class='unexecuted'>        _returnLeftovers(initialBalances);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>    function adjustTrove(</span>
 140 |     | <span class='neutral'>        uint256 _troveId,</span>
 141 |     | <span class='neutral'>        uint256 _collChange,</span>
 142 |     | <span class='neutral'>        bool _isCollIncrease,</span>
 143 |     | <span class='neutral'>        uint256 _boldChange,</span>
 144 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
 145 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
 146 |     | <span class='neutral'>    ) external {</span>
 147 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
 148 |     | <span class='unexecuted'>        address receiver =</span>
 149 |     | <span class='unexecuted'>            _adjustTrovePre(_troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, initialBalances);</span>
 150 |     | <span class='unexecuted'>        borrowerOperations.adjustTrove(</span>
 151 |     | <span class='neutral'>            _troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, _maxUpfrontFee</span>
 152 |     | <span class='neutral'>        );</span>
 153 |     | <span class='unexecuted'>        _adjustTrovePost(_collChange, _isCollIncrease, _boldChange, _isDebtIncrease, receiver, initialBalances);</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>    function adjustZombieTrove(</span>
 157 |     | <span class='neutral'>        uint256 _troveId,</span>
 158 |     | <span class='neutral'>        uint256 _collChange,</span>
 159 |     | <span class='neutral'>        bool _isCollIncrease,</span>
 160 |     | <span class='neutral'>        uint256 _boldChange,</span>
 161 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
 162 |     | <span class='neutral'>        uint256 _upperHint,</span>
 163 |     | <span class='neutral'>        uint256 _lowerHint,</span>
 164 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
 165 |     | <span class='unexecuted'>    ) external {</span>
 166 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
 167 |     | <span class='unexecuted'>        address receiver =</span>
 168 |     | <span class='unexecuted'>            _adjustTrovePre(_troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, initialBalances);</span>
 169 |     | <span class='unexecuted'>        borrowerOperations.adjustZombieTrove(</span>
 170 |     | <span class='neutral'>            _troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, _upperHint, _lowerHint, _maxUpfrontFee</span>
 171 |     | <span class='neutral'>        );</span>
 172 |     | <span class='unexecuted'>        _adjustTrovePost(_collChange, _isCollIncrease, _boldChange, _isDebtIncrease, receiver, initialBalances);</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>    function _adjustTrovePre(</span>
 176 |     | <span class='neutral'>        uint256 _troveId,</span>
 177 |     | <span class='neutral'>        uint256 _collChange,</span>
 178 |     | <span class='neutral'>        bool _isCollIncrease,</span>
 179 |     | <span class='neutral'>        uint256 _boldChange,</span>
 180 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
 181 |     | <span class='neutral'>        InitialBalances memory _initialBalances</span>
 182 |     | <span class='unexecuted'>    ) internal returns (address) {</span>
 183 |     | <span class='unexecuted'>        address receiver =</span>
 184 |     | <span class='unexecuted'>            _checkAdjustTroveManagers(_troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease);</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>        // Set initial balances to make sure there are not lefovers</span>
 187 |     | <span class='unexecuted'>        _setInitialTokensAndBalances(collToken, boldToken, _initialBalances);</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>        // Pull coll</span>
 190 |     | <span class='unexecuted'>        if (_isCollIncrease) {</span>
 191 |     | <span class='unexecuted'>            collToken.safeTransferFrom(msg.sender, address(this), _collChange);</span>
 192 |     | <span class='neutral'>        }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>        // Pull Bold</span>
 195 |     | <span class='unexecuted'>        if (!_isDebtIncrease) {</span>
 196 |     | <span class='unexecuted'>            boldToken.transferFrom(msg.sender, address(this), _boldChange);</span>
 197 |     | <span class='neutral'>        }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='unexecuted'>        return receiver;</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>    function _adjustTrovePost(</span>
 203 |     | <span class='neutral'>        uint256 _collChange,</span>
 204 |     | <span class='neutral'>        bool _isCollIncrease,</span>
 205 |     | <span class='neutral'>        uint256 _boldChange,</span>
 206 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
 207 |     | <span class='neutral'>        address _receiver,</span>
 208 |     | <span class='neutral'>        InitialBalances memory _initialBalances</span>
 209 |     | <span class='neutral'>    ) internal {</span>
 210 |     | <span class='neutral'>        // Send coll left</span>
 211 |     | <span class='unexecuted'>        if (!_isCollIncrease) {</span>
 212 |     | <span class='unexecuted'>            collToken.safeTransfer(_receiver, _collChange);</span>
 213 |     | <span class='neutral'>        }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>        // Send Bold</span>
 216 |     | <span class='unexecuted'>        if (_isDebtIncrease) {</span>
 217 |     | <span class='unexecuted'>            boldToken.transfer(_receiver, _boldChange);</span>
 218 |     | <span class='neutral'>        }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>        // return leftovers to user</span>
 221 |     | <span class='unexecuted'>        _returnLeftovers(_initialBalances);</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='unexecuted'>    function closeTroveToRawETH(uint256 _troveId) external {</span>
 225 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_troveId);</span>
 226 |     | <span class='unexecuted'>        address payable receiver = payable(_requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner));</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>        // pull Bold for repayment</span>
 229 |     | <span class='unexecuted'>        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);</span>
 230 |     | <span class='unexecuted'>        boldToken.transferFrom(msg.sender, address(this), trove.entireDebt);</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='unexecuted'>        borrowerOperations.closeTrove(_troveId);</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>        // Send coll left</span>
 235 |     | <span class='unexecuted'>        collToken.safeTransfer(receiver, trove.entireColl);</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>        // Send gas compensation</span>
 238 |     | <span class='unexecuted'>        WETH.withdraw(ETH_GAS_COMPENSATION);</span>
 239 |     | <span class='unexecuted'>        (bool success,) = receiver.call{value: ETH_GAS_COMPENSATION}(&quot;&quot;);</span>
 240 |     | <span class='unexecuted'>        require(success, &quot;GCZ: Sending ETH failed&quot;);</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='unexecuted'>    function closeTroveFromCollateral(uint256 _troveId, uint256 _flashLoanAmount) external override {</span>
 244 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_troveId);</span>
 245 |     | <span class='unexecuted'>        address payable receiver = payable(_requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner));</span>
 246 |     | <span class='unexecuted'>        CloseTroveParams memory params =</span>
 247 |     | <span class='unexecuted'>            CloseTroveParams({troveId: _troveId, flashLoanAmount: _flashLoanAmount, receiver: receiver});</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='neutral'>        // Set initial balances to make sure there are not lefovers</span>
 250 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
 251 |     | <span class='unexecuted'>        initialBalances.tokens[0] = collToken;</span>
 252 |     | <span class='unexecuted'>        initialBalances.tokens[1] = boldToken;</span>
 253 |     | <span class='unexecuted'>        _setInitialBalancesAndReceiver(initialBalances, receiver);</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>        // Flash loan coll</span>
 256 |     | <span class='unexecuted'>        flashLoanProvider.makeFlashLoan(</span>
 257 |     | <span class='unexecuted'>            collToken, _flashLoanAmount, IFlashLoanProvider.Operation.CloseTrove, abi.encode(params)</span>
 258 |     | <span class='neutral'>        );</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>        // return leftovers to user</span>
 261 |     | <span class='unexecuted'>        _returnLeftovers(initialBalances);</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='unexecuted'>    function receiveFlashLoanOnCloseTroveFromCollateral(</span>
 265 |     | <span class='neutral'>        CloseTroveParams calldata _params,</span>
 266 |     | <span class='neutral'>        uint256 _effectiveFlashLoanAmount</span>
 267 |     | <span class='neutral'>    ) external {</span>
 268 |     | <span class='unexecuted'>        require(msg.sender == address(flashLoanProvider), &quot;GCZ: Caller not FlashLoan provider&quot;);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='unexecuted'>        LatestTroveData memory trove = troveManager.getLatestTroveData(_params.troveId);</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>        // Swap Coll from flash loan to Bold, so we can repay and close trove</span>
 273 |     | <span class='neutral'>        // We swap the flash loan minus the flash loan fee</span>
 274 |     | <span class='unexecuted'>        exchange.swapToBold(_effectiveFlashLoanAmount, trove.entireDebt);</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>        // We asked for a min of entireDebt in swapToBold call above, so we don’t check again here:</span>
 277 |     | <span class='neutral'>        //uint256 receivedBoldAmount = exchange.swapToBold(_effectiveFlashLoanAmount, trove.entireDebt);</span>
 278 |     | <span class='neutral'>        //require(receivedBoldAmount &gt;= trove.entireDebt, &quot;GCZ: Not enough BOLD obtained to repay&quot;);</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='unexecuted'>        borrowerOperations.closeTrove(_params.troveId);</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>        // Send coll back to return flash loan</span>
 283 |     | <span class='unexecuted'>        collToken.safeTransfer(address(flashLoanProvider), _params.flashLoanAmount);</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>        // Send coll left</span>
 286 |     | <span class='unexecuted'>        collToken.safeTransfer(_params.receiver, trove.entireColl - _params.flashLoanAmount);</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>        // Send gas compensation</span>
 289 |     | <span class='unexecuted'>        WETH.withdraw(ETH_GAS_COMPENSATION);</span>
 290 |     | <span class='unexecuted'>        (bool success,) = _params.receiver.call{value: ETH_GAS_COMPENSATION}(&quot;&quot;);</span>
 291 |     | <span class='unexecuted'>        require(success, &quot;GCZ: Sending ETH failed&quot;);</span>
 292 |     | <span class='neutral'>    }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>    receive() external payable {}</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>    // Unimplemented flash loan receive functions for leverage</span>
 297 |     | <span class='unexecuted'>    function receiveFlashLoanOnOpenLeveragedTrove(</span>
 298 |     | <span class='neutral'>        ILeverageZapper.OpenLeveragedTroveParams calldata _params,</span>
 299 |     | <span class='neutral'>        uint256 _effectiveFlashLoanAmount</span>
 300 |     | <span class='neutral'>    ) external virtual override {}</span>
 301 |     | <span class='unexecuted'>    function receiveFlashLoanOnLeverUpTrove(</span>
 302 |     | <span class='neutral'>        ILeverageZapper.LeverUpTroveParams calldata _params,</span>
 303 |     | <span class='neutral'>        uint256 _effectiveFlashLoanAmount</span>
 304 |     | <span class='neutral'>    ) external virtual override {}</span>
 305 |     | <span class='unexecuted'>    function receiveFlashLoanOnLeverDownTrove(</span>
 306 |     | <span class='neutral'>        ILeverageZapper.LeverDownTroveParams calldata _params,</span>
 307 |     | <span class='neutral'>        uint256 _effectiveFlashLoanAmount</span>
 308 |     | <span class='neutral'>    ) external virtual override {}</span>
 309 |     | <span class='neutral'>}</span>
 310 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Interfaces/IExchange.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface IExchange {</span>
  6 |     | <span class='neutral'>    function swapFromBold(uint256 _boldAmount, uint256 _minCollAmount) external;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    function swapToBold(uint256 _collAmount, uint256 _minBoldAmount) external returns (uint256);</span>
  9 |     | <span class='neutral'>}</span>
 10 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Interfaces/IExchangeHelpers.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IExchangeHelpers {</span>
  8 |     | <span class='neutral'>    function getCollFromBold(uint256 _boldAmount, IERC20 _collToken, uint256 _desiredCollAmount)</span>
  9 |     | <span class='neutral'>        external /* view */</span>
 10 |     | <span class='neutral'>        returns (uint256, uint256);</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Interfaces/IFlashLoanProvider.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./ILeverageZapper.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./IFlashLoanReceiver.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>interface IFlashLoanProvider {</span>
 10 |     | <span class='neutral'>    enum Operation {</span>
 11 |     | <span class='neutral'>        OpenTrove,</span>
 12 |     | <span class='neutral'>        CloseTrove,</span>
 13 |     | <span class='neutral'>        LeverUpTrove,</span>
 14 |     | <span class='neutral'>        LeverDownTrove</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function receiver() external view returns (IFlashLoanReceiver);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function makeFlashLoan(IERC20 _token, uint256 _amount, Operation _operation, bytes calldata userData) external;</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Interfaces/IFlashLoanReceiver.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./IZapper.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./ILeverageZapper.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>interface IFlashLoanReceiver {</span>
  9 |     | <span class='neutral'>    function receiveFlashLoanOnOpenLeveragedTrove(</span>
 10 |     | <span class='neutral'>        ILeverageZapper.OpenLeveragedTroveParams calldata _params,</span>
 11 |     | <span class='neutral'>        uint256 _effectiveFlashLoanAmount</span>
 12 |     | <span class='neutral'>    ) external;</span>
 13 |     | <span class='neutral'>    function receiveFlashLoanOnLeverUpTrove(</span>
 14 |     | <span class='neutral'>        ILeverageZapper.LeverUpTroveParams calldata _params,</span>
 15 |     | <span class='neutral'>        uint256 _effectiveFlashLoanAmount</span>
 16 |     | <span class='neutral'>    ) external;</span>
 17 |     | <span class='neutral'>    function receiveFlashLoanOnLeverDownTrove(</span>
 18 |     | <span class='neutral'>        ILeverageZapper.LeverDownTroveParams calldata _params,</span>
 19 |     | <span class='neutral'>        uint256 _effectiveFlashLoanAmount</span>
 20 |     | <span class='neutral'>    ) external;</span>
 21 |     | <span class='neutral'>    function receiveFlashLoanOnCloseTroveFromCollateral(</span>
 22 |     | <span class='neutral'>        IZapper.CloseTroveParams calldata _params,</span>
 23 |     | <span class='neutral'>        uint256 _effectiveFlashLoanAmount</span>
 24 |     | <span class='neutral'>    ) external;</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Interfaces/ILeverageZapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./IZapper.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface ILeverageZapper is IZapper {</span>
  8 |     | <span class='neutral'>    struct OpenLeveragedTroveParams {</span>
  9 |     | <span class='neutral'>        address owner;</span>
 10 |     | <span class='neutral'>        uint256 ownerIndex;</span>
 11 |     | <span class='neutral'>        uint256 collAmount;</span>
 12 |     | <span class='neutral'>        uint256 flashLoanAmount;</span>
 13 |     | <span class='neutral'>        uint256 boldAmount;</span>
 14 |     | <span class='neutral'>        uint256 upperHint;</span>
 15 |     | <span class='neutral'>        uint256 lowerHint;</span>
 16 |     | <span class='neutral'>        uint256 annualInterestRate;</span>
 17 |     | <span class='neutral'>        address batchManager;</span>
 18 |     | <span class='neutral'>        uint256 maxUpfrontFee;</span>
 19 |     | <span class='neutral'>        address addManager;</span>
 20 |     | <span class='neutral'>        address removeManager;</span>
 21 |     | <span class='neutral'>        address receiver;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    struct LeverUpTroveParams {</span>
 25 |     | <span class='neutral'>        uint256 troveId;</span>
 26 |     | <span class='neutral'>        uint256 flashLoanAmount;</span>
 27 |     | <span class='neutral'>        uint256 boldAmount;</span>
 28 |     | <span class='neutral'>        uint256 maxUpfrontFee;</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    struct LeverDownTroveParams {</span>
 32 |     | <span class='neutral'>        uint256 troveId;</span>
 33 |     | <span class='neutral'>        uint256 flashLoanAmount;</span>
 34 |     | <span class='neutral'>        uint256 minBoldAmount;</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function openLeveragedTroveWithRawETH(OpenLeveragedTroveParams calldata _params) external payable;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    function leverUpTrove(LeverUpTroveParams calldata _params) external;</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    function leverDownTrove(LeverDownTroveParams calldata _params) external;</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    function leverageRatioToCollateralRatio(uint256 _inputRatio) external pure returns (uint256);</span>
 44 |     | <span class='neutral'>}</span>
 45 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Interfaces/IZapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./IFlashLoanProvider.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./IExchange.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>interface IZapper {</span>
  9 |     | <span class='neutral'>    struct OpenTroveParams {</span>
 10 |     | <span class='neutral'>        address owner;</span>
 11 |     | <span class='neutral'>        uint256 ownerIndex;</span>
 12 |     | <span class='neutral'>        uint256 collAmount;</span>
 13 |     | <span class='neutral'>        uint256 boldAmount;</span>
 14 |     | <span class='neutral'>        uint256 upperHint;</span>
 15 |     | <span class='neutral'>        uint256 lowerHint;</span>
 16 |     | <span class='neutral'>        uint256 annualInterestRate;</span>
 17 |     | <span class='neutral'>        address batchManager;</span>
 18 |     | <span class='neutral'>        uint256 maxUpfrontFee;</span>
 19 |     | <span class='neutral'>        address addManager;</span>
 20 |     | <span class='neutral'>        address removeManager;</span>
 21 |     | <span class='neutral'>        address receiver;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    struct CloseTroveParams {</span>
 25 |     | <span class='neutral'>        uint256 troveId;</span>
 26 |     | <span class='neutral'>        uint256 flashLoanAmount;</span>
 27 |     | <span class='neutral'>        address receiver;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    function flashLoanProvider() external view returns (IFlashLoanProvider);</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    function exchange() external view returns (IExchange);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    function openTroveWithRawETH(OpenTroveParams calldata _params) external payable returns (uint256);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    function closeTroveFromCollateral(uint256 _troveId, uint256 _flashLoanAmount) external;</span>
 37 |     | <span class='neutral'>}</span>
 38 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/LeftoversSweep.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>import &quot;../Interfaces/IBoldToken.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 | *   | <span class='executed'>contract LeftoversSweep {</span>
 11 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    struct InitialBalances {</span>
 14 |     | <span class='neutral'>        IERC20[4] tokens; // paving the way for completely dynamic routes</span>
 15 |     | <span class='neutral'>        uint256[4] balances;</span>
 16 |     | <span class='neutral'>        address receiver;</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function _setInitialTokensAndBalances(</span>
 20 |     | <span class='neutral'>        IERC20 _collToken,</span>
 21 |     | <span class='neutral'>        IBoldToken _boldToken,</span>
 22 |     | <span class='neutral'>        InitialBalances memory _initialBalances</span>
 23 |     | <span class='neutral'>    ) internal view {</span>
 24 |     | <span class='unexecuted'>        _setInitialTokensBalancesAndReceiver(_collToken, _boldToken, _initialBalances, msg.sender);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function _setInitialTokensBalancesAndReceiver(</span>
 28 |     | <span class='neutral'>        IERC20 _collToken,</span>
 29 |     | <span class='neutral'>        IBoldToken _boldToken,</span>
 30 |     | <span class='neutral'>        InitialBalances memory _initialBalances,</span>
 31 |     | <span class='neutral'>        address _receiver</span>
 32 |     | <span class='neutral'>    ) internal view {</span>
 33 |     | <span class='unexecuted'>        _initialBalances.tokens[0] = _collToken;</span>
 34 |     | <span class='unexecuted'>        _initialBalances.tokens[1] = _boldToken;</span>
 35 |     | <span class='unexecuted'>        _setInitialBalancesAndReceiver(_initialBalances, _receiver);</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='unexecuted'>    function _setInitialBalances(InitialBalances memory _initialBalances) internal view {</span>
 39 |     | <span class='unexecuted'>        _setInitialBalancesAndReceiver(_initialBalances, msg.sender);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='unexecuted'>    function _setInitialBalancesAndReceiver(InitialBalances memory _initialBalances, address _receiver) internal view {</span>
 43 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _initialBalances.tokens.length; i++) {</span>
 44 |     | <span class='unexecuted'>            if (address(_initialBalances.tokens[i]) == address(0)) break;</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>            _initialBalances.balances[i] = _initialBalances.tokens[i].balanceOf(address(this));</span>
 47 |     | <span class='neutral'>        }</span>
 48 |     | <span class='unexecuted'>        _initialBalances.receiver = _receiver;</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>    function _returnLeftovers(InitialBalances memory _initialBalances) internal {</span>
 52 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _initialBalances.tokens.length; i++) {</span>
 53 |     | <span class='unexecuted'>            if (address(_initialBalances.tokens[i]) == address(0)) break;</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>            uint256 currentBalance = _initialBalances.tokens[i].balanceOf(address(this));</span>
 56 |     | <span class='unexecuted'>            if (currentBalance &gt; _initialBalances.balances[i]) {</span>
 57 |     | <span class='unexecuted'>                _initialBalances.tokens[i].safeTransfer(</span>
 58 |     | <span class='unexecuted'>                    _initialBalances.receiver, currentBalance - _initialBalances.balances[i]</span>
 59 |     | <span class='neutral'>                );</span>
 60 |     | <span class='neutral'>            }</span>
 61 |     | <span class='neutral'>        }</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'>}</span>
 64 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/LeverageLSTZapper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;./GasCompZapper.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../Dependencies/Constants.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>contract LeverageLSTZapper is GasCompZapper, ILeverageZapper {</span>
  11 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>    constructor(IAddressesRegistry _addressesRegistry, IFlashLoanProvider _flashLoanProvider, IExchange _exchange)</span>
  14 |     | <span class='unexecuted'>        GasCompZapper(_addressesRegistry, _flashLoanProvider, _exchange)</span>
  15 |     | <span class='neutral'>    {</span>
  16 |     | <span class='neutral'>        // Approval of WETH and Coll to BorrowerOperations is done in parent GasCompZapper</span>
  17 |     | <span class='neutral'>        // Approve Bold to exchange module (Coll is approved in parent GasCompZapper)</span>
  18 |     | <span class='unexecuted'>        boldToken.approve(address(_exchange), type(uint256).max);</span>
  19 |     | <span class='neutral'>    }</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    function openLeveragedTroveWithRawETH(OpenLeveragedTroveParams calldata _params) external payable {</span>
  22 |     | <span class='unexecuted'>        require(msg.value == ETH_GAS_COMPENSATION, &quot;LZ: Wrong ETH&quot;);</span>
  23 |     | <span class='unexecuted'>        require(</span>
  24 |     | <span class='unexecuted'>            _params.batchManager == address(0) || _params.annualInterestRate == 0,</span>
  25 |     | <span class='neutral'>            &quot;LZ: Cannot choose interest if joining a batch&quot;</span>
  26 |     | <span class='neutral'>        );</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>        // Set initial balances to make sure there are not lefovers</span>
  29 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
  30 |     | <span class='unexecuted'>        _setInitialTokensAndBalances(collToken, boldToken, initialBalances);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>        // Convert ETH to WETH</span>
  33 |     | <span class='unexecuted'>        WETH.deposit{value: msg.value}();</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>        // Pull own coll</span>
  36 |     | <span class='unexecuted'>        collToken.safeTransferFrom(msg.sender, address(this), _params.collAmount);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>        // Flash loan coll</span>
  39 |     | <span class='unexecuted'>        flashLoanProvider.makeFlashLoan(</span>
  40 |     | <span class='unexecuted'>            collToken, _params.flashLoanAmount, IFlashLoanProvider.Operation.OpenTrove, abi.encode(_params)</span>
  41 |     | <span class='neutral'>        );</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>        // return leftovers to user</span>
  44 |     | <span class='unexecuted'>        _returnLeftovers(initialBalances);</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    // Callback from the flash loan provider</span>
  48 |     | <span class='unexecuted'>    function receiveFlashLoanOnOpenLeveragedTrove(</span>
  49 |     | <span class='neutral'>        OpenLeveragedTroveParams calldata _params,</span>
  50 |     | <span class='neutral'>        uint256 _effectiveFlashLoanAmount</span>
  51 |     | <span class='neutral'>    ) external override {</span>
  52 |     | <span class='unexecuted'>        require(msg.sender == address(flashLoanProvider), &quot;LZ: Caller not FlashLoan provider&quot;);</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>        uint256 totalCollAmount = _params.collAmount + _effectiveFlashLoanAmount;</span>
  55 |     | <span class='neutral'>        // We compute boldAmount off-chain for efficiency</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>        // Open trove</span>
  58 |     | <span class='unexecuted'>        uint256 troveId;</span>
  59 |     | <span class='unexecuted'>        if (_params.batchManager == address(0)) {</span>
  60 |     | <span class='unexecuted'>            troveId = borrowerOperations.openTrove(</span>
  61 |     | <span class='unexecuted'>                _params.owner,</span>
  62 |     | <span class='unexecuted'>                _params.ownerIndex,</span>
  63 |     | <span class='unexecuted'>                totalCollAmount,</span>
  64 |     | <span class='unexecuted'>                _params.boldAmount,</span>
  65 |     | <span class='unexecuted'>                _params.upperHint,</span>
  66 |     | <span class='unexecuted'>                _params.lowerHint,</span>
  67 |     | <span class='unexecuted'>                _params.annualInterestRate,</span>
  68 |     | <span class='unexecuted'>                _params.maxUpfrontFee,</span>
  69 |     | <span class='neutral'>                // Add this contract as add/receive manager to be able to fully adjust trove,</span>
  70 |     | <span class='neutral'>                // while keeping the same management functionality</span>
  71 |     | <span class='unexecuted'>                address(this), // add manager</span>
  72 |     | <span class='unexecuted'>                address(this), // remove manager</span>
  73 |     | <span class='unexecuted'>                address(this) // receiver for remove manager</span>
  74 |     | <span class='neutral'>            );</span>
  75 |     | <span class='unexecuted'>        } else {</span>
  76 |     | <span class='unexecuted'>            IBorrowerOperations.OpenTroveAndJoinInterestBatchManagerParams memory</span>
  77 |     | <span class='unexecuted'>                openTroveAndJoinInterestBatchManagerParams = IBorrowerOperations</span>
  78 |     | <span class='neutral'>                    .OpenTroveAndJoinInterestBatchManagerParams({</span>
  79 |     | <span class='unexecuted'>                    owner: _params.owner,</span>
  80 |     | <span class='unexecuted'>                    ownerIndex: _params.ownerIndex,</span>
  81 |     | <span class='unexecuted'>                    collAmount: totalCollAmount,</span>
  82 |     | <span class='unexecuted'>                    boldAmount: _params.boldAmount,</span>
  83 |     | <span class='unexecuted'>                    upperHint: _params.upperHint,</span>
  84 |     | <span class='unexecuted'>                    lowerHint: _params.lowerHint,</span>
  85 |     | <span class='unexecuted'>                    interestBatchManager: _params.batchManager,</span>
  86 |     | <span class='unexecuted'>                    maxUpfrontFee: _params.maxUpfrontFee,</span>
  87 |     | <span class='neutral'>                    // Add this contract as add/receive manager to be able to fully adjust trove,</span>
  88 |     | <span class='neutral'>                    // while keeping the same management functionality</span>
  89 |     | <span class='unexecuted'>                    addManager: address(this), // add manager</span>
  90 |     | <span class='neutral'>                    removeManager: address(this), // remove manager</span>
  91 |     | <span class='neutral'>                    receiver: address(this) // receiver for remove manager</span>
  92 |     | <span class='neutral'>                });</span>
  93 |     | <span class='unexecuted'>            troveId =</span>
  94 |     | <span class='unexecuted'>                borrowerOperations.openTroveAndJoinInterestBatchManager(openTroveAndJoinInterestBatchManagerParams);</span>
  95 |     | <span class='neutral'>        }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>        // Set add/remove managers</span>
  98 |     | <span class='unexecuted'>        _setAddManager(troveId, _params.addManager);</span>
  99 |     | <span class='unexecuted'>        _setRemoveManagerAndReceiver(troveId, _params.removeManager, _params.receiver);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>        // Swap Bold to Coll</span>
 102 |     | <span class='unexecuted'>        exchange.swapFromBold(_params.boldAmount, _params.flashLoanAmount);</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>        // Send coll back to return flash loan</span>
 105 |     | <span class='unexecuted'>        collToken.safeTransfer(address(flashLoanProvider), _params.flashLoanAmount);</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>    function leverUpTrove(LeverUpTroveParams calldata _params) external {</span>
 109 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_params.troveId);</span>
 110 |     | <span class='unexecuted'>        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_params.troveId, owner);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>        // Set initial balances to make sure there are not lefovers</span>
 113 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
 114 |     | <span class='unexecuted'>        _setInitialTokensBalancesAndReceiver(collToken, boldToken, initialBalances, receiver);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>        // Flash loan coll</span>
 117 |     | <span class='unexecuted'>        flashLoanProvider.makeFlashLoan(</span>
 118 |     | <span class='unexecuted'>            collToken, _params.flashLoanAmount, IFlashLoanProvider.Operation.LeverUpTrove, abi.encode(_params)</span>
 119 |     | <span class='neutral'>        );</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>        // return leftovers to user</span>
 122 |     | <span class='unexecuted'>        _returnLeftovers(initialBalances);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    // Callback from the flash loan provider</span>
 126 |     | <span class='unexecuted'>    function receiveFlashLoanOnLeverUpTrove(LeverUpTroveParams calldata _params, uint256 _effectiveFlashLoanAmount)</span>
 127 |     | <span class='neutral'>        external</span>
 128 |     | <span class='neutral'>        override</span>
 129 |     | <span class='neutral'>    {</span>
 130 |     | <span class='unexecuted'>        require(msg.sender == address(flashLoanProvider), &quot;LZ: Caller not FlashLoan provider&quot;);</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>        // Adjust trove</span>
 133 |     | <span class='neutral'>        // With the received coll from flash loan, we increase both the trove coll and debt</span>
 134 |     | <span class='unexecuted'>        borrowerOperations.adjustTrove(</span>
 135 |     | <span class='unexecuted'>            _params.troveId,</span>
 136 |     | <span class='neutral'>            _effectiveFlashLoanAmount, // flash loan amount minus fee</span>
 137 |     | <span class='unexecuted'>            true, // _isCollIncrease</span>
 138 |     | <span class='unexecuted'>            _params.boldAmount,</span>
 139 |     | <span class='neutral'>            true, // _isDebtIncrease</span>
 140 |     | <span class='unexecuted'>            _params.maxUpfrontFee</span>
 141 |     | <span class='neutral'>        );</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>        // Swap Bold to Coll</span>
 144 |     | <span class='neutral'>        // No need to use a min: if the obtained amount is not enough, the flash loan return below won’t be enough</span>
 145 |     | <span class='neutral'>        // And the flash loan provider will revert after this function exits</span>
 146 |     | <span class='neutral'>        // The frontend should calculate in advance the `_params.boldAmount` needed for this to work</span>
 147 |     | <span class='unexecuted'>        exchange.swapFromBold(_params.boldAmount, _params.flashLoanAmount);</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>        // Send coll back to return flash loan</span>
 150 |     | <span class='unexecuted'>        collToken.safeTransfer(address(flashLoanProvider), _params.flashLoanAmount);</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>    function leverDownTrove(LeverDownTroveParams calldata _params) external {</span>
 154 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_params.troveId);</span>
 155 |     | <span class='unexecuted'>        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_params.troveId, owner);</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>        // Set initial balances to make sure there are not lefovers</span>
 158 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
 159 |     | <span class='unexecuted'>        _setInitialTokensBalancesAndReceiver(collToken, boldToken, initialBalances, receiver);</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>        // Flash loan coll</span>
 162 |     | <span class='unexecuted'>        flashLoanProvider.makeFlashLoan(</span>
 163 |     | <span class='unexecuted'>            collToken, _params.flashLoanAmount, IFlashLoanProvider.Operation.LeverDownTrove, abi.encode(_params)</span>
 164 |     | <span class='neutral'>        );</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>        // return leftovers to user</span>
 167 |     | <span class='neutral'>        _returnLeftovers(initialBalances);</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    // Callback from the flash loan provider</span>
 171 |     | <span class='unexecuted'>    function receiveFlashLoanOnLeverDownTrove(LeverDownTroveParams calldata _params, uint256 _effectiveFlashLoanAmount)</span>
 172 |     | <span class='neutral'>        external</span>
 173 |     | <span class='neutral'>        override</span>
 174 |     | <span class='unexecuted'>    {</span>
 175 |     | <span class='unexecuted'>        require(msg.sender == address(flashLoanProvider), &quot;LZ: Caller not FlashLoan provider&quot;);</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>        // Swap Coll from flash loan to Bold, so we can repay and downsize trove</span>
 178 |     | <span class='neutral'>        // We swap the flash loan minus the flash loan fee</span>
 179 |     | <span class='neutral'>        // The frontend should calculate in advance the `_params.minBoldAmount` to achieve the desired leverage ratio</span>
 180 |     | <span class='neutral'>        // (with some slippage tolerance)</span>
 181 |     | <span class='unexecuted'>        uint256 receivedBoldAmount = exchange.swapToBold(_effectiveFlashLoanAmount, _params.minBoldAmount);</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>        // Adjust trove</span>
 184 |     | <span class='unexecuted'>        borrowerOperations.adjustTrove(</span>
 185 |     | <span class='unexecuted'>            _params.troveId,</span>
 186 |     | <span class='unexecuted'>            _params.flashLoanAmount,</span>
 187 |     | <span class='neutral'>            false, // _isCollIncrease</span>
 188 |     | <span class='neutral'>            receivedBoldAmount,</span>
 189 |     | <span class='neutral'>            false, // _isDebtIncrease</span>
 190 |     | <span class='neutral'>            0</span>
 191 |     | <span class='neutral'>        );</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>        // Send coll back to return flash loan</span>
 194 |     | <span class='unexecuted'>        collToken.safeTransfer(address(flashLoanProvider), _params.flashLoanAmount);</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>    // As formulas are symmetrical, it can be used in both ways</span>
 198 |     | <span class='unexecuted'>    function leverageRatioToCollateralRatio(uint256 _inputRatio) external pure returns (uint256) {</span>
 199 |     | <span class='unexecuted'>        return _inputRatio * DECIMAL_PRECISION / (_inputRatio - DECIMAL_PRECISION);</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'>}</span>
 202 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/LeverageWETHZapper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./WETHZapper.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../Dependencies/Constants.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Interfaces/ILeverageZapper.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>// TODO: unwrap WETH in _returnLeftovers</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>contract LeverageWETHZapper is WETHZapper, ILeverageZapper {</span>
  12 |     | <span class='unexecuted'>    constructor(IAddressesRegistry _addressesRegistry, IFlashLoanProvider _flashLoanProvider, IExchange _exchange)</span>
  13 |     | <span class='unexecuted'>        WETHZapper(_addressesRegistry, _flashLoanProvider, _exchange)</span>
  14 |     | <span class='neutral'>    {</span>
  15 |     | <span class='neutral'>        // Approval of coll (WETH) to BorrowerOperations is done in parent WETHZapper</span>
  16 |     | <span class='neutral'>        // Approve Bold to exchange module (Coll is approved in parent WETHZapper)</span>
  17 |     | <span class='unexecuted'>        boldToken.approve(address(_exchange), type(uint256).max);</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    function openLeveragedTroveWithRawETH(OpenLeveragedTroveParams calldata _params) external payable {</span>
  21 |     | <span class='unexecuted'>        require(msg.value == ETH_GAS_COMPENSATION + _params.collAmount, &quot;LZ: Wrong amount of ETH&quot;);</span>
  22 |     | <span class='unexecuted'>        require(</span>
  23 |     | <span class='unexecuted'>            _params.batchManager == address(0) || _params.annualInterestRate == 0,</span>
  24 |     | <span class='neutral'>            &quot;LZ: Cannot choose interest if joining a batch&quot;</span>
  25 |     | <span class='neutral'>        );</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>        // Set initial balances to make sure there are not lefovers</span>
  28 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
  29 |     | <span class='unexecuted'>        _setInitialTokensAndBalances(WETH, boldToken, initialBalances);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>        // Convert ETH to WETH</span>
  32 |     | <span class='unexecuted'>        WETH.deposit{value: msg.value}();</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>        // Flash loan coll</span>
  35 |     | <span class='unexecuted'>        flashLoanProvider.makeFlashLoan(</span>
  36 |     | <span class='unexecuted'>            WETH, _params.flashLoanAmount, IFlashLoanProvider.Operation.OpenTrove, abi.encode(_params)</span>
  37 |     | <span class='neutral'>        );</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>        // return leftovers to user</span>
  40 |     | <span class='unexecuted'>        _returnLeftovers(initialBalances);</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    // Callback from the flash loan provider</span>
  44 |     | <span class='unexecuted'>    function receiveFlashLoanOnOpenLeveragedTrove(</span>
  45 |     | <span class='neutral'>        OpenLeveragedTroveParams calldata _params,</span>
  46 |     | <span class='neutral'>        uint256 _effectiveFlashLoanAmount</span>
  47 |     | <span class='unexecuted'>    ) external override {</span>
  48 |     | <span class='unexecuted'>        require(msg.sender == address(flashLoanProvider), &quot;LZ: Caller not FlashLoan provider&quot;);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>        uint256 totalCollAmount = _params.collAmount + _effectiveFlashLoanAmount;</span>
  51 |     | <span class='neutral'>        // We compute boldAmount off-chain for efficiency</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>        uint256 troveId;</span>
  54 |     | <span class='neutral'>        // Open trove</span>
  55 |     | <span class='unexecuted'>        if (_params.batchManager == address(0)) {</span>
  56 |     | <span class='unexecuted'>            troveId = borrowerOperations.openTrove(</span>
  57 |     | <span class='unexecuted'>                _params.owner,</span>
  58 |     | <span class='unexecuted'>                _params.ownerIndex,</span>
  59 |     | <span class='unexecuted'>                totalCollAmount,</span>
  60 |     | <span class='unexecuted'>                _params.boldAmount,</span>
  61 |     | <span class='unexecuted'>                _params.upperHint,</span>
  62 |     | <span class='unexecuted'>                _params.lowerHint,</span>
  63 |     | <span class='unexecuted'>                _params.annualInterestRate,</span>
  64 |     | <span class='unexecuted'>                _params.maxUpfrontFee,</span>
  65 |     | <span class='neutral'>                // Add this contract as add/receive manager to be able to fully adjust trove,</span>
  66 |     | <span class='neutral'>                // while keeping the same management functionality</span>
  67 |     | <span class='unexecuted'>                address(this), // add manager</span>
  68 |     | <span class='unexecuted'>                address(this), // remove manager</span>
  69 |     | <span class='unexecuted'>                address(this) // receiver for remove manager</span>
  70 |     | <span class='neutral'>            );</span>
  71 |     | <span class='unexecuted'>        } else {</span>
  72 |     | <span class='unexecuted'>            IBorrowerOperations.OpenTroveAndJoinInterestBatchManagerParams memory</span>
  73 |     | <span class='unexecuted'>                openTroveAndJoinInterestBatchManagerParams = IBorrowerOperations</span>
  74 |     | <span class='neutral'>                    .OpenTroveAndJoinInterestBatchManagerParams({</span>
  75 |     | <span class='unexecuted'>                    owner: _params.owner,</span>
  76 |     | <span class='unexecuted'>                    ownerIndex: _params.ownerIndex,</span>
  77 |     | <span class='unexecuted'>                    collAmount: totalCollAmount,</span>
  78 |     | <span class='unexecuted'>                    boldAmount: _params.boldAmount,</span>
  79 |     | <span class='unexecuted'>                    upperHint: _params.upperHint,</span>
  80 |     | <span class='unexecuted'>                    lowerHint: _params.lowerHint,</span>
  81 |     | <span class='unexecuted'>                    interestBatchManager: _params.batchManager,</span>
  82 |     | <span class='unexecuted'>                    maxUpfrontFee: _params.maxUpfrontFee,</span>
  83 |     | <span class='neutral'>                    // Add this contract as add/receive manager to be able to fully adjust trove,</span>
  84 |     | <span class='neutral'>                    // while keeping the same management functionality</span>
  85 |     | <span class='unexecuted'>                    addManager: address(this), // add manager</span>
  86 |     | <span class='neutral'>                    removeManager: address(this), // remove manager</span>
  87 |     | <span class='neutral'>                    receiver: address(this) // receiver for remove manager</span>
  88 |     | <span class='neutral'>                });</span>
  89 |     | <span class='unexecuted'>            troveId =</span>
  90 |     | <span class='unexecuted'>                borrowerOperations.openTroveAndJoinInterestBatchManager(openTroveAndJoinInterestBatchManagerParams);</span>
  91 |     | <span class='neutral'>        }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>        // Set add/remove managers</span>
  94 |     | <span class='unexecuted'>        _setAddManager(troveId, _params.addManager);</span>
  95 |     | <span class='unexecuted'>        _setRemoveManagerAndReceiver(troveId, _params.removeManager, _params.receiver);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>        // Swap Bold to Coll</span>
  98 |     | <span class='unexecuted'>        exchange.swapFromBold(_params.boldAmount, _params.flashLoanAmount);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>        // Send coll back to return flash loan</span>
 101 |     | <span class='unexecuted'>        WETH.transfer(address(flashLoanProvider), _params.flashLoanAmount);</span>
 102 |     | <span class='neutral'>        // WETH reverts on failure: https://etherscan.io/token/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>    function leverUpTrove(LeverUpTroveParams calldata _params) external {</span>
 106 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_params.troveId);</span>
 107 |     | <span class='unexecuted'>        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_params.troveId, owner);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        // Set initial balances to make sure there are not lefovers</span>
 110 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
 111 |     | <span class='unexecuted'>        _setInitialTokensBalancesAndReceiver(WETH, boldToken, initialBalances, receiver);</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        // Flash loan coll</span>
 114 |     | <span class='unexecuted'>        flashLoanProvider.makeFlashLoan(</span>
 115 |     | <span class='unexecuted'>            WETH, _params.flashLoanAmount, IFlashLoanProvider.Operation.LeverUpTrove, abi.encode(_params)</span>
 116 |     | <span class='neutral'>        );</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>        // return leftovers to user</span>
 119 |     | <span class='unexecuted'>        _returnLeftovers(initialBalances);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    // Callback from the flash loan provider</span>
 123 |     | <span class='unexecuted'>    function receiveFlashLoanOnLeverUpTrove(LeverUpTroveParams calldata _params, uint256 _effectiveFlashLoanAmount)</span>
 124 |     | <span class='neutral'>        external</span>
 125 |     | <span class='neutral'>        override</span>
 126 |     | <span class='neutral'>    {</span>
 127 |     | <span class='unexecuted'>        require(msg.sender == address(flashLoanProvider), &quot;LZ: Caller not FlashLoan provider&quot;);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>        // Adjust trove</span>
 130 |     | <span class='neutral'>        // With the received coll from flash loan, we increase both the trove coll and debt</span>
 131 |     | <span class='unexecuted'>        borrowerOperations.adjustTrove(</span>
 132 |     | <span class='unexecuted'>            _params.troveId,</span>
 133 |     | <span class='neutral'>            _effectiveFlashLoanAmount, // flash loan amount minus fee</span>
 134 |     | <span class='unexecuted'>            true, // _isCollIncrease</span>
 135 |     | <span class='unexecuted'>            _params.boldAmount,</span>
 136 |     | <span class='neutral'>            true, // _isDebtIncrease</span>
 137 |     | <span class='unexecuted'>            _params.maxUpfrontFee</span>
 138 |     | <span class='neutral'>        );</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>        // Swap Bold to Coll</span>
 141 |     | <span class='neutral'>        // No need to use a min: if the obtained amount is not enough, the flash loan return below won’t be enough</span>
 142 |     | <span class='neutral'>        // And the flash loan provider will revert after this function exits</span>
 143 |     | <span class='neutral'>        // The frontend should calculate in advance the `_params.boldAmount` needed for this to work</span>
 144 |     | <span class='unexecuted'>        exchange.swapFromBold(_params.boldAmount, _params.flashLoanAmount);</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>        // Send coll back to return flash loan</span>
 147 |     | <span class='unexecuted'>        WETH.transfer(address(flashLoanProvider), _params.flashLoanAmount);</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='unexecuted'>    function leverDownTrove(LeverDownTroveParams calldata _params) external {</span>
 151 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_params.troveId);</span>
 152 |     | <span class='unexecuted'>        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_params.troveId, owner);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>        // Set initial balances to make sure there are not lefovers</span>
 155 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
 156 |     | <span class='unexecuted'>        _setInitialTokensBalancesAndReceiver(WETH, boldToken, initialBalances, receiver);</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>        // Flash loan coll</span>
 159 |     | <span class='unexecuted'>        flashLoanProvider.makeFlashLoan(</span>
 160 |     | <span class='unexecuted'>            WETH, _params.flashLoanAmount, IFlashLoanProvider.Operation.LeverDownTrove, abi.encode(_params)</span>
 161 |     | <span class='neutral'>        );</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>        // return leftovers to user</span>
 164 |     | <span class='neutral'>        _returnLeftovers(initialBalances);</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    // Callback from the flash loan provider</span>
 168 |     | <span class='unexecuted'>    function receiveFlashLoanOnLeverDownTrove(LeverDownTroveParams calldata _params, uint256 _effectiveFlashLoanAmount)</span>
 169 |     | <span class='neutral'>        external</span>
 170 |     | <span class='neutral'>        override</span>
 171 |     | <span class='neutral'>    {</span>
 172 |     | <span class='unexecuted'>        require(msg.sender == address(flashLoanProvider), &quot;LZ: Caller not FlashLoan provider&quot;);</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>        // Swap Coll from flash loan to Bold, so we can repay and downsize trove</span>
 175 |     | <span class='neutral'>        // We swap the flash loan minus the flash loan fee</span>
 176 |     | <span class='neutral'>        // The frontend should calculate in advance the `_params.minBoldAmount` to achieve the desired leverage ratio</span>
 177 |     | <span class='neutral'>        // (with some slippage tolerance)</span>
 178 |     | <span class='unexecuted'>        uint256 receivedBoldAmount = exchange.swapToBold(_effectiveFlashLoanAmount, _params.minBoldAmount);</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>        // Adjust trove</span>
 181 |     | <span class='unexecuted'>        borrowerOperations.adjustTrove(</span>
 182 |     | <span class='unexecuted'>            _params.troveId,</span>
 183 |     | <span class='unexecuted'>            _params.flashLoanAmount,</span>
 184 |     | <span class='neutral'>            false, // _isCollIncrease</span>
 185 |     | <span class='neutral'>            receivedBoldAmount,</span>
 186 |     | <span class='neutral'>            false, // _isDebtIncrease</span>
 187 |     | <span class='neutral'>            0</span>
 188 |     | <span class='neutral'>        );</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>        // Send coll back to return flash loan</span>
 191 |     | <span class='unexecuted'>        WETH.transfer(address(flashLoanProvider), _params.flashLoanAmount);</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    // As formulas are symmetrical, it can be used in both ways</span>
 195 |     | <span class='unexecuted'>    function leverageRatioToCollateralRatio(uint256 _inputRatio) external pure returns (uint256) {</span>
 196 |     | <span class='unexecuted'>        return _inputRatio * DECIMAL_PRECISION / (_inputRatio - DECIMAL_PRECISION);</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'>}</span>
 199 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/Exchanges/Curve/ICurveFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./ICurvePool.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface ICurveFactory {</span>
  8 |     | <span class='neutral'>    function deploy_pool(</span>
  9 |     | <span class='neutral'>        string memory name,</span>
 10 |     | <span class='neutral'>        string memory symbol,</span>
 11 |     | <span class='neutral'>        address[2] memory coins,</span>
 12 |     | <span class='neutral'>        uint256 implementation_id,</span>
 13 |     | <span class='neutral'>        uint256 A,</span>
 14 |     | <span class='neutral'>        uint256 gamma,</span>
 15 |     | <span class='neutral'>        uint256 mid_fee,</span>
 16 |     | <span class='neutral'>        uint256 out_fee,</span>
 17 |     | <span class='neutral'>        uint256 fee_gamma,</span>
 18 |     | <span class='neutral'>        uint256 allowed_extra_profit,</span>
 19 |     | <span class='neutral'>        uint256 adjustment_step,</span>
 20 |     | <span class='neutral'>        uint256 ma_exp_time,</span>
 21 |     | <span class='neutral'>        uint256 initial_price</span>
 22 |     | <span class='neutral'>    ) external returns (ICurvePool);</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/Exchanges/Curve/ICurvePool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface ICurvePool {</span>
  6 |     | <span class='neutral'>    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external returns (uint256);</span>
  7 |     | <span class='neutral'>    //function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy, bool use_eth, address receiver) external returns (uint256 output);</span>
  8 |     | <span class='neutral'>    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns (uint256 output);</span>
  9 |     | <span class='neutral'>    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256 dy);</span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/Exchanges/Curve/ICurveStableswapNGFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./ICurveStableswapNGPool.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface ICurveStableswapNGFactory {</span>
  8 |     | <span class='neutral'>    /*</span>
  9 |     | <span class='neutral'>    function deploy_plain_pool(</span>
 10 |     | <span class='neutral'>        string memory name,</span>
 11 |     | <span class='neutral'>        string memory symbol,</span>
 12 |     | <span class='neutral'>        address[2] memory coins,</span>
 13 |     | <span class='neutral'>        uint256 A,</span>
 14 |     | <span class='neutral'>        uint256 fee,</span>
 15 |     | <span class='neutral'>        uint256 asset_type,</span>
 16 |     | <span class='neutral'>        uint256 implementation_id</span>
 17 |     | <span class='neutral'>    ) external returns (ICurvePool);</span>
 18 |     | <span class='neutral'>    */</span>
 19 |     | <span class='neutral'>    function deploy_plain_pool(</span>
 20 |     | <span class='neutral'>        string memory name,</span>
 21 |     | <span class='neutral'>        string memory symbol,</span>
 22 |     | <span class='neutral'>        address[] memory coins,</span>
 23 |     | <span class='neutral'>        uint256 A,</span>
 24 |     | <span class='neutral'>        uint256 fee,</span>
 25 |     | <span class='neutral'>        uint256 offpeg_fee_multiplier,</span>
 26 |     | <span class='neutral'>        uint256 ma_exp_time,</span>
 27 |     | <span class='neutral'>        uint256 implementation_id,</span>
 28 |     | <span class='neutral'>        uint8[] memory asset_types,</span>
 29 |     | <span class='neutral'>        bytes4[] memory method_ids,</span>
 30 |     | <span class='neutral'>        address[] memory oracles</span>
 31 |     | <span class='neutral'>    ) external returns (ICurveStableswapNGPool);</span>
 32 |     | <span class='neutral'>}</span>
 33 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/Exchanges/Curve/ICurveStableswapNGPool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface ICurveStableswapNGPool {</span>
  6 |     | <span class='neutral'>    function add_liquidity(uint256[] memory amounts, uint256 min_mint_amount) external returns (uint256);</span>
  7 |     | <span class='neutral'>    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256 output);</span>
  8 |     | <span class='neutral'>    function get_dx(int128 i, int128 j, uint256 dy) external view returns (uint256 dx);</span>
  9 |     | <span class='neutral'>    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256 dy);</span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/Exchanges/CurveExchange.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>import &quot;../../../Interfaces/IBoldToken.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;./Curve/ICurvePool.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;../../Interfaces/IExchange.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>contract CurveExchange is IExchange {</span>
 12 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    IERC20 public immutable collToken;</span>
 15 |     | <span class='unexecuted'>    IBoldToken public immutable boldToken;</span>
 16 |     | <span class='unexecuted'>    ICurvePool public immutable curvePool;</span>
 17 |     | <span class='unexecuted'>    uint256 public immutable COLL_TOKEN_INDEX;</span>
 18 |     | <span class='unexecuted'>    uint256 public immutable BOLD_TOKEN_INDEX;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    constructor(</span>
 21 |     | <span class='neutral'>        IERC20 _collToken,</span>
 22 |     | <span class='neutral'>        IBoldToken _boldToken,</span>
 23 |     | <span class='neutral'>        ICurvePool _curvePool,</span>
 24 |     | <span class='neutral'>        uint256 _collIndex,</span>
 25 |     | <span class='neutral'>        uint256 _boldIndex</span>
 26 |     | <span class='neutral'>    ) {</span>
 27 |     | <span class='unexecuted'>        collToken = _collToken;</span>
 28 |     | <span class='unexecuted'>        boldToken = _boldToken;</span>
 29 |     | <span class='unexecuted'>        curvePool = _curvePool;</span>
 30 |     | <span class='unexecuted'>        COLL_TOKEN_INDEX = _collIndex;</span>
 31 |     | <span class='unexecuted'>        BOLD_TOKEN_INDEX = _boldIndex;</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>    function swapFromBold(uint256 _boldAmount, uint256 _minCollAmount) external {</span>
 35 |     | <span class='unexecuted'>        ICurvePool curvePoolCached = curvePool;</span>
 36 |     | <span class='unexecuted'>        uint256 initialBoldBalance = boldToken.balanceOf(address(this));</span>
 37 |     | <span class='unexecuted'>        boldToken.transferFrom(msg.sender, address(this), _boldAmount);</span>
 38 |     | <span class='unexecuted'>        boldToken.approve(address(curvePoolCached), _boldAmount);</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>        uint256 output = curvePoolCached.exchange(BOLD_TOKEN_INDEX, COLL_TOKEN_INDEX, _boldAmount, _minCollAmount);</span>
 41 |     | <span class='unexecuted'>        collToken.safeTransfer(msg.sender, output);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>        uint256 currentBoldBalance = boldToken.balanceOf(address(this));</span>
 44 |     | <span class='unexecuted'>        if (currentBoldBalance &gt; initialBoldBalance) {</span>
 45 |     | <span class='unexecuted'>            boldToken.transfer(msg.sender, currentBoldBalance - initialBoldBalance);</span>
 46 |     | <span class='neutral'>        }</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='unexecuted'>    function swapToBold(uint256 _collAmount, uint256 _minBoldAmount) external returns (uint256) {</span>
 50 |     | <span class='unexecuted'>        ICurvePool curvePoolCached = curvePool;</span>
 51 |     | <span class='unexecuted'>        uint256 initialCollBalance = collToken.balanceOf(address(this));</span>
 52 |     | <span class='unexecuted'>        collToken.safeTransferFrom(msg.sender, address(this), _collAmount);</span>
 53 |     | <span class='unexecuted'>        collToken.approve(address(curvePoolCached), _collAmount);</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>        uint256 output = curvePoolCached.exchange(COLL_TOKEN_INDEX, BOLD_TOKEN_INDEX, _collAmount, _minBoldAmount);</span>
 56 |     | <span class='unexecuted'>        boldToken.transfer(msg.sender, output);</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='unexecuted'>        uint256 currentCollBalance = collToken.balanceOf(address(this));</span>
 59 |     | <span class='unexecuted'>        if (currentCollBalance &gt; initialCollBalance) {</span>
 60 |     | <span class='unexecuted'>            collToken.safeTransfer(msg.sender, currentCollBalance - initialCollBalance);</span>
 61 |     | <span class='neutral'>        }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='unexecuted'>        return output;</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'>}</span>
 66 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/Exchanges/HybridCurveUniV3Exchange.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.18;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/utils/math/Math.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>import &quot;../../../Interfaces/IWETH.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../../LeftoversSweep.sol&quot;;</span>
  10 |     | <span class='neutral'>// Curve</span>
  11 |     | <span class='neutral'>import &quot;./Curve/ICurveStableswapNGPool.sol&quot;;</span>
  12 |     | <span class='neutral'>// UniV3</span>
  13 |     | <span class='neutral'>import &quot;./UniswapV3/ISwapRouter.sol&quot;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>import &quot;../../Interfaces/IExchange.sol&quot;;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>// import &quot;forge-std/console2.sol&quot;;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>contract HybridCurveUniV3Exchange is LeftoversSweep, IExchange {</span>
  20 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    // TODO: pass it as param in functions, so we can reuse the same exchange for different branches</span>
  23 |     | <span class='unexecuted'>    IERC20 public immutable collToken;</span>
  24 |     | <span class='unexecuted'>    IBoldToken public immutable boldToken;</span>
  25 |     | <span class='unexecuted'>    IERC20 public immutable USDC;</span>
  26 |     | <span class='unexecuted'>    IWETH public immutable WETH;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    // Curve</span>
  29 |     | <span class='unexecuted'>    ICurveStableswapNGPool public immutable curvePool;</span>
  30 |     | <span class='unexecuted'>    uint128 public immutable USDC_INDEX;</span>
  31 |     | <span class='unexecuted'>    uint128 public immutable BOLD_TOKEN_INDEX;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    // Uniswap</span>
  34 |     | <span class='unexecuted'>    uint24 public immutable feeUsdcWeth;</span>
  35 |     | <span class='unexecuted'>    uint24 public immutable feeWethColl;</span>
  36 |     | <span class='unexecuted'>    ISwapRouter public immutable uniV3Router;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    constructor(</span>
  39 |     | <span class='neutral'>        IERC20 _collToken,</span>
  40 |     | <span class='neutral'>        IBoldToken _boldToken,</span>
  41 |     | <span class='neutral'>        IERC20 _usdc,</span>
  42 |     | <span class='neutral'>        IWETH _weth,</span>
  43 |     | <span class='neutral'>        // Curve</span>
  44 |     | <span class='neutral'>        ICurveStableswapNGPool _curvePool,</span>
  45 |     | <span class='neutral'>        uint128 _usdcIndex,</span>
  46 |     | <span class='neutral'>        uint128 _boldIndex,</span>
  47 |     | <span class='neutral'>        // UniV3</span>
  48 |     | <span class='neutral'>        uint24 _feeUsdcWeth,</span>
  49 |     | <span class='neutral'>        uint24 _feeWethColl,</span>
  50 |     | <span class='neutral'>        ISwapRouter _uniV3Router</span>
  51 |     | <span class='neutral'>    ) {</span>
  52 |     | <span class='unexecuted'>        collToken = _collToken;</span>
  53 |     | <span class='unexecuted'>        boldToken = _boldToken;</span>
  54 |     | <span class='unexecuted'>        USDC = _usdc;</span>
  55 |     | <span class='unexecuted'>        WETH = _weth;</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>        // Curve</span>
  58 |     | <span class='unexecuted'>        curvePool = _curvePool;</span>
  59 |     | <span class='unexecuted'>        USDC_INDEX = _usdcIndex;</span>
  60 |     | <span class='unexecuted'>        BOLD_TOKEN_INDEX = _boldIndex;</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>        // Uniswap</span>
  63 |     | <span class='unexecuted'>        feeUsdcWeth = _feeUsdcWeth;</span>
  64 |     | <span class='unexecuted'>        feeWethColl = _feeWethColl;</span>
  65 |     | <span class='unexecuted'>        uniV3Router = _uniV3Router;</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    // Bold -&gt; USDC on Curve; then USDC -&gt; WETH, and optionally WETH -&gt; Coll, on UniV3</span>
  69 |     | <span class='unexecuted'>    function swapFromBold(uint256 _boldAmount, uint256 _minCollAmount) external {</span>
  70 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
  71 |     | <span class='unexecuted'>        _setHybridExchangeInitialBalances(initialBalances);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>        // Curve</span>
  74 |     | <span class='unexecuted'>        boldToken.transferFrom(msg.sender, address(this), _boldAmount);</span>
  75 |     | <span class='unexecuted'>        boldToken.approve(address(curvePool), _boldAmount);</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>        uint256 curveUsdcAmount = curvePool.exchange(int128(BOLD_TOKEN_INDEX), int128(USDC_INDEX), _boldAmount, 0);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        // Uniswap</span>
  80 |     | <span class='unexecuted'>        USDC.approve(address(uniV3Router), curveUsdcAmount);</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>        // See: https://docs.uniswap.org/contracts/v3/guides/swaps/multihop-swaps</span>
  83 |     | <span class='unexecuted'>        bytes memory path;</span>
  84 |     | <span class='unexecuted'>        if (address(WETH) == address(collToken)) {</span>
  85 |     | <span class='unexecuted'>            path = abi.encodePacked(USDC, feeUsdcWeth, WETH);</span>
  86 |     | <span class='neutral'>        } else {</span>
  87 |     | <span class='unexecuted'>            path = abi.encodePacked(USDC, feeUsdcWeth, WETH, feeWethColl, collToken);</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({</span>
  91 |     | <span class='neutral'>            path: path,</span>
  92 |     | <span class='unexecuted'>            recipient: msg.sender,</span>
  93 |     | <span class='unexecuted'>            deadline: block.timestamp,</span>
  94 |     | <span class='neutral'>            amountIn: curveUsdcAmount,</span>
  95 |     | <span class='neutral'>            amountOutMinimum: _minCollAmount</span>
  96 |     | <span class='neutral'>        });</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>        // Executes the swap.</span>
  99 |     | <span class='unexecuted'>        uniV3Router.exactInput(params);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>        // return leftovers to user</span>
 102 |     | <span class='unexecuted'>        _returnLeftovers(initialBalances);</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    // Optionally Coll -&gt; WETH, and WETH -&gt; USDC on UniV3; then USDC -&gt; Bold on Curve</span>
 106 |     | <span class='unexecuted'>    function swapToBold(uint256 _collAmount, uint256 _minBoldAmount) external returns (uint256) {</span>
 107 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
 108 |     | <span class='unexecuted'>        _setHybridExchangeInitialBalances(initialBalances);</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>        // Uniswap</span>
 111 |     | <span class='unexecuted'>        collToken.safeTransferFrom(msg.sender, address(this), _collAmount);</span>
 112 |     | <span class='unexecuted'>        collToken.approve(address(uniV3Router), _collAmount);</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>        // See: https://docs.uniswap.org/contracts/v3/guides/swaps/multihop-swaps</span>
 115 |     | <span class='unexecuted'>        bytes memory path;</span>
 116 |     | <span class='unexecuted'>        if (address(WETH) == address(collToken)) {</span>
 117 |     | <span class='unexecuted'>            path = abi.encodePacked(WETH, feeUsdcWeth, USDC);</span>
 118 |     | <span class='neutral'>        } else {</span>
 119 |     | <span class='unexecuted'>            path = abi.encodePacked(collToken, feeWethColl, WETH, feeUsdcWeth, USDC);</span>
 120 |     | <span class='neutral'>        }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({</span>
 123 |     | <span class='neutral'>            path: path,</span>
 124 |     | <span class='unexecuted'>            recipient: address(this),</span>
 125 |     | <span class='unexecuted'>            deadline: block.timestamp,</span>
 126 |     | <span class='neutral'>            amountIn: _collAmount,</span>
 127 |     | <span class='neutral'>            amountOutMinimum: 0</span>
 128 |     | <span class='neutral'>        });</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>        // Executes the swap.</span>
 131 |     | <span class='unexecuted'>        uint256 uniV3UsdcAmount = uniV3Router.exactInput(params);</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>        // Curve</span>
 134 |     | <span class='unexecuted'>        USDC.approve(address(curvePool), uniV3UsdcAmount);</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='unexecuted'>        uint256 boldAmount =</span>
 137 |     | <span class='unexecuted'>            curvePool.exchange(int128(USDC_INDEX), int128(BOLD_TOKEN_INDEX), uniV3UsdcAmount, _minBoldAmount);</span>
 138 |     | <span class='unexecuted'>        boldToken.transfer(msg.sender, boldAmount);</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>        // return leftovers to user</span>
 141 |     | <span class='unexecuted'>        _returnLeftovers(initialBalances);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>        return boldAmount;</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>    function _setHybridExchangeInitialBalances(InitialBalances memory initialBalances) internal view {</span>
 147 |     | <span class='unexecuted'>        initialBalances.tokens[0] = boldToken;</span>
 148 |     | <span class='unexecuted'>        initialBalances.tokens[1] = USDC;</span>
 149 |     | <span class='unexecuted'>        initialBalances.tokens[2] = WETH;</span>
 150 |     | <span class='unexecuted'>        if (address(WETH) != address(collToken)) {</span>
 151 |     | <span class='unexecuted'>            initialBalances.tokens[3] = collToken;</span>
 152 |     | <span class='neutral'>        }</span>
 153 |     | <span class='unexecuted'>        _setInitialBalances(initialBalances);</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'>}</span>
 156 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/Exchanges/HybridCurveUniV3ExchangeHelpers.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.18;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;../../../Interfaces/IWETH.sol&quot;;</span>
   6 |     | <span class='neutral'>// Curve</span>
   7 |     | <span class='neutral'>import &quot;./Curve/ICurveStableswapNGPool.sol&quot;;</span>
   8 |     | <span class='neutral'>// UniV3</span>
   9 |     | <span class='neutral'>import &quot;./UniswapV3/IQuoterV2.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>import &quot;../../Interfaces/IExchangeHelpers.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>contract HybridCurveUniV3ExchangeHelpers is IExchangeHelpers {</span>
  14 |     | <span class='unexecuted'>    uint256 private constant DECIMAL_PRECISION = 1e18;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    //HybridCurveUniV3Exchange public immutable exchange;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    IERC20 public immutable USDC;</span>
  19 |     | <span class='unexecuted'>    IWETH public immutable WETH;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    // Curve</span>
  22 |     | <span class='unexecuted'>    ICurveStableswapNGPool public immutable curvePool;</span>
  23 |     | <span class='unexecuted'>    uint128 public immutable USDC_INDEX;</span>
  24 |     | <span class='unexecuted'>    uint128 public immutable BOLD_TOKEN_INDEX;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    // Uniswap</span>
  27 |     | <span class='unexecuted'>    uint24 public immutable feeUsdcWeth;</span>
  28 |     | <span class='unexecuted'>    uint24 public immutable feeWethColl;</span>
  29 |     | <span class='unexecuted'>    IQuoterV2 public immutable uniV3Quoter;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /*</span>
  32 |     | <span class='neutral'>    constructor(HybridCurveUniV3Exchange _exchange) {</span>
  33 |     | <span class='neutral'>        exchange = _exchange;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>        USDC = _exchange.USDC();</span>
  36 |     | <span class='neutral'>        WETH = _exchange.WETH();</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>        curvePool = _exchange.curvePool();</span>
  39 |     | <span class='neutral'>        USDC_INDEX = _exchange.USDC_INDEX();</span>
  40 |     | <span class='neutral'>        BOLD_TOKEN_INDEX = _exchange.BOLD_INDEX();</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>        // Uniswap</span>
  43 |     | <span class='neutral'>        feeUsdcWeth = _exchange.feeUsdcWeth();</span>
  44 |     | <span class='neutral'>        feeWethColl = _exchange.feeWethColl();</span>
  45 |     | <span class='neutral'>        uniV3Quoter = _exchange.uniV3Quoter();</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'>    */</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    constructor(</span>
  50 |     | <span class='neutral'>        IERC20 _usdc,</span>
  51 |     | <span class='neutral'>        IWETH _weth,</span>
  52 |     | <span class='neutral'>        // Curve</span>
  53 |     | <span class='neutral'>        ICurveStableswapNGPool _curvePool,</span>
  54 |     | <span class='neutral'>        uint128 _usdcIndex,</span>
  55 |     | <span class='neutral'>        uint128 _boldIndex,</span>
  56 |     | <span class='neutral'>        // UniV3</span>
  57 |     | <span class='neutral'>        uint24 _feeUsdcWeth,</span>
  58 |     | <span class='neutral'>        uint24 _feeWethColl,</span>
  59 |     | <span class='neutral'>        IQuoterV2 _uniV3Quoter</span>
  60 |     | <span class='neutral'>    ) {</span>
  61 |     | <span class='unexecuted'>        USDC = _usdc;</span>
  62 |     | <span class='unexecuted'>        WETH = _weth;</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>        // Curve</span>
  65 |     | <span class='unexecuted'>        curvePool = _curvePool;</span>
  66 |     | <span class='unexecuted'>        USDC_INDEX = _usdcIndex;</span>
  67 |     | <span class='unexecuted'>        BOLD_TOKEN_INDEX = _boldIndex;</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>        // Uniswap</span>
  70 |     | <span class='unexecuted'>        feeUsdcWeth = _feeUsdcWeth;</span>
  71 |     | <span class='unexecuted'>        feeWethColl = _feeWethColl;</span>
  72 |     | <span class='unexecuted'>        uniV3Quoter = _uniV3Quoter;</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>    function getCollFromBold(uint256 _boldAmount, IERC20 _collToken, uint256 _desiredCollAmount)</span>
  76 |     | <span class='neutral'>        external /* view */</span>
  77 |     | <span class='unexecuted'>        returns (uint256 collAmount, uint256 deviation)</span>
  78 |     | <span class='neutral'>    {</span>
  79 |     | <span class='neutral'>        // BOLD -&gt; USDC</span>
  80 |     | <span class='unexecuted'>        uint256 curveUsdcAmount = curvePool.get_dy(int128(BOLD_TOKEN_INDEX), int128(USDC_INDEX), _boldAmount);</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>        // USDC -&gt; Coll</span>
  83 |     | <span class='unexecuted'>        bytes memory path;</span>
  84 |     | <span class='unexecuted'>        if (address(WETH) == address(_collToken)) {</span>
  85 |     | <span class='unexecuted'>            path = abi.encodePacked(USDC, feeUsdcWeth, WETH);</span>
  86 |     | <span class='neutral'>        } else {</span>
  87 |     | <span class='unexecuted'>            path = abi.encodePacked(USDC, feeUsdcWeth, WETH, feeWethColl, _collToken);</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>        (collAmount,,,) = uniV3Quoter.quoteExactInput(path, curveUsdcAmount);</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>        if (_desiredCollAmount &gt; 0 &amp;&amp; collAmount &lt;= _desiredCollAmount) {</span>
  93 |     | <span class='unexecuted'>            deviation = DECIMAL_PRECISION - collAmount * DECIMAL_PRECISION / _desiredCollAmount;</span>
  94 |     | <span class='neutral'>        }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        return (collAmount, deviation);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'>}</span>
  99 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/Exchanges/UniV3Exchange.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/utils/math/Math.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>import &quot;../../LeftoversSweep.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;../../../Interfaces/IBoldToken.sol&quot;;</span>
 10 |     | <span class='neutral'>import &quot;./UniswapV3/ISwapRouter.sol&quot;;</span>
 11 |     | <span class='neutral'>import &quot;./UniswapV3/UniPriceConverter.sol&quot;;</span>
 12 |     | <span class='neutral'>import &quot;../../Interfaces/IExchange.sol&quot;;</span>
 13 |     | <span class='neutral'>import {DECIMAL_PRECISION} from &quot;../../../Dependencies/Constants.sol&quot;;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>contract UniV3Exchange is LeftoversSweep, UniPriceConverter, IExchange {</span>
 16 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    IERC20 public immutable collToken;</span>
 19 |     | <span class='unexecuted'>    IBoldToken public immutable boldToken;</span>
 20 |     | <span class='unexecuted'>    uint24 public immutable fee;</span>
 21 |     | <span class='unexecuted'>    ISwapRouter public immutable uniV3Router;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    constructor(IERC20 _collToken, IBoldToken _boldToken, uint24 _fee, ISwapRouter _uniV3Router) {</span>
 24 |     | <span class='unexecuted'>        collToken = _collToken;</span>
 25 |     | <span class='unexecuted'>        boldToken = _boldToken;</span>
 26 |     | <span class='unexecuted'>        fee = _fee;</span>
 27 |     | <span class='unexecuted'>        uniV3Router = _uniV3Router;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>    function swapFromBold(uint256 _boldAmount, uint256 _minCollAmount) external {</span>
 31 |     | <span class='unexecuted'>        ISwapRouter uniV3RouterCached = uniV3Router;</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>        // Set initial balances to make sure there are not lefovers</span>
 34 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
 35 |     | <span class='unexecuted'>        _setInitialTokensAndBalances(collToken, boldToken, initialBalances);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>        boldToken.transferFrom(msg.sender, address(this), _boldAmount);</span>
 38 |     | <span class='unexecuted'>        boldToken.approve(address(uniV3RouterCached), _boldAmount);</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams({</span>
 41 |     | <span class='unexecuted'>            tokenIn: address(boldToken),</span>
 42 |     | <span class='unexecuted'>            tokenOut: address(collToken),</span>
 43 |     | <span class='unexecuted'>            fee: fee,</span>
 44 |     | <span class='unexecuted'>            recipient: msg.sender,</span>
 45 |     | <span class='unexecuted'>            deadline: block.timestamp,</span>
 46 |     | <span class='neutral'>            amountOut: _minCollAmount,</span>
 47 |     | <span class='neutral'>            amountInMaximum: _boldAmount,</span>
 48 |     | <span class='neutral'>            sqrtPriceLimitX96: 0 // See: https://ethereum.stackexchange.com/a/156018/9205</span>
 49 |     | <span class='neutral'>        });</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>        uniV3RouterCached.exactOutputSingle(params);</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>        // return leftovers to user</span>
 54 |     | <span class='unexecuted'>        _returnLeftovers(initialBalances);</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='unexecuted'>    function swapToBold(uint256 _collAmount, uint256 _minBoldAmount) external returns (uint256) {</span>
 58 |     | <span class='unexecuted'>        ISwapRouter uniV3RouterCached = uniV3Router;</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>        // Set initial balances to make sure there are not lefovers</span>
 61 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
 62 |     | <span class='unexecuted'>        _setInitialTokensAndBalances(collToken, boldToken, initialBalances);</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='unexecuted'>        collToken.safeTransferFrom(msg.sender, address(this), _collAmount);</span>
 65 |     | <span class='unexecuted'>        collToken.approve(address(uniV3RouterCached), _collAmount);</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({</span>
 68 |     | <span class='unexecuted'>            tokenIn: address(collToken),</span>
 69 |     | <span class='unexecuted'>            tokenOut: address(boldToken),</span>
 70 |     | <span class='unexecuted'>            fee: fee,</span>
 71 |     | <span class='unexecuted'>            recipient: msg.sender,</span>
 72 |     | <span class='unexecuted'>            deadline: block.timestamp,</span>
 73 |     | <span class='neutral'>            amountIn: _collAmount,</span>
 74 |     | <span class='neutral'>            amountOutMinimum: _minBoldAmount,</span>
 75 |     | <span class='neutral'>            sqrtPriceLimitX96: 0 // See: https://ethereum.stackexchange.com/a/156018/9205</span>
 76 |     | <span class='neutral'>        });</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='unexecuted'>        uint256 amountOut = uniV3RouterCached.exactInputSingle(params);</span>
 79 |     | <span class='neutral'></span>
 80 |     | <span class='neutral'>        // return leftovers to user</span>
 81 |     | <span class='unexecuted'>        _returnLeftovers(initialBalances);</span>
 82 |     | <span class='neutral'></span>
 83 |     | <span class='unexecuted'>        return amountOut;</span>
 84 |     | <span class='neutral'>    }</span>
 85 |     | <span class='neutral'></span>
 86 |     | <span class='unexecuted'>    function priceToSqrtPrice(IBoldToken _boldToken, IERC20 _collToken, uint256 _price) public pure returns (uint160) {</span>
 87 |     | <span class='neutral'>        // inverse price if Bold goes first</span>
 88 |     | <span class='unexecuted'>        uint256 price = _zeroForOne(_boldToken, _collToken) ? DECIMAL_PRECISION * DECIMAL_PRECISION / _price : _price;</span>
 89 |     | <span class='unexecuted'>        return priceToSqrtPriceX96(price);</span>
 90 |     | <span class='neutral'>    }</span>
 91 |     | <span class='neutral'></span>
 92 |     | <span class='neutral'>    // See: https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/QuoterV2.sol#L207C9-L207C60</span>
 93 |     | <span class='neutral'>    function _zeroForOne(IBoldToken _boldToken, IERC20 _collToken) internal pure returns (bool) {</span>
 94 |     | <span class='unexecuted'>        return address(_boldToken) &lt; address(_collToken);</span>
 95 |     | <span class='neutral'>    }</span>
 96 |     | <span class='neutral'>}</span>
 97 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/Exchanges/UniswapV3/INonfungiblePositionManager.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.7.5;</span>
   3 |     | <span class='neutral'>pragma abicoder v2;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./IPoolInitializer.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/// @title Non-fungible token for positions</span>
   8 |     | <span class='neutral'>/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred</span>
   9 |     | <span class='neutral'>/// and authorized.</span>
  10 |     | <span class='neutral'>interface INonfungiblePositionManager is IPoolInitializer {</span>
  11 |     | <span class='neutral'>    /// @notice Emitted when liquidity is increased for a position NFT</span>
  12 |     | <span class='neutral'>    /// @dev Also emitted when a token is minted</span>
  13 |     | <span class='neutral'>    /// @param tokenId The ID of the token for which liquidity was increased</span>
  14 |     | <span class='neutral'>    /// @param liquidity The amount by which liquidity for the NFT position was increased</span>
  15 |     | <span class='neutral'>    /// @param amount0 The amount of token0 that was paid for the increase in liquidity</span>
  16 |     | <span class='neutral'>    /// @param amount1 The amount of token1 that was paid for the increase in liquidity</span>
  17 |     | <span class='neutral'>    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);</span>
  18 |     | <span class='neutral'>    /// @notice Emitted when liquidity is decreased for a position NFT</span>
  19 |     | <span class='neutral'>    /// @param tokenId The ID of the token for which liquidity was decreased</span>
  20 |     | <span class='neutral'>    /// @param liquidity The amount by which liquidity for the NFT position was decreased</span>
  21 |     | <span class='neutral'>    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity</span>
  22 |     | <span class='neutral'>    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity</span>
  23 |     | <span class='neutral'>    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);</span>
  24 |     | <span class='neutral'>    /// @notice Emitted when tokens are collected for a position NFT</span>
  25 |     | <span class='neutral'>    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior</span>
  26 |     | <span class='neutral'>    /// @param tokenId The ID of the token for which underlying tokens were collected</span>
  27 |     | <span class='neutral'>    /// @param recipient The address of the account that received the collected tokens</span>
  28 |     | <span class='neutral'>    /// @param amount0 The amount of token0 owed to the position that was collected</span>
  29 |     | <span class='neutral'>    /// @param amount1 The amount of token1 owed to the position that was collected</span>
  30 |     | <span class='neutral'>    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /// @notice Returns the position information associated with a given token ID.</span>
  33 |     | <span class='neutral'>    /// @dev Throws if the token ID is not valid.</span>
  34 |     | <span class='neutral'>    /// @param tokenId The ID of the token that represents the position</span>
  35 |     | <span class='neutral'>    /// @return nonce The nonce for permits</span>
  36 |     | <span class='neutral'>    /// @return operator The address that is approved for spending</span>
  37 |     | <span class='neutral'>    /// @return token0 The address of the token0 for a specific pool</span>
  38 |     | <span class='neutral'>    /// @return token1 The address of the token1 for a specific pool</span>
  39 |     | <span class='neutral'>    /// @return fee The fee associated with the pool</span>
  40 |     | <span class='neutral'>    /// @return tickLower The lower end of the tick range for the position</span>
  41 |     | <span class='neutral'>    /// @return tickUpper The higher end of the tick range for the position</span>
  42 |     | <span class='neutral'>    /// @return liquidity The liquidity of the position</span>
  43 |     | <span class='neutral'>    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position</span>
  44 |     | <span class='neutral'>    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position</span>
  45 |     | <span class='neutral'>    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation</span>
  46 |     | <span class='neutral'>    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation</span>
  47 |     | <span class='neutral'>    function positions(uint256 tokenId)</span>
  48 |     | <span class='neutral'>        external</span>
  49 |     | <span class='neutral'>        view</span>
  50 |     | <span class='neutral'>        returns (</span>
  51 |     | <span class='neutral'>            uint96 nonce,</span>
  52 |     | <span class='neutral'>            address operator,</span>
  53 |     | <span class='neutral'>            address token0,</span>
  54 |     | <span class='neutral'>            address token1,</span>
  55 |     | <span class='neutral'>            uint24 fee,</span>
  56 |     | <span class='neutral'>            int24 tickLower,</span>
  57 |     | <span class='neutral'>            int24 tickUpper,</span>
  58 |     | <span class='neutral'>            uint128 liquidity,</span>
  59 |     | <span class='neutral'>            uint256 feeGrowthInside0LastX128,</span>
  60 |     | <span class='neutral'>            uint256 feeGrowthInside1LastX128,</span>
  61 |     | <span class='neutral'>            uint128 tokensOwed0,</span>
  62 |     | <span class='neutral'>            uint128 tokensOwed1</span>
  63 |     | <span class='neutral'>        );</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    struct MintParams {</span>
  66 |     | <span class='neutral'>        address token0;</span>
  67 |     | <span class='neutral'>        address token1;</span>
  68 |     | <span class='neutral'>        uint24 fee;</span>
  69 |     | <span class='neutral'>        int24 tickLower;</span>
  70 |     | <span class='neutral'>        int24 tickUpper;</span>
  71 |     | <span class='neutral'>        uint256 amount0Desired;</span>
  72 |     | <span class='neutral'>        uint256 amount1Desired;</span>
  73 |     | <span class='neutral'>        uint256 amount0Min;</span>
  74 |     | <span class='neutral'>        uint256 amount1Min;</span>
  75 |     | <span class='neutral'>        address recipient;</span>
  76 |     | <span class='neutral'>        uint256 deadline;</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /// @notice Creates a new position wrapped in a NFT</span>
  80 |     | <span class='neutral'>    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized</span>
  81 |     | <span class='neutral'>    /// a method does not exist, i.e. the pool is assumed to be initialized.</span>
  82 |     | <span class='neutral'>    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata</span>
  83 |     | <span class='neutral'>    /// @return tokenId The ID of the token that represents the minted position</span>
  84 |     | <span class='neutral'>    /// @return liquidity The amount of liquidity for this position</span>
  85 |     | <span class='neutral'>    /// @return amount0 The amount of token0</span>
  86 |     | <span class='neutral'>    /// @return amount1 The amount of token1</span>
  87 |     | <span class='neutral'>    function mint(MintParams calldata params)</span>
  88 |     | <span class='neutral'>        external</span>
  89 |     | <span class='neutral'>        payable</span>
  90 |     | <span class='neutral'>        returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    struct IncreaseLiquidityParams {</span>
  93 |     | <span class='neutral'>        uint256 tokenId;</span>
  94 |     | <span class='neutral'>        uint256 amount0Desired;</span>
  95 |     | <span class='neutral'>        uint256 amount1Desired;</span>
  96 |     | <span class='neutral'>        uint256 amount0Min;</span>
  97 |     | <span class='neutral'>        uint256 amount1Min;</span>
  98 |     | <span class='neutral'>        uint256 deadline;</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`</span>
 102 |     | <span class='neutral'>    /// @param params tokenId The ID of the token for which liquidity is being increased,</span>
 103 |     | <span class='neutral'>    /// amount0Desired The desired amount of token0 to be spent,</span>
 104 |     | <span class='neutral'>    /// amount1Desired The desired amount of token1 to be spent,</span>
 105 |     | <span class='neutral'>    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,</span>
 106 |     | <span class='neutral'>    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,</span>
 107 |     | <span class='neutral'>    /// deadline The time by which the transaction must be included to effect the change</span>
 108 |     | <span class='neutral'>    /// @return liquidity The new liquidity amount as a result of the increase</span>
 109 |     | <span class='neutral'>    /// @return amount0 The amount of token0 to acheive resulting liquidity</span>
 110 |     | <span class='neutral'>    /// @return amount1 The amount of token1 to acheive resulting liquidity</span>
 111 |     | <span class='neutral'>    function increaseLiquidity(IncreaseLiquidityParams calldata params)</span>
 112 |     | <span class='neutral'>        external</span>
 113 |     | <span class='neutral'>        payable</span>
 114 |     | <span class='neutral'>        returns (uint128 liquidity, uint256 amount0, uint256 amount1);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    struct DecreaseLiquidityParams {</span>
 117 |     | <span class='neutral'>        uint256 tokenId;</span>
 118 |     | <span class='neutral'>        uint128 liquidity;</span>
 119 |     | <span class='neutral'>        uint256 amount0Min;</span>
 120 |     | <span class='neutral'>        uint256 amount1Min;</span>
 121 |     | <span class='neutral'>        uint256 deadline;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    /// @notice Decreases the amount of liquidity in a position and accounts it to the position</span>
 125 |     | <span class='neutral'>    /// @param params tokenId The ID of the token for which liquidity is being decreased,</span>
 126 |     | <span class='neutral'>    /// amount The amount by which liquidity will be decreased,</span>
 127 |     | <span class='neutral'>    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,</span>
 128 |     | <span class='neutral'>    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,</span>
 129 |     | <span class='neutral'>    /// deadline The time by which the transaction must be included to effect the change</span>
 130 |     | <span class='neutral'>    /// @return amount0 The amount of token0 accounted to the position&#39;s tokens owed</span>
 131 |     | <span class='neutral'>    /// @return amount1 The amount of token1 accounted to the position&#39;s tokens owed</span>
 132 |     | <span class='neutral'>    function decreaseLiquidity(DecreaseLiquidityParams calldata params)</span>
 133 |     | <span class='neutral'>        external</span>
 134 |     | <span class='neutral'>        payable</span>
 135 |     | <span class='neutral'>        returns (uint256 amount0, uint256 amount1);</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    struct CollectParams {</span>
 138 |     | <span class='neutral'>        uint256 tokenId;</span>
 139 |     | <span class='neutral'>        address recipient;</span>
 140 |     | <span class='neutral'>        uint128 amount0Max;</span>
 141 |     | <span class='neutral'>        uint128 amount1Max;</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient</span>
 145 |     | <span class='neutral'>    /// @param params tokenId The ID of the NFT for which tokens are being collected,</span>
 146 |     | <span class='neutral'>    /// recipient The account that should receive the tokens,</span>
 147 |     | <span class='neutral'>    /// amount0Max The maximum amount of token0 to collect,</span>
 148 |     | <span class='neutral'>    /// amount1Max The maximum amount of token1 to collect</span>
 149 |     | <span class='neutral'>    /// @return amount0 The amount of fees collected in token0</span>
 150 |     | <span class='neutral'>    /// @return amount1 The amount of fees collected in token1</span>
 151 |     | <span class='neutral'>    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens</span>
 154 |     | <span class='neutral'>    /// must be collected first.</span>
 155 |     | <span class='neutral'>    /// @param tokenId The ID of the token that is being burned</span>
 156 |     | <span class='neutral'>    function burn(uint256 tokenId) external payable;</span>
 157 |     | <span class='neutral'>}</span>
 158 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/Exchanges/UniswapV3/IPoolInitializer.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.7.5;</span>
  3 |     | <span class='neutral'>pragma abicoder v2;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>/// @title Creates and initializes V3 Pools</span>
  6 |     | <span class='neutral'>/// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that</span>
  7 |     | <span class='neutral'>/// require the pool to exist.</span>
  8 |     | <span class='neutral'>interface IPoolInitializer {</span>
  9 |     | <span class='neutral'>    /// @notice Creates a new pool if it does not exist, then initializes if not initialized</span>
 10 |     | <span class='neutral'>    /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool</span>
 11 |     | <span class='neutral'>    /// @param token0 The contract address of token0 of the pool</span>
 12 |     | <span class='neutral'>    /// @param token1 The contract address of token1 of the pool</span>
 13 |     | <span class='neutral'>    /// @param fee The fee amount of the v3 pool for the specified token pair</span>
 14 |     | <span class='neutral'>    /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value</span>
 15 |     | <span class='neutral'>    /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary</span>
 16 |     | <span class='neutral'>    function createAndInitializePoolIfNecessary(address token0, address token1, uint24 fee, uint160 sqrtPriceX96)</span>
 17 |     | <span class='neutral'>        external</span>
 18 |     | <span class='neutral'>        payable</span>
 19 |     | <span class='neutral'>        returns (address pool);</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/Exchanges/UniswapV3/IQuoterV2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.7.5;</span>
  3 |     | <span class='neutral'>pragma abicoder v2;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>/// @title QuoterV2 Interface</span>
  6 |     | <span class='neutral'>/// @notice Supports quoting the calculated amounts from exact input or exact output swaps.</span>
  7 |     | <span class='neutral'>/// @notice For each pool also tells you the number of initialized ticks crossed and the sqrt price of the pool after the swap.</span>
  8 |     | <span class='neutral'>/// @dev These functions are not marked view because they rely on calling non-view functions and reverting</span>
  9 |     | <span class='neutral'>/// to compute the result. They are also not gas efficient and should not be called on-chain.</span>
 10 |     | <span class='neutral'>interface IQuoterV2 {</span>
 11 |     | <span class='neutral'>    /// @notice Returns the amount out received for a given exact input swap without executing the swap</span>
 12 |     | <span class='neutral'>    /// @param path The path of the swap, i.e. each token pair and the pool fee</span>
 13 |     | <span class='neutral'>    /// @param amountIn The amount of the first token to swap</span>
 14 |     | <span class='neutral'>    /// @return amountOut The amount of the last token that would be received</span>
 15 |     | <span class='neutral'>    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path</span>
 16 |     | <span class='neutral'>    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path</span>
 17 |     | <span class='neutral'>    /// @return gasEstimate The estimate of the gas that the swap consumes</span>
 18 |     | <span class='neutral'>    function quoteExactInput(bytes memory path, uint256 amountIn)</span>
 19 |     | <span class='neutral'>        external</span>
 20 |     | <span class='neutral'>        returns (</span>
 21 |     | <span class='neutral'>            uint256 amountOut,</span>
 22 |     | <span class='neutral'>            uint160[] memory sqrtPriceX96AfterList,</span>
 23 |     | <span class='neutral'>            uint32[] memory initializedTicksCrossedList,</span>
 24 |     | <span class='neutral'>            uint256 gasEstimate</span>
 25 |     | <span class='neutral'>        );</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    struct QuoteExactInputSingleParams {</span>
 28 |     | <span class='neutral'>        address tokenIn;</span>
 29 |     | <span class='neutral'>        address tokenOut;</span>
 30 |     | <span class='neutral'>        uint256 amountIn;</span>
 31 |     | <span class='neutral'>        uint24 fee;</span>
 32 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96;</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool</span>
 36 |     | <span class='neutral'>    /// @param params The params for the quote, encoded as `QuoteExactInputSingleParams`</span>
 37 |     | <span class='neutral'>    /// tokenIn The token being swapped in</span>
 38 |     | <span class='neutral'>    /// tokenOut The token being swapped out</span>
 39 |     | <span class='neutral'>    /// fee The fee of the token pool to consider for the pair</span>
 40 |     | <span class='neutral'>    /// amountIn The desired input amount</span>
 41 |     | <span class='neutral'>    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap</span>
 42 |     | <span class='neutral'>    /// @return amountOut The amount of `tokenOut` that would be received</span>
 43 |     | <span class='neutral'>    /// @return sqrtPriceX96After The sqrt price of the pool after the swap</span>
 44 |     | <span class='neutral'>    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed</span>
 45 |     | <span class='neutral'>    /// @return gasEstimate The estimate of the gas that the swap consumes</span>
 46 |     | <span class='neutral'>    function quoteExactInputSingle(QuoteExactInputSingleParams memory params)</span>
 47 |     | <span class='neutral'>        external</span>
 48 |     | <span class='neutral'>        returns (uint256 amountOut, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    /// @notice Returns the amount in required for a given exact output swap without executing the swap</span>
 51 |     | <span class='neutral'>    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order</span>
 52 |     | <span class='neutral'>    /// @param amountOut The amount of the last token to receive</span>
 53 |     | <span class='neutral'>    /// @return amountIn The amount of first token required to be paid</span>
 54 |     | <span class='neutral'>    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path</span>
 55 |     | <span class='neutral'>    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path</span>
 56 |     | <span class='neutral'>    /// @return gasEstimate The estimate of the gas that the swap consumes</span>
 57 |     | <span class='neutral'>    function quoteExactOutput(bytes memory path, uint256 amountOut)</span>
 58 |     | <span class='neutral'>        external</span>
 59 |     | <span class='neutral'>        returns (</span>
 60 |     | <span class='neutral'>            uint256 amountIn,</span>
 61 |     | <span class='neutral'>            uint160[] memory sqrtPriceX96AfterList,</span>
 62 |     | <span class='neutral'>            uint32[] memory initializedTicksCrossedList,</span>
 63 |     | <span class='neutral'>            uint256 gasEstimate</span>
 64 |     | <span class='neutral'>        );</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>    struct QuoteExactOutputSingleParams {</span>
 67 |     | <span class='neutral'>        address tokenIn;</span>
 68 |     | <span class='neutral'>        address tokenOut;</span>
 69 |     | <span class='neutral'>        uint256 amount;</span>
 70 |     | <span class='neutral'>        uint24 fee;</span>
 71 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96;</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool</span>
 75 |     | <span class='neutral'>    /// @param params The params for the quote, encoded as `QuoteExactOutputSingleParams`</span>
 76 |     | <span class='neutral'>    /// tokenIn The token being swapped in</span>
 77 |     | <span class='neutral'>    /// tokenOut The token being swapped out</span>
 78 |     | <span class='neutral'>    /// fee The fee of the token pool to consider for the pair</span>
 79 |     | <span class='neutral'>    /// amountOut The desired output amount</span>
 80 |     | <span class='neutral'>    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap</span>
 81 |     | <span class='neutral'>    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`</span>
 82 |     | <span class='neutral'>    /// @return sqrtPriceX96After The sqrt price of the pool after the swap</span>
 83 |     | <span class='neutral'>    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed</span>
 84 |     | <span class='neutral'>    /// @return gasEstimate The estimate of the gas that the swap consumes</span>
 85 |     | <span class='neutral'>    function quoteExactOutputSingle(QuoteExactOutputSingleParams memory params)</span>
 86 |     | <span class='neutral'>        external</span>
 87 |     | <span class='neutral'>        returns (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate);</span>
 88 |     | <span class='neutral'>}</span>
 89 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/Exchanges/UniswapV3/ISwapRouter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.7.5;</span>
  3 |     | <span class='neutral'>pragma abicoder v2;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>/// @title Router token swapping functionality</span>
  6 |     | <span class='neutral'>/// @notice Functions for swapping tokens via Uniswap V3</span>
  7 |     | <span class='neutral'>interface ISwapRouter {</span>
  8 |     | <span class='neutral'>    struct ExactInputSingleParams {</span>
  9 |     | <span class='neutral'>        address tokenIn;</span>
 10 |     | <span class='neutral'>        address tokenOut;</span>
 11 |     | <span class='neutral'>        uint24 fee;</span>
 12 |     | <span class='neutral'>        address recipient;</span>
 13 |     | <span class='neutral'>        uint256 deadline;</span>
 14 |     | <span class='neutral'>        uint256 amountIn;</span>
 15 |     | <span class='neutral'>        uint256 amountOutMinimum;</span>
 16 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96;</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /// @notice Swaps `amountIn` of one token for as much as possible of another token</span>
 20 |     | <span class='neutral'>    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata</span>
 21 |     | <span class='neutral'>    /// @return amountOut The amount of the received token</span>
 22 |     | <span class='neutral'>    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    struct ExactInputParams {</span>
 25 |     | <span class='neutral'>        bytes path;</span>
 26 |     | <span class='neutral'>        address recipient;</span>
 27 |     | <span class='neutral'>        uint256 deadline;</span>
 28 |     | <span class='neutral'>        uint256 amountIn;</span>
 29 |     | <span class='neutral'>        uint256 amountOutMinimum;</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path</span>
 33 |     | <span class='neutral'>    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata</span>
 34 |     | <span class='neutral'>    /// @return amountOut The amount of the received token</span>
 35 |     | <span class='neutral'>    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    struct ExactOutputSingleParams {</span>
 38 |     | <span class='neutral'>        address tokenIn;</span>
 39 |     | <span class='neutral'>        address tokenOut;</span>
 40 |     | <span class='neutral'>        uint24 fee;</span>
 41 |     | <span class='neutral'>        address recipient;</span>
 42 |     | <span class='neutral'>        uint256 deadline;</span>
 43 |     | <span class='neutral'>        uint256 amountOut;</span>
 44 |     | <span class='neutral'>        uint256 amountInMaximum;</span>
 45 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96;</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    /// @notice Swaps as little as possible of one token for `amountOut` of another token</span>
 49 |     | <span class='neutral'>    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata</span>
 50 |     | <span class='neutral'>    /// @return amountIn The amount of the input token</span>
 51 |     | <span class='neutral'>    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    struct ExactOutputParams {</span>
 54 |     | <span class='neutral'>        bytes path;</span>
 55 |     | <span class='neutral'>        address recipient;</span>
 56 |     | <span class='neutral'>        uint256 deadline;</span>
 57 |     | <span class='neutral'>        uint256 amountOut;</span>
 58 |     | <span class='neutral'>        uint256 amountInMaximum;</span>
 59 |     | <span class='neutral'>    }</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)</span>
 62 |     | <span class='neutral'>    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata</span>
 63 |     | <span class='neutral'>    /// @return amountIn The amount of the input token</span>
 64 |     | <span class='neutral'>    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);</span>
 65 |     | <span class='neutral'>}</span>
 66 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/Exchanges/UniswapV3/IUniswapV3Factory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IUniswapV3Factory {</span>
  5 |     | <span class='neutral'>    /// @notice Emitted when the owner of the factory is changed</span>
  6 |     | <span class='neutral'>    /// @param oldOwner The owner before the owner was changed</span>
  7 |     | <span class='neutral'>    /// @param newOwner The owner after the owner was changed</span>
  8 |     | <span class='neutral'>    event OwnerChanged(address indexed oldOwner, address indexed newOwner);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    /// @notice Emitted when a pool is created</span>
 11 |     | <span class='neutral'>    /// @param token0 The first token of the pool by address sort order</span>
 12 |     | <span class='neutral'>    /// @param token1 The second token of the pool by address sort order</span>
 13 |     | <span class='neutral'>    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 14 |     | <span class='neutral'>    /// @param tickSpacing The minimum number of ticks between initialized ticks</span>
 15 |     | <span class='neutral'>    /// @param pool The address of the created pool</span>
 16 |     | <span class='neutral'>    event PoolCreated(</span>
 17 |     | <span class='neutral'>        address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool</span>
 18 |     | <span class='neutral'>    );</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory</span>
 21 |     | <span class='neutral'>    /// @param fee The enabled fee, denominated in hundredths of a bip</span>
 22 |     | <span class='neutral'>    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee</span>
 23 |     | <span class='neutral'>    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /// @notice Returns the current owner of the factory</span>
 26 |     | <span class='neutral'>    /// @dev Can be changed by the current owner via setOwner</span>
 27 |     | <span class='neutral'>    /// @return The address of the factory owner</span>
 28 |     | <span class='neutral'>    function owner() external view returns (address);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled</span>
 31 |     | <span class='neutral'>    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context</span>
 32 |     | <span class='neutral'>    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee</span>
 33 |     | <span class='neutral'>    /// @return The tick spacing</span>
 34 |     | <span class='neutral'>    function feeAmountTickSpacing(uint24 fee) external view returns (int24);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist</span>
 37 |     | <span class='neutral'>    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order</span>
 38 |     | <span class='neutral'>    /// @param tokenA The contract address of either token0 or token1</span>
 39 |     | <span class='neutral'>    /// @param tokenB The contract address of the other token</span>
 40 |     | <span class='neutral'>    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 41 |     | <span class='neutral'>    /// @return pool The pool address</span>
 42 |     | <span class='neutral'>    function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    /// @notice Creates a pool for the given two tokens and fee</span>
 45 |     | <span class='neutral'>    /// @param tokenA One of the two tokens in the desired pool</span>
 46 |     | <span class='neutral'>    /// @param tokenB The other of the two tokens in the desired pool</span>
 47 |     | <span class='neutral'>    /// @param fee The desired fee for the pool</span>
 48 |     | <span class='neutral'>    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved</span>
 49 |     | <span class='neutral'>    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments</span>
 50 |     | <span class='neutral'>    /// are invalid.</span>
 51 |     | <span class='neutral'>    /// @return pool The address of the newly created pool</span>
 52 |     | <span class='neutral'>    function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /// @notice Updates the owner of the factory</span>
 55 |     | <span class='neutral'>    /// @dev Must be called by the current owner</span>
 56 |     | <span class='neutral'>    /// @param _owner The new owner of the factory</span>
 57 |     | <span class='neutral'>    function setOwner(address _owner) external;</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    /// @notice Enables a fee amount with the given tickSpacing</span>
 60 |     | <span class='neutral'>    /// @dev Fee amounts may never be removed once enabled</span>
 61 |     | <span class='neutral'>    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)</span>
 62 |     | <span class='neutral'>    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount</span>
 63 |     | <span class='neutral'>    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;</span>
 64 |     | <span class='neutral'>}</span>
 65 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/Exchanges/UniswapV3/IUniswapV3Pool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>interface IUniswapV3Pool {</span>
   5 |     | <span class='neutral'>    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface</span>
   6 |     | <span class='neutral'>    /// @return The contract address</span>
   7 |     | <span class='neutral'>    function factory() external view returns (address);</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    /// @notice The first of the two tokens of the pool, sorted by address</span>
  10 |     | <span class='neutral'>    /// @return The token contract address</span>
  11 |     | <span class='neutral'>    function token0() external view returns (address);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    /// @notice The second of the two tokens of the pool, sorted by address</span>
  14 |     | <span class='neutral'>    /// @return The token contract address</span>
  15 |     | <span class='neutral'>    function token1() external view returns (address);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @notice The pool&#39;s fee in hundredths of a bip, i.e. 1e-6</span>
  18 |     | <span class='neutral'>    /// @return The fee</span>
  19 |     | <span class='neutral'>    function fee() external view returns (uint24);</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    /// @notice The pool tick spacing</span>
  22 |     | <span class='neutral'>    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive</span>
  23 |     | <span class='neutral'>    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...</span>
  24 |     | <span class='neutral'>    /// This value is an int24 to avoid casting even though it is always positive.</span>
  25 |     | <span class='neutral'>    /// @return The tick spacing</span>
  26 |     | <span class='neutral'>    function tickSpacing() external view returns (int24);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    /// @notice The maximum amount of position liquidity that can use any tick in the range</span>
  29 |     | <span class='neutral'>    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and</span>
  30 |     | <span class='neutral'>    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool</span>
  31 |     | <span class='neutral'>    /// @return The max amount of liquidity per tick</span>
  32 |     | <span class='neutral'>    function maxLiquidityPerTick() external view returns (uint128);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas</span>
  35 |     | <span class='neutral'>    /// when accessed externally.</span>
  36 |     | <span class='neutral'>    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value</span>
  37 |     | <span class='neutral'>    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.</span>
  38 |     | <span class='neutral'>    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick</span>
  39 |     | <span class='neutral'>    /// boundary.</span>
  40 |     | <span class='neutral'>    /// observationIndex The index of the last oracle observation that was written,</span>
  41 |     | <span class='neutral'>    /// observationCardinality The current maximum number of observations stored in the pool,</span>
  42 |     | <span class='neutral'>    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.</span>
  43 |     | <span class='neutral'>    /// feeProtocol The protocol fee for both tokens of the pool.</span>
  44 |     | <span class='neutral'>    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0</span>
  45 |     | <span class='neutral'>    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.</span>
  46 |     | <span class='neutral'>    /// unlocked Whether the pool is currently locked to reentrancy</span>
  47 |     | <span class='neutral'>    function slot0()</span>
  48 |     | <span class='neutral'>        external</span>
  49 |     | <span class='neutral'>        view</span>
  50 |     | <span class='neutral'>        returns (</span>
  51 |     | <span class='neutral'>            uint160 sqrtPriceX96,</span>
  52 |     | <span class='neutral'>            int24 tick,</span>
  53 |     | <span class='neutral'>            uint16 observationIndex,</span>
  54 |     | <span class='neutral'>            uint16 observationCardinality,</span>
  55 |     | <span class='neutral'>            uint16 observationCardinalityNext,</span>
  56 |     | <span class='neutral'>            uint8 feeProtocol,</span>
  57 |     | <span class='neutral'>            bool unlocked</span>
  58 |     | <span class='neutral'>        );</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool</span>
  61 |     | <span class='neutral'>    /// @dev This value can overflow the uint256</span>
  62 |     | <span class='neutral'>    function feeGrowthGlobal0X128() external view returns (uint256);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool</span>
  65 |     | <span class='neutral'>    /// @dev This value can overflow the uint256</span>
  66 |     | <span class='neutral'>    function feeGrowthGlobal1X128() external view returns (uint256);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /// @notice The amounts of token0 and token1 that are owed to the protocol</span>
  69 |     | <span class='neutral'>    /// @dev Protocol fees will never exceed uint128 max in either token</span>
  70 |     | <span class='neutral'>    function protocolFees() external view returns (uint128 token0, uint128 token1);</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /// @notice The currently in range liquidity available to the pool</span>
  73 |     | <span class='neutral'>    /// @dev This value has no relationship to the total liquidity across all ticks</span>
  74 |     | <span class='neutral'>    function liquidity() external view returns (uint128);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    /// @notice Look up information about a specific tick in the pool</span>
  77 |     | <span class='neutral'>    /// @param tick The tick to look up</span>
  78 |     | <span class='neutral'>    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or</span>
  79 |     | <span class='neutral'>    /// tick upper,</span>
  80 |     | <span class='neutral'>    /// liquidityNet how much liquidity changes when the pool price crosses the tick,</span>
  81 |     | <span class='neutral'>    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,</span>
  82 |     | <span class='neutral'>    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,</span>
  83 |     | <span class='neutral'>    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick</span>
  84 |     | <span class='neutral'>    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,</span>
  85 |     | <span class='neutral'>    /// secondsOutside the seconds spent on the other side of the tick from the current tick,</span>
  86 |     | <span class='neutral'>    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.</span>
  87 |     | <span class='neutral'>    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.</span>
  88 |     | <span class='neutral'>    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for</span>
  89 |     | <span class='neutral'>    /// a specific position.</span>
  90 |     | <span class='neutral'>    function ticks(int24 tick)</span>
  91 |     | <span class='neutral'>        external</span>
  92 |     | <span class='neutral'>        view</span>
  93 |     | <span class='neutral'>        returns (</span>
  94 |     | <span class='neutral'>            uint128 liquidityGross,</span>
  95 |     | <span class='neutral'>            int128 liquidityNet,</span>
  96 |     | <span class='neutral'>            uint256 feeGrowthOutside0X128,</span>
  97 |     | <span class='neutral'>            uint256 feeGrowthOutside1X128,</span>
  98 |     | <span class='neutral'>            int56 tickCumulativeOutside,</span>
  99 |     | <span class='neutral'>            uint160 secondsPerLiquidityOutsideX128,</span>
 100 |     | <span class='neutral'>            uint32 secondsOutside,</span>
 101 |     | <span class='neutral'>            bool initialized</span>
 102 |     | <span class='neutral'>        );</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information</span>
 105 |     | <span class='neutral'>    function tickBitmap(int16 wordPosition) external view returns (uint256);</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /// @notice Returns the information about a position by the position&#39;s key</span>
 108 |     | <span class='neutral'>    /// @param key The position&#39;s key is a hash of a preimage composed by the owner, tickLower and tickUpper</span>
 109 |     | <span class='neutral'>    /// @return _liquidity The amount of liquidity in the position,</span>
 110 |     | <span class='neutral'>    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,</span>
 111 |     | <span class='neutral'>    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,</span>
 112 |     | <span class='neutral'>    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,</span>
 113 |     | <span class='neutral'>    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke</span>
 114 |     | <span class='neutral'>    function positions(bytes32 key)</span>
 115 |     | <span class='neutral'>        external</span>
 116 |     | <span class='neutral'>        view</span>
 117 |     | <span class='neutral'>        returns (</span>
 118 |     | <span class='neutral'>            uint128 _liquidity,</span>
 119 |     | <span class='neutral'>            uint256 feeGrowthInside0LastX128,</span>
 120 |     | <span class='neutral'>            uint256 feeGrowthInside1LastX128,</span>
 121 |     | <span class='neutral'>            uint128 tokensOwed0,</span>
 122 |     | <span class='neutral'>            uint128 tokensOwed1</span>
 123 |     | <span class='neutral'>        );</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    /// @notice Returns data about a specific observation index</span>
 126 |     | <span class='neutral'>    /// @param index The element of the observations array to fetch</span>
 127 |     | <span class='neutral'>    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time</span>
 128 |     | <span class='neutral'>    /// ago, rather than at a specific index in the array.</span>
 129 |     | <span class='neutral'>    /// @return blockTimestamp The timestamp of the observation,</span>
 130 |     | <span class='neutral'>    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,</span>
 131 |     | <span class='neutral'>    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,</span>
 132 |     | <span class='neutral'>    /// Returns initialized whether the observation has been initialized and the values are safe to use</span>
 133 |     | <span class='neutral'>    function observations(uint256 index)</span>
 134 |     | <span class='neutral'>        external</span>
 135 |     | <span class='neutral'>        view</span>
 136 |     | <span class='neutral'>        returns (</span>
 137 |     | <span class='neutral'>            uint32 blockTimestamp,</span>
 138 |     | <span class='neutral'>            int56 tickCumulative,</span>
 139 |     | <span class='neutral'>            uint160 secondsPerLiquidityCumulativeX128,</span>
 140 |     | <span class='neutral'>            bool initialized</span>
 141 |     | <span class='neutral'>        );</span>
 142 |     | <span class='neutral'>    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp</span>
 143 |     | <span class='neutral'>    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing</span>
 144 |     | <span class='neutral'>    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,</span>
 145 |     | <span class='neutral'>    /// you must call it with secondsAgos = [3600, 0].</span>
 146 |     | <span class='neutral'>    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in</span>
 147 |     | <span class='neutral'>    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.</span>
 148 |     | <span class='neutral'>    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned</span>
 149 |     | <span class='neutral'>    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp</span>
 150 |     | <span class='neutral'>    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block</span>
 151 |     | <span class='neutral'>    /// timestamp</span>
 152 |     | <span class='neutral'>    function observe(uint32[] calldata secondsAgos)</span>
 153 |     | <span class='neutral'>        external</span>
 154 |     | <span class='neutral'>        view</span>
 155 |     | <span class='neutral'>        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range</span>
 158 |     | <span class='neutral'>    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.</span>
 159 |     | <span class='neutral'>    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first</span>
 160 |     | <span class='neutral'>    /// snapshot is taken and the second snapshot is taken.</span>
 161 |     | <span class='neutral'>    /// @param tickLower The lower tick of the range</span>
 162 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the range</span>
 163 |     | <span class='neutral'>    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range</span>
 164 |     | <span class='neutral'>    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range</span>
 165 |     | <span class='neutral'>    /// @return secondsInside The snapshot of seconds per liquidity for the range</span>
 166 |     | <span class='neutral'>    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)</span>
 167 |     | <span class='neutral'>        external</span>
 168 |     | <span class='neutral'>        view</span>
 169 |     | <span class='neutral'>        returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside);</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    /// @notice Sets the initial price for the pool</span>
 172 |     | <span class='neutral'>    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value</span>
 173 |     | <span class='neutral'>    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96</span>
 174 |     | <span class='neutral'>    function initialize(uint160 sqrtPriceX96) external;</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position</span>
 177 |     | <span class='neutral'>    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback</span>
 178 |     | <span class='neutral'>    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends</span>
 179 |     | <span class='neutral'>    /// on tickLower, tickUpper, the amount of liquidity, and the current price.</span>
 180 |     | <span class='neutral'>    /// @param recipient The address for which the liquidity will be created</span>
 181 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position in which to add liquidity</span>
 182 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position in which to add liquidity</span>
 183 |     | <span class='neutral'>    /// @param amount The amount of liquidity to mint</span>
 184 |     | <span class='neutral'>    /// @param data Any data that should be passed through to the callback</span>
 185 |     | <span class='neutral'>    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback</span>
 186 |     | <span class='neutral'>    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback</span>
 187 |     | <span class='neutral'>    function mint(address recipient, int24 tickLower, int24 tickUpper, uint128 amount, bytes calldata data)</span>
 188 |     | <span class='neutral'>        external</span>
 189 |     | <span class='neutral'>        returns (uint256 amount0, uint256 amount1);</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    /// @notice Collects tokens owed to a position</span>
 192 |     | <span class='neutral'>    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.</span>
 193 |     | <span class='neutral'>    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or</span>
 194 |     | <span class='neutral'>    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the</span>
 195 |     | <span class='neutral'>    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.</span>
 196 |     | <span class='neutral'>    /// @param recipient The address which should receive the fees collected</span>
 197 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position for which to collect fees</span>
 198 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position for which to collect fees</span>
 199 |     | <span class='neutral'>    /// @param amount0Requested How much token0 should be withdrawn from the fees owed</span>
 200 |     | <span class='neutral'>    /// @param amount1Requested How much token1 should be withdrawn from the fees owed</span>
 201 |     | <span class='neutral'>    /// @return amount0 The amount of fees collected in token0</span>
 202 |     | <span class='neutral'>    /// @return amount1 The amount of fees collected in token1</span>
 203 |     | <span class='neutral'>    function collect(</span>
 204 |     | <span class='neutral'>        address recipient,</span>
 205 |     | <span class='neutral'>        int24 tickLower,</span>
 206 |     | <span class='neutral'>        int24 tickUpper,</span>
 207 |     | <span class='neutral'>        uint128 amount0Requested,</span>
 208 |     | <span class='neutral'>        uint128 amount1Requested</span>
 209 |     | <span class='neutral'>    ) external returns (uint128 amount0, uint128 amount1);</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position</span>
 212 |     | <span class='neutral'>    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0</span>
 213 |     | <span class='neutral'>    /// @dev Fees must be collected separately via a call to #collect</span>
 214 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position for which to burn liquidity</span>
 215 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position for which to burn liquidity</span>
 216 |     | <span class='neutral'>    /// @param amount How much liquidity to burn</span>
 217 |     | <span class='neutral'>    /// @return amount0 The amount of token0 sent to the recipient</span>
 218 |     | <span class='neutral'>    /// @return amount1 The amount of token1 sent to the recipient</span>
 219 |     | <span class='neutral'>    function burn(int24 tickLower, int24 tickUpper, uint128 amount)</span>
 220 |     | <span class='neutral'>        external</span>
 221 |     | <span class='neutral'>        returns (uint256 amount0, uint256 amount1);</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    /// @notice Swap token0 for token1, or token1 for token0</span>
 224 |     | <span class='neutral'>    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback</span>
 225 |     | <span class='neutral'>    /// @param recipient The address to receive the output of the swap</span>
 226 |     | <span class='neutral'>    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0</span>
 227 |     | <span class='neutral'>    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)</span>
 228 |     | <span class='neutral'>    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this</span>
 229 |     | <span class='neutral'>    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap</span>
 230 |     | <span class='neutral'>    /// @param data Any data to be passed through to the callback</span>
 231 |     | <span class='neutral'>    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive</span>
 232 |     | <span class='neutral'>    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive</span>
 233 |     | <span class='neutral'>    function swap(</span>
 234 |     | <span class='neutral'>        address recipient,</span>
 235 |     | <span class='neutral'>        bool zeroForOne,</span>
 236 |     | <span class='neutral'>        int256 amountSpecified,</span>
 237 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96,</span>
 238 |     | <span class='neutral'>        bytes calldata data</span>
 239 |     | <span class='neutral'>    ) external returns (int256 amount0, int256 amount1);</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='neutral'>    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback</span>
 242 |     | <span class='neutral'>    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback</span>
 243 |     | <span class='neutral'>    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling</span>
 244 |     | <span class='neutral'>    /// with 0 amount{0,1} and sending the donation amount(s) from the callback</span>
 245 |     | <span class='neutral'>    /// @param recipient The address which will receive the token0 and token1 amounts</span>
 246 |     | <span class='neutral'>    /// @param amount0 The amount of token0 to send</span>
 247 |     | <span class='neutral'>    /// @param amount1 The amount of token1 to send</span>
 248 |     | <span class='neutral'>    /// @param data Any data to be passed through to the callback</span>
 249 |     | <span class='neutral'>    function flash(address recipient, uint256 amount0, uint256 amount1, bytes calldata data) external;</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    /// @notice Increase the maximum number of price and liquidity observations that this pool will store</span>
 252 |     | <span class='neutral'>    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to</span>
 253 |     | <span class='neutral'>    /// the input observationCardinalityNext.</span>
 254 |     | <span class='neutral'>    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store</span>
 255 |     | <span class='neutral'>    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>    /// @notice Set the denominator of the protocol&#39;s % share of the fees</span>
 258 |     | <span class='neutral'>    /// @param feeProtocol0 new protocol fee for token0 of the pool</span>
 259 |     | <span class='neutral'>    /// @param feeProtocol1 new protocol fee for token1 of the pool</span>
 260 |     | <span class='neutral'>    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    /// @notice Collect the protocol fee accrued to the pool</span>
 263 |     | <span class='neutral'>    /// @param recipient The address to which collected protocol fees should be sent</span>
 264 |     | <span class='neutral'>    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1</span>
 265 |     | <span class='neutral'>    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0</span>
 266 |     | <span class='neutral'>    /// @return amount0 The protocol fee collected in token0</span>
 267 |     | <span class='neutral'>    /// @return amount1 The protocol fee collected in token1</span>
 268 |     | <span class='neutral'>    function collectProtocol(address recipient, uint128 amount0Requested, uint128 amount1Requested)</span>
 269 |     | <span class='neutral'>        external</span>
 270 |     | <span class='neutral'>        returns (uint128 amount0, uint128 amount1);</span>
 271 |     | <span class='neutral'>}</span>
 272 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/Exchanges/UniswapV3/UniPriceConverter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/utils/math/Math.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>import {DECIMAL_PRECISION} from &quot;../../../../Dependencies/Constants.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>contract UniPriceConverter {</span>
 10 |     | <span class='unexecuted'>    function priceToSqrtPriceX96(uint256 _price) public pure returns (uint160 sqrtPriceX96) {</span>
 11 |     | <span class='neutral'>        // overflow vs precision</span>
 12 |     | <span class='unexecuted'>        if (_price &gt; (1 &lt;&lt; 64)) {</span>
 13 |     | <span class='neutral'>            // ~18.4e18</span>
 14 |     | <span class='unexecuted'>            sqrtPriceX96 = uint160(Math.sqrt(_price / DECIMAL_PRECISION) &lt;&lt; 96);</span>
 15 |     | <span class='neutral'>        } else {</span>
 16 |     | <span class='unexecuted'>            sqrtPriceX96 = uint160(Math.sqrt((_price &lt;&lt; 192) / DECIMAL_PRECISION));</span>
 17 |     | <span class='neutral'>        }</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function sqrtPriceX96ToPrice(uint160 _sqrtPriceX96) public pure returns (uint256 price) {</span>
 21 |     | <span class='neutral'>        //price = uint256(_sqrtPriceX96) * uint256(_sqrtPriceX96) * DECIMAL_PRECISION / (1 &lt;&lt; 192);</span>
 22 |     | <span class='unexecuted'>        uint256 squaredPrice = uint256(_sqrtPriceX96) * uint256(_sqrtPriceX96);</span>
 23 |     | <span class='neutral'>        // overflow vs precision</span>
 24 |     | <span class='unexecuted'>        if (squaredPrice &gt; 115e57) {</span>
 25 |     | <span class='neutral'>            // max uint256 / 1e18</span>
 26 |     | <span class='unexecuted'>            price = ((squaredPrice &gt;&gt; 96) * DECIMAL_PRECISION) &gt;&gt; 96;</span>
 27 |     | <span class='neutral'>        } else {</span>
 28 |     | <span class='unexecuted'>            price = (squaredPrice * DECIMAL_PRECISION) &gt;&gt; 192;</span>
 29 |     | <span class='neutral'>        }</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'>}</span>
 32 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/FlashLoans/Balancer/vault/IFlashLoanRecipient.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>// This program is free software: you can redistribute it and/or modify</span>
  3 |     | <span class='neutral'>// it under the terms of the GNU General Public License as published by</span>
  4 |     | <span class='neutral'>// the Free Software Foundation, either version 3 of the License, or</span>
  5 |     | <span class='neutral'>// (at your option) any later version.</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>// This program is distributed in the hope that it will be useful,</span>
  8 |     | <span class='neutral'>// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  9 |     | <span class='neutral'>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
 10 |     | <span class='neutral'>// GNU General Public License for more details.</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>// You should have received a copy of the GNU General Public License</span>
 13 |     | <span class='neutral'>// along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>pragma solidity &gt;=0.7.0 &lt;0.9.0;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>// Inspired by Aave Protocol&#39;s IFlashLoanReceiver.</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/IERC20.sol&quot;;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>interface IFlashLoanRecipient {</span>
 22 |     | <span class='neutral'>    /**</span>
 23 |     | <span class='neutral'>     * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.</span>
 24 |     | <span class='neutral'>     *</span>
 25 |     | <span class='neutral'>     * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this</span>
 26 |     | <span class='neutral'>     * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the</span>
 27 |     | <span class='neutral'>     * Vault, or else the entire flash loan will revert.</span>
 28 |     | <span class='neutral'>     *</span>
 29 |     | <span class='neutral'>     * `userData` is the same value passed in the `IVault.flashLoan` call.</span>
 30 |     | <span class='neutral'>     */</span>
 31 |     | <span class='neutral'>    function receiveFlashLoan(</span>
 32 |     | <span class='neutral'>        IERC20[] memory tokens,</span>
 33 |     | <span class='neutral'>        uint256[] memory amounts,</span>
 34 |     | <span class='neutral'>        uint256[] memory feeAmounts,</span>
 35 |     | <span class='neutral'>        bytes memory userData</span>
 36 |     | <span class='neutral'>    ) external;</span>
 37 |     | <span class='neutral'>}</span>
 38 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/FlashLoans/Balancer/vault/IVault.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>// This program is free software: you can redistribute it and/or modify</span>
  3 |     | <span class='neutral'>// it under the terms of the GNU General Public License as published by</span>
  4 |     | <span class='neutral'>// the Free Software Foundation, either version 3 of the License, or</span>
  5 |     | <span class='neutral'>// (at your option) any later version.</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>// This program is distributed in the hope that it will be useful,</span>
  8 |     | <span class='neutral'>// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  9 |     | <span class='neutral'>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
 10 |     | <span class='neutral'>// GNU General Public License for more details.</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>// You should have received a copy of the GNU General Public License</span>
 13 |     | <span class='neutral'>// along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/IERC20.sol&quot;;</span>
 16 |     | <span class='neutral'>import &quot;./IFlashLoanRecipient.sol&quot;;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>pragma solidity &gt;=0.7.0 &lt;0.9.0;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>/**</span>
 21 |     | <span class='neutral'> * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that</span>
 22 |     | <span class='neutral'> * don&#39;t override one of these declarations.</span>
 23 |     | <span class='neutral'> */</span>
 24 |     | <span class='neutral'>interface IVault {</span>
 25 |     | <span class='neutral'>    // Flash Loans</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    /**</span>
 28 |     | <span class='neutral'>     * @dev Performs a &#39;flash loan&#39;, sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it,</span>
 29 |     | <span class='neutral'>     * and then reverting unless the tokens plus a proportional protocol fee have been returned.</span>
 30 |     | <span class='neutral'>     *</span>
 31 |     | <span class='neutral'>     * The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount</span>
 32 |     | <span class='neutral'>     * for each token contract. `tokens` must be sorted in ascending order.</span>
 33 |     | <span class='neutral'>     *</span>
 34 |     | <span class='neutral'>     * The &#39;userData&#39; field is ignored by the Vault, and forwarded as-is to `recipient` as part of the</span>
 35 |     | <span class='neutral'>     * `receiveFlashLoan` call.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Emits `FlashLoan` events.</span>
 38 |     | <span class='neutral'>     */</span>
 39 |     | <span class='neutral'>    function flashLoan(</span>
 40 |     | <span class='neutral'>        IFlashLoanRecipient recipient,</span>
 41 |     | <span class='neutral'>        IERC20[] memory tokens,</span>
 42 |     | <span class='neutral'>        uint256[] memory amounts,</span>
 43 |     | <span class='neutral'>        bytes memory userData</span>
 44 |     | <span class='neutral'>    ) external;</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    /**</span>
 47 |     | <span class='neutral'>     * @dev Emitted for each individual flash loan performed by `flashLoan`.</span>
 48 |     | <span class='neutral'>     */</span>
 49 |     | <span class='neutral'>    event FlashLoan(IFlashLoanRecipient indexed recipient, IERC20 indexed token, uint256 amount, uint256 feeAmount);</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    /**</span>
 52 |     | <span class='neutral'>     * @dev Returns the Vault&#39;s WETH instance.</span>
 53 |     | <span class='neutral'>     */</span>
 54 |     | <span class='neutral'>    //function WETH() external view returns (IWETH);</span>
 55 |     | <span class='neutral'>    // solhint-disable-previous-line func-name-mixedcase</span>
 56 |     | <span class='neutral'>}</span>
 57 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/Modules/FlashLoans/BalancerFlashLoan.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Balancer/vault/IVault.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Balancer/vault/IFlashLoanRecipient.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>import &quot;../../Interfaces/ILeverageZapper.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../../Interfaces/IFlashLoanReceiver.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../../Interfaces/IFlashLoanProvider.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>contract BalancerFlashLoan is IFlashLoanRecipient, IFlashLoanProvider {</span>
  14 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>    IVault private constant vault = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);</span>
  17 |     | <span class='unexecuted'>    IFlashLoanReceiver public receiver;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>    function makeFlashLoan(IERC20 _token, uint256 _amount, Operation _operation, bytes calldata _params) external {</span>
  20 |     | <span class='unexecuted'>        IERC20[] memory tokens = new IERC20[](1);</span>
  21 |     | <span class='unexecuted'>        tokens[0] = _token;</span>
  22 |     | <span class='unexecuted'>        uint256[] memory amounts = new uint256[](1);</span>
  23 |     | <span class='unexecuted'>        amounts[0] = _amount;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>        // Data for the callback receiveFlashLoan</span>
  26 |     | <span class='unexecuted'>        bytes memory userData;</span>
  27 |     | <span class='unexecuted'>        if (_operation == Operation.OpenTrove) {</span>
  28 |     | <span class='unexecuted'>            ILeverageZapper.OpenLeveragedTroveParams memory openTroveParams =</span>
  29 |     | <span class='unexecuted'>                abi.decode(_params, (ILeverageZapper.OpenLeveragedTroveParams));</span>
  30 |     | <span class='unexecuted'>            userData = abi.encode(_operation, openTroveParams);</span>
  31 |     | <span class='unexecuted'>        } else if (_operation == Operation.LeverUpTrove) {</span>
  32 |     | <span class='unexecuted'>            ILeverageZapper.LeverUpTroveParams memory leverUpTroveParams =</span>
  33 |     | <span class='unexecuted'>                abi.decode(_params, (ILeverageZapper.LeverUpTroveParams));</span>
  34 |     | <span class='unexecuted'>            userData = abi.encode(_operation, leverUpTroveParams);</span>
  35 |     | <span class='unexecuted'>        } else if (_operation == Operation.LeverDownTrove) {</span>
  36 |     | <span class='unexecuted'>            ILeverageZapper.LeverDownTroveParams memory leverDownTroveParams =</span>
  37 |     | <span class='unexecuted'>                abi.decode(_params, (ILeverageZapper.LeverDownTroveParams));</span>
  38 |     | <span class='unexecuted'>            userData = abi.encode(_operation, leverDownTroveParams);</span>
  39 |     | <span class='unexecuted'>        } else if (_operation == Operation.CloseTrove) {</span>
  40 |     | <span class='unexecuted'>            IZapper.CloseTroveParams memory closeTroveParams = abi.decode(_params, (IZapper.CloseTroveParams));</span>
  41 |     | <span class='unexecuted'>            userData = abi.encode(_operation, closeTroveParams);</span>
  42 |     | <span class='neutral'>        } else {</span>
  43 |     | <span class='unexecuted'>            revert(&quot;LZ: Wrong Operation&quot;);</span>
  44 |     | <span class='neutral'>        }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>        // This will be used by the callback below no</span>
  47 |     | <span class='unexecuted'>        receiver = IFlashLoanReceiver(msg.sender);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>        vault.flashLoan(this, tokens, amounts, userData);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>    function receiveFlashLoan(</span>
  53 |     | <span class='neutral'>        IERC20[] calldata tokens,</span>
  54 |     | <span class='neutral'>        uint256[] calldata amounts,</span>
  55 |     | <span class='neutral'>        uint256[] calldata feeAmounts,</span>
  56 |     | <span class='neutral'>        bytes calldata userData</span>
  57 |     | <span class='unexecuted'>    ) external override {</span>
  58 |     | <span class='unexecuted'>        require(msg.sender == address(vault), &quot;Caller is not Vault&quot;);</span>
  59 |     | <span class='unexecuted'>        require(address(receiver) != address(0), &quot;Flash loan not properly initiated&quot;);</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>        // Cache and reset receiver, to comply with CEI pattern, as some callbacks in zappers do raw calls</span>
  62 |     | <span class='neutral'>        // It’s not necessary, as Balancer flash loans are protected against re-entrancy</span>
  63 |     | <span class='neutral'>        // But it’s safer, specially if someone tries to reuse this code, and more gas efficient</span>
  64 |     | <span class='unexecuted'>        IFlashLoanReceiver receiverCached = receiver;</span>
  65 |     | <span class='unexecuted'>        receiver = IFlashLoanReceiver(address(0));</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>        // decode and operation</span>
  68 |     | <span class='unexecuted'>        Operation operation = abi.decode(userData[0:32], (Operation));</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>        if (operation == Operation.OpenTrove) {</span>
  71 |     | <span class='neutral'>            // Open</span>
  72 |     | <span class='neutral'>            // decode params</span>
  73 |     | <span class='unexecuted'>            ILeverageZapper.OpenLeveragedTroveParams memory openTroveParams =</span>
  74 |     | <span class='unexecuted'>                abi.decode(userData[32:], (ILeverageZapper.OpenLeveragedTroveParams));</span>
  75 |     | <span class='neutral'>            // Flash loan minus fees</span>
  76 |     | <span class='unexecuted'>            uint256 effectiveFlashLoanAmount = amounts[0] - feeAmounts[0];</span>
  77 |     | <span class='neutral'>            // We send only effective flash loan, keeping fees here</span>
  78 |     | <span class='unexecuted'>            tokens[0].safeTransfer(address(receiverCached), effectiveFlashLoanAmount);</span>
  79 |     | <span class='neutral'>            // Zapper callback</span>
  80 |     | <span class='unexecuted'>            receiverCached.receiveFlashLoanOnOpenLeveragedTrove(openTroveParams, effectiveFlashLoanAmount);</span>
  81 |     | <span class='unexecuted'>        } else if (operation == Operation.LeverUpTrove) {</span>
  82 |     | <span class='neutral'>            // Lever up</span>
  83 |     | <span class='neutral'>            // decode params</span>
  84 |     | <span class='unexecuted'>            ILeverageZapper.LeverUpTroveParams memory leverUpTroveParams =</span>
  85 |     | <span class='unexecuted'>                abi.decode(userData[32:], (ILeverageZapper.LeverUpTroveParams));</span>
  86 |     | <span class='neutral'>            // Flash loan minus fees</span>
  87 |     | <span class='unexecuted'>            uint256 effectiveFlashLoanAmount = amounts[0] - feeAmounts[0];</span>
  88 |     | <span class='neutral'>            // We send only effective flash loan, keeping fees here</span>
  89 |     | <span class='unexecuted'>            tokens[0].safeTransfer(address(receiverCached), effectiveFlashLoanAmount);</span>
  90 |     | <span class='neutral'>            // Zapper callback</span>
  91 |     | <span class='unexecuted'>            receiverCached.receiveFlashLoanOnLeverUpTrove(leverUpTroveParams, effectiveFlashLoanAmount);</span>
  92 |     | <span class='unexecuted'>        } else if (operation == Operation.LeverDownTrove) {</span>
  93 |     | <span class='neutral'>            // Lever down</span>
  94 |     | <span class='neutral'>            // decode params</span>
  95 |     | <span class='unexecuted'>            ILeverageZapper.LeverDownTroveParams memory leverDownTroveParams =</span>
  96 |     | <span class='unexecuted'>                abi.decode(userData[32:], (ILeverageZapper.LeverDownTroveParams));</span>
  97 |     | <span class='neutral'>            // Flash loan minus fees</span>
  98 |     | <span class='unexecuted'>            uint256 effectiveFlashLoanAmount = amounts[0] - feeAmounts[0];</span>
  99 |     | <span class='neutral'>            // We send only effective flash loan, keeping fees here</span>
 100 |     | <span class='unexecuted'>            tokens[0].safeTransfer(address(receiverCached), effectiveFlashLoanAmount);</span>
 101 |     | <span class='neutral'>            // Zapper callback</span>
 102 |     | <span class='unexecuted'>            receiverCached.receiveFlashLoanOnLeverDownTrove(leverDownTroveParams, effectiveFlashLoanAmount);</span>
 103 |     | <span class='unexecuted'>        } else if (operation == Operation.CloseTrove) {</span>
 104 |     | <span class='neutral'>            // Close trove</span>
 105 |     | <span class='neutral'>            // decode params</span>
 106 |     | <span class='unexecuted'>            IZapper.CloseTroveParams memory closeTroveParams = abi.decode(userData[32:], (IZapper.CloseTroveParams));</span>
 107 |     | <span class='neutral'>            // Flash loan minus fees</span>
 108 |     | <span class='unexecuted'>            uint256 effectiveFlashLoanAmount = amounts[0] - feeAmounts[0];</span>
 109 |     | <span class='neutral'>            // We send only effective flash loan, keeping fees here</span>
 110 |     | <span class='unexecuted'>            tokens[0].safeTransfer(address(receiverCached), effectiveFlashLoanAmount);</span>
 111 |     | <span class='neutral'>            // Zapper callback</span>
 112 |     | <span class='unexecuted'>            receiverCached.receiveFlashLoanOnCloseTroveFromCollateral(closeTroveParams, effectiveFlashLoanAmount);</span>
 113 |     | <span class='neutral'>        } else {</span>
 114 |     | <span class='neutral'>            revert(&quot;LZ: Wrong Operation&quot;);</span>
 115 |     | <span class='neutral'>        }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>        // Return flash loan</span>
 118 |     | <span class='unexecuted'>        tokens[0].safeTransfer(address(vault), amounts[0] + feeAmounts[0]);</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'>}</span>
 121 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/src/Zappers/WETHZapper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.24;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./BaseZapper.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../Dependencies/Constants.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>contract WETHZapper is BaseZapper {</span>
   9 |     | <span class='unexecuted'>    constructor(IAddressesRegistry _addressesRegistry, IFlashLoanProvider _flashLoanProvider, IExchange _exchange)</span>
  10 |     | <span class='unexecuted'>        BaseZapper(_addressesRegistry, _flashLoanProvider, _exchange)</span>
  11 |     | <span class='neutral'>    {</span>
  12 |     | <span class='unexecuted'>        require(address(WETH) == address(_addressesRegistry.collToken()), &quot;WZ: Wrong coll branch&quot;);</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>        // Approve coll to BorrowerOperations</span>
  15 |     | <span class='unexecuted'>        WETH.approve(address(borrowerOperations), type(uint256).max);</span>
  16 |     | <span class='neutral'>        // Approve Coll to exchange module (for closeTroveFromCollateral)</span>
  17 |     | <span class='unexecuted'>        WETH.approve(address(_exchange), type(uint256).max);</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    function openTroveWithRawETH(OpenTroveParams calldata _params) external payable returns (uint256) {</span>
  21 |     | <span class='unexecuted'>        require(msg.value &gt; ETH_GAS_COMPENSATION, &quot;WZ: Insufficient ETH&quot;);</span>
  22 |     | <span class='unexecuted'>        require(</span>
  23 |     | <span class='unexecuted'>            _params.batchManager == address(0) || _params.annualInterestRate == 0,</span>
  24 |     | <span class='neutral'>            &quot;WZ: Cannot choose interest if joining a batch&quot;</span>
  25 |     | <span class='neutral'>        );</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>        // Convert ETH to WETH</span>
  28 |     | <span class='unexecuted'>        WETH.deposit{value: msg.value}();</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>        uint256 troveId;</span>
  31 |     | <span class='unexecuted'>        if (_params.batchManager == address(0)) {</span>
  32 |     | <span class='unexecuted'>            troveId = borrowerOperations.openTrove(</span>
  33 |     | <span class='unexecuted'>                _params.owner,</span>
  34 |     | <span class='unexecuted'>                _params.ownerIndex,</span>
  35 |     | <span class='unexecuted'>                msg.value - ETH_GAS_COMPENSATION,</span>
  36 |     | <span class='unexecuted'>                _params.boldAmount,</span>
  37 |     | <span class='unexecuted'>                _params.upperHint,</span>
  38 |     | <span class='unexecuted'>                _params.lowerHint,</span>
  39 |     | <span class='unexecuted'>                _params.annualInterestRate,</span>
  40 |     | <span class='unexecuted'>                _params.maxUpfrontFee,</span>
  41 |     | <span class='neutral'>                // Add this contract as add/receive manager to be able to fully adjust trove,</span>
  42 |     | <span class='neutral'>                // while keeping the same management functionality</span>
  43 |     | <span class='unexecuted'>                address(this), // add manager</span>
  44 |     | <span class='unexecuted'>                address(this), // remove manager</span>
  45 |     | <span class='unexecuted'>                address(this) // receiver for remove manager</span>
  46 |     | <span class='neutral'>            );</span>
  47 |     | <span class='unexecuted'>        } else {</span>
  48 |     | <span class='unexecuted'>            IBorrowerOperations.OpenTroveAndJoinInterestBatchManagerParams memory</span>
  49 |     | <span class='unexecuted'>                openTroveAndJoinInterestBatchManagerParams = IBorrowerOperations</span>
  50 |     | <span class='neutral'>                    .OpenTroveAndJoinInterestBatchManagerParams({</span>
  51 |     | <span class='unexecuted'>                    owner: _params.owner,</span>
  52 |     | <span class='unexecuted'>                    ownerIndex: _params.ownerIndex,</span>
  53 |     | <span class='unexecuted'>                    collAmount: msg.value - ETH_GAS_COMPENSATION,</span>
  54 |     | <span class='unexecuted'>                    boldAmount: _params.boldAmount,</span>
  55 |     | <span class='unexecuted'>                    upperHint: _params.upperHint,</span>
  56 |     | <span class='unexecuted'>                    lowerHint: _params.lowerHint,</span>
  57 |     | <span class='unexecuted'>                    interestBatchManager: _params.batchManager,</span>
  58 |     | <span class='unexecuted'>                    maxUpfrontFee: _params.maxUpfrontFee,</span>
  59 |     | <span class='neutral'>                    // Add this contract as add/receive manager to be able to fully adjust trove,</span>
  60 |     | <span class='neutral'>                    // while keeping the same management functionality</span>
  61 |     | <span class='unexecuted'>                    addManager: address(this), // add manager</span>
  62 |     | <span class='neutral'>                    removeManager: address(this), // remove manager</span>
  63 |     | <span class='neutral'>                    receiver: address(this) // receiver for remove manager</span>
  64 |     | <span class='neutral'>                });</span>
  65 |     | <span class='unexecuted'>            troveId =</span>
  66 |     | <span class='unexecuted'>                borrowerOperations.openTroveAndJoinInterestBatchManager(openTroveAndJoinInterestBatchManagerParams);</span>
  67 |     | <span class='neutral'>        }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>        boldToken.transfer(msg.sender, _params.boldAmount);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        // Set add/remove managers</span>
  72 |     | <span class='unexecuted'>        _setAddManager(troveId, _params.addManager);</span>
  73 |     | <span class='unexecuted'>        _setRemoveManagerAndReceiver(troveId, _params.removeManager, _params.receiver);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        return troveId;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>    function addCollWithRawETH(uint256 _troveId) external payable {</span>
  79 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_troveId);</span>
  80 |     | <span class='unexecuted'>        _requireSenderIsOwnerOrAddManager(_troveId, owner);</span>
  81 |     | <span class='neutral'>        // Convert ETH to WETH</span>
  82 |     | <span class='unexecuted'>        WETH.deposit{value: msg.value}();</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        borrowerOperations.addColl(_troveId, msg.value);</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>    function withdrawCollToRawETH(uint256 _troveId, uint256 _amount) external {</span>
  88 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_troveId);</span>
  89 |     | <span class='unexecuted'>        address payable receiver = payable(_requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner));</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>        borrowerOperations.withdrawColl(_troveId, _amount);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>        // Convert WETH to ETH</span>
  94 |     | <span class='unexecuted'>        WETH.withdraw(_amount);</span>
  95 |     | <span class='unexecuted'>        (bool success,) = receiver.call{value: _amount}(&quot;&quot;);</span>
  96 |     | <span class='neutral'>        require(success, &quot;WZ: Sending ETH failed&quot;);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>    function withdrawBold(uint256 _troveId, uint256 _boldAmount, uint256 _maxUpfrontFee) external {</span>
 100 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_troveId);</span>
 101 |     | <span class='unexecuted'>        address receiver = _requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>        borrowerOperations.withdrawBold(_troveId, _boldAmount, _maxUpfrontFee);</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>        // Send Bold</span>
 106 |     | <span class='unexecuted'>        boldToken.transfer(receiver, _boldAmount);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>    function repayBold(uint256 _troveId, uint256 _boldAmount) external {</span>
 110 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_troveId);</span>
 111 |     | <span class='unexecuted'>        _requireSenderIsOwnerOrAddManager(_troveId, owner);</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        // Set initial balances to make sure there are not lefovers</span>
 114 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
 115 |     | <span class='unexecuted'>        _setInitialTokensAndBalances(WETH, boldToken, initialBalances);</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>        // Pull Bold</span>
 118 |     | <span class='unexecuted'>        boldToken.transferFrom(msg.sender, address(this), _boldAmount);</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>        borrowerOperations.repayBold(_troveId, _boldAmount);</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>        // return leftovers to user</span>
 123 |     | <span class='unexecuted'>        _returnLeftovers(initialBalances);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>    function adjustTroveWithRawETH(</span>
 127 |     | <span class='neutral'>        uint256 _troveId,</span>
 128 |     | <span class='neutral'>        uint256 _collChange,</span>
 129 |     | <span class='neutral'>        bool _isCollIncrease,</span>
 130 |     | <span class='neutral'>        uint256 _boldChange,</span>
 131 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
 132 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
 133 |     | <span class='unexecuted'>    ) external payable {</span>
 134 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
 135 |     | <span class='unexecuted'>        address payable receiver =</span>
 136 |     | <span class='unexecuted'>            _adjustTrovePre(_troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, initialBalances);</span>
 137 |     | <span class='unexecuted'>        borrowerOperations.adjustTrove(</span>
 138 |     | <span class='neutral'>            _troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, _maxUpfrontFee</span>
 139 |     | <span class='neutral'>        );</span>
 140 |     | <span class='unexecuted'>        _adjustTrovePost(_collChange, _isCollIncrease, _boldChange, _isDebtIncrease, receiver, initialBalances);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>    function adjustZombieTroveWithRawETH(</span>
 144 |     | <span class='neutral'>        uint256 _troveId,</span>
 145 |     | <span class='neutral'>        uint256 _collChange,</span>
 146 |     | <span class='neutral'>        bool _isCollIncrease,</span>
 147 |     | <span class='neutral'>        uint256 _boldChange,</span>
 148 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
 149 |     | <span class='neutral'>        uint256 _upperHint,</span>
 150 |     | <span class='neutral'>        uint256 _lowerHint,</span>
 151 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
 152 |     | <span class='unexecuted'>    ) external payable {</span>
 153 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
 154 |     | <span class='unexecuted'>        address payable receiver =</span>
 155 |     | <span class='unexecuted'>            _adjustTrovePre(_troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, initialBalances);</span>
 156 |     | <span class='unexecuted'>        borrowerOperations.adjustZombieTrove(</span>
 157 |     | <span class='neutral'>            _troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, _upperHint, _lowerHint, _maxUpfrontFee</span>
 158 |     | <span class='neutral'>        );</span>
 159 |     | <span class='unexecuted'>        _adjustTrovePost(_collChange, _isCollIncrease, _boldChange, _isDebtIncrease, receiver, initialBalances);</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='unexecuted'>    function _adjustTrovePre(</span>
 163 |     | <span class='neutral'>        uint256 _troveId,</span>
 164 |     | <span class='neutral'>        uint256 _collChange,</span>
 165 |     | <span class='neutral'>        bool _isCollIncrease,</span>
 166 |     | <span class='neutral'>        uint256 _boldChange,</span>
 167 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
 168 |     | <span class='neutral'>        InitialBalances memory _initialBalances</span>
 169 |     | <span class='unexecuted'>    ) internal returns (address payable) {</span>
 170 |     | <span class='unexecuted'>        if (_isCollIncrease) {</span>
 171 |     | <span class='unexecuted'>            require(_collChange == msg.value, &quot;WZ: Wrong coll amount&quot;);</span>
 172 |     | <span class='neutral'>        } else {</span>
 173 |     | <span class='unexecuted'>            require(msg.value == 0, &quot;WZ: Not adding coll, no ETH should be received&quot;);</span>
 174 |     | <span class='neutral'>        }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='unexecuted'>        address payable receiver =</span>
 177 |     | <span class='unexecuted'>            payable(_checkAdjustTroveManagers(_troveId, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease));</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>        // Set initial balances to make sure there are not lefovers</span>
 180 |     | <span class='unexecuted'>        _setInitialTokensAndBalances(WETH, boldToken, _initialBalances);</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>        // ETH -&gt; WETH</span>
 183 |     | <span class='unexecuted'>        if (_isCollIncrease) {</span>
 184 |     | <span class='unexecuted'>            WETH.deposit{value: _collChange}();</span>
 185 |     | <span class='neutral'>        }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>        // Pull Bold</span>
 188 |     | <span class='unexecuted'>        if (!_isDebtIncrease) {</span>
 189 |     | <span class='unexecuted'>            boldToken.transferFrom(msg.sender, address(this), _boldChange);</span>
 190 |     | <span class='neutral'>        }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='unexecuted'>        return receiver;</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>    function _adjustTrovePost(</span>
 196 |     | <span class='neutral'>        uint256 _collChange,</span>
 197 |     | <span class='neutral'>        bool _isCollIncrease,</span>
 198 |     | <span class='neutral'>        uint256 _boldChange,</span>
 199 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
 200 |     | <span class='neutral'>        address payable _receiver,</span>
 201 |     | <span class='neutral'>        InitialBalances memory _initialBalances</span>
 202 |     | <span class='unexecuted'>    ) internal {</span>
 203 |     | <span class='neutral'>        // Send Bold</span>
 204 |     | <span class='unexecuted'>        if (_isDebtIncrease) {</span>
 205 |     | <span class='unexecuted'>            boldToken.transfer(_receiver, _boldChange);</span>
 206 |     | <span class='neutral'>        }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>        // return BOLD leftovers to user (trying to repay more than possible)</span>
 209 |     | <span class='unexecuted'>        uint256 currentBoldBalance = boldToken.balanceOf(address(this));</span>
 210 |     | <span class='unexecuted'>        if (currentBoldBalance &gt; _initialBalances.balances[1]) {</span>
 211 |     | <span class='unexecuted'>            boldToken.transfer(_initialBalances.receiver, currentBoldBalance - _initialBalances.balances[1]);</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>        // There shouldn’t be Collateral leftovers, everything sent should end up in the trove</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>        // WETH -&gt; ETH</span>
 216 |     | <span class='unexecuted'>        if (!_isCollIncrease &amp;&amp; _collChange &gt; 0) {</span>
 217 |     | <span class='unexecuted'>            WETH.withdraw(_collChange);</span>
 218 |     | <span class='unexecuted'>            (bool success,) = _receiver.call{value: _collChange}(&quot;&quot;);</span>
 219 |     | <span class='unexecuted'>            require(success, &quot;WZ: Sending ETH failed&quot;);</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'>        // TODO: remove before deployment!!</span>
 222 |     | <span class='unexecuted'>        assert(address(this).balance == 0);</span>
 223 |     | <span class='unexecuted'>        assert(WETH.balanceOf(address(this)) == 0);</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='unexecuted'>    function closeTroveToRawETH(uint256 _troveId) external {</span>
 227 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_troveId);</span>
 228 |     | <span class='unexecuted'>        address payable receiver = payable(_requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner));</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>        // pull Bold for repayment</span>
 231 |     | <span class='unexecuted'>        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);</span>
 232 |     | <span class='unexecuted'>        boldToken.transferFrom(msg.sender, address(this), trove.entireDebt);</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='unexecuted'>        borrowerOperations.closeTrove(_troveId);</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='unexecuted'>        WETH.withdraw(trove.entireColl + ETH_GAS_COMPENSATION);</span>
 237 |     | <span class='unexecuted'>        (bool success,) = receiver.call{value: trove.entireColl + ETH_GAS_COMPENSATION}(&quot;&quot;);</span>
 238 |     | <span class='unexecuted'>        require(success, &quot;WZ: Sending ETH failed&quot;);</span>
 239 |     | <span class='neutral'>    }</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='unexecuted'>    function closeTroveFromCollateral(uint256 _troveId, uint256 _flashLoanAmount) external override {</span>
 242 |     | <span class='unexecuted'>        address owner = troveNFT.ownerOf(_troveId);</span>
 243 |     | <span class='unexecuted'>        address payable receiver = payable(_requireSenderIsOwnerOrRemoveManagerAndGetReceiver(_troveId, owner));</span>
 244 |     | <span class='unexecuted'>        CloseTroveParams memory params =</span>
 245 |     | <span class='unexecuted'>            CloseTroveParams({troveId: _troveId, flashLoanAmount: _flashLoanAmount, receiver: receiver});</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>        // Set initial balances to make sure there are not lefovers</span>
 248 |     | <span class='unexecuted'>        InitialBalances memory initialBalances;</span>
 249 |     | <span class='unexecuted'>        initialBalances.tokens[0] = WETH;</span>
 250 |     | <span class='unexecuted'>        initialBalances.tokens[1] = boldToken;</span>
 251 |     | <span class='unexecuted'>        _setInitialBalancesAndReceiver(initialBalances, receiver);</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='neutral'>        // Flash loan coll</span>
 254 |     | <span class='unexecuted'>        flashLoanProvider.makeFlashLoan(</span>
 255 |     | <span class='unexecuted'>            WETH, _flashLoanAmount, IFlashLoanProvider.Operation.CloseTrove, abi.encode(params)</span>
 256 |     | <span class='neutral'>        );</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>        // return leftovers to user</span>
 259 |     | <span class='unexecuted'>        _returnLeftovers(initialBalances);</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='unexecuted'>    function receiveFlashLoanOnCloseTroveFromCollateral(</span>
 263 |     | <span class='neutral'>        CloseTroveParams calldata _params,</span>
 264 |     | <span class='neutral'>        uint256 _effectiveFlashLoanAmount</span>
 265 |     | <span class='neutral'>    ) external {</span>
 266 |     | <span class='unexecuted'>        require(msg.sender == address(flashLoanProvider), &quot;WZ: Caller not FlashLoan provider&quot;);</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='unexecuted'>        LatestTroveData memory trove = troveManager.getLatestTroveData(_params.troveId);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>        // Swap Coll from flash loan to Bold, so we can repay and close trove</span>
 271 |     | <span class='neutral'>        // We swap the flash loan minus the flash loan fee</span>
 272 |     | <span class='unexecuted'>        exchange.swapToBold(_effectiveFlashLoanAmount, trove.entireDebt);</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>        // We asked for a min of entireDebt in swapToBold call above, so we don’t check again here:</span>
 275 |     | <span class='neutral'>        // uint256 receivedBoldAmount = exchange.swapToBold(_effectiveFlashLoanAmount, trove.entireDebt);</span>
 276 |     | <span class='neutral'>        //require(receivedBoldAmount &gt;= trove.entireDebt, &quot;WZ: Not enough BOLD obtained to repay&quot;);</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='unexecuted'>        borrowerOperations.closeTrove(_params.troveId);</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>        // Send coll back to return flash loan</span>
 281 |     | <span class='unexecuted'>        WETH.transfer(address(flashLoanProvider), _params.flashLoanAmount);</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>        // Send coll left and gas compensation</span>
 284 |     | <span class='unexecuted'>        uint256 collLeft = trove.entireColl + ETH_GAS_COMPENSATION - _params.flashLoanAmount;</span>
 285 |     | <span class='unexecuted'>        WETH.withdraw(collLeft);</span>
 286 |     | <span class='unexecuted'>        (bool success,) = _params.receiver.call{value: collLeft}(&quot;&quot;);</span>
 287 |     | <span class='neutral'>        require(success, &quot;WZ: Sending ETH failed&quot;);</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>    receive() external payable {}</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>    // Unimplemented flash loan receive functions for leverage</span>
 293 |     | <span class='unexecuted'>    function receiveFlashLoanOnOpenLeveragedTrove(</span>
 294 |     | <span class='neutral'>        ILeverageZapper.OpenLeveragedTroveParams calldata _params,</span>
 295 |     | <span class='neutral'>        uint256 _effectiveFlashLoanAmount</span>
 296 |     | <span class='neutral'>    ) external virtual override {}</span>
 297 |     | <span class='unexecuted'>    function receiveFlashLoanOnLeverUpTrove(</span>
 298 |     | <span class='neutral'>        ILeverageZapper.LeverUpTroveParams calldata _params,</span>
 299 |     | <span class='neutral'>        uint256 _effectiveFlashLoanAmount</span>
 300 |     | <span class='neutral'>    ) external virtual override {}</span>
 301 |     | <span class='unexecuted'>    function receiveFlashLoanOnLeverDownTrove(</span>
 302 |     | <span class='neutral'>        ILeverageZapper.LeverDownTroveParams calldata _params,</span>
 303 |     | <span class='neutral'>        uint256 _effectiveFlashLoanAmount</span>
 304 |     | <span class='neutral'>    ) external virtual override {}</span>
 305 |     | <span class='neutral'>}</span>
 306 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/BeforeAfter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Setup} from &quot;./Setup.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>// ghost variables for tracking state variable values before and after function calls</span>
  7 |     | <span class='neutral'>abstract contract BeforeAfter is Setup {</span>
  8 |     | <span class='neutral'>//     struct Vars {</span>
  9 |     | <span class='neutral'>//         uint256 counter_number;</span>
 10 |     | <span class='neutral'>//     }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>//     Vars internal _before;</span>
 13 |     | <span class='neutral'>//     Vars internal _after;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>//     function __before() internal {</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>//     }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>//     function __after() internal {</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>//     }</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/CryticTester.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {TargetFunctions} from &quot;./TargetFunctions.sol&quot;;</span>
  5 |     | <span class='neutral'>import {CryticAsserts} from &quot;@chimera/CryticAsserts.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>// echidna . --contract CryticTester --config echidna.yaml</span>
  8 |     | <span class='neutral'>// medusa fuzz</span>
  9 |     | <span class='neutral'>// echidna . --contract CryticTester --config echidna.yaml --test-limit 1000000</span>
 10 |     | <span class='neutral'></span>
 11 | *r  | <span class='executed'>contract CryticTester is TargetFunctions, CryticAsserts {</span>
 12 |     | <span class='neutral'>    constructor() payable {</span>
 13 | *   | <span class='executed'>        setup();</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/CryticToFoundry.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Test} from &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'>import {TargetFunctions} from &quot;./TargetFunctions.sol&quot;;</span>
  6 |     | <span class='neutral'>import {FoundryAsserts} from &quot;@chimera/FoundryAsserts.sol&quot;;</span>
  7 |     | <span class='neutral'>import {console} from &quot;forge-std/console.sol&quot;;</span>
  8 |     | <span class='neutral'>import {LatestTroveData} from &quot;src/Types/LatestTroveData.sol&quot;;</span>
  9 |     | <span class='neutral'>//forge test --match-test test_crytically -vvvv</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>contract CryticToFoundry is Test, TargetFunctions, FoundryAsserts {</span>
 12 |     | <span class='unexecuted'>    function setUp() public {</span>
 13 |     | <span class='unexecuted'>        setup();</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    function test_crytic() public {</span>
 17 |     | <span class='unexecuted'>        currentUser = users[0];</span>
 18 |     | <span class='unexecuted'>        mintColl(100000000e18);</span>
 19 |     | <span class='unexecuted'>        mintColl(100000e18);</span>
 20 |     | <span class='unexecuted'>        mintWeth(1000e18);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>        switch_randomUnit(1);</span>
 23 |     | <span class='unexecuted'>        priceFeed_setPrice(2000e18);</span>
 24 |     | <span class='unexecuted'>        clamped_registerBatchManager(1.5e18, 2e18, 1.7e18, 0, 1 days);</span>
 25 |     | <span class='unexecuted'>        clamped_openTroveAndJoinInterestBatchManager(11e18, 2000e18);</span>
 26 |     | <span class='unexecuted'>        switch_batchTrove(1);</span>
 27 |     | <span class='unexecuted'>        console.log(currentBatchTrove);</span>
 28 |     | <span class='unexecuted'>        console.log(&quot;1&quot;);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>        switch_trove(0);</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>        priceFeed_setRedemptionPrice(20000e18);</span>
 33 |     | <span class='unexecuted'>        collateralRegistry.redeemCollateral(500e18, 10, 1e18);</span>
 34 |     | <span class='unexecuted'>        findZombies();</span>
 35 |     | <span class='unexecuted'>        switch_zombie(0);</span>
 36 |     | <span class='unexecuted'>        console.log(currentZombieTrove);</span>
 37 |     | <span class='unexecuted'>        clamped_adjustZombieTrove(1e18, true, 10000e18, true, 1000e18);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    // function test_crytical() public {</span>
 41 |     | <span class='neutral'>    //     uint256 MIN_DEBT = 2000e18;</span>
 42 |     | <span class='neutral'>    //     switch_user(0);</span>
 43 |     | <span class='neutral'>    //     mintTokenToAll(100000e18);</span>
 44 |     | <span class='neutral'>    //     mintWeth(1000e18);</span>
 45 |     | <span class='neutral'>    //     priceFeed_setPrice(2000e18);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    //     // Open trove with 10 ETH collateral and 2000e18 BOLD debt + upfront fee</span>
 48 |     | <span class='neutral'>    //     clamped_open_trove(10e18, 2000e18, 25e16);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    //     switch_trove(0);</span>
 51 |     | <span class='neutral'>    //     priceFeed_setRedemptionPrice(2000e18);</span>
 52 |     | <span class='neutral'>    //     uint256 redeem = getTheTroveEntireDebt(currentTrove);</span>
 53 |     | <span class='neutral'>    //     collateralRegistry.redeemCollateral(1000e18, 10, 1e18);</span>
 54 |     | <span class='neutral'>    //     findZombies();</span>
 55 |     | <span class='neutral'>    //     console.log(&#39;HERE&#39;);</span>
 56 |     | <span class='neutral'>    //     clamped_adjustZombieTrove(1e18, true, 10000e18, true, 100e18);</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    // }</span>
 59 |     | <span class='neutral'>    // function test_crytically() public {</span>
 60 |     | <span class='neutral'>    //     uint256 MIN_DEBT = 2000e18;</span>
 61 |     | <span class='neutral'>    //     switch_user(0);</span>
 62 |     | <span class='neutral'>    //     mintTokenToAll(100000e18);</span>
 63 |     | <span class='neutral'>    //     mintWeth(1000e18);</span>
 64 |     | <span class='neutral'>    //     priceFeed_setPrice(2000e18);</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>    //     // Open trove with 10 ETH collateral and 2000e18 BOLD debt + upfront fee</span>
 67 |     | <span class='neutral'>    //     clamped_open_trove(10e18, 2000e18, 25e16);</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>    //     switch_trove(0);</span>
 70 |     | <span class='neutral'>    //     BO_withdrawBold(currentTrove, 10e18, 2e18);</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>    // }</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>    function getTheTroveEntireDebt(uint256 _troveId) internal view returns (uint256) {</span>
 75 |     | <span class='neutral'>        LatestTroveData memory trove = troveManager.getLatestTroveData(_troveId);</span>
 76 |     | <span class='neutral'>        return trove.entireDebt;</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/Deployer.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {AddressesRegistry} from &quot;src/AddressesRegistry.sol&quot;;</span>
   5 |     | <span class='neutral'>import {ActivePool} from &quot;src/ActivePool.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BaseSetup} from &quot;@chimera/BaseSetup.sol&quot;;</span>
   7 |     | <span class='neutral'>import {BoldToken} from &quot;src/BoldToken.sol&quot;;</span>
   8 |     | <span class='neutral'>import {BorrowerOperations} from &quot;src/BorrowerOperations.sol&quot;;</span>
   9 |     | <span class='neutral'>import {CollateralRegistry} from &quot;src/CollateralRegistry.sol&quot;;</span>
  10 |     | <span class='neutral'>import {CollSurplusPool} from &quot;src/CollSurplusPool.sol&quot;;</span>
  11 |     | <span class='neutral'>import {console} from &quot;forge-std/console.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>import {DefaultPool} from &quot;src/DefaultPool.sol&quot;;</span>
  14 |     | <span class='neutral'>import {ERC20Token} from &quot;./mocks/ERC20.sol&quot;;</span>
  15 |     | <span class='neutral'>import {GasPool} from &quot;src/GasPool.sol&quot;;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>import {FixedAssetReader} from &quot;src/NFTMetadata/utils/FixedAssets.sol&quot;;</span>
  18 |     | <span class='neutral'>import {IAddressesRegistry} from &quot;src/Interfaces/IAddressesRegistry.sol&quot;;</span>
  19 |     | <span class='neutral'>import {IERC20Metadata} from &quot;lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>import {IInterestRouter} from &quot;src/Interfaces/IInterestRouter.sol&quot;;</span>
  22 |     | <span class='neutral'>import {ITroveManager} from &quot;src/Interfaces/ITroveManager.sol&quot;;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>import {IWETH} from &quot;src/Interfaces/IWETH.sol&quot;;</span>
  25 |     | <span class='neutral'>import {HintHelpers} from &quot;src/HintHelpers.sol&quot;;</span>
  26 |     | <span class='neutral'>import {MetadataNFT} from &quot;src/NFTMetadata/MetadataNFT.sol&quot;;</span>
  27 |     | <span class='neutral'>import {MockPriceFeed} from &quot;./mocks/MockPriceFeed.sol&quot;;</span>
  28 |     | <span class='neutral'>import {MultiTroveGetter} from &quot;src/MultiTroveGetter.sol&quot;;</span>
  29 |     | <span class='neutral'>import {PredeployCalculator} from &quot;./PredeployCalculator.sol&quot;;</span>
  30 |     | <span class='neutral'>import {TroveManager} from &quot;src/TroveManager.sol&quot;;</span>
  31 |     | <span class='neutral'>import {TroveNFT} from &quot;src/TroveNFT.sol&quot;;</span>
  32 |     | <span class='neutral'>import {StabilityPool} from &quot;src/StabilityPool.sol&quot;;</span>
  33 |     | <span class='neutral'>import {SortedTroves} from &quot;src/SortedTroves.sol&quot;;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>import {Asserts} from &quot;@chimera/Asserts.sol&quot;;</span>
  36 |     | <span class='neutral'>import {Weth} from &quot;./mocks/WETH.sol&quot;;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>//NOTE ADDRESS MULTITROVE</span>
  39 |     | <span class='neutral'>// NOTE NEED TO ADD THE OTHER COLLATERALS</span>
  40 |     | <span class='neutral'>abstract contract Deployer is BaseSetup, PredeployCalculator {</span>
  41 |     | <span class='neutral'>    AddressesRegistry addressesRegistry;</span>
  42 |     | <span class='neutral'>    ActivePool activePool;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    BoldToken boldToken;</span>
  45 |     | <span class='neutral'>    BorrowerOperations borrowerOperations;</span>
  46 |     | <span class='neutral'>    CollSurplusPool collSurplusPool;</span>
  47 |     | <span class='neutral'>    CollateralRegistry collateralRegistry;</span>
  48 |     | <span class='neutral'>    DefaultPool defaultPool;</span>
  49 |     | <span class='neutral'>    GasPool gasPool;</span>
  50 |     | <span class='neutral'>    IInterestRouter interestRouter;</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    FixedAssetReader fixedAssetReader;</span>
  53 |     | <span class='neutral'>    HintHelpers hintHelpers;</span>
  54 |     | <span class='neutral'>    MetadataNFT metadataNFT;</span>
  55 |     | <span class='neutral'>    MockPriceFeed priceFeed;</span>
  56 |     | <span class='neutral'>    MultiTroveGetter multiTroveGetter;</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    TroveManager troveManager;</span>
  59 |     | <span class='neutral'>    TroveNFT troveNFT;</span>
  60 |     | <span class='neutral'>    StabilityPool stabilityPool;</span>
  61 |     | <span class='neutral'>    SortedTroves sortedTroves;</span>
  62 |     | <span class='neutral'>    ERC20Token collateral;</span>
  63 |     | <span class='neutral'>    Weth weth;</span>
  64 |     | <span class='neutral'>    ERC20Token wstETH;</span>
  65 |     | <span class='neutral'>    ERC20Token rETH;</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    address[] precomputed;</span>
  68 |     | <span class='neutral'>    bytes4[] fixedAsset;</span>
  69 |     | <span class='neutral'>    FixedAssetReader.Asset[] assets;</span>
  70 |     | <span class='neutral'></span>
  71 | *   | <span class='executed'>    function deploy(</span>
  72 |     | <span class='neutral'>        address owner,</span>
  73 |     | <span class='neutral'>        uint256 ccr,</span>
  74 |     | <span class='neutral'>        uint256 mcr,</span>
  75 |     | <span class='neutral'>        uint256 scr,</span>
  76 |     | <span class='neutral'>        uint256 liquidationPenaltySP,</span>
  77 |     | <span class='neutral'>        uint256 liquidationPenaltyRedistribution</span>
  78 | *   | <span class='executed'>    ) public {</span>
  79 |     | <span class='neutral'>        //// COLLATERAL</span>
  80 | *   | <span class='executed'>        weth = new Weth();</span>
  81 | *   | <span class='executed'>        collateral = new ERC20Token();</span>
  82 | *   | <span class='executed'>        wstETH = new ERC20Token();</span>
  83 | *   | <span class='executed'>        rETH = new ERC20Token();</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>        ////</span>
  86 |     | <span class='neutral'></span>
  87 | *   | <span class='executed'>        IERC20Metadata[] memory erc20Tokens = new IERC20Metadata[](1);</span>
  88 | *   | <span class='executed'>        erc20Tokens[0] = IWETH(weth);</span>
  89 |     | <span class='neutral'>        // erc20Tokens[1] = rETH;</span>
  90 |     | <span class='neutral'>        // erc20Tokens[2] = wstETH;</span>
  91 |     | <span class='neutral'>        // erc20Tokens[3] = collateral;</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>        ////</span>
  94 |     | <span class='neutral'></span>
  95 | *   | <span class='executed'>        addressesRegistry =</span>
  96 | *r  | <span class='executed'>            new AddressesRegistry(owner, ccr, mcr, scr, liquidationPenaltySP, liquidationPenaltyRedistribution); //consider programmatic deployment, yes and do not forget the dictionary</span>
  97 | *   | <span class='executed'>        precomputed = setupPrecomputedAddresses(address(this));</span>
  98 |     | <span class='neutral'></span>
  99 | *   | <span class='executed'>        IAddressesRegistry.AddressVars memory vars = IAddressesRegistry.AddressVars({</span>
 100 | *   | <span class='executed'>            activePool: ActivePool(precomputed[0]),</span>
 101 | *   | <span class='executed'>            boldToken: BoldToken(precomputed[1]),</span>
 102 | *   | <span class='executed'>            borrowerOperations: BorrowerOperations(precomputed[2]),</span>
 103 | *   | <span class='executed'>            collSurplusPool: CollSurplusPool(precomputed[3]),</span>
 104 | *   | <span class='executed'>            collateralRegistry: CollateralRegistry(precomputed[4]), // Not in deployment list</span>
 105 | *   | <span class='executed'>            collToken: ERC20Token(collateral),</span>
 106 | *   | <span class='executed'>            defaultPool: DefaultPool(precomputed[5]),</span>
 107 | *   | <span class='executed'>            gasPoolAddress: precomputed[7],</span>
 108 | *   | <span class='executed'>            hintHelpers: HintHelpers(precomputed[8]),</span>
 109 | *   | <span class='executed'>            interestRouter: IInterestRouter(address(666)),</span>
 110 | *   | <span class='executed'>            metadataNFT: MetadataNFT(precomputed[9]),</span>
 111 | *   | <span class='executed'>            multiTroveGetter: MultiTroveGetter(precomputed[10]),</span>
 112 | *   | <span class='executed'>            priceFeed: MockPriceFeed(precomputed[11]),</span>
 113 | *   | <span class='executed'>            sortedTroves: SortedTroves(precomputed[12]),</span>
 114 | *   | <span class='executed'>            stabilityPool: StabilityPool(precomputed[13]),</span>
 115 | *   | <span class='executed'>            troveManager: TroveManager(precomputed[14]),</span>
 116 | *   | <span class='executed'>            troveNFT: TroveNFT(precomputed[15]),</span>
 117 | *   | <span class='executed'>            WETH: IWETH(weth)</span>
 118 |     | <span class='neutral'>        });</span>
 119 | *   | <span class='executed'>        addressesRegistry.setAddresses(vars); // nonce 3</span>
 120 |     | <span class='neutral'></span>
 121 | *   | <span class='executed'>        ITroveManager[] memory troveManagers = new ITroveManager[](1);</span>
 122 |     | <span class='neutral'></span>
 123 | *   | <span class='executed'>        troveManagers[0] = TroveManager(precomputed[14]); //NOTE MAKE ARRAY OF TROVES</span>
 124 |     | <span class='neutral'></span>
 125 | *   | <span class='executed'>        activePool = new ActivePool(addressesRegistry);</span>
 126 | *   | <span class='executed'>        boldToken = new BoldToken(owner);</span>
 127 | *   | <span class='executed'>        borrowerOperations = new BorrowerOperations(addressesRegistry);</span>
 128 | *   | <span class='executed'>        collSurplusPool = new CollSurplusPool(addressesRegistry);</span>
 129 | *   | <span class='executed'>        collateralRegistry = new CollateralRegistry(boldToken, erc20Tokens, troveManagers);</span>
 130 | *   | <span class='executed'>        defaultPool = new DefaultPool(addressesRegistry);</span>
 131 | *   | <span class='executed'>        fixedAssetReader = new FixedAssetReader(address(1), fixedAsset, assets);</span>
 132 | *   | <span class='executed'>        gasPool = new GasPool(addressesRegistry);</span>
 133 | *   | <span class='executed'>        hintHelpers = new HintHelpers(collateralRegistry);</span>
 134 | *   | <span class='executed'>        interestRouter = IInterestRouter(address(666));</span>
 135 | *   | <span class='executed'>        metadataNFT = new MetadataNFT(fixedAssetReader);</span>
 136 | *   | <span class='executed'>        multiTroveGetter = new MultiTroveGetter(collateralRegistry);</span>
 137 | *   | <span class='executed'>        priceFeed = new MockPriceFeed(1e18);</span>
 138 | *   | <span class='executed'>        sortedTroves = new SortedTroves(addressesRegistry);</span>
 139 | *   | <span class='executed'>        stabilityPool = new StabilityPool(addressesRegistry);</span>
 140 | *   | <span class='executed'>        troveManager = new TroveManager(addressesRegistry);</span>
 141 | *   | <span class='executed'>        troveNFT = new TroveNFT(addressesRegistry);</span>
 142 |     | <span class='neutral'></span>
 143 | *   | <span class='executed'>        boldToken.setBranchAddresses(</span>
 144 | *   | <span class='executed'>            address(troveManager), address(stabilityPool), address(borrowerOperations), address(activePool)</span>
 145 |     | <span class='neutral'>        );</span>
 146 | *   | <span class='executed'>        boldToken.setCollateralRegistry(address(collateralRegistry));</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'>}</span>
 149 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/PredeployCalculator.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Test} from &quot;forge-std/Test.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract PredeployCalculator {</span>
  7 | *   | <span class='executed'>    function setupPrecomputedAddresses(address deployer) public pure returns (address[] memory addresses) {</span>
  8 | *   | <span class='executed'>        addresses = new address[](16); // Number of contracts to deploy</span>
  9 | *   | <span class='executed'>        uint256 nonce = 6; // Starting nonce</span>
 10 |     | <span class='neutral'></span>
 11 | *   | <span class='executed'>        addresses[0] = _computeCreateAddress(deployer, nonce++); // activePool</span>
 12 | *   | <span class='executed'>        addresses[1] = _computeCreateAddress(deployer, nonce++); // boldToken</span>
 13 | *   | <span class='executed'>        addresses[2] = _computeCreateAddress(deployer, nonce++); // borrowerOperations</span>
 14 | *   | <span class='executed'>        addresses[3] = _computeCreateAddress(deployer, nonce++); // collSurplusPool</span>
 15 | *   | <span class='executed'>        addresses[4] = _computeCreateAddress(deployer, nonce++); // defaultPool</span>
 16 | *   | <span class='executed'>        addresses[5] = _computeCreateAddress(deployer, nonce++); // fixedAssetReader</span>
 17 | *   | <span class='executed'>        addresses[6] = _computeCreateAddress(deployer, nonce++); // hintHelpers</span>
 18 | *   | <span class='executed'>        addresses[7] = _computeCreateAddress(deployer, nonce++); // metadataNFT</span>
 19 | *   | <span class='executed'>        addresses[8] = _computeCreateAddress(deployer, nonce++); // multiTroveGetter</span>
 20 | *   | <span class='executed'>        addresses[9] = _computeCreateAddress(deployer, nonce++); // priceFeed</span>
 21 | *   | <span class='executed'>        addresses[10] = _computeCreateAddress(deployer, nonce++); // stabilityPool</span>
 22 | *   | <span class='executed'>        addresses[11] = _computeCreateAddress(deployer, nonce++); // troveManager</span>
 23 | *   | <span class='executed'>        addresses[12] = _computeCreateAddress(deployer, nonce++); // ...</span>
 24 | *   | <span class='executed'>        addresses[13] = _computeCreateAddress(deployer, nonce++);</span>
 25 | *   | <span class='executed'>        addresses[14] = _computeCreateAddress(deployer, nonce++);</span>
 26 | *   | <span class='executed'>        addresses[15] = _computeCreateAddress(deployer, nonce++);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 | *   | <span class='executed'>    function _computeCreateAddress(address deployer, uint256 nonce) internal pure returns (address) {</span>
 30 |     | <span class='neutral'>        return address(</span>
 31 | *   | <span class='executed'>            uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(uint8(nonce))))))</span>
 32 |     | <span class='neutral'>        );</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/Properties.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>import {Asserts} from &quot;@chimera/Asserts.sol&quot;;</span>
 5 |     | <span class='neutral'>import {BeforeAfter} from &quot;./BeforeAfter.sol&quot;;</span>
 6 |     | <span class='neutral'></span>
 7 |     | <span class='neutral'>abstract contract Properties is BeforeAfter, Asserts {}</span>
 8 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/Setup.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {BaseSetup} from &quot;@chimera/BaseSetup.sol&quot;;</span>
  5 |     | <span class='neutral'>import {console} from &quot;forge-std/console.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>import {Deployer} from &quot;./Deployer.sol&quot;;</span>
  8 |     | <span class='neutral'>import {ERC20Token} from &quot;./mocks/ERC20.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>import {IAddressesRegistry} from &quot;src/Interfaces/IAddressesRegistry.sol&quot;;</span>
 11 |     | <span class='neutral'>import {IERC20Metadata} from &quot;lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>import {IInterestRouter} from &quot;src/Interfaces/IInterestRouter.sol&quot;;</span>
 14 |     | <span class='neutral'>import {ITroveManager} from &quot;src/Interfaces/ITroveManager.sol&quot;;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>import {IWETH} from &quot;src/Interfaces/IWETH.sol&quot;;</span>
 17 |     | <span class='neutral'>import {HintHelpers} from &quot;src/HintHelpers.sol&quot;;</span>
 18 |     | <span class='neutral'>import {MockPriceFeed} from &quot;./mocks/MockPriceFeed.sol&quot;;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>import {Asserts} from &quot;@chimera/Asserts.sol&quot;;</span>
 21 |     | <span class='neutral'>import {Weth} from &quot;./mocks/WETH.sol&quot;;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>abstract contract Setup is BaseSetup, Deployer {</span>
 24 |     | <span class='neutral'>    address[] users;</span>
 25 |     | <span class='neutral'>    uint256[] activeTroves;</span>
 26 |     | <span class='neutral'>    uint256[] normalTroves;</span>
 27 |     | <span class='neutral'>    uint256[] batchTroves;</span>
 28 |     | <span class='neutral'>    uint256[] zombieTroves;</span>
 29 |     | <span class='neutral'>    uint256[] mixedTroves;</span>
 30 |     | <span class='neutral'>    address[] tokens;</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    // USERS</span>
 33 | *   | <span class='executed'>    address owner = address(this);</span>
 34 | *   | <span class='executed'>    address bob = address(123);</span>
 35 | *   | <span class='executed'>    address patrick = address(234);</span>
 36 | *   | <span class='executed'>    address schneider = address(345);</span>
 37 | *   | <span class='executed'>    address interestManager = address(888);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    address currentUser;</span>
 40 |     | <span class='neutral'>    uint256 currentTrove;</span>
 41 |     | <span class='neutral'>    uint256 currentBatchTrove;</span>
 42 |     | <span class='neutral'>    uint256 currentZombieTrove;</span>
 43 |     | <span class='neutral'>    uint256 currentMixedTrove;</span>
 44 |     | <span class='neutral'>    uint256 currentNormalTrove;</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    uint256 timestamp;</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    uint256 randomUnit;</span>
 49 |     | <span class='neutral'></span>
 50 | *   | <span class='executed'>    function setup() internal virtual override {</span>
 51 | *   | <span class='executed'>        users.push(owner);</span>
 52 | *   | <span class='executed'>        users.push(bob);</span>
 53 | *   | <span class='executed'>        users.push(patrick);</span>
 54 | *   | <span class='executed'>        users.push(schneider);</span>
 55 | *   | <span class='executed'>        users.push(bob);</span>
 56 |     | <span class='neutral'></span>
 57 | *   | <span class='executed'>        deploy(owner, 1.5e18, 1.5e18, 1.5e18, 1e17, 1.5e17);</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'>}</span>
 60 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/TargetFunctions.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {BoldTokenTarget} from &quot;./targets/boldToken/BoldTokenTarget.sol&quot;;</span>
  5 |     | <span class='neutral'>import {BaseTargetFunctions} from &quot;@chimera/BaseTargetFunctions.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BeforeAfter} from &quot;./BeforeAfter.sol&quot;;</span>
  7 |     | <span class='neutral'>import {BOClamped} from &quot;./targets/borrowerOperations/BOClamped.sol&quot;;</span>
  8 |     | <span class='neutral'>import {Deployer} from &quot;./Deployer.sol&quot;;</span>
  9 |     | <span class='neutral'>// import {MAX_LIQUIDATION_PENALTY_REDISTRIBUTION, MIN_LIQUIDATION_PENALTY_SP} from &quot;src/Dependencies/Constants.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>import {ITroveManager} from &quot;src/Interfaces/ITroveManager.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>import {LatestTroveData} from &quot;src/Types/LatestTroveData.sol&quot;;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>import {Manager} from &quot;./managers/Manager.sol&quot;;</span>
 16 |     | <span class='neutral'>import {PriceFeedTarget} from &quot;./targets/priceFeed/PriceFeedTarget.sol&quot;;</span>
 17 |     | <span class='neutral'>import {Properties} from &quot;./Properties.sol&quot;;</span>
 18 |     | <span class='neutral'>import {SPTarget} from &quot;./targets/SPTarget.sol&quot;;</span>
 19 |     | <span class='neutral'>import {TM_Clamped} from &quot;./targets/troveManager/TM_Clamped.sol&quot;;</span>
 20 |     | <span class='neutral'>import {vm} from &quot;@chimera/Hevm.sol&quot;;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>abstract contract TargetFunctions is</span>
 23 |     | <span class='neutral'>    BaseTargetFunctions,</span>
 24 |     | <span class='neutral'>    Properties,</span>
 25 |     | <span class='neutral'>    BOClamped,</span>
 26 |     | <span class='neutral'>    BoldTokenTarget,</span>
 27 |     | <span class='neutral'>    PriceFeedTarget,</span>
 28 |     | <span class='neutral'>    SPTarget,</span>
 29 |     | <span class='neutral'>    TM_Clamped</span>
 30 |     | <span class='neutral'>{</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    // bool deployed;</span>
 33 |     | <span class='neutral'>    // function deployment(</span>
 34 |     | <span class='neutral'>    //     uint256 ccr,</span>
 35 |     | <span class='neutral'>    //     uint256 mcr,</span>
 36 |     | <span class='neutral'>    //     uint256 scr,</span>
 37 |     | <span class='neutral'>    //     uint256 liquidationPenaltySP,</span>
 38 |     | <span class='neutral'>    //     uint256 liquidationPenaltyRedistribution</span>
 39 |     | <span class='neutral'>    // ) public {</span>
 40 |     | <span class='neutral'>    //     if (!deployed) {</span>
 41 |     | <span class='neutral'>    //         (ccr, mcr, scr, liquidationPenaltySP, liquidationPenaltyRedistribution) =</span>
 42 |     | <span class='neutral'>    //             _fix_deploy_args(ccr, mcr, scr, liquidationPenaltySP, liquidationPenaltyRedistribution);</span>
 43 |     | <span class='neutral'>    //         deploy(owner, ccr, mcr, scr, liquidationPenaltySP, liquidationPenaltyRedistribution);</span>
 44 |     | <span class='neutral'>    //         deployed = true;</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    //     }</span>
 47 |     | <span class='neutral'>    // }</span>
 48 |     | <span class='neutral'></span>
 49 | *   | <span class='executed'>    function collateralRegistry_redeemCollateral(</span>
 50 |     | <span class='neutral'>        uint256 amt,</span>
 51 |     | <span class='neutral'>        uint256 _maxIterationsPerCollateral,</span>
 52 |     | <span class='neutral'>        uint256 _maxFeePercentage</span>
 53 |     | <span class='neutral'>    ) public {</span>
 54 | *r  | <span class='executed'>        collateralRegistry.redeemCollateral(amt, _maxIterationsPerCollateral, _maxFeePercentage);</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    // function deployer() public {</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>//     if (!deployed) {</span>
 60 |     | <span class='neutral'>//     deploy(owner, 1.5e18, 1.5e18, 1.5e18, 1e17, 1.5e17);</span>
 61 |     | <span class='neutral'>//     deployed = true;</span>
 62 |     | <span class='neutral'>//         }</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>// }</span>
 65 |     | <span class='neutral'>}</span>
 66 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/managers/Helpers.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Properties} from &quot;../Properties.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IBorrowerOperations} from &quot;src/Interfaces/IBorrowerOperations.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract Helpers is Properties {</span>
  8 |     | <span class='neutral'>    uint256 constant MIN_LIQUIDATION_PENALTY_SP = 5e16;</span>
  9 |     | <span class='neutral'>    uint256 constant MAX_LIQUIDATION_PENALTY_REDISTRIBUTION = 20e16;</span>
 10 |     | <span class='neutral'></span>
 11 | *   | <span class='executed'>    function _return_random_User() internal returns (address user) {</span>
 12 | *   | <span class='executed'>        user = users[randomUnit % users.length];</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 | *   | <span class='executed'>    function _return_batch_open_trove_params(uint256 collAmount, uint256 boldAmount)</span>
 16 |     | <span class='neutral'>        internal</span>
 17 | *   | <span class='executed'>        returns (IBorrowerOperations.OpenTroveAndJoinInterestBatchManagerParams memory params)</span>
 18 |     | <span class='neutral'>    {</span>
 19 |     | <span class='neutral'>        // address batchManager = _return_random_User();</span>
 20 | *r  | <span class='executed'>        params.maxUpfrontFee = hintHelpers.predictOpenTroveUpfrontFee(0, boldAmount, 2e18);</span>
 21 | *   | <span class='executed'>        params.owner = currentUser;</span>
 22 |     | <span class='neutral'>        // params.ownerIndex = 0;</span>
 23 | *   | <span class='executed'>        params.collAmount = collAmount;</span>
 24 | *   | <span class='executed'>        params.boldAmount = boldAmount;</span>
 25 | *   | <span class='executed'>        params.interestBatchManager = _return_random_User();</span>
 26 |     | <span class='neutral'>        params.maxUpfrontFee;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function _fix_deploy_args(</span>
 30 |     | <span class='neutral'>        uint256 ccr,</span>
 31 |     | <span class='neutral'>        uint256 mcr,</span>
 32 |     | <span class='neutral'>        uint256 scr,</span>
 33 |     | <span class='neutral'>        uint256 liquidationPenaltySP,</span>
 34 |     | <span class='neutral'>        uint256 liquidationPenaltyRedistribution</span>
 35 |     | <span class='neutral'>    ) internal returns (uint256, uint256, uint256, uint256, uint256) {</span>
 36 |     | <span class='neutral'>        ccr = 1e18 + (ccr % 1e18);</span>
 37 |     | <span class='neutral'>        mcr = 1e18 + (mcr % 1e18);</span>
 38 |     | <span class='neutral'>        scr = 1e18 + (scr % 1e18);</span>
 39 |     | <span class='neutral'>        liquidationPenaltySP = MIN_LIQUIDATION_PENALTY_SP</span>
 40 |     | <span class='neutral'>            + (liquidationPenaltySP % (MAX_LIQUIDATION_PENALTY_REDISTRIBUTION - MIN_LIQUIDATION_PENALTY_SP));</span>
 41 |     | <span class='neutral'>        uint256 minRedistribution = liquidationPenaltySP + 1;</span>
 42 |     | <span class='neutral'>        uint256 availableRange = MAX_LIQUIDATION_PENALTY_REDISTRIBUTION - minRedistribution;</span>
 43 |     | <span class='neutral'>        liquidationPenaltyRedistribution = minRedistribution + (liquidationPenaltyRedistribution % (availableRange + 1));</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'>}</span>
 46 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/managers/Manager.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {BaseTargetFunctions} from &quot;@chimera/BaseTargetFunctions.sol&quot;;</span>
  5 |     | <span class='neutral'>import {BeforeAfter} from &quot;../BeforeAfter.sol&quot;;</span>
  6 |     | <span class='neutral'>import {Helpers} from &quot;./Helpers.sol&quot;;</span>
  7 |     | <span class='neutral'>import {ITroveManager} from &quot;src/Interfaces/ITroveManager.sol&quot;;</span>
  8 |     | <span class='neutral'>import {Modifiers} from &quot;./Modifiers.sol&quot;;</span>
  9 |     | <span class='neutral'>import {Properties} from &quot;../Properties.sol&quot;;</span>
 10 |     | <span class='neutral'>import {IERC20} from &quot;../mocks/IERC20.sol&quot;;</span>
 11 |     | <span class='neutral'>import {vm} from &quot;@chimera/Hevm.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>abstract contract Manager is BaseTargetFunctions, Properties, Modifiers, Helpers {</span>
 14 | *   | <span class='executed'>    function mintColl(uint256 amount) public {</span>
 15 | *r  | <span class='executed'>        collateral.mint(currentUser, amount);</span>
 16 | *   | <span class='executed'>        collateral.approve(address(borrowerOperations), amount);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 | *   | <span class='executed'>    function mintWeth(uint256 amount) public {</span>
 20 | *r  | <span class='executed'>        weth.mint(currentUser, amount);</span>
 21 | *   | <span class='executed'>        weth.approve(address(borrowerOperations), amount);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 | *   | <span class='executed'>    function switch_user(uint256 index) public {</span>
 25 | *   | <span class='executed'>        currentUser = users[index %= users.length];</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 | *   | <span class='executed'>    function switch_trove(uint256 index) public {</span>
 29 | *   | <span class='executed'>        index %= activeTroves.length;</span>
 30 | *   | <span class='executed'>        currentTrove = activeTroves[index];</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 | *   | <span class='executed'>    function switch_batchTrove(uint256 index) public {</span>
 34 | *   | <span class='executed'>        index %= batchTroves.length;</span>
 35 | *   | <span class='executed'>        currentBatchTrove = batchTroves[index];</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 | *   | <span class='executed'>    function switch_mixedTrove(uint256 index) public {</span>
 39 | *   | <span class='executed'>        index %= mixedTroves.length;</span>
 40 | *   | <span class='executed'>        currentMixedTrove = mixedTroves[index];</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 | *   | <span class='executed'>    function switch_normalTrove(uint256 index) public {</span>
 44 | *   | <span class='executed'>        index %= normalTroves.length;</span>
 45 |     | <span class='unexecuted'>        currentNormalTrove = normalTroves[index];</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 | *   | <span class='executed'>    function switch_zombie(uint256 index) public {</span>
 49 | *   | <span class='executed'>        index %= zombieTroves.length;</span>
 50 | *   | <span class='executed'>        currentZombieTrove = zombieTroves[index];</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 | *   | <span class='executed'>    function mintBold(uint256 amt) public onlyBO {</span>
 54 | *r  | <span class='executed'>        borrowerOperations.boldToken().mint(currentUser, amt);</span>
 55 |     | <span class='unexecuted'>        borrowerOperations.boldToken().approve(address(collateralRegistry), amt);</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 | *   | <span class='executed'>    function switch_randomUnit(uint256 unit) public {</span>
 59 | *   | <span class='executed'>        randomUnit = unit;</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'></span>
 62 | *   | <span class='executed'>    function pushTime() public {</span>
 63 | *   | <span class='executed'>        vm.warp(timestamp + 10 days);</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'></span>
 66 | *   | <span class='executed'>    function findZombies() public {</span>
 67 | *   | <span class='executed'>        uint256 len = troveManager.getTroveIdsCount();</span>
 68 | *   | <span class='executed'>        delete zombieTroves;</span>
 69 | *   | <span class='executed'>        for (uint256 i; i &lt; len; i++) {</span>
 70 | *   | <span class='executed'>            uint256 trove = troveManager.getTroveFromTroveIdsArray(i);</span>
 71 | *   | <span class='executed'>            uint256 status = uint8(troveManager.getTroveStatus(trove));</span>
 72 | *   | <span class='executed'>            if (status == uint8(ITroveManager.Status.zombie)) zombieTroves.push(trove);</span>
 73 |     | <span class='neutral'>        }</span>
 74 |     | <span class='neutral'>    }</span>
 75 |     | <span class='neutral'>}</span>
 76 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/managers/Modifiers.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {BaseTargetFunctions} from &quot;@chimera/BaseTargetFunctions.sol&quot;;</span>
  5 |     | <span class='neutral'>import {BeforeAfter} from &quot;../BeforeAfter.sol&quot;;</span>
  6 |     | <span class='neutral'>import {Properties} from &quot;../Properties.sol&quot;;</span>
  7 |     | <span class='neutral'>import {vm} from &quot;@chimera/Hevm.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>abstract contract Modifiers is BaseTargetFunctions, Properties {</span>
 10 |     | <span class='neutral'>    modifier onlyTroveManager() {</span>
 11 |     | <span class='neutral'>        vm.prank(address(troveManager));</span>
 12 |     | <span class='neutral'>        _;</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    modifier randomUser() {</span>
 16 | *   | <span class='executed'>        address randomUser = users[randomUnit % users.length];</span>
 17 | *   | <span class='executed'>        vm.prank(randomUser);</span>
 18 |     | <span class='neutral'>        _;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _returnNumber(uint256 modulo) internal returns (uint256) {</span>
 22 |     | <span class='neutral'>        uint256 randomUnitImage = randomUnit;</span>
 23 |     | <span class='neutral'>        return randomUnitImage % modulo;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    modifier onlyBO() {</span>
 27 | *   | <span class='executed'>        vm.prank(address(borrowerOperations));</span>
 28 |     | <span class='neutral'>        _;</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    modifier onlySP() {</span>
 32 |     | <span class='neutral'>        vm.prank(address(stabilityPool));</span>
 33 |     | <span class='neutral'>        _;</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    modifier ownerCalls() {</span>
 37 | *   | <span class='executed'>        vm.prank(address(owner));</span>
 38 |     | <span class='neutral'>        _;</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'>}</span>
 41 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/mocks/ERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// Represents a symbolic/dummy ERC20 token</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>// SPDX-License-Identifier: agpl-3.0</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {ERC20} from &quot;lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  8 |     | <span class='neutral'></span>
  9 | *   | <span class='executed'>contract ERC20Token is ERC20(&quot;TOKEN&quot;, &quot;TKN&quot;) {</span>
 10 | *   | <span class='executed'>    function mint(address receiver, uint256 amt) public {</span>
 11 | *   | <span class='executed'>        _mint(receiver, amt);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/mocks/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>interface IERC20 {</span>
  2 |     | <span class='neutral'>    /**</span>
  3 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
  4 |     | <span class='neutral'>     * another (`to`).</span>
  5 |     | <span class='neutral'>     *</span>
  6 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
  7 |     | <span class='neutral'>     */</span>
  8 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 12 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 13 |     | <span class='neutral'>     */</span>
 14 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns the value of tokens in existence.</span>
 18 |     | <span class='neutral'>     */</span>
 19 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /**</span>
 22 |     | <span class='neutral'>     * @dev Returns the value of tokens owned by `account`.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    /**</span>
 27 |     | <span class='neutral'>     * @dev Moves a `value` amount of tokens from the caller&#39;s account to `to`.</span>
 28 |     | <span class='neutral'>     *</span>
 29 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 30 |     | <span class='neutral'>     *</span>
 31 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 32 |     | <span class='neutral'>     */</span>
 33 |     | <span class='neutral'>    function transfer(address to, uint256 value) external returns (bool);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /**</span>
 36 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 37 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 38 |     | <span class='neutral'>     * zero by default.</span>
 39 |     | <span class='neutral'>     *</span>
 40 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 41 |     | <span class='neutral'>     */</span>
 42 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    /**</span>
 45 |     | <span class='neutral'>     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the</span>
 46 |     | <span class='neutral'>     * caller&#39;s tokens.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 49 |     | <span class='neutral'>     *</span>
 50 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 51 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 52 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 53 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 54 |     | <span class='neutral'>     * desired value afterwards:</span>
 55 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 58 |     | <span class='neutral'>     */</span>
 59 |     | <span class='neutral'>    function approve(address spender, uint256 value) external returns (bool);</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>    /**</span>
 62 |     | <span class='neutral'>     * @dev Moves a `value` amount of tokens from `from` to `to` using the</span>
 63 |     | <span class='neutral'>     * allowance mechanism. `value` is then deducted from the caller&#39;s</span>
 64 |     | <span class='neutral'>     * allowance.</span>
 65 |     | <span class='neutral'>     *</span>
 66 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 67 |     | <span class='neutral'>     *</span>
 68 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 69 |     | <span class='neutral'>     */</span>
 70 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 value) external returns (bool);</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>    function mint(address receiver, uint256 amount) external;</span>
 73 |     | <span class='neutral'>}</span>
 74 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/mocks/MockPriceFeed.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IPriceFeed} from &quot;src/Interfaces/IPriceFeed.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 | *   | <span class='executed'>contract MockPriceFeed is IPriceFeed {</span>
  7 |     | <span class='unexecuted'>    address public borrowerOperationsAddress;</span>
  8 |     | <span class='neutral'>    uint256 private price;</span>
  9 |     | <span class='neutral'>    uint256 private redemptionPrice;</span>
 10 |     | <span class='neutral'>    bool private priceValid;</span>
 11 |     | <span class='neutral'>    bool private redemptionPriceValid;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    // Events for tracking state changes</span>
 14 |     | <span class='neutral'>    event PriceUpdated(uint256 newPrice);</span>
 15 |     | <span class='neutral'>    event RedemptionPriceUpdated(uint256 newRedemptionPrice);</span>
 16 |     | <span class='neutral'>    event PriceValidityUpdated(bool isValid);</span>
 17 |     | <span class='neutral'>    event RedemptionPriceValidityUpdated(bool isValid);</span>
 18 |     | <span class='neutral'></span>
 19 | *   | <span class='executed'>    constructor(uint256 _initialPrice) {</span>
 20 | *   | <span class='executed'>        price = _initialPrice;</span>
 21 | *   | <span class='executed'>        redemptionPrice = _initialPrice;</span>
 22 | *   | <span class='executed'>        priceValid = true;</span>
 23 | *   | <span class='executed'>        redemptionPriceValid = true;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 | *   | <span class='executed'>    function fetchPrice() external override returns (uint256, bool) {</span>
 27 | *   | <span class='executed'>        return (price, false);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 | *   | <span class='executed'>    function fetchRedemptionPrice() external override returns (uint256, bool) {</span>
 31 | *   | <span class='executed'>        return (redemptionPrice, redemptionPriceValid);</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 | *   | <span class='executed'>    function lastGoodPrice() external view override returns (uint256) {</span>
 35 |     | <span class='unexecuted'>        return price;</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 | *   | <span class='executed'>    function setAddresses(address _borrowerOperationsAddress) external override {</span>
 39 | *   | <span class='executed'>        borrowerOperationsAddress = _borrowerOperationsAddress;</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    // Helper functions for testing</span>
 43 | *   | <span class='executed'>    function setPrice(uint256 _price) external {</span>
 44 | *   | <span class='executed'>        price = _price;</span>
 45 | *   | <span class='executed'>        emit PriceUpdated(_price);</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 | *   | <span class='executed'>    function setRedemptionPrice(uint256 _redemptionPrice) external {</span>
 49 | *   | <span class='executed'>        redemptionPrice = _redemptionPrice;</span>
 50 | *   | <span class='executed'>        emit RedemptionPriceUpdated(_redemptionPrice);</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 | *   | <span class='executed'>    function setPriceValidity(bool _isValid) external {</span>
 54 |     | <span class='unexecuted'>        priceValid = _isValid;</span>
 55 | *   | <span class='executed'>        emit PriceValidityUpdated(_isValid);</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 | *   | <span class='executed'>    function setRedemptionPriceValidity(bool _isValid) external {</span>
 59 | *   | <span class='executed'>        redemptionPriceValid = _isValid;</span>
 60 | *   | <span class='executed'>        emit RedemptionPriceValidityUpdated(_isValid);</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'>}</span>
 63 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/mocks/WETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ERC20} from &quot;lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IWETH} from &quot;src/Interfaces/IWETH.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 | *   | <span class='executed'>contract Weth is IWETH, ERC20(&quot;Wrapped Ether&quot;, &quot;WETH&quot;) {</span>
  8 |     | <span class='neutral'>    event Deposit(address indexed from, uint256 amount);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    event Withdrawal(address indexed to, uint256 amount);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    function deposit() public payable virtual {</span>
 13 |     | <span class='unexecuted'>        _mint(msg.sender, msg.value);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>        emit Deposit(msg.sender, msg.value);</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 | *   | <span class='executed'>    function withdraw(uint256 amount) public virtual {</span>
 19 |     | <span class='unexecuted'>        _burn(msg.sender, amount);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>        emit Withdrawal(msg.sender, amount);</span>
 22 |     | <span class='neutral'></span>
 23 | *   | <span class='executed'>        msg.sender.call{value: amount}(&quot;&quot;);</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 | *   | <span class='executed'>    function mint(address receiver, uint256 amt) public {</span>
 27 | *   | <span class='executed'>        _mint(receiver, amt);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    receive() external payable virtual {</span>
 31 | *   | <span class='executed'>        deposit();</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'>}</span>
 34 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/targets/SPTarget.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {BaseTargetFunctions} from &quot;@chimera/BaseTargetFunctions.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Properties} from &quot;../Properties.sol&quot;;</span>
  6 |     | <span class='neutral'>import {vm} from &quot;@chimera/Hevm.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>abstract contract SPTarget is BaseTargetFunctions, Properties {</span>
  9 | *   | <span class='executed'>    function stabilityPool_provideToSP(uint256 _topUp, bool _doClaim) public {</span>
 10 | *   | <span class='executed'>        stabilityPool.provideToSP(_topUp, _doClaim);</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 | *   | <span class='executed'>    function stabilityPool_withdrawFromSP(uint256 _amount, bool _doClaim) public {</span>
 14 | *   | <span class='executed'>        stabilityPool.withdrawFromSP(_amount, _doClaim);</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 | *   | <span class='executed'>    function stabilityPool_claimAllCollGains() public {</span>
 18 | *   | <span class='executed'>        stabilityPool.claimAllCollGains();</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/targets/boldToken/BoldTokenTarget.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {BaseTargetFunctions} from &quot;@chimera/BaseTargetFunctions.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Modifiers} from &quot;../../managers/Modifiers.sol&quot;;</span>
  6 |     | <span class='neutral'>import {Properties} from &quot;../../Properties.sol&quot;;</span>
  7 |     | <span class='neutral'>import {vm} from &quot;@chimera/Hevm.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>abstract contract BoldTokenTarget is BaseTargetFunctions, Properties, Modifiers {</span>
 10 | *   | <span class='executed'>    function boldToken_setBranchAddresses(</span>
 11 |     | <span class='neutral'>        address _troveManagerAddress,</span>
 12 |     | <span class='neutral'>        address _stabilityPoolAddress,</span>
 13 |     | <span class='neutral'>        address _borrowerOperationsAddress,</span>
 14 |     | <span class='neutral'>        address _activePoolAddress</span>
 15 |     | <span class='neutral'>    ) public ownerCalls {</span>
 16 | *r  | <span class='executed'>        boldToken.setBranchAddresses(</span>
 17 |     | <span class='neutral'>            _troveManagerAddress, _stabilityPoolAddress, _borrowerOperationsAddress, _activePoolAddress</span>
 18 |     | <span class='neutral'>        );</span>
 19 |     | <span class='unexecuted'>        revert(&quot;Stateless&quot;); //NOTE FOR now</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 | *   | <span class='executed'>    function boldToken_setCollateralRegistry(address _collateralRegistryAddress) public ownerCalls {</span>
 23 | *   | <span class='executed'>        boldToken.setCollateralRegistry(_collateralRegistryAddress);</span>
 24 |     | <span class='neutral'>        revert(&quot;Stateless&quot;); // annoying</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/targets/borrowerOperations/BOClamped.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {BaseTargetFunctions} from &quot;@chimera/BaseTargetFunctions.sol&quot;;</span>
   5 |     | <span class='neutral'>import {BORaw} from &quot;./borrowerOperationsRaw/BORaw.sol&quot;;</span>
   6 |     | <span class='neutral'>import {BOHelpers} from &quot;./BOHelpers.sol&quot;;</span>
   7 |     | <span class='neutral'>import {IBorrowerOperations} from &quot;src/Interfaces/IBorrowerOperations.sol&quot;;</span>
   8 |     | <span class='neutral'>import {vm} from &quot;@chimera/Hevm.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>abstract contract BOClamped is BORaw, BOHelpers {</span>
  11 |     | <span class='neutral'>    /**</span>
  12 |     | <span class='neutral'>     * Here we clamp the _annualInterestRate</span>
  13 |     | <span class='neutral'>     */</span>
  14 | *   | <span class='executed'>    function clamped_open_trove(uint256 _collAmount, uint256 _boldAmount, uint128 _annualInterestRate)</span>
  15 |     | <span class='neutral'>        public</span>
  16 | *   | <span class='executed'>        returns (uint256)</span>
  17 |     | <span class='neutral'>    {</span>
  18 | *   | <span class='executed'>        _annualInterestRate = _fix_interest_rate(_annualInterestRate);</span>
  19 | *   | <span class='executed'>        _collAmount %= collateral.balanceOf(currentUser) + 1;</span>
  20 | *   | <span class='executed'>        uint256 trove = BO_openTrove(_collAmount, _boldAmount, uint256(_annualInterestRate));</span>
  21 | *   | <span class='executed'>        activeTroves.push(trove);</span>
  22 | *   | <span class='executed'>        normalTroves.push(trove);</span>
  23 | *   | <span class='executed'>        mixedTroves.push(trove);</span>
  24 |     | <span class='neutral'>        return trove;</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 | *   | <span class='executed'>    function clamped_openTroveAndJoinInterestBatchManager(uint256 collAmount, uint256 boldAmount) public {</span>
  28 | *   | <span class='executed'>        IBorrowerOperations.OpenTroveAndJoinInterestBatchManagerParams memory _params =</span>
  29 | *   | <span class='executed'>            _return_batch_open_trove_params(collAmount, boldAmount);</span>
  30 | *   | <span class='executed'>        BO_openTroveAndJoinInterestBatchManager(_params);</span>
  31 |     | <span class='neutral'>        </span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    // NOTE caller is owner, but should create option where caller is interestManager</span>
  35 | *   | <span class='executed'>    function clamped_adjustTroveInterestRate(uint128 _newAnnualInterestRate) public {</span>
  36 | *   | <span class='executed'>        _newAnnualInterestRate = _fix_interest_rate(_newAnnualInterestRate);</span>
  37 | *   | <span class='executed'>        uint256 _maxUpfrontFee =</span>
  38 | *r  | <span class='executed'>            hintHelpers.predictAdjustInterestRateUpfrontFee(0, currentTrove, _newAnnualInterestRate);</span>
  39 | *   | <span class='executed'>        BO_adjustTroveInterestRate(uint256(_newAnnualInterestRate), _maxUpfrontFee);</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    //NOTE //msg.sender is batch manager</span>
  43 | *   | <span class='executed'>    function clamped_registerBatchManager(</span>
  44 |     | <span class='neutral'>        uint128 _minInterestRate,</span>
  45 |     | <span class='neutral'>        uint128 _maxInterestRate,</span>
  46 |     | <span class='neutral'>        uint128 _currentInterestRate,</span>
  47 |     | <span class='neutral'>        uint128 _annualManagementFee,</span>
  48 |     | <span class='neutral'>        uint128 _minInterestRateChangePeriod</span>
  49 |     | <span class='neutral'>    ) public {</span>
  50 | *   | <span class='executed'>        _minInterestRate = _fix_interest_rate(_minInterestRate);</span>
  51 | *   | <span class='executed'>        _maxInterestRate = _fix_interest_rate(_maxInterestRate);</span>
  52 | *   | <span class='executed'>        (_minInterestRate, _maxInterestRate, _minInterestRateChangePeriod) = _fix_max_min_interest(</span>
  53 | *   | <span class='executed'>            _minInterestRate, _maxInterestRate, uint128(_currentInterestRate), _minInterestRateChangePeriod</span>
  54 |     | <span class='neutral'>        );</span>
  55 |     | <span class='neutral'></span>
  56 | *   | <span class='executed'>        BO_registerBatchManager(</span>
  57 | *   | <span class='executed'>            _minInterestRate, _maxInterestRate, _currentInterestRate, _annualManagementFee, _minInterestRateChangePeriod</span>
  58 |     | <span class='neutral'>        );</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 | *   | <span class='executed'>    function clamped_setInterestIndividualDelegate(</span>
  62 |     | <span class='neutral'>        uint128 _minInterestRate,</span>
  63 |     | <span class='neutral'>        uint128 _maxInterestRate,</span>
  64 |     | <span class='neutral'>        uint128 _newAnnualInterestRate,</span>
  65 |     | <span class='neutral'>        uint256 _maxUpfrontFee, //NOTE I CAN REMOVE THIS ?</span>
  66 |     | <span class='neutral'>        uint128 _minInterestRateChangePeriod</span>
  67 |     | <span class='neutral'>    ) public {</span>
  68 | *   | <span class='executed'>        address delegate = _return_random_User();</span>
  69 | *   | <span class='executed'>        _minInterestRate = _fix_interest_rate(_minInterestRate);</span>
  70 | *   | <span class='executed'>        _maxInterestRate = _fix_interest_rate(_maxInterestRate);</span>
  71 |     | <span class='neutral'></span>
  72 | *   | <span class='executed'>        (_minInterestRate, _maxInterestRate, _minInterestRateChangePeriod) = _fix_max_min_interest(</span>
  73 | *   | <span class='executed'>            _minInterestRate, _maxInterestRate, _newAnnualInterestRate, _minInterestRateChangePeriod</span>
  74 |     | <span class='neutral'>        );</span>
  75 | *   | <span class='executed'>        BO_setInterestIndividualDelegate(</span>
  76 | *   | <span class='executed'>            delegate,</span>
  77 |     | <span class='neutral'>            _minInterestRate,</span>
  78 |     | <span class='neutral'>            _maxInterestRate,</span>
  79 |     | <span class='neutral'>            _newAnnualInterestRate,</span>
  80 | *   | <span class='executed'>            0,</span>
  81 |     | <span class='neutral'>            0,</span>
  82 | *   | <span class='executed'>            _maxUpfrontFee,</span>
  83 |     | <span class='neutral'>            _minInterestRateChangePeriod</span>
  84 |     | <span class='neutral'>        );</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 | *   | <span class='executed'>    function clamped_setBatchManagerAnnualInterestRate(uint128 _newAnnualInterestRate, uint256 _maxUpfrontFee) public {</span>
  88 | *   | <span class='executed'>        _newAnnualInterestRate = _fix_interest_BM_rate(msg.sender, _newAnnualInterestRate); //NOTE fix clamping</span>
  89 | *   | <span class='executed'>        BO_setBatchManagerAnnualInterestRate(_newAnnualInterestRate, 0, 0, _maxUpfrontFee);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    //NOTE clamped to active troves</span>
  93 | *   | <span class='executed'>    function clamped_applyPendingDebt() public {</span>
  94 | *   | <span class='executed'>        BO_applyPendingDebt(currentTrove, 0, 0);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 | *   | <span class='executed'>    function clamped_adjustZombieTrove(</span>
  98 |     | <span class='neutral'>        uint256 _collChange,</span>
  99 |     | <span class='neutral'>        bool _isCollIncrease,</span>
 100 |     | <span class='neutral'>        uint256 _boldChange,</span>
 101 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
 102 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
 103 |     | <span class='neutral'>    ) public {</span>
 104 | *   | <span class='executed'>        BO_adjustZombieTrove(</span>
 105 | *   | <span class='executed'>            currentZombieTrove, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, 0, 0, _maxUpfrontFee</span>
 106 |     | <span class='neutral'>        );</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 | *   | <span class='executed'>    function clamped_zombie_applyPendingDebt() public {</span>
 110 | *   | <span class='executed'>        BO_applyPendingDebt(currentZombieTrove, 0, 0);</span>
 111 |     | <span class='unexecuted'>        t(false, &quot;QnD&quot;);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////////////////</span>
 115 | *   | <span class='executed'>    function stateless_withdrawBold() public {</span>
 116 | *   | <span class='executed'>        currentTrove = clamped_open_trove(10e18, 2000e18, 24e16);</span>
 117 | *   | <span class='executed'>        BO_withdrawBold(currentTrove, 10e18, 2e18);</span>
 118 |     | <span class='neutral'>        revert(&quot;stateless&quot;);</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 | *   | <span class='executed'>    function stateless_withdrawColl() public {</span>
 122 | *   | <span class='executed'>        currentTrove = clamped_open_trove(10e18, 2000e18, 23e16);</span>
 123 | *   | <span class='executed'>        BO_withdrawColl(currentTrove, 1e18);</span>
 124 | *   | <span class='executed'>        revert(&quot;stateless&quot;);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 | *   | <span class='executed'>    function stateless_createZombie(uint256 price) public {</span>
 128 | *   | <span class='executed'>        clamped_open_trove(10e18, 2000e18, 25e16);</span>
 129 | *   | <span class='executed'>        priceFeed.setRedemptionPrice(price);</span>
 130 | *r  | <span class='executed'>        collateralRegistry.redeemCollateral(1000e18, 10, 1e18);</span>
 131 | *r  | <span class='executed'>        revert(&quot;stateless&quot;);</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 | *   | <span class='executed'>    function stateless_zombie_applyPendingDebt(</span>
 135 |     | <span class='neutral'>        uint256 coll,</span>
 136 |     | <span class='neutral'>        uint256 bold,</span>
 137 |     | <span class='neutral'>        bool increaseColl,</span>
 138 |     | <span class='neutral'>        bool increaseDebt,</span>
 139 |     | <span class='neutral'>        uint256 redemtpionPrice</span>
 140 |     | <span class='neutral'>    ) public {</span>
 141 | *   | <span class='executed'>        clamped_open_trove(10e18, 2000e18, 25e16);</span>
 142 | *   | <span class='executed'>        priceFeed.setRedemptionPrice(redemtpionPrice);</span>
 143 | *r  | <span class='executed'>        collateralRegistry.redeemCollateral(1000e18, 10, 1e18);</span>
 144 | *   | <span class='executed'>        clamped_adjustZombieTrove(coll, increaseColl, bold, increaseDebt, 110e18);</span>
 145 |     | <span class='unexecuted'>        BO_applyPendingDebt(currentZombieTrove, 0, 0);</span>
 146 |     | <span class='unexecuted'>        t(false, &quot;QnD&quot;);</span>
 147 |     | <span class='neutral'>        revert(&quot;stateless&quot;);</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 | *   | <span class='executed'>    function stateless_adjustZombie() public {</span>
 151 | *   | <span class='executed'>        clamped_open_trove(10e18, 2000e18, 25e16);</span>
 152 | *   | <span class='executed'>        switch_trove(0);</span>
 153 | *   | <span class='executed'>        priceFeed.setRedemptionPrice(2000e18);</span>
 154 | *r  | <span class='executed'>        collateralRegistry.redeemCollateral(1000e18, 10, 1e18);</span>
 155 | *   | <span class='executed'>        findZombies();</span>
 156 | *   | <span class='executed'>        clamped_adjustZombieTrove(1e18, true, 10000e18, true, 100e18);</span>
 157 |     | <span class='neutral'>        revert(&quot;stateless&quot;);</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 | *   | <span class='executed'>    function stateless_zombie_adjust_batch() public {</span>
 161 | *   | <span class='executed'>        clamped_openTroveAndJoinInterestBatchManager(11e18, 2000e18);</span>
 162 | *   | <span class='executed'>        priceFeed.setRedemptionPrice(20000e18);</span>
 163 | *r  | <span class='executed'>        collateralRegistry.redeemCollateral(500e18, 10, 1e18);</span>
 164 | *   | <span class='executed'>        findZombies();</span>
 165 | *   | <span class='executed'>        switch_zombie(0);</span>
 166 | *   | <span class='executed'>        clamped_adjustZombieTrove(1e18, true, 10000e18, true, 1000e18);</span>
 167 |     | <span class='neutral'>        revert(&quot;stateless&quot;);</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'>}</span>
 170 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/targets/borrowerOperations/BOHelpers.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IBorrowerOperations} from &quot;src/Interfaces/IBorrowerOperations.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Properties} from &quot;./../../Properties.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract BOHelpers is Properties {</span>
  8 | *   | <span class='executed'>    function _fix_max_min_interest(</span>
  9 |     | <span class='neutral'>        uint128 _minInterestRate,</span>
 10 |     | <span class='neutral'>        uint128 _maxInterestRate,</span>
 11 |     | <span class='neutral'>        uint128 _newAnnualInterestRate,</span>
 12 |     | <span class='neutral'>        uint128 _minInterestRateChangePeriod</span>
 13 | *   | <span class='executed'>    ) internal returns (uint128, uint128, uint128) {</span>
 14 | *   | <span class='executed'>        if (_minInterestRate &gt; _maxInterestRate) {</span>
 15 | *   | <span class='executed'>            (_minInterestRate, _maxInterestRate) = (_maxInterestRate, _minInterestRate);</span>
 16 |     | <span class='neutral'>        }</span>
 17 |     | <span class='neutral'></span>
 18 | *   | <span class='executed'>        _newAnnualInterestRate = _newAnnualInterestRate &gt; _maxInterestRate</span>
 19 | *   | <span class='executed'>            ? _newAnnualInterestRate % _maxInterestRate</span>
 20 | *   | <span class='executed'>            : _newAnnualInterestRate;</span>
 21 | *   | <span class='executed'>        _newAnnualInterestRate =</span>
 22 | *   | <span class='executed'>            _newAnnualInterestRate &lt; _minInterestRate ? _minInterestRate + 1 : _newAnnualInterestRate;</span>
 23 | *   | <span class='executed'>        if (_minInterestRateChangePeriod &lt; 1 hours) _minInterestRateChangePeriod += 1 hours;</span>
 24 | *   | <span class='executed'>        return (_minInterestRate, _maxInterestRate, _minInterestRateChangePeriod);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 | *   | <span class='executed'>    function _fix_interest_rate(uint128 input) internal returns (uint128) {</span>
 28 | *   | <span class='executed'>        if (input &gt; 250 * 1e16) input %= 2.5e18 + 1; //NOTE to better</span>
 29 | *   | <span class='executed'>        if (input &lt; 5e15) input + 5e15;</span>
 30 | *   | <span class='executed'>        return input;</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 | *   | <span class='executed'>    function _fix_interest_BM_rate(address batchManager, uint128 _newAnnualInterestRate) internal returns (uint128) {</span>
 34 | *   | <span class='executed'>        IBorrowerOperations.InterestBatchManager memory interestBM =</span>
 35 | *   | <span class='executed'>            borrowerOperations.getInterestBatchManager(batchManager);</span>
 36 | *   | <span class='executed'>        if (interestBM.maxInterestRate &lt; _newAnnualInterestRate) _newAnnualInterestRate %= interestBM.maxInterestRate;</span>
 37 | *   | <span class='executed'>        if (interestBM.minInterestRate &gt; _newAnnualInterestRate) {</span>
 38 |     | <span class='unexecuted'>            _newAnnualInterestRate = interestBM.minInterestRate + 1;</span>
 39 |     | <span class='neutral'>        }</span>
 40 | *   | <span class='executed'>        return _newAnnualInterestRate;</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'>}</span>
 43 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/targets/borrowerOperations/borrowerOperationsRaw/BORaw.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {BaseTargetFunctions} from &quot;@chimera/BaseTargetFunctions.sol&quot;;</span>
   5 |     | <span class='neutral'>import {IBorrowerOperations} from &quot;src/Interfaces/IBorrowerOperations.sol&quot;;</span>
   6 |     | <span class='neutral'>import {Properties} from &quot;../../../Properties.sol&quot;;</span>
   7 |     | <span class='neutral'>import {Manager} from &quot;../../../managers/Manager.sol&quot;;</span>
   8 |     | <span class='neutral'>import {vm} from &quot;@chimera/Hevm.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>abstract contract BORaw is BaseTargetFunctions, Properties, Manager {</span>
  11 | *   | <span class='executed'>    function BO_addColl(uint256 _collAmount) public {</span>
  12 | *   | <span class='executed'>        borrowerOperations.addColl(currentTrove, _collAmount);</span>
  13 |     | <span class='neutral'>    }</span>
  14 |     | <span class='neutral'></span>
  15 | *   | <span class='executed'>    function BO_adjustTrove(</span>
  16 |     | <span class='neutral'>        uint256 _collChange,</span>
  17 |     | <span class='neutral'>        bool _isCollIncrease,</span>
  18 |     | <span class='neutral'>        uint256 _boldChange,</span>
  19 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
  20 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
  21 |     | <span class='neutral'>    ) public {</span>
  22 | *r  | <span class='executed'>        borrowerOperations.adjustTrove(</span>
  23 | *   | <span class='executed'>            currentTrove, _collChange, _isCollIncrease, _boldChange, _isDebtIncrease, _maxUpfrontFee</span>
  24 |     | <span class='neutral'>        );</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 | *   | <span class='executed'>    function BO_adjustTroveInterestRate(uint256 _newAnnualInterestRate, uint256 _maxUpfrontFee) public {</span>
  28 | *   | <span class='executed'>        borrowerOperations.adjustTroveInterestRate(currentTrove, _newAnnualInterestRate, 0, 0, _maxUpfrontFee);</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 | *   | <span class='executed'>    function BO_adjustZombieTrove(</span>
  32 |     | <span class='neutral'>        uint256 zombieTrove,</span>
  33 |     | <span class='neutral'>        uint256 _collChange,</span>
  34 |     | <span class='neutral'>        bool _isCollIncrease,</span>
  35 |     | <span class='neutral'>        uint256 _boldChange,</span>
  36 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
  37 |     | <span class='neutral'>        uint256 _upperHint,</span>
  38 |     | <span class='neutral'>        uint256 _lowerHint,</span>
  39 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
  40 |     | <span class='neutral'>    ) public {</span>
  41 | *   | <span class='executed'>        borrowerOperations.adjustZombieTrove(</span>
  42 |     | <span class='neutral'>            zombieTrove,</span>
  43 |     | <span class='neutral'>            _collChange,</span>
  44 |     | <span class='neutral'>            _isCollIncrease,</span>
  45 |     | <span class='neutral'>            _boldChange,</span>
  46 |     | <span class='neutral'>            _isDebtIncrease,</span>
  47 |     | <span class='neutral'>            _upperHint,</span>
  48 |     | <span class='neutral'>            _lowerHint,</span>
  49 |     | <span class='neutral'>            _maxUpfrontFee</span>
  50 |     | <span class='neutral'>        );</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 | *   | <span class='executed'>    function BO_applyPendingDebt(uint256 trove, uint256 _lowerHint, uint256 _upperHint) public {</span>
  54 | *   | <span class='executed'>        borrowerOperations.applyPendingDebt(trove, _lowerHint, _upperHint);</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 | *   | <span class='executed'>    function BO_claimCollateral() public {</span>
  58 | *   | <span class='executed'>        borrowerOperations.claimCollateral();</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 | *   | <span class='executed'>    function BO_closeTrove() public {</span>
  62 | *   | <span class='executed'>        borrowerOperations.closeTrove(currentTrove);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 | *   | <span class='executed'>    function BO_lowerBatchManagementFee(uint256 _newAnnualManagementFee) public {</span>
  66 | *   | <span class='executed'>        borrowerOperations.lowerBatchManagementFee(_newAnnualManagementFee);</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 | *   | <span class='executed'>    function BO_onLiquidateTrove(uint256 _troveId) public {</span>
  70 | *   | <span class='executed'>        borrowerOperations.onLiquidateTrove(_troveId);</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 | *   | <span class='executed'>    function BO_openTrove(uint256 _collAmount, uint256 _boldAmount, uint256 _annualInterestRate)</span>
  74 |     | <span class='neutral'>        public</span>
  75 | *   | <span class='executed'>        returns (uint256 troveId)</span>
  76 |     | <span class='neutral'>    {</span>
  77 | *r  | <span class='executed'>        uint256 maxUpfrontFee = hintHelpers.predictOpenTroveUpfrontFee(0, _boldAmount, _annualInterestRate);</span>
  78 | *r  | <span class='executed'>        troveId = borrowerOperations.openTrove(</span>
  79 | *   | <span class='executed'>            currentUser,</span>
  80 |     | <span class='neutral'>            0,</span>
  81 |     | <span class='neutral'>            _collAmount,</span>
  82 |     | <span class='neutral'>            _boldAmount,</span>
  83 |     | <span class='neutral'>            0,</span>
  84 |     | <span class='neutral'>            0,</span>
  85 |     | <span class='neutral'>            _annualInterestRate,</span>
  86 |     | <span class='neutral'>            maxUpfrontFee,</span>
  87 |     | <span class='neutral'>            address(0),</span>
  88 |     | <span class='neutral'>            address(0),</span>
  89 |     | <span class='neutral'>            address(0)</span>
  90 |     | <span class='neutral'>        );</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 | *   | <span class='executed'>    function BO_openTroveAndJoinInterestBatchManager(</span>
  94 |     | <span class='neutral'>        IBorrowerOperations.OpenTroveAndJoinInterestBatchManagerParams memory _params</span>
  95 | *   | <span class='executed'>    ) public returns (uint256 trove) {</span>
  96 | *r  | <span class='executed'>        trove = borrowerOperations.openTroveAndJoinInterestBatchManager(_params);</span>
  97 | *   | <span class='executed'>        activeTroves.push(trove);</span>
  98 | *   | <span class='executed'>        batchTroves.push(trove);</span>
  99 | *   | <span class='executed'>        mixedTroves.push(trove);</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 | *   | <span class='executed'>    function BO_registerBatchManager(</span>
 103 |     | <span class='neutral'>        uint128 _minInterestRate,</span>
 104 |     | <span class='neutral'>        uint128 _maxInterestRate,</span>
 105 |     | <span class='neutral'>        uint128 _currentInterestRate,</span>
 106 |     | <span class='neutral'>        uint128 _annualManagementFee,</span>
 107 |     | <span class='neutral'>        uint128 _minInterestRateChangePeriod</span>
 108 |     | <span class='neutral'>    ) public randomUser {</span>
 109 | *   | <span class='executed'>        borrowerOperations.registerBatchManager(</span>
 110 |     | <span class='neutral'>            _minInterestRate, _maxInterestRate, _currentInterestRate, _annualManagementFee, _minInterestRateChangePeriod</span>
 111 |     | <span class='neutral'>        );</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 | *   | <span class='executed'>    function BO_removeFromBatch(</span>
 115 |     | <span class='neutral'>        uint256 _newAnnualInterestRate,</span>
 116 |     | <span class='neutral'>        uint256 _upperHint,</span>
 117 |     | <span class='neutral'>        uint256 _lowerHint,</span>
 118 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
 119 |     | <span class='neutral'>    ) public {</span>
 120 | *   | <span class='executed'>        borrowerOperations.removeFromBatch(currentTrove, _newAnnualInterestRate, _upperHint, _lowerHint, _maxUpfrontFee);</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 | *   | <span class='executed'>    function BO_removeInterestIndividualDelegate() public {</span>
 124 | *   | <span class='executed'>        borrowerOperations.removeInterestIndividualDelegate(currentTrove);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 | *   | <span class='executed'>    function BO_repayBold(uint256 _boldAmount) public {</span>
 128 | *   | <span class='executed'>        borrowerOperations.repayBold(currentTrove, _boldAmount);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 | *   | <span class='executed'>    function BO_setAddManager(address _manager) public {</span>
 132 | *   | <span class='executed'>        borrowerOperations.setAddManager(currentTrove, _manager);</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 | *   | <span class='executed'>    function BO_setBatchManagerAnnualInterestRate(</span>
 136 |     | <span class='neutral'>        uint128 _newAnnualInterestRate,</span>
 137 |     | <span class='neutral'>        uint256 _upperHint,</span>
 138 |     | <span class='neutral'>        uint256 _lowerHint,</span>
 139 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
 140 |     | <span class='neutral'>    ) public {</span>
 141 | *r  | <span class='executed'>        borrowerOperations.setBatchManagerAnnualInterestRate(</span>
 142 |     | <span class='neutral'>            _newAnnualInterestRate, _upperHint, _lowerHint, _maxUpfrontFee</span>
 143 |     | <span class='neutral'>        );</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 | *   | <span class='executed'>    function BO_setInterestBatchManager(</span>
 147 |     | <span class='neutral'>        address _newBatchManager,</span>
 148 |     | <span class='neutral'>        uint256 _upperHint,</span>
 149 |     | <span class='neutral'>        uint256 _lowerHint,</span>
 150 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
 151 |     | <span class='neutral'>    ) public {</span>
 152 | *   | <span class='executed'>        borrowerOperations.setInterestBatchManager(</span>
 153 | *   | <span class='executed'>            currentNormalTrove, _newBatchManager, _upperHint, _lowerHint, _maxUpfrontFee</span>
 154 |     | <span class='neutral'>        );</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 | *   | <span class='executed'>    function BO_setInterestIndividualDelegate(</span>
 158 |     | <span class='neutral'>        address _delegate,</span>
 159 |     | <span class='neutral'>        uint128 _minInterestRate,</span>
 160 |     | <span class='neutral'>        uint128 _maxInterestRate,</span>
 161 |     | <span class='neutral'>        uint256 _newAnnualInterestRate,</span>
 162 |     | <span class='neutral'>        uint256 _upperHint,</span>
 163 |     | <span class='neutral'>        uint256 _lowerHint,</span>
 164 |     | <span class='neutral'>        uint256 _maxUpfrontFee,</span>
 165 |     | <span class='neutral'>        uint256 _minInterestRateChangePeriod</span>
 166 |     | <span class='neutral'>    ) public {</span>
 167 | *r  | <span class='executed'>        borrowerOperations.setInterestIndividualDelegate(</span>
 168 | *   | <span class='executed'>            currentTrove,</span>
 169 |     | <span class='neutral'>            _delegate,</span>
 170 |     | <span class='neutral'>            _minInterestRate,</span>
 171 |     | <span class='neutral'>            _maxInterestRate,</span>
 172 |     | <span class='neutral'>            _newAnnualInterestRate,</span>
 173 |     | <span class='neutral'>            _upperHint,</span>
 174 |     | <span class='neutral'>            _lowerHint,</span>
 175 |     | <span class='neutral'>            _maxUpfrontFee,</span>
 176 |     | <span class='neutral'>            _minInterestRateChangePeriod</span>
 177 |     | <span class='neutral'>        );</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 | *   | <span class='executed'>    function BO_setRemoveManager(uint256 _troveId, address _manager) public {</span>
 181 | *   | <span class='executed'>        borrowerOperations.setRemoveManager(_troveId, _manager);</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 | *   | <span class='executed'>    function BO_setRemoveManagerWithReceiver(uint256 _troveId, address _manager, address _receiver) public {</span>
 185 | *   | <span class='executed'>        borrowerOperations.setRemoveManagerWithReceiver(_troveId, _manager, _receiver);</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 | *   | <span class='executed'>    function BO_shutdown() public {</span>
 189 | *r  | <span class='executed'>        borrowerOperations.shutdown();</span>
 190 |     | <span class='neutral'>        // revert(&quot;Stateless&quot;);</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'></span>
 193 | *   | <span class='executed'>    function BO_shutdownFromOracleFailure() public {</span>
 194 | *   | <span class='executed'>        borrowerOperations.shutdownFromOracleFailure();</span>
 195 |     | <span class='neutral'>        // revert(&quot;lets reach coverage&quot;);</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 | *   | <span class='executed'>    function BO_switchBatchManager(</span>
 199 |     | <span class='neutral'>        uint256 _removeUpperHint,</span>
 200 |     | <span class='neutral'>        uint256 _removeLowerHint,</span>
 201 |     | <span class='neutral'>        address _newBatchManager,</span>
 202 |     | <span class='neutral'>        uint256 _addUpperHint,</span>
 203 |     | <span class='neutral'>        uint256 _addLowerHint,</span>
 204 |     | <span class='neutral'>        uint256 _maxUpfrontFee</span>
 205 |     | <span class='neutral'>    ) public {</span>
 206 | *r  | <span class='executed'>        borrowerOperations.switchBatchManager(</span>
 207 | *   | <span class='executed'>            currentBatchTrove,</span>
 208 |     | <span class='neutral'>            _removeUpperHint,</span>
 209 |     | <span class='neutral'>            _removeLowerHint,</span>
 210 |     | <span class='neutral'>            _newBatchManager,</span>
 211 |     | <span class='neutral'>            _addUpperHint,</span>
 212 |     | <span class='neutral'>            _addLowerHint,</span>
 213 |     | <span class='neutral'>            _maxUpfrontFee</span>
 214 |     | <span class='neutral'>        );</span>
 215 |     | <span class='neutral'>    }</span>
 216 |     | <span class='neutral'></span>
 217 | *   | <span class='executed'>    function BO_withdrawBold(uint256 _troveId, uint256 _boldAmount, uint256 _maxUpfrontFee) public {</span>
 218 | *   | <span class='executed'>        borrowerOperations.withdrawBold(_troveId, _boldAmount, _maxUpfrontFee);</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 | *   | <span class='executed'>    function BO_withdrawColl(uint256 _troveId, uint256 _collWithdrawal) public {</span>
 222 | *r  | <span class='executed'>        borrowerOperations.withdrawColl(_troveId, _collWithdrawal);</span>
 223 |     | <span class='neutral'>    }</span>
 224 |     | <span class='neutral'>}</span>
 225 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/targets/priceFeed/PriceFeedTarget.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {BaseTargetFunctions} from &quot;@chimera/BaseTargetFunctions.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Properties} from &quot;../../Properties.sol&quot;;</span>
  6 |     | <span class='neutral'>import {vm} from &quot;@chimera/Hevm.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>abstract contract PriceFeedTarget is BaseTargetFunctions, Properties {</span>
  9 | *   | <span class='executed'>    function priceFeed_fetchPrice() public {</span>
 10 | *   | <span class='executed'>        priceFeed.fetchPrice();</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 | *   | <span class='executed'>    function priceFeed_fetchRedemptionPrice() public {</span>
 14 | *   | <span class='executed'>        priceFeed.fetchRedemptionPrice();</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 | *   | <span class='executed'>    function priceFeed_setAddresses(address _borrowerOperationsAddress) public {</span>
 18 | *   | <span class='executed'>        priceFeed.setAddresses(_borrowerOperationsAddress);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 | *   | <span class='executed'>    function priceFeed_setPrice(uint256 _price) public {</span>
 22 | *r  | <span class='executed'>        priceFeed.setPrice(_price);</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    // function priceFeed_setPriceValidity(bool _isValid) public {</span>
 26 |     | <span class='neutral'>    //     priceFeed.setPriceValidity(_isValid);</span>
 27 |     | <span class='neutral'>    // }</span>
 28 |     | <span class='neutral'></span>
 29 | *   | <span class='executed'>    function priceFeed_setRedemptionPrice(uint256 _redemptionPrice) public {</span>
 30 | *   | <span class='executed'>        priceFeed.setRedemptionPrice(_redemptionPrice);</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 | *   | <span class='executed'>    function priceFeed_setRedemptionPriceValidity(bool _isValid) public {</span>
 34 | *   | <span class='executed'>        priceFeed.setRedemptionPriceValidity(_isValid);</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/targets/troveManager/TM_Clamped.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {BaseTargetFunctions} from &quot;@chimera/BaseTargetFunctions.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ITroveManager} from &quot;src/Interfaces/ITroveManager.sol&quot;;</span>
  6 |     | <span class='neutral'>import {Properties} from &quot;../../Properties.sol&quot;;</span>
  7 |     | <span class='neutral'>import {TM_Raw} from &quot;./TM_Raw/TM_Raw.sol&quot;;</span>
  8 |     | <span class='neutral'>import {vm} from &quot;@chimera/Hevm.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>abstract contract TM_Clamped is TM_Raw {</span>
 11 | *   | <span class='executed'>    function clamped_batchLiquidateTroves() public {</span>
 12 | *   | <span class='executed'>        uint256[] memory trovesArray = _return_troves_array();</span>
 13 | *   | <span class='executed'>        TM_batchLiquidateTroves(trovesArray);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    // function macro_batchLiquidateTroves(uint256 price) public {</span>
 17 |     | <span class='neutral'>    //     priceFeed.setPrice(price); // necesssary ?</span>
 18 |     | <span class='neutral'>    //     clamped_batchLiquidateTroves();</span>
 19 |     | <span class='neutral'>    // }</span>
 20 |     | <span class='neutral'></span>
 21 | *   | <span class='executed'>    function _return_troves_array() private returns (uint256[] memory trovesArray) {</span>
 22 | *   | <span class='executed'>        uint256 length = randomUnit % activeTroves.length;</span>
 23 | *   | <span class='executed'>        trovesArray = new uint256[](length);</span>
 24 | *   | <span class='executed'>        uint256 seed = randomUnit;</span>
 25 |     | <span class='neutral'></span>
 26 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; length; i++) {</span>
 27 |     | <span class='neutral'>            // Generate a pseudo-random index using the seed</span>
 28 |     | <span class='unexecuted'>            seed = uint256(keccak256(abi.encodePacked(seed, i)));</span>
 29 |     | <span class='unexecuted'>            uint256 randomIndex = seed % activeTroves.length;</span>
 30 |     | <span class='unexecuted'>            trovesArray[i] = activeTroves[randomIndex];</span>
 31 |     | <span class='neutral'>        }</span>
 32 | *   | <span class='executed'>        return trovesArray;</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/giorgio/Documents/FuzzCademy/BootCamp/liquity/bold-fuzz/contracts/test/recon/targets/troveManager/TM_Raw/TM_Raw.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {BaseTargetFunctions} from &quot;@chimera/BaseTargetFunctions.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ITroveManager} from &quot;src/Interfaces/ITroveManager.sol&quot;;</span>
  6 |     | <span class='neutral'>import {Properties} from &quot;../../../Properties.sol&quot;;</span>
  7 |     | <span class='neutral'>import {TroveChange} from &quot;src/Types/TroveChange.sol&quot;;</span>
  8 |     | <span class='neutral'>import {vm} from &quot;@chimera/Hevm.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>abstract contract TM_Raw is BaseTargetFunctions, Properties {</span>
 11 | *   | <span class='executed'>    function TM_batchLiquidateTroves(uint256[] memory _troveArray) public {</span>
 12 | *   | <span class='executed'>        troveManager.batchLiquidateTroves(_troveArray);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 | *   | <span class='executed'>    function TM_urgentRedemption(uint256 _boldAmount, uint256[] memory _troveIds, uint256 _minCollateral) public {</span>
 16 | *   | <span class='executed'>        troveManager.urgentRedemption(_boldAmount, _troveIds, _minCollateral);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 | *   | <span class='executed'>    function TM_getUnbackedPortionPriceAndRedeemability() public {</span>
 20 | *r  | <span class='executed'>        (,, bool redeemable) = troveManager.getUnbackedPortionPriceAndRedeemability();</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    // function TM_onAdjustTrove(uint256 _troveId, uint256 _newColl, uint256 _newDebt, TroveChange memory _troveChange) public {</span>
 24 |     | <span class='neutral'>    //     troveManager.onAdjustTrove(_troveId, _newColl, _newDebt, _troveChange);</span>
 25 |     | <span class='neutral'>    // }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    // function TM_onAdjustTroveInsideBatch(uint256 _troveId, uint256 _newTroveColl, uint256 _newTroveDebt, TroveChange memory _troveChange, address _batchAddress, uint256 _newBatchColl, uint256 _newBatchDebt) public {</span>
 28 |     | <span class='neutral'>    //     troveManager.onAdjustTroveInsideBatch(_troveId, _newTroveColl, _newTroveDebt, _troveChange, _batchAddress, _newBatchColl, _newBatchDebt);</span>
 29 |     | <span class='neutral'>    // }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    // function TM_onAdjustTroveInterestRate(uint256 _troveId, uint256 _newColl, uint256 _newDebt, uint256 _newAnnualInterestRate, TroveChange memory _troveChange) public {</span>
 32 |     | <span class='neutral'>    //     troveManager.onAdjustTroveInterestRate(_troveId, _newColl, _newDebt, _newAnnualInterestRate, _troveChange);</span>
 33 |     | <span class='neutral'>    // }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    // function TM_onApplyTroveInterest(uint256 _troveId, uint256 _newTroveColl, uint256 _newTroveDebt, address _batchAddress, uint256 _newBatchColl, uint256 _newBatchDebt, TroveChange memory _troveChange) public {</span>
 36 |     | <span class='neutral'>    //     troveManager.onApplyTroveInterest(_troveId, _newTroveColl, _newTroveDebt, _batchAddress, _newBatchColl, _newBatchDebt, _troveChange);</span>
 37 |     | <span class='neutral'>    // }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    // function TM_onCloseTrove(uint256 _troveId, TroveChange memory _troveChange, address _batchAddress, uint256 _newBatchColl, uint256 _newBatchDebt) public {</span>
 40 |     | <span class='neutral'>    //     troveManager.onCloseTrove(_troveId, _troveChange, _batchAddress, _newBatchColl, _newBatchDebt);</span>
 41 |     | <span class='neutral'>    // }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    // function TM_onLowerBatchManagerAnnualFee(address _batchAddress, uint256 _newColl, uint256 _newDebt, uint256 _newAnnualManagementFee) public {</span>
 44 |     | <span class='neutral'>    //     troveManager.onLowerBatchManagerAnnualFee(_batchAddress, _newColl, _newDebt, _newAnnualManagementFee);</span>
 45 |     | <span class='neutral'>    // }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    // function TM_onOpenTrove(address _owner, uint256 _troveId, TroveChange memory _troveChange, uint256 _annualInterestRate) public {</span>
 48 |     | <span class='neutral'>    //     troveManager.onOpenTrove(_owner, _troveId, _troveChange, _annualInterestRate);</span>
 49 |     | <span class='neutral'>    // }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    // function TM_onOpenTroveAndJoinBatch(address _owner, uint256 _troveId, TroveChange memory _troveChange, address _batchAddress, uint256 _batchColl, uint256 _batchDebt) public {</span>
 52 |     | <span class='neutral'>    //     troveManager.onOpenTroveAndJoinBatch(_owner, _troveId, _troveChange, _batchAddress, _batchColl, _batchDebt);</span>
 53 |     | <span class='neutral'>    // }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    // function TM_onRegisterBatchManager(address _account, uint256 _annualInterestRate, uint256 _annualManagementFee) public {</span>
 56 |     | <span class='neutral'>    //     troveManager.onRegisterBatchManager(_account, _annualInterestRate, _annualManagementFee);</span>
 57 |     | <span class='neutral'>    // }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    // function TM_onRemoveFromBatch(uint256 _troveId, uint256 _newTroveColl, uint256 _newTroveDebt, TroveChange memory _troveChange, address _batchAddress, uint256 _newBatchColl, uint256 _newBatchDebt, uint256 _newAnnualInterestRate) public {</span>
 60 |     | <span class='neutral'>    //     troveManager.onRemoveFromBatch(_troveId, _newTroveColl, _newTroveDebt, _troveChange, _batchAddress, _newBatchColl, _newBatchDebt, _newAnnualInterestRate);</span>
 61 |     | <span class='neutral'>    // }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>    // function TM_onSetBatchManagerAnnualInterestRate(address _batchAddress, uint256 _newColl, uint256 _newDebt, uint256 _newAnnualInterestRate, uint256 _upfrontFee) public {</span>
 64 |     | <span class='neutral'>    //     troveManager.onSetBatchManagerAnnualInterestRate(_batchAddress, _newColl, _newDebt, _newAnnualInterestRate, _upfrontFee);</span>
 65 |     | <span class='neutral'>    // }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='neutral'>    // function TM_onSetInterestBatchManager(ITroveManager.OnSetInterestBatchManagerParams memory _params) public {</span>
 68 |     | <span class='neutral'>    //     troveManager.onSetInterestBatchManager(_params);</span>
 69 |     | <span class='neutral'>    // }</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='neutral'>    // function TM_setTroveStatusToActive(uint256 _troveId) public {</span>
 72 |     | <span class='neutral'>    //     troveManager.setTroveStatusToActive(_troveId);</span>
 73 |     | <span class='neutral'>    // }</span>
 74 |     | <span class='neutral'>}</span>
 75 |     | <span class='neutral'></span>

</code>
<br />

